Description: Updated include-binaries.
 .
 athrill-rh850f1x (0.A.1-3) unstable; urgency=medium
 .
   * Added athrill list command tool.
Author: mikoto2000 <mikoto2000@gmail.com>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2021-05-30

--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/E_PACKAGE
@@ -0,0 +1,7 @@
+E_PACKAGE athrill-target-rh850f1x
+VERSION %date
+
+INCLUDE MANIFEST
+INCLUDE ../athrill/MANIFEST
+
+build_linux/athrill2
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/LICENSE.md
@@ -0,0 +1,87 @@
+athrill-target-rh850f1x  
+    rh850f1x Target dependencies for Athrill  
+  
+Copyright (C) 2019 by Center for Embedded Computing Systems
+                        Graduate School of Informatics, Nagoya Univ., JAPAN
+Copyright (C) 2019 by ESM, Inc.
+Copyright (C) 2020- by Hakoniwa Working-Group, TOPPERS Project  
+  
+ The above copyright holders grant permission gratis to use,  
+ duplicate, modify, or redistribute (hereafter called use) this  
+ software (including the one made by modifying this software),  
+ provided that the following four conditions (1) through (4) are  
+ satisfied.  
+  
+ (1) When this software is used in the form of source code, the above  
+     copyright notice, this use conditions, and the disclaimer shown  
+     below must be retained in the source code without modification.  
+  
+ (2) When this software is redistributed in the forms usable for the  
+     development of other software, such as in library form, the above  
+     copyright notice, this use conditions, and the disclaimer shown  
+     below must be shown without modification in the document provided  
+     with the redistributed software, such as the user manual.  
+  
+ (3) When this software is redistributed in the forms unusable for the  
+     development of other software, such as the case when the software  
+     is embedded in a piece of equipment, either of the following two  
+     conditions must be satisfied:  
+  
+   (a) The above copyright notice, this use conditions, and the  
+       disclaimer shown below must be shown without modification in  
+       the document provided with the redistributed software, such as  
+       the user manual.  
+  
+   (b) How the software is to be redistributed must be reported to the  
+       TOPPERS Project according to the procedure described  
+       separately.  
+  
+ (4) The above copyright holders and the TOPPERS Project are exempt  
+     from responsibility for any type of damage directly or indirectly  
+     caused from the use of this software and are indemnified by any  
+     users or end users of this software from any and all causes of  
+     action whatsoever.  
+  
+ THIS SOFTWARE IS PROVIDED "AS IS." THE ABOVE COPYRIGHT HOLDERS AND  
+ THE TOPPERS PROJECT DISCLAIM ANY EXPRESS OR IMPLIED WARRANTIES,  
+ INCLUDING, BUT NOT LIMITED TO, ITS APPLICABILITY TO A PARTICULAR  
+ PURPOSE. IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS AND THE  
+ TOPPERS PROJECT BE LIABLE FOR ANY TYPE OF DAMAGE DIRECTLY OR  
+ INDIRECTLY CAUSED FROM THE USE OF THIS SOFTWARE.  
+  
+---  
+   
+athrill-target-rh850f1x  
+    Athrillのrh850f1xターゲット依存部  
+  
+Copyright (C) 2019 by Center for Embedded Computing Systems
+                        Graduate School of Informatics, Nagoya Univ., JAPAN
+Copyright (C) 2019 by ESM, Inc.
+Copyright (C) 2020- by TOPPERSプロジェクト箱庭ワーキンググループ  
+  
+ 上記著作権者は，以下の (1)〜(4) の条件を満たす場合に限り，本ソフトウェ  
+ ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改変・  
+ 再配布（以下，利用と呼ぶ）することを無償で許諾する．  
+ (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作権  
+     表示，この利用条件および下記の無保証規定が，そのままの形でソース  
+     コード中に含まれていること．  
+ (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使用  
+     できる形で再配布する場合には，再配布に伴うドキュメント（利用者マ  
+     ニュアルなど）に，上記の著作権表示，この利用条件および下記の無保  
+     証規定を掲載すること．  
+ (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使用  
+     できない形で再配布する場合には，次のいずれかの条件を満たすこと．  
+   (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著作  
+       権表示，この利用条件および下記の無保証規定を掲載すること．  
+   (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに報  
+       告すること．  
+ (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損害  
+     からも，上記著作権者およびTOPPERSプロジェクトを免責すること．また，  
+     本ソフトウェアのユーザまたはエンドユーザからのいかなる理由に基づ  
+     く請求からも，上記著作権者およびTOPPERSプロジェクトを免責すること．  
+  
+ 本ソフトウェアは，無保証で提供されているものである．上記著作権者およ  
+ びTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的に対す  
+ る適合性も含めて，いかなる保証も行わない．また，本ソフトウェアの利用  
+ により直接的または間接的に生じたいかなる損害に関しても，その責任を負  
+ わない．  
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/MANIFEST
@@ -0,0 +1,130 @@
+PACKAGE athrill-target-rh850f1x
+VERSION 1.0.0
+
+LICENSE.md
+MANIFEST
+README.md
+
+build_linux/Makefile
+build_linux/Makefile.can
+build_linux/Makefile.cpu
+build_linux/Makefile.device
+build_linux/Makefile.env
+build_linux/Makefile.mpu
+build_linux/Makefile_v850.cpu
+
+params/rh850f1k/atk2-sc1/device_config.txt
+params/rh850f1k/atk2-sc1/memory.txt
+params/rh850f1k/atk2-sc3/device_config.txt
+params/rh850f1k/atk2-sc3/memory.txt
+
+src/cpu/config/cpu_config.c
+src/cpu/config/cpu_config.h
+src/cpu/config/cpuemu_config.h
+src/cpu/config/mpu_config.h
+src/cpu/config/rh850f1k/mpu_config.c
+src/cpu/cpu_common/cpu_fpu_ops.h
+src/cpu/cpu_common/cpu_ops.h
+src/cpu/cpu_dec/op_codeid.h
+src/cpu/cpu_dec/op_dec.c
+src/cpu/cpu_dec/op_dec.h
+src/cpu/cpu_dec/op_dec_types.h
+src/cpu/cpu_dec/op_format.h
+src/cpu/cpu_dec/op_parse.c
+src/cpu/cpu_dec/op_parse.h
+src/cpu/cpu_dec/op_parse_private.c
+src/cpu/cpu_dec/op_parse_private.h
+src/cpu/cpu_exec/op_exec_arithm.c
+src/cpu/cpu_exec/op_exec_arithm_rh850.c
+src/cpu/cpu_exec/op_exec_bit.c
+src/cpu/cpu_exec/op_exec_branch.c
+src/cpu/cpu_exec/op_exec_branch_rh850.c
+src/cpu/cpu_exec/op_exec.c
+src/cpu/cpu_exec/op_exec_dbg.c
+src/cpu/cpu_exec/op_exec_div.c
+src/cpu/cpu_exec/op_exec_fpu.c
+src/cpu/cpu_exec/op_exec.h
+src/cpu/cpu_exec/op_exec_load.c
+src/cpu/cpu_exec/op_exec_load_rh850.c
+src/cpu/cpu_exec/op_exec_logic.c
+src/cpu/cpu_exec/op_exec_ops.h
+src/cpu/cpu_exec/op_exec_sat.c
+src/cpu/cpu_exec/op_exec_spec.c
+src/cpu/cpu_exec/op_exec_spec_rh850.c
+src/cpu/cpu_exec/op_exec_store.c
+src/cpu/cpu_exec/op_exec_store_rh850.c
+src/cpu/mpu/target/rh850f1k/target_mpu.c
+src/cpu/mpu/target/rh850f1k/target_mpu.h
+src/cpu/mpu/target/rh850f1k/target_mpu_mei.c
+src/cpu/mpu/target/rh850f1k/target_mpu_mei.h
+src/cpu/mpu/target/target_mpu_common.c
+src/cpu/mpu/target/target_mpu_common.h
+src/cpu/mpu/target/target_mpu_op.h
+src/cpu/target_cpu.h
+src/debugger/executor/concrete_executor/dbg_target_cpu.c
+src/debugger/executor/concrete_executor/dbg_target_serial.c
+src/debugger/executor/concrete_executor/dbg_target_serial_tcp.c
+src/debugger/interaction/inc/dbg_interaction_target_ids.h
+src/device/device.c
+src/device/device.h
+src/device/intc/intc.c
+src/device/intc/intc.h
+src/device/intc/intc_target.c
+src/device/intc/intc_target.h
+src/device/intc/intc_user.c
+src/device/intc/intc_user.h
+src/device/intc/rh850f1k/intc_config.c
+src/device/intc/rh850f1k/intc_config.h
+src/device/peripheral/rh850f1k/can/can_buffer.c
+src/device/peripheral/rh850f1k/can/can_buffer.h
+src/device/peripheral/rh850f1k/can/canbus/can_bus.h
+src/device/peripheral/rh850f1k/can/canbus/can_bus_impl_ros.c
+src/device/peripheral/rh850f1k/can/can.c
+src/device/peripheral/rh850f1k/can/can_config.h
+src/device/peripheral/rh850f1k/can/can_data.h
+src/device/peripheral/rh850f1k/can/can_fifo.c
+src/device/peripheral/rh850f1k/can/can_fifo.h
+src/device/peripheral/rh850f1k/can/can.h
+src/device/peripheral/rh850f1k/can/can_interrupt.c
+src/device/peripheral/rh850f1k/can/can_interrupt.h
+src/device/peripheral/rh850f1k/can/can_mode_channel.c
+src/device/peripheral/rh850f1k/can/can_mode_channel.h
+src/device/peripheral/rh850f1k/can/can_mode_global.c
+src/device/peripheral/rh850f1k/can/can_mode_global.h
+src/device/peripheral/rh850f1k/can/can_rule.h
+src/device/peripheral/rh850f1k/can/can_rx.c
+src/device/peripheral/rh850f1k/can/can_rx.h
+src/device/peripheral/rh850f1k/can/can_tx.c
+src/device/peripheral/rh850f1k/can/can_tx.h
+src/device/peripheral/rh850f1k/can/can_tx_history.c
+src/device/peripheral/rh850f1k/can/can_tx_history.h
+src/device/peripheral/rh850f1k/can/can_tx_queue.c
+src/device/peripheral/rh850f1k/can/can_tx_queue.h
+src/device/peripheral/rh850f1k/can/can_types.h
+src/device/peripheral/rh850f1k/can/mapping/can_register.h
+src/device/peripheral/rh850f1k/can/mapping/can_register_mapping.c
+src/device/peripheral/rh850f1k/can/mapping/can_register_mapping.h
+src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io_channel.c
+src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io_fifo_status.c
+src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io_global.c
+src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io.h
+src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io_rx_buffer.c
+src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io_rx_fifo.c
+src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io_rx_rule.c
+src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io_table.c
+src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io_table.h
+src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io_tx_buffer.c
+src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io_tx_buffer_status.c
+src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io_tx_history.c
+src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io_tx_queue.c
+src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io_txrx_fifo.c
+src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_reset.h
+src/device/peripheral/rh850f1k/can/mapping/can_register_memory.c
+src/device/peripheral/rh850f1k/clock/clock.c
+src/device/peripheral/rh850f1k/digital/digital.c
+src/device/peripheral/rh850f1k/inc/clock.h
+src/device/peripheral/rh850f1k/inc/digital.h
+src/device/peripheral/rh850f1k/inc/serial.h
+src/device/peripheral/rh850f1k/inc/timer.h
+src/device/peripheral/rh850f1k/serial/serial.c
+src/device/peripheral/rh850f1k/timer/timer.c
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/README.md
@@ -0,0 +1,16 @@
+# athrill-target-rh850f1x
+
+rh850f1x Target dependencies for [Athrill](https://github.com/toppers/athrill)
+
+## License
+
+This repository is distributed with [TOPPERS License](https://toppers.jp/en/license.html).
+
+## Support target group
+
+- RH850/F1K
+    - The reference manual is as follows.
+       - RH850/F1K ユーザーズマニュアルハードウェア編　2016年12月21日Rev.1.10（R01UH0562JJ0110 Rev.1.10）
+       - RH850G3KHユーザーズマニュアル ソフトウェア編　2016年12月22日Rev.1.20（R01US0165JJ0120 Rev.1.20）
+    - The files in Makefile_v850.cpu are based on [v850e2m](https://github.com/toppers/athrill-target-v850e2m), not on rh850. 
+    
\ No newline at end of file
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/build_linux/Makefile
@@ -0,0 +1,132 @@
+#
+#  TOPPERS athrill
+#      Athrill is a CPU emulator. Athrill was developed to easily
+#      execute and debug embedded programs on virtual microcomputer.
+#
+#  Copyright (C) 2019 by Center for Embedded Computing Systems
+#                Graduate School of Informatics, Nagoya Univ., JAPAN
+#  Copyright (C) 2019 by ESM, Inc.
+#
+#
+#  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+#  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+#  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+#  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+#      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+#      スコード中に含まれていること．
+#  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+#      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+#      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+#      の無保証規定を掲載すること．
+#  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+#      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+#      と．
+#    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+#        作権表示，この利用条件および下記の無保証規定を掲載すること．
+#    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+#        報告すること．
+#  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+#      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+#      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+#      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+#      免責すること．
+#
+#  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+#  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+#  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+#  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+#  の責任を負わない．
+#
+#  $Id$
+#
+
+include Makefile.env
+
+LIBCUI		:= libcui.a
+LIBCPU		:= libcpu.a
+LIBCAN		:= libcan.a
+LIBDEVICE	:= libdevice.a
+LIBBUS		:= libbus.a
+LIBMPU		:= libmpu.a
+LIBLOADER	:= libloader.a
+LIBSTD		:= libstd.a
+LIBMAIN		:= libmain.a
+LIBMROS		:= libmros.a
+
+
+AROBJS		:= $(LIBMAIN)
+AROBJS		+= $(LIBCUI)
+AROBJS		+= $(LIBCPU)
+AROBJS		+= $(LIBFPU)
+AROBJS		+= $(LIBDEVICE)
+AROBJS		+= $(LIBBUS)
+AROBJS		+= $(LIBMPU)
+AROBJS		+= $(LIBCAN)
+AROBJS		+= $(LIBLOADER)
+AROBJS		+= $(LIBSTD)
+AROBJS		+= $(LIBMROS)
+
+all: $(AROBJS)
+	$(RANLIB) $(AROBJS)
+	$(GCC) -O3 $(LFLAGS) $(AROBJS) -o $(TARGET)  $(LIBS)
+	$(CP) $(TARGET) $(INSTALL_DIR)/
+	chmod +x $(INSTALL_DIR)/$(TARGET)
+
+build_all:
+	make -f $(CORE_MKDIR)/Makefile.main all
+	make -f $(CORE_MKDIR)/Makefile.cui all
+	make -f $(TARGET_MKDIR)/Makefile.cpu all
+	make -f $(TARGET_MKDIR)/Makefile.device all
+	make -f $(CORE_MKDIR)/Makefile.bus all
+	make -f $(CORE_MKDIR)/Makefile.loader all
+	make -f $(TARGET_MKDIR)/Makefile.mpu all
+	make -f $(CORE_MKDIR)/Makefile.std all
+	make -f $(CORE_MKDIR)/Makefile.mros all
+	$(RANLIB) $(AROBJS)
+	$(GCC) -O3 $(LFLAGS) $(AROBJS) -o $(TARGET)  $(LIBS)
+	$(CP) $(TARGET) $(INSTALL_DIR)/
+	chmod +x $(INSTALL_DIR)/$(TARGET)
+
+$(LIBMAIN):
+	make -f $(CORE_MKDIR)/Makefile.main all
+
+$(LIBCUI): 
+	make -f $(CORE_MKDIR)/Makefile.cui all
+
+$(LIBCPU): 
+	make -f $(TARGET_MKDIR)/Makefile.cpu all
+
+$(LIBDEVICE): 
+	make -f $(TARGET_MKDIR)/Makefile.device all
+
+$(LIBBUS): 
+	make -f $(CORE_MKDIR)/Makefile.bus all
+
+$(LIBLOADER):
+	make -f $(CORE_MKDIR)/Makefile.loader all
+
+$(LIBMPU): 
+	make -f $(TARGET_MKDIR)/Makefile.mpu all
+
+$(LIBSTD):
+	make -f $(CORE_MKDIR)/Makefile.std all
+
+$(LIBMROS):
+	make -f $(CORE_MKDIR)/Makefile.mros all
+
+clean:
+	make -f $(TARGET_MKDIR)/Makefile.cpu clean
+	make -f $(TARGET_MKDIR)/Makefile.device clean
+	make -f $(CORE_MKDIR)/Makefile.bus clean
+	make -f $(CORE_MKDIR)/Makefile.cui clean
+	make -f $(CORE_MKDIR)/Makefile.loader clean
+	make -f $(TARGET_MKDIR)/Makefile.mpu clean
+	make -f $(CORE_MKDIR)/Makefile.std clean
+	make -f $(CORE_MKDIR)/Makefile.main clean
+	make -f $(CORE_MKDIR)/Makefile.mros clean
+	$(RM) -f $(TARGET) 
+	$(RM) -f $(INSTALL_DIR)/$(TARGET)
+		
+list:
+	@echo $(AROBJS)
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/build_linux/Makefile.can
@@ -0,0 +1,105 @@
+#
+#  TOPPERS athrill
+#      Athrill is a CPU emulator. Athrill was developed to easily
+#      execute and debug embedded programs on virtual microcomputer.
+#
+#  Copyright (C) 2019 by Center for Embedded Computing Systems
+#                Graduate School of Informatics, Nagoya Univ., JAPAN
+#  Copyright (C) 2019 by ESM, Inc.
+#
+#
+#  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+#  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+#  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+#  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+#      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+#      スコード中に含まれていること．
+#  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+#      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+#      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+#      の無保証規定を掲載すること．
+#  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+#      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+#      と．
+#    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+#        作権表示，この利用条件および下記の無保証規定を掲載すること．
+#    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+#        報告すること．
+#  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+#      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+#      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+#      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+#      免責すること．
+#
+#  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+#  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+#  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+#  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+#  の責任を負わない．
+#
+#  $Id$
+#
+include Makefile.env
+
+SRC_ROOT	:=	$(CORE_DIR)/device/peripheral/mros-dev/mros-src
+CAN_DIR		:= $(TARGET_DIR)/device/peripheral/rh850f1k/can
+
+CAN_TARGET	:= libcan.a
+
+IFLAGS	:= -I.
+IFLAGS	+= -I$(CORE_DIR)/inc
+IFLAGS	+= -I$(CORE_DIR)/lib
+IFLAGS	+= -I$(CORE_DIR)/cpu
+IFLAGS	+= -I$(CORE_DIR)/device/mpu
+IFLAGS	+= -I$(CORE_DIR)/device/peripheral/mros-dev/mros-src/os/target/os_asp
+IFLAGS	+= -I$(CORE_DIR)/device/peripheral/mros-dev/mros-athrill/api
+IFLAGS	+= -I$(CORE_DIR)/device/peripheral/mros-dev/mros-athrill/device
+IFLAGS	+= -I$(CORE_DIR)/device/peripheral/mros-dev/mros-athrill/target/os
+IFLAGS	+= -I$(TARGET_DIR)/device
+IFLAGS	+= -I$(TARGET_DIR)/cpu
+IFLAGS	+= -I$(TARGET_DIR)/cpu/config
+IFLAGS	+= -I$(TARGET_DIR)/cpu/mpu/target
+IFLAGS  += -I$(CAN_DIR)
+
+CAN_OBJS := can.o
+CAN_OBJS += can_tx.o
+CAN_OBJS += can_rx.o
+CAN_OBJS += can_buffer.o
+CAN_OBJS += can_fifo.o
+CAN_OBJS += can_mode_global.o
+CAN_OBJS += can_mode_channel.o
+CAN_OBJS += can_register_mapping.o
+CAN_OBJS += can_register_mapping_io_table.o
+CAN_OBJS += can_register_mapping_io_rx_rule.o
+CAN_OBJS += can_register_mapping_io_rx_fifo.o
+CAN_OBJS += can_register_mapping_io_rx_buffer.o
+CAN_OBJS += can_register_mapping_io_global.o
+CAN_OBJS += can_register_mapping_io_channel.o
+CAN_OBJS += can_register_mapping_io_fifo_status.o
+CAN_OBJS += can_register_mapping_io_tx_buffer.o
+CAN_OBJS += can_register_mapping_io_txrx_fifo.o
+CAN_OBJS += can_register_mapping_io_tx_buffer_status.o
+CAN_OBJS += can_register_memory.o
+CAN_OBJS += can_interrupt.o
+CAN_OBJS += can_tx_queue.o
+CAN_OBJS += can_tx_history.o
+CAN_OBJS += can_register_mapping_io_tx_queue.o
+CAN_OBJS += can_register_mapping_io_tx_history.o
+CAN_OBJS += can_bus_impl_ros.o
+
+CFLAGS	:= $(WFLAGS)
+CFLAGS	+= $(IFLAGS)
+
+
+VPATH  := $(CAN_DIR)
+VPATH  += $(CAN_DIR)/mapping
+VPATH  += $(CAN_DIR)/canbus
+
+all: $(CAN_TARGET)
+
+$(CAN_TARGET): $(CAN_OBJS)
+	$(AR)  $(AFLAGS) $(CAN_TARGET) $(CAN_OBJS)
+
+cleanobjs:
+	$(RM) -f $(CAN_OBJS) $(CAN_TARGET) $(CAN_TARGET)
+	
\ No newline at end of file
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/build_linux/Makefile.cpu
@@ -0,0 +1,103 @@
+#
+#  TOPPERS athrill
+#      Athrill is a CPU emulator. Athrill was developed to easily
+#      execute and debug embedded programs on virtual microcomputer.
+#
+#  Copyright (C) 2019 by Center for Embedded Computing Systems
+#                Graduate School of Informatics, Nagoya Univ., JAPAN
+#  Copyright (C) 2019 by ESM, Inc.
+#
+#
+#  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+#  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+#  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+#  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+#      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+#      スコード中に含まれていること．
+#  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+#      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+#      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+#      の無保証規定を掲載すること．
+#  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+#      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+#      と．
+#    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+#        作権表示，この利用条件および下記の無保証規定を掲載すること．
+#    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+#        報告すること．
+#  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+#      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+#      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+#      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+#      免責すること．
+#
+#  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+#  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+#  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+#  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+#  の責任を負わない．
+#
+#  $Id$
+#
+
+include Makefile.env
+
+LIBTARGET	:= libcpu.a
+
+IFLAGS	:= -I$(CORE_DIR)/inc
+IFLAGS	+= -I$(CORE_DIR)/cpu
+IFLAGS	+= -I$(CORE_DIR)/bus
+IFLAGS	+= -I$(CORE_DIR)/device/mpu
+IFLAGS	+= -I$(CORE_DIR)/lib
+IFLAGS	+= -I$(TARGET_DIR)/cpu
+IFLAGS	+= -I$(TARGET_DIR)/device
+IFLAGS	+= -I$(TARGET_DIR)/cpu/config
+IFLAGS	+= -I$(TARGET_DIR)/cpu/mpu
+IFLAGS	+= -I$(TARGET_DIR)/cpu/mpu/target
+IFLAGS	+= -I$(TARGET_DIR)/cpu/mpu/target/$(V850_VERSION)
+
+VPATH	:=	$(TARGET_DIR)/cpu/cpu_common
+VPATH	+=	$(TARGET_DIR)/cpu/cpu_dec
+VPATH	+=	$(TARGET_DIR)/cpu/cpu_exec
+VPATH	+=	$(TARGET_DIR)/cpu/config
+VPATH	+=	$(TARGET_DIR)/cpu/mpu
+VPATH	+=	$(TARGET_DIR)/cpu/mpu/target
+VPATH	+=	$(TARGET_DIR)/cpu/mpu/target/$(V850_VERSION)
+VPATH	+=	$(CORE_DIR)/lib
+
+
+CFLAGS	:= $(WFLAGS)
+CFLAGS	+= $(IFLAGS)
+
+OBJS	:=	op_exec.o
+OBJS	+=	op_dec.o
+OBJS	+=	op_parse.o
+OBJS	+=	op_parse_private.o
+OBJS	+=	op_exec_bit.o
+OBJS	+=	op_exec_branch_rh850.o
+OBJS	+=	op_exec_dbg.o
+OBJS	+=	op_exec_div.o
+OBJS	+=	op_exec_logic.o
+OBJS	+=	op_exec_sat.o
+OBJS	+=	op_exec_arithm_rh850.o
+OBJS	+=	op_exec_store_rh850.o
+OBJS	+=	op_exec_load_rh850.o
+OBJS	+=	op_exec_spec_rh850.o
+OBJS	+=	cpu_config.o
+OBJS	+=	dbg_log.o
+OBJS	+=	target_mpu_mei.o
+OBJS	+=	target_mpu_common.o
+OBJS	+=	target_mpu.o
+
+include Makefile_v850.cpu
+
+all:	$(LIBTARGET)
+
+$(LIBTARGET):	$(OBJS)
+	$(AR) $(AFLAGS) $(LIBTARGET) $(OBJS)
+
+clean:
+	$(RM) -f $(OBJS) $(LIBTARGET)
+
+
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/build_linux/Makefile.device
@@ -0,0 +1,112 @@
+#
+#  TOPPERS athrill
+#      Athrill is a CPU emulator. Athrill was developed to easily
+#      execute and debug embedded programs on virtual microcomputer.
+#
+#  Copyright (C) 2019 by Center for Embedded Computing Systems
+#                Graduate School of Informatics, Nagoya Univ., JAPAN
+#  Copyright (C) 2019 by ESM, Inc.
+#
+#
+#  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+#  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+#  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+#  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+#      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+#      スコード中に含まれていること．
+#  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+#      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+#      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+#      の無保証規定を掲載すること．
+#  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+#      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+#      と．
+#    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+#        作権表示，この利用条件および下記の無保証規定を掲載すること．
+#    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+#        報告すること．
+#  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+#      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+#      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+#      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+#      免責すること．
+#
+#  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+#  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+#  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+#  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+#  の責任を負わない．
+#
+#  $Id$
+#
+
+include Makefile.env
+
+LIBTARGET	:= libdevice.a
+LIBCAN		:= libcan.a
+
+IFLAGS	:= -I$(CORE_DIR)/inc
+IFLAGS	+= -I$(CORE_DIR)/cpu
+IFLAGS	+= -I$(CORE_DIR)/device/mpu
+IFLAGS	+= -I$(CORE_DIR)/debugger/executor
+IFLAGS	+= -I$(CORE_DIR)/lib
+IFLAGS	+= -I$(CORE_DIR)/device/peripheral/target
+IFLAGS	+= -I$(CORE_DIR)/device/peripheral/mros-dev/mros-src/os/target/os_asp
+IFLAGS  += -I$(CORE_DIR)/device/peripheral/serial/fifo
+IFLAGS	+= -I$(APLDIR)/include
+IFLAGS	+= -I$(TARGET_DIR)/cpu
+IFLAGS	+= -I$(TARGET_DIR)/device
+IFLAGS	+= -I$(TARGET_DIR)/device/intc
+IFLAGS	+= -I$(TARGET_DIR)/device/intc/$(V850_VERSION)
+IFLAGS	+= -I$(TARGET_DIR)/device/peripheral/$(V850_VERSION)
+IFLAGS	+= -I$(TARGET_DIR)/device/peripheral/$(V850_VERSION)/inc
+IFLAGS	+= -I$(TARGET_DIR)/cpu/config
+IFLAGS	+= -I$(TARGET_DIR)/cpu/mpu/target
+
+VPATH	:=	$(CORE_DIR)/device/peripheral
+VPATH   +=      $(CORE_DIR)/device/peripheral/serial/fifo
+VPATH	+=	$(TARGET_DIR)/device
+VPATH	+=	$(TARGET_DIR)/device/intc
+VPATH	+=	$(TARGET_DIR)/device/intc/$(V850_VERSION)
+VPATH	+=	$(TARGET_DIR)/device/peripheral
+VPATH	+=	$(TARGET_DIR)/device/peripheral/$(V850_VERSION)/timer
+VPATH	+=	$(TARGET_DIR)/device/peripheral/$(V850_VERSION)/serial
+VPATH	+=	$(TARGET_DIR)/device/peripheral/$(V850_VERSION)/clock
+VPATH	+=	$(TARGET_DIR)/device/peripheral/$(V850_VERSION)/digital
+VPATH	+=	$(TARGET_DIR)/debugger/executor/concrete_executor
+
+
+CFLAGS	:= $(WFLAGS)
+CFLAGS	+= $(IFLAGS)
+
+OBJS	:=	device.o
+OBJS	+=	timer.o
+OBJS	+=	serial.o
+OBJS	+=	clock.o
+OBJS	+=	digital.o
+OBJS	+=	dbg_target_serial.o
+OBJS	+=	dbg_target_serial_tcp.o
+OBJS	+=	dbg_target_cpu.o
+OBJS	+=	athrill_mpthread.o
+OBJS	+=	intc_config.o
+OBJS	+=	intc_user.o
+OBJS	+=	intc_target.o
+OBJS	+=	intc.o
+OBJS	+=	athrill_device.o
+OBJS	+=	athrill_syscall_device.o
+OBJS    +=      serial_fifo.o
+
+all:	$(LIBTARGET)
+
+$(LIBTARGET):	$(OBJS) $(LIBCAN)
+	$(AR) $(AFLAGS) $(LIBTARGET) $(OBJS)
+
+$(LIBCAN):
+	make -f Makefile.can all
+
+clean:
+	make -f Makefile.can cleanobjs
+	$(RM) -f $(OBJS) $(LIBTARGET)
+
+
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/build_linux/Makefile.env
@@ -0,0 +1,124 @@
+#
+#  TOPPERS athrill
+#      Athrill is a CPU emulator. Athrill was developed to easily
+#      execute and debug embedded programs on virtual microcomputer.
+#
+#  Copyright (C) 2019 by Center for Embedded Computing Systems
+#                Graduate School of Informatics, Nagoya Univ., JAPAN
+#  Copyright (C) 2019 by ESM, Inc.
+#
+#
+#  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+#  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+#  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+#  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+#      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+#      スコード中に含まれていること．
+#  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+#      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+#      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+#      の無保証規定を掲載すること．
+#  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+#      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+#      と．
+#    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+#        作権表示，この利用条件および下記の無保証規定を掲載すること．
+#    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+#        報告すること．
+#  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+#      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+#      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+#      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+#      免責すること．
+#
+#  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+#  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+#  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+#  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+#  の責任を負わない．
+#
+#  $Id$
+#
+
+ATHRILL_DIR			:=../../athrill
+CORE_DIR			:= $(ATHRILL_DIR)/src
+APLDIR				:= $(ATHRILL_DIR)/apl
+TARGET_DIR			:= ../src
+INSTALL_DIR			:= $(ATHRILL_DIR)/bin/linux
+
+CORE_MKDIR			:= $(ATHRILL_DIR)/build/core/linux
+TARGET_MKDIR		:= .
+
+#V850_VERSION := v850
+V850_VERSION := rh850f1k
+
+#
+# Warning flags
+#
+WFLAGS			:= -g -Wall
+WFLAGS			+= -Wunknown-pragmas
+WFLAGS			+= -Wimplicit-int
+WFLAGS			+= -Wtrigraphs
+WFLAGS			+= -std=gnu99
+WFLAGS			+= -mtune=native -march=native -mfpmath=both 
+
+#
+# Define flags
+#
+DFLAGS			:= -DOS_LINUX
+DFLAGS			+= -DSUPRESS_DETECT_WARNING_MESSAGE
+ifeq ($(supress_detect_error),true)
+DFLAGS			+= -DSUPRESS_DETECT_ERROR
+endif
+#DFLAGS			+= -DMINIMUM_DEVICE_CONFIG
+#DFLAGS			+= -DCONFIG_STAT_PERF
+DFLAGS			+= -DDISABLE_MEMPROTECT
+DFLAGS			+= -DCPU_CONFIG_MEMORY_PROTECTION_ENABLE
+DFLAGS			+= -DEXDEV_ENABLE
+ifeq ($(serial_fifo_enable),true)
+DFLAGS			+= -D SERIAL_FIFO_ENABLE
+endif
+ifeq ($(skip_clock_bugfix), true)
+DFLAGS			+= -D CPUEMU_CLOCK_BUG_FIX
+endif
+ifeq ($(fix_intr_cpu_rcv_clr), true)
+DFLAGS			+= -D FIX_INTR_CPU_RCV_CLR
+endif
+ifeq ($(fix_intr_pmr_bugfix), true)
+DFLAGS			+= -D USER_INTR_PMR_BUGFIX
+endif
+
+#
+# ARCH
+#
+#ARCH		:= v850e2m
+ARCH		:= rh850
+
+#
+# compiler
+#
+GCC			:= gcc
+AR			:= ar
+RANLIB			:= ranlib
+CP			:= /bin/cp
+RM			:= /bin/rm
+
+#
+# AR flags
+#
+AFLAGS			:= -rcSv
+
+TARGET		:= athrill2
+
+LFLAGS	:= -Wl,--allow-multiple-definition
+LIBS	:= -lm -lpthread  -ldl
+LIBS	+= $(CAN_DBG_LIBS)
+
+ifeq ($(gprof),true)
+ include make_conf/gnu_profile.def
+endif
+
+.SUFFIXES:      .c .o
+
+.c.o:	$<
+	$(GCC) -O3 -c $(CFLAGS) $(DFLAGS) $<
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/build_linux/Makefile.mpu
@@ -0,0 +1,80 @@
+#
+#  TOPPERS athrill
+#      Athrill is a CPU emulator. Athrill was developed to easily
+#      execute and debug embedded programs on virtual microcomputer.
+#
+#  Copyright (C) 2019 by Center for Embedded Computing Systems
+#                Graduate School of Informatics, Nagoya Univ., JAPAN
+#  Copyright (C) 2019 by ESM, Inc.
+#
+#
+#  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+#  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+#  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+#  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+#      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+#      スコード中に含まれていること．
+#  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+#      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+#      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+#      の無保証規定を掲載すること．
+#  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+#      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+#      と．
+#    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+#        作権表示，この利用条件および下記の無保証規定を掲載すること．
+#    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+#        報告すること．
+#  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+#      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+#      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+#      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+#      免責すること．
+#
+#  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+#  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+#  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+#  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+#  の責任を負わない．
+#
+#  $Id$
+#
+
+include Makefile.env
+
+LIBTARGET	:= libmpu.a
+
+IFLAGS	:= -I$(CORE_DIR)/inc
+IFLAGS	+= -I$(CORE_DIR)/device/mpu
+IFLAGS	+= -I$(CORE_DIR)/lib
+IFLAGS	+= -I$(CORE_DIR)/lib/dwarf
+IFLAGS	+= -I$(CORE_DIR)/lib/dwarf/data_type
+IFLAGS	+= -I$(CORE_DIR)/cpu
+IFLAGS	+= -I$(TARGET_DIR)/cpu
+IFLAGS	+= -I$(TARGET_DIR)/cpu/config
+IFLAGS  += -I$(CORE_DIR)/device/peripheral/serial/fifo
+
+VPATH	:=	$(CORE_DIR)/device/mpu
+VPATH	+=	$(CORE_DIR)/device/mpu/loader
+VPATH	+=	$(TARGET_DIR)/cpu/config
+VPATH	+=	$(TARGET_DIR)/cpu/config/$(V850_VERSION)
+
+
+CFLAGS	:= $(WFLAGS)
+CFLAGS	+= $(IFLAGS)
+
+OBJS	:=	mpu.o
+OBJS	+=	mpu_config.o
+OBJS	+=	mpu_malloc.o
+OBJS	+=	loader.o
+
+all:	$(LIBTARGET)
+
+$(LIBTARGET):	$(OBJS)
+	$(AR) $(AFLAGS) $(LIBTARGET) $(OBJS)
+
+clean:
+	$(RM) -f $(OBJS) $(LIBTARGET)
+
+
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/build_linux/Makefile_v850.cpu
@@ -0,0 +1,56 @@
+#
+#  TOPPERS athrill
+#      Athrill is a CPU emulator. Athrill was developed to easily
+#      execute and debug embedded programs on virtual microcomputer.
+#
+#  Copyright (C) 2019 by Center for Embedded Computing Systems
+#                Graduate School of Informatics, Nagoya Univ., JAPAN
+#  Copyright (C) 2019 by ESM, Inc.
+#
+#
+#  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+#  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+#  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+#  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+#      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+#      スコード中に含まれていること．
+#  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+#      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+#      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+#      の無保証規定を掲載すること．
+#  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+#      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+#      と．
+#    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+#        作権表示，この利用条件および下記の無保証規定を掲載すること．
+#    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+#        報告すること．
+#  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+#      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+#      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+#      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+#      免責すること．
+#
+#  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+#  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+#  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+#  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+#  の責任を負わない．
+#
+#  $Id$
+#
+
+#The following files are based on v850e2m(https://github.com/toppers/athrill-target-v850e2m).
+
+OBJS	+=	op_exec_arithm.o
+OBJS	+=	op_exec_bit.o
+OBJS	+=	op_exec_branch.o
+OBJS	+=	op_exec_dbg.o
+OBJS	+=	op_exec_div.o
+OBJS	+=	op_exec_fpu.o
+OBJS	+=	op_exec_load.o
+OBJS	+=	op_exec_logic.o
+OBJS	+=	op_exec_sat.o
+OBJS	+=	op_exec_spec.o
+OBJS	+=	op_exec_store.o
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/params/rh850f1k/atk2-sc1/device_config.txt
@@ -0,0 +1,6 @@
+DEVICE_CONFIG_TIMER_FD		1
+DEBUG_FUNC_ENABLE_FT		1
+DEBUG_FUNC_ENABLE_BT		1
+DEBUG_FUNC_ENABLE_PROF		1
+DEBUG_FUNC_ENABLE_WATCH		1
+DEBUG_FUNC_ENABLE_SKIP_CLOCK    1
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/params/rh850f1k/atk2-sc1/memory.txt
@@ -0,0 +1,2 @@
+ROM, 0x00000000, 1024
+RAM, 0xFEDE8000, 512
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/params/rh850f1k/atk2-sc3/device_config.txt
@@ -0,0 +1,6 @@
+DEVICE_CONFIG_TIMER_FD		50
+DEBUG_FUNC_ENABLE_FT		1
+DEBUG_FUNC_ENABLE_BT		1
+DEBUG_FUNC_ENABLE_PROF		1
+DEBUG_FUNC_ENABLE_WATCH		1
+DEBUG_FUNC_ENABLE_SKIP_CLOCK    1
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/params/rh850f1k/atk2-sc3/memory.txt
@@ -0,0 +1,2 @@
+ROM, 0x00000000, 2048
+RAM, 0xfebd0000, 2048
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/config/cpu_config.c
@@ -0,0 +1,478 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "cpu.h"
+#include "bus.h"
+#include "std_cpu_ops.h"
+#include <stdio.h>
+#include "cpu_common/cpu_ops.h"
+#include "cpu_dec/op_parse.h"
+#include "cpu_exec/op_exec.h"
+#include "mpu_types.h"
+#include <sys/time.h>
+#include "std_device_ops.h"
+#include "device.h"
+
+
+#include "target_cpu.h"
+#include "target_mpu_op.h"
+
+CpuType virtual_cpu;
+
+void cpu_init(void)
+{
+	CoreIdType i;
+	for (i = 0; i < cpu_config_get_core_id_num(); i++) {
+		virtual_cpu.cores[i].core.core_id = i;
+		cpu_reset(i);
+	}
+	return;
+}
+bool cpu_has_permission(CoreIdType core_id, MpuAddressRegionEnumType region_type, CpuMemoryAccessType access_type, uint32 addr, uint32 size)
+{
+	TargetMpuAccessType mpu_access_type;
+
+	switch (access_type) {
+	case CpuMemoryAccess_READ:
+		mpu_access_type = MPU_TARGET_ACCESS_READ;
+		break;
+	case CpuMemoryAccess_WRITE:
+		mpu_access_type = MPU_TARGET_ACCESS_WRITE;
+		break;
+	case CpuMemoryAccess_EXEC:
+		mpu_access_type = MPU_TARGET_ACCESS_EXEC;
+		break;
+	case CpuMemoryAccess_NONE:
+	default:
+		mpu_access_type = MPU_TARGET_ACCESS_NONE;
+		break;
+	}
+
+	return target_mpu_has_permission(&(virtual_cpu.cores[core_id].core), mpu_access_type, addr, size);
+}
+
+bool cpu_illegal_access(CoreIdType core_id)
+{
+	if (virtual_cpu.cores[core_id].core.current_code_exception.is_code_exception == FALSE) {
+		return FALSE;
+	}
+
+	switch (virtual_cpu.cores[core_id].core.current_code_exception.exception_type) {
+	case ExceptionId_PIE:
+		intc_raise_exception(core_id, ExceptionId_PIE);
+		break;
+	case ExceptionId_MDP:
+		intc_raise_exception(core_id, ExceptionId_MDP);
+		target_mpu_set_error(&(virtual_cpu.cores[core_id].core));
+		break;
+	case ExceptionId_MIP:
+		intc_raise_exception(core_id, ExceptionId_MIP);
+		target_mpu_set_error(&(virtual_cpu.cores[core_id].core));
+		break;
+	default:
+		break;
+	}
+
+	virtual_cpu.cores[core_id].core.current_code_exception.is_code_exception = FALSE;
+	virtual_cpu.cores[core_id].core.current_code_exception.exception_type = ExceptionId_Num;
+	virtual_cpu.cores[core_id].core.mpu.excption_error_info.is_error_occurred = FALSE;
+
+	return TRUE;
+}
+
+static void private_sys_init(void)
+{
+	(void)bus_put_data32(0, (uint32)PLLS,  0x00000004);
+	return;
+}
+
+static void private_cpu_reset(TargetCoreType *cpu)
+{
+	uint32 *sysreg;
+	cpu->reg.pc = 0x00;
+	cpu->reg.r[0] = 0;
+
+	cpu->reg.sys.current_grp = SYS_GRP_CPU;
+	cpu->reg.sys.current_bnk = SYS_GRP_CPU_BNK_0;
+	for (int regId = 0; regId < CPU_GREG_NUM; regId++) {
+		sysreg = cpu_get_sysreg(&cpu->reg.sys, regId);
+		*sysreg = 0;
+	}
+	sys_get_cpu_base(&cpu->reg)->r[SYS_REG_PSW] = 0x20;
+
+	sys_get_cpu_base(&cpu->reg)->r[SYS_REG_FPSR] = (1U << 17); // FS bit on
+
+	sysreg = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_2, SYS_REG_HTCFG0);
+	*sysreg = ( ((cpu->core_id + 1) << 16) | 0x8000 );
+
+	private_sys_init();
+	cpu->is_halt = FALSE;
+	cpu->current_code_exception.is_code_exception = FALSE;
+	cpu->current_code_exception.exception_type = ExceptionId_Num;
+	return;
+}
+
+void cpu_reset(CoreIdType core_id)
+{
+	private_cpu_reset(&virtual_cpu.cores[core_id].core);
+	target_mpu_init(&virtual_cpu.cores[core_id].core);
+	virtual_cpu.cores[core_id].core.fatal_error = FALSE;
+	virtual_cpu.cores[core_id].core.current_code_exception.exception_type = ExceptionId_Num;
+	virtual_cpu.cores[core_id].core.current_code_exception.is_code_exception = FALSE;
+
+	return;
+}
+bool cpu_is_halt(CoreIdType core_id)
+{
+	return virtual_cpu.cores[core_id].core.is_halt;
+}
+void cpu_set_current_core(CoreIdType core_id)
+{
+	virtual_cpu.current_core = &virtual_cpu.cores[core_id];
+	return;
+}
+
+static Std_ReturnType cpu_supply_clock_not_cached(CoreIdType core_id, CachedOperationCodeType *cached_code, uint32 inx)
+{
+	int ret;
+	Std_ReturnType err;
+	static OpDecodedCodeType	decoded_code;
+	OpDecodedCodeType		*p_decoded_code;
+	OperationCodeType optype;
+	bool permission;
+
+	if (cached_code != NULL) {
+		p_decoded_code = &cached_code->codes[inx].decoded_code;
+		virtual_cpu.cores[core_id].core.decoded_code = &cached_code->codes[inx].decoded_code;
+	}
+	else {
+		p_decoded_code = &decoded_code;
+		virtual_cpu.cores[core_id].core.decoded_code = &decoded_code;
+	}
+	/*
+	 * 命令取得する
+	 */
+	err = bus_get_pointer(core_id,
+			virtual_cpu.cores[core_id].core.reg.pc,
+				(uint8**)&(virtual_cpu.cores[core_id].core.current_code));
+	if (err != STD_E_OK) {
+		return err;
+	}
+
+	/*
+	 * デコード
+	 */
+	ret = op_parse(virtual_cpu.cores[core_id].core.current_code,
+			p_decoded_code, &optype);
+	if (ret < 0) {
+		printf("Decode Error\n");
+		return STD_E_DECODE;
+	}
+
+	permission = cpu_has_permission(core_id,
+			READONLY_MEMORY,
+			CpuMemoryAccess_EXEC,
+			virtual_cpu.cores[core_id].core.reg.pc,
+			OpFormatSize[p_decoded_code->type_id]);
+	if (permission == FALSE) {
+		if (virtual_cpu.cores[core_id].core.mpu.excption_error_info.is_error_occurred) {
+			virtual_cpu.cores[core_id].core.mpu.excption_error_info.op_codeid = optype.code_id;
+			virtual_cpu.cores[core_id].core.current_code_exception.is_code_exception = TRUE;
+			virtual_cpu.cores[core_id].core.current_code_exception.exception_type = ExceptionId_MIP;
+			return -1;
+		}
+		return STD_E_SEGV;
+	}
+
+	if (op_exec_table[optype.code_id].exec == NULL) {
+		printf("Not supported code(%d fmt=%d) Error code[0]=0x%x code[1]=0x%x type_id=0x%x\n",
+				optype.code_id, optype.format_id,
+				virtual_cpu.cores[core_id].core.current_code[0],
+				virtual_cpu.cores[core_id].core.current_code[1],
+				virtual_cpu.cores[core_id].core.decoded_code->type_id);
+		return STD_E_EXEC;
+	}
+
+	/*
+	 * 命令実行
+	 */
+	virtual_cpu.cores[core_id].core.real_elaps = (uint32)op_exec_table[optype.code_id].clocks;
+	ret = op_exec_table[optype.code_id].exec(&virtual_cpu.cores[core_id].core);
+
+	if (virtual_cpu.cores[core_id].core.mpu.excption_error_info.is_error_occurred) {
+		virtual_cpu.cores[core_id].core.mpu.excption_error_info.op_codeid = optype.code_id;
+		virtual_cpu.cores[core_id].core.current_code_exception.is_code_exception = TRUE;
+		virtual_cpu.cores[core_id].core.current_code_exception.exception_type = ExceptionId_MDP;
+		return -1;
+	}
+
+	if (ret < 0) {
+		printf("Exec Error code[0]=0x%x code[1]=0x%x type_id=0x%x code_id=%u\n",
+				virtual_cpu.cores[core_id].core.current_code[0],
+				virtual_cpu.cores[core_id].core.current_code[1],
+				virtual_cpu.cores[core_id].core.decoded_code->type_id,
+				optype.code_id);
+		return STD_E_EXEC;
+	}
+	virtual_cpu.cores[core_id].elaps += (uint64)virtual_cpu.cores[core_id].core.real_elaps;
+
+	if (cached_code != NULL) {
+		cached_code->codes[inx].code_id = optype.code_id;
+		cached_code->codes[inx].op_exec = op_exec_table[optype.code_id].exec;
+	}
+	return STD_E_OK;
+}
+
+Std_ReturnType cpu_supply_clock(CoreIdType core_id)
+{
+	int ret;
+	Std_ReturnType err;
+	uint32 inx = 0U;
+	CachedOperationCodeType *cached_code;
+
+	if (virtual_cpu.cores[core_id].core.fatal_error) {
+		return STD_E_INVALID;
+	}
+
+	if (virtual_cpu.cores[core_id].core.is_halt == TRUE) {
+		return STD_E_OK;
+	}
+	virtual_cpu.cores[core_id].core.reg.r[0] = 0U;
+
+	cached_code = virtual_cpu_get_cached_code(virtual_cpu.cores[core_id].core.reg.pc);
+	if (cached_code != NULL) {
+		inx = virtual_cpu.cores[core_id].core.reg.pc - cached_code->code_start_addr;
+	}
+	if ((cached_code == NULL) || (cached_code->codes[inx].op_exec == NULL)) {
+		err = cpu_supply_clock_not_cached(core_id, cached_code, inx);
+		if (err != STD_E_OK) {
+			return err;
+		}
+		virtual_cpu.cores[core_id].core.reg.r[0] = 0U;
+	}
+	else {
+		OpCodeId code_id = cached_code->codes[inx].code_id;
+#ifdef CONFIG_STAT_PERF
+		PROFSTAT_START(&op_exec_stat_table[code_id]);
+#endif /* CONFIG_STAT_PERF */
+		virtual_cpu.cores[core_id].core.decoded_code = &cached_code->codes[inx].decoded_code;
+#ifndef DISABLE_MEMPROTECT
+		bool permission;
+		permission = cpu_has_permission(core_id,
+				READONLY_MEMORY,
+				CpuMemoryAccess_EXEC,
+				virtual_cpu.cores[core_id].core.reg.pc,
+				OpFormatSize[cached_code->codes[inx].decoded_code.type_id]);
+		if (permission == FALSE) {
+			if (virtual_cpu.cores[core_id].core.mpu.excption_error_info.is_error_occurred) {
+				virtual_cpu.cores[core_id].core.mpu.excption_error_info.op_codeid = code_id;
+				virtual_cpu.cores[core_id].core.current_code_exception.is_code_exception = TRUE;
+				virtual_cpu.cores[core_id].core.current_code_exception.exception_type = ExceptionId_MIP;
+				return -1;
+			}
+			return STD_E_SEGV;
+		}
+#endif /* DISABLE_MEMPROTECT */
+		virtual_cpu.cores[core_id].core.real_elaps = (uint32)op_exec_table[code_id].clocks;
+		ret = cached_code->codes[inx].op_exec(&virtual_cpu.cores[core_id].core);
+#ifdef CONFIG_STAT_PERF
+		PROFSTAT_END(&op_exec_stat_table[code_id]);
+#endif /* CONFIG_STAT_PERF */
+
+		if (virtual_cpu.cores[core_id].core.mpu.excption_error_info.is_error_occurred) {
+			virtual_cpu.cores[core_id].core.mpu.excption_error_info.op_codeid = code_id;
+			virtual_cpu.cores[core_id].core.current_code_exception.is_code_exception = TRUE;
+			virtual_cpu.cores[core_id].core.current_code_exception.exception_type = ExceptionId_MDP;
+			return -1;
+		}
+
+		if (ret < 0) {
+			printf("Exec Error code[0]=0x%x code[1]=0x%x type_id=0x%x\n",
+					virtual_cpu.cores[core_id].core.current_code[0],
+					virtual_cpu.cores[core_id].core.current_code[1],
+					virtual_cpu.cores[core_id].core.decoded_code->type_id);
+			return STD_E_EXEC;
+		}
+		virtual_cpu.cores[core_id].elaps += (uint64)virtual_cpu.cores[core_id].core.real_elaps;
+		virtual_cpu.cores[core_id].core.reg.r[0] = 0U;
+	}
+	return STD_E_OK;
+}
+
+void cpu_illegal_opcode_trap(CoreIdType core_id)
+{
+	uint32 eicc;
+	uint32 ecr;
+
+	eicc = 0x60;
+	sys_get_cpu_base(&virtual_cpu.cores[core_id].core.reg)->r[SYS_REG_EIPC] = virtual_cpu.cores[core_id].core.reg.pc - 4;
+	sys_get_cpu_base(&virtual_cpu.cores[core_id].core.reg)->r[SYS_REG_EIPSW] = sys_get_cpu_base(&virtual_cpu.cores[core_id].core.reg)->r[SYS_REG_PSW];
+
+	ecr = sys_get_cpu_base(&virtual_cpu.cores[core_id].core.reg)->r[SYS_REG_ECR];
+	ecr = ecr & 0x00FF;
+	ecr |= (eicc << 16);
+	sys_get_cpu_base(&virtual_cpu.cores[core_id].core.reg)->r[SYS_REG_ECR] = ecr;
+	CPU_SET_NP(&virtual_cpu.cores[core_id].core.reg);
+	CPU_SET_EP(&virtual_cpu.cores[core_id].core.reg);
+	CPU_SET_ID(&virtual_cpu.cores[core_id].core.reg);
+	virtual_cpu.cores[core_id].core.reg.pc = 0x60;
+
+	return;
+}
+
+
+static Std_ReturnType cpu_get_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 *data);
+static Std_ReturnType cpu_put_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 data);
+
+MpuAddressRegionOperationType cpu_register_operation = {
+		.get_data8 = NULL,
+		.get_data16 = NULL,
+		.get_data32 = cpu_get_data32,
+		.put_data8 = NULL,
+		.put_data16 = NULL,
+		.put_data32 = cpu_put_data32,
+};
+static uint32 *get_cpu_register_addr(MpuAddressRegionType *region, TargetCoreType *core, uint32 addr)
+{
+	uint32 inx = (addr - CPU_CONFIG_DEBUG_REGISTER_ADDR) / sizeof(uint32);
+
+	//printf("get_cpu_register_addr:inx=%u\n", inx);
+	if (inx >= 0 && inx <= 31) {
+		return (uint32*)&core->reg.r[inx];
+	}
+	else if (addr == CPU_CONFIG_ADDR_PEID) {
+		inx = (addr - CPU_CONFIG_DEBUG_REGISTER_ADDR) * core->core_id;
+		return (uint32*)&region->data[inx];
+	}
+	else if ((addr >= CPU_CONFIG_ADDR_MEV_0) && (addr <= CPU_CONFIG_ADDR_MEV_7)) {
+		inx = (addr - CPU_CONFIG_DEBUG_REGISTER_ADDR);
+		return (uint32*)&region->data[inx];
+	}
+	else if ((addr >= CPU_CONFIG_ADDR_MIR_0) && (addr <= CPU_CONFIG_ADDR_MIR_1)) {
+		inx = (addr - CPU_CONFIG_DEBUG_REGISTER_ADDR);
+		return (uint32*)&region->data[inx];
+	}
+	return NULL;
+}
+static Std_ReturnType cpu_get_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 *data)
+{
+	uint32 *registerp = get_cpu_register_addr(region, &virtual_cpu.current_core->core, addr);
+	if (registerp == NULL) {
+		return STD_E_SEGV;
+	}
+	else if (addr == CPU_CONFIG_ADDR_PEID) {
+		*registerp = (core_id + 1);
+	}
+	*data = *registerp;
+	return STD_E_OK;
+}
+
+static Std_ReturnType cpu_put_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 data)
+{
+	uint32 *registerp = get_cpu_register_addr(region, &virtual_cpu.current_core->core, addr);
+	if (registerp == NULL) {
+		return STD_E_SEGV;
+	}
+	else if (addr == CPU_CONFIG_ADDR_PEID) {
+		return STD_E_SEGV;
+	}
+	else if ((addr == CPU_CONFIG_ADDR_MIR_0)) {
+		intc_cpu_trigger_interrupt(core_id, CPU_CONFIG_ADDR_MIR_0_INTNO);
+		return STD_E_OK;
+	}
+	else if ((addr == CPU_CONFIG_ADDR_MIR_1)) {
+		intc_cpu_trigger_interrupt(core_id, CPU_CONFIG_ADDR_MIR_1_INTNO);
+		return STD_E_OK;
+	}
+	*registerp = data;
+	return STD_E_OK;
+}
+
+
+uint32 cpu_get_pc(const TargetCoreType *core)
+{
+	return core->reg.pc;
+}
+uint32 cpu_get_ep(const TargetCoreType *core)
+{
+	return core->reg.r[30];
+}
+uint32 cpu_get_current_core_id(void)
+{
+	return ((const TargetCoreType *)virtual_cpu.current_core)->core_id;
+}
+uint32 cpu_get_current_core_pc(void)
+{
+	return cpu_get_pc((const TargetCoreType *)virtual_cpu.current_core);
+}
+void cpu_set_core_pc(CoreIdType core_id, uint32 pc)
+{
+	virtual_cpu.cores[core_id].core.reg.pc = pc;
+	return;
+}
+uint32 cpu_get_current_core_register(uint32 inx)
+{
+	return ((TargetCoreType *)virtual_cpu.current_core)->reg.r[inx];
+}
+
+uint32 cpu_get_sp(const TargetCoreType *core)
+{
+	return core->reg.r[3];
+}
+uint32 cpu_get_current_core_sp(void)
+{
+	return cpu_get_sp((const TargetCoreType *)virtual_cpu.current_core);
+}
+uint32 cpu_get_current_core_ep(void)
+{
+	return cpu_get_ep((const TargetCoreType *)virtual_cpu.current_core);
+}
+
+
+uint32 cpu_get_return_addr(const TargetCoreType *core)
+{
+	return core->reg.r[31];
+}
+CoreIdType cpu_get_core_id(const TargetCoreType *core)
+{
+	return core->core_id;
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/config/cpu_config.h
@@ -0,0 +1,113 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _CPU_CONFIG_H_
+#define _CPU_CONFIG_H_
+
+
+/*
+ * CPUコアの数
+ */
+#define CPU_CONFIG_CORE_NUM					(2)
+
+#define CPU_CONFIG_CORE_ID_0				(0)
+#define CPU_CONFIG_CORE_ID_1				(1)
+
+
+#define CPU_CONFIG_DEBUG_REGISTER_ADDR		0x06FF0000
+#define CPU_CONFIG_DEBUG_REGADDR_R0			0x06FF0600
+#define CPU_CONFIG_DEBUG_REGADDR_R1			0x06FF0604
+#define CPU_CONFIG_DEBUG_REGADDR_R2			0x06FF0608
+#define CPU_CONFIG_DEBUG_REGADDR_R3			0x06FF060C
+#define CPU_CONFIG_DEBUG_REGADDR_R4			0x06FF0610
+#define CPU_CONFIG_DEBUG_REGADDR_R5			0x06FF0614
+#define CPU_CONFIG_DEBUG_REGADDR_R6			0x06FF0618
+#define CPU_CONFIG_DEBUG_REGADDR_R7			0x06FF061C
+#define CPU_CONFIG_DEBUG_REGADDR_R8			0x06FF0620
+#define CPU_CONFIG_DEBUG_REGADDR_R9			0x06FF0624
+#define CPU_CONFIG_DEBUG_REGADDR_R10		0x06FF0628
+#define CPU_CONFIG_DEBUG_REGADDR_R11		0x06FF062C
+#define CPU_CONFIG_DEBUG_REGADDR_R12		0x06FF0630
+#define CPU_CONFIG_DEBUG_REGADDR_R13		0x06FF0634
+#define CPU_CONFIG_DEBUG_REGADDR_R14		0x06FF0638
+#define CPU_CONFIG_DEBUG_REGADDR_R15		0x06FF063C
+#define CPU_CONFIG_DEBUG_REGADDR_R16		0x06FF0640
+#define CPU_CONFIG_DEBUG_REGADDR_R17		0x06FF0644
+#define CPU_CONFIG_DEBUG_REGADDR_R18		0x06FF0648
+#define CPU_CONFIG_DEBUG_REGADDR_R19		0x06FF064C
+#define CPU_CONFIG_DEBUG_REGADDR_R20		0x06FF0650
+#define CPU_CONFIG_DEBUG_REGADDR_R21		0x06FF0654
+#define CPU_CONFIG_DEBUG_REGADDR_R22		0x06FF0658
+#define CPU_CONFIG_DEBUG_REGADDR_R23		0x06FF065C
+#define CPU_CONFIG_DEBUG_REGADDR_R24		0x06FF0660
+#define CPU_CONFIG_DEBUG_REGADDR_R25		0x06FF0664
+#define CPU_CONFIG_DEBUG_REGADDR_R26		0x06FF0668
+#define CPU_CONFIG_DEBUG_REGADDR_R27		0x06FF066C
+#define CPU_CONFIG_DEBUG_REGADDR_R28		0x06FF0670
+#define CPU_CONFIG_DEBUG_REGADDR_R29		0x06FF0674
+#define CPU_CONFIG_DEBUG_REGADDR_R30		0x06FF0678
+#define CPU_CONFIG_DEBUG_REGADDR_R31		0x06FF067C
+
+#define CPU_CONFIG_ADDR_PEID				0x06FF6490
+
+
+#define CPU_CONFIG_ADDR_MIR_0				0x06FF6800
+#define CPU_CONFIG_ADDR_MIR_1				0x06FF6804
+
+#define CPU_CONFIG_ADDR_MEV_0				0x06FF6900
+#define CPU_CONFIG_ADDR_MEV_1				0x06FF6904
+#define CPU_CONFIG_ADDR_MEV_2				0x06FF6908
+#define CPU_CONFIG_ADDR_MEV_3				0x06FF690C
+#define CPU_CONFIG_ADDR_MEV_4				0x06FF6910
+#define CPU_CONFIG_ADDR_MEV_5				0x06FF6914
+#define CPU_CONFIG_ADDR_MEV_6				0x06FF6918
+#define CPU_CONFIG_ADDR_MEV_7				0x06FF691C
+
+/*
+ * CPU間割り込み番号
+ */
+#define CPU_CONFIG_ADDR_MIR_0_INTNO			0
+#define CPU_CONFIG_ADDR_MIR_1_INTNO			1
+
+#define PLLS		0xfff89004
+
+
+#endif /* _CPU_CONFIG_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/config/cpuemu_config.h
@@ -0,0 +1,54 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _CPUEMU_CONFIG_H_
+#define _CPUEMU_CONFIG_H_
+
+/*
+ * symbol table config
+ */
+#define CPUEMU_CONFIG_FUNC_SYMBOL_TABLE_NUM		1024
+#define CPUEMU_CONFIG_OBJECT_SYMBOL_TABLE_NUM	1024
+
+#define CPUEMU_CONFIG_CUI_EMULATOR_PORTNO		49152
+#define CPUEMU_CONFIG_CUI_CLIENT_PORTNO			49153
+
+#endif /* _CPUEMU_CONFIG_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/config/mpu_config.h
@@ -0,0 +1,83 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _MPU_CONFIG_H_
+#define _MPU_CONFIG_H_
+
+#include "std_types.h"
+#include "loader/elf.h"
+
+#define MPU_CONFIG_REGION_NUM		UINT_C(8)
+
+#define MPU_ADDRESS_REGION_INX_INTC1	(0U)
+#define MPU_ADDRESS_REGION_INX_INTC2	(1U)
+#define MPU_ADDRESS_REGION_INX_TIMER	(2U)
+#define MPU_ADDRESS_REGION_INX_SERIAL	(3U)
+#define MPU_ADDRESS_REGION_INX_CAN		(4U)
+#define MPU_ADDRESS_REGION_INX_CLOCK	(5U)
+#define MPU_ADDRESS_REGION_INX_PH0		(6U)
+#define MPU_ADDRESS_REGION_INX_PH1		(7U)
+
+#define ELF_MACHINE_TYPE	EM_V800
+
+
+#define MPU_ADDRESS_REGION_MASK_PH		0xFFFFFFFF
+#define MPU_ADDRESS_REGION_MASK_CPU		0x06FFFFFF
+
+#define MPU_ADDRESS_REGION_SIZE_INX_INTC1	(0xFFFEEC00 - 0xFFFEEA00)
+#define MPU_ADDRESS_REGION_SIZE_INX_INTC2	(0xFFFFC000 - 0xFFFFB000)
+#define MPU_ADDRESS_REGION_SIZE_INX_SERIAL	(0xFFCE2180 - 0xFFCE2000)
+#define MPU_ADDRESS_REGION_SIZE_INX_CAN		(0xFFD08000 - 0xFFD00000)
+#define MPU_ADDRESS_REGION_SIZE_INX_CLOCK	(0xFFF8A80C - 0xFFF81100)
+#define MPU_ADDRESS_REGION_SIZE_INX_TIMER	(0xFFE51100 - 0xFFE50000)
+
+#define MPU_ADDRESS_REGION_SADDR_SYS		(0xFFF82800)
+#define MPU_ADDRESS_REGION_EADDR_SYS		(0xFFF8C000)
+#define MPU_ADDRESS_REGION_SIZE_INX_SYS		(MPU_ADDRESS_REGION_EADDR_SYS - MPU_ADDRESS_REGION_SADDR_SYS)
+
+#define MPU_ADDRESS_REGION_SIZE_INX_CPU		(1024U * 1024U)
+#define MPU_ADDRESS_REGION_SIZE_INX_PH0		(0xFFF8E015 - 0xFFF80000)
+#define MPU_ADDRESS_REGION_SIZE_INX_PH1		(0xFFC340A0 - 0xFFA00004)
+#define MPU_ADDRESS_REGION_SIZE_INX_PH2		(1024U * 8U)
+
+extern uint8 memory_data_CAN[MPU_ADDRESS_REGION_SIZE_INX_CAN];
+
+#endif /* _MPU_CONFIG_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/config/rh850f1k/mpu_config.c
@@ -0,0 +1,176 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "mpu.h"
+#include "cpu_config.h"
+#include "mpu_config.h"
+
+
+static uint8 memory_data_INTC1[MPU_ADDRESS_REGION_SIZE_INX_INTC1 * CPU_CONFIG_CORE_NUM];
+static uint8 memory_data_INTC2[MPU_ADDRESS_REGION_SIZE_INX_INTC2 * CPU_CONFIG_CORE_NUM];
+static uint8 memory_data_SERIAL[MPU_ADDRESS_REGION_SIZE_INX_SERIAL];
+static uint8 memory_data_CLOCK[MPU_ADDRESS_REGION_SIZE_INX_SERIAL];
+static uint8 memory_data_TIMER[MPU_ADDRESS_REGION_SIZE_INX_TIMER];
+static uint8 memory_data_PH0[MPU_ADDRESS_REGION_SIZE_INX_PH0];
+static uint8 memory_data_PH1[MPU_ADDRESS_REGION_SIZE_INX_PH1];
+
+
+extern MpuAddressRegionOperationType	serial_memory_operation;
+extern MpuAddressRegionOperationType	timer_memory_operation;
+extern MpuAddressRegionOperationType	intc_memory_operation;
+extern MpuAddressRegionOperationType	clock_memory_operation;
+extern MpuAddressRegionOperationType	can_memory_operation;
+
+MpuAddressMapType mpu_address_map = {
+		.dynamic_map_num = 0,
+		.dynamic_map = NULL,
+		.map = {
+				/*
+				 * INDEX 2:DEVICE(割込みコントローラ(INTC1)
+				 */
+				{
+						.type		= DEVICE,
+						.is_malloc	= FALSE,
+						.permission	= MPU_ADDRESS_REGION_PERM_ALL,
+						.start		= 0xFFFEEA00,
+						.size		= MPU_ADDRESS_REGION_SIZE_INX_INTC1,
+						.mask		= MPU_ADDRESS_REGION_MASK_PH,
+						.data		= memory_data_INTC1,
+						.ops		= &intc_memory_operation
+				},
+				/*
+				 * INDEX 2:DEVICE(割込みコントローラ(INTC2))
+				 */
+				{
+						.type		= DEVICE,
+						.is_malloc	= FALSE,
+						.permission	= MPU_ADDRESS_REGION_PERM_ALL,
+						.start		= 0xFFFFB000,
+						.size		= MPU_ADDRESS_REGION_SIZE_INX_INTC2,
+						.mask		= MPU_ADDRESS_REGION_MASK_PH,
+						.data		= memory_data_INTC2,
+						.ops		= &intc_memory_operation
+				},
+				/*
+				 * TIMER
+				 */
+				{
+						.type		= DEVICE,
+						.is_malloc	= FALSE,
+						.permission	= MPU_ADDRESS_REGION_PERM_ALL,
+						.start		= 0xFFE50000,
+						.size		= MPU_ADDRESS_REGION_SIZE_INX_TIMER,
+						.mask		= MPU_ADDRESS_REGION_MASK_PH,
+						.data		= memory_data_TIMER,
+						.ops		= &timer_memory_operation
+				},
+
+				/*
+				 * SERIAL
+				 */
+				{
+						.type		= DEVICE,
+						.is_malloc	= FALSE,
+						.permission	= MPU_ADDRESS_REGION_PERM_ALL,
+						.start		= 0xFFCE2000,
+						.size		= MPU_ADDRESS_REGION_SIZE_INX_SERIAL,
+						.mask		= MPU_ADDRESS_REGION_MASK_PH,
+						.data		= memory_data_SERIAL,
+						.ops		= &serial_memory_operation
+				},
+
+				/*
+				 * CAN
+				 */
+				{
+						.type		= DEVICE,
+						.is_malloc	= FALSE,
+						.permission	= MPU_ADDRESS_REGION_PERM_ALL,
+						.start		= 0xFFD00000,
+						.size		= MPU_ADDRESS_REGION_SIZE_INX_CAN,
+						.mask		= MPU_ADDRESS_REGION_MASK_PH,
+						.data		= memory_data_CAN,
+						.ops		= &can_memory_operation
+				},
+
+				/*
+				 * CLKC
+				 */
+				{
+						.type		= DEVICE,
+						.is_malloc	= FALSE,
+						.permission	= MPU_ADDRESS_REGION_PERM_ALL,
+						.start		= 0xFFF81100,
+						.size		= MPU_ADDRESS_REGION_SIZE_INX_CLOCK,
+						.mask		= MPU_ADDRESS_REGION_MASK_PH,
+						.data		= memory_data_CLOCK,
+						.ops		= &clock_memory_operation
+				},
+
+				/*
+				 * INDEX :DEVICE(その他内蔵周辺I/O領域)
+				 */
+				{
+						.type		= DEVICE,
+						.is_malloc	= FALSE,
+						.permission	= MPU_ADDRESS_REGION_PERM_ALL,
+						.start		= 0xFFF80000,
+						.size		= MPU_ADDRESS_REGION_SIZE_INX_PH0,
+						.mask		= MPU_ADDRESS_REGION_MASK_PH,
+						.data		= memory_data_PH0,
+						.ops		= &default_memory_operation
+				},
+				/*
+				 * INDEX :DEVICE(プログラマブル周辺I/O領域1)
+				 */
+				{
+						.type		= DEVICE,
+						.is_malloc	= FALSE,
+						.permission	= MPU_ADDRESS_REGION_PERM_ALL,
+						.start		= 0xFFA00004,
+						.size		= MPU_ADDRESS_REGION_SIZE_INX_PH1,
+						.mask		= MPU_ADDRESS_REGION_MASK_PH,
+						.data		= memory_data_PH1,
+						.ops		= &default_memory_operation
+				},
+
+		}
+};
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_common/cpu_fpu_ops.h
@@ -0,0 +1,682 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _CPU_FPU_OPS_H_
+#define _CPU_FPU_OPS_H_
+
+#include "target_cpu.h"
+
+typedef float float32;
+typedef double float64;
+
+#define FLOAT_SIGN_BIT_POS		31
+#define FLOAT_SIGN_BIT_PTRN		(1U << FLOAT_SIGN_BIT_POS)
+#define FLOAT_SIGN_BIT_MASK		~(1U << FLOAT_SIGN_BIT_POS)
+#define GET_FLOAT_SIGN_BIT_VALUE(x) ( (((FLOAT_SIGN_BIT_PTRN) & (x).binary) != 0) ? 1U : 0U )
+#define FLOAT_SIGN_BIT_SET(x)	\
+do {	\
+	(x).binary |= FLOAT_SIGN_BIT_PTRN;	\
+} while (0)
+
+#define FLOAT_SIGN_BIT_CLR(x)	\
+do {	\
+	(x).binary &= FLOAT_SIGN_BIT_MASK;	\
+} while (0)
+
+#define DOUBLE_SIGN_BIT_POS		FLOAT_SIGN_BIT_POS
+#define DOUBLE_SIGN_BIT_PTRN	FLOAT_SIGN_BIT_PTRN
+#define DOUBLE_SIGN_BIT_MASK		FLOAT_SIGN_BIT_MASK
+#define GET_DOUBLE_SIGN_BIT_VALUE(x) ( (((DOUBLE_SIGN_BIT_PTRN) & (x).binary[1]) != 0) ? 1U : 0U )
+#define DOUBLE_SIGN_BIT_SET(x)	\
+do {	\
+	(x).binary[1] |= DOUBLE_SIGN_BIT_PTRN;	\
+} while (0)
+
+#define DOUBLE_SIGN_BIT_CLR(x)	\
+do {	\
+	(x).binary[1] &= DOUBLE_SIGN_BIT_MASK;	\
+} while (0)
+
+
+#define FLOAT_EXP_BIT_POS_START		30
+#define FLOAT_EXP_BIT_POS_END		23
+#define FLOAT_EXP_BIT_MASK			0x7F800000
+#define FLOAT_EXP_BIAS_VALUE		((sint16)127)
+#define GET_FLOAT_EXP_VALUE(x) 		( (sint16)( ((FLOAT_EXP_BIT_MASK & (x).binary) >> FLOAT_EXP_BIT_POS_END) ) )
+#define GET_FLOAT_EXPB_VALUE(x) 	( GET_FLOAT_EXP_VALUE(x) - FLOAT_EXP_BIAS_VALUE )
+
+
+#define DOUBLE_EXP_BIT_POS_START	30
+#define DOUBLE_EXP_BIT_POS_END		20
+#define DOUBLE_EXP_BIT_MASK			0x7FE00000
+#define DOUBLE_EXP_BIAS_VALUE		((sint16)1023)
+#define GET_DOUBLE_EXP_VALUE(x) 		( (sint16)( ((DOUBLE_EXP_BIT_MASK & (x).binary[1]) >> DOUBLE_EXP_BIT_POS_END) ) )
+#define GET_DOUBLE_EXPB_VALUE(x) 	( GET_DOUBLE_EXP_VALUE(x) - DOUBLE_EXP_BIAS_VALUE )
+
+
+#define FLOAT_EXP_MAX				((sint16)+127)
+#define FLOAT_EXP_MIN				((sint16)-126)
+#define FLOAT_EXP_MAX_PLUS_1		((sint16)+128)
+#define FLOAT_EXP_MIN_MINUS_1		((sint16)-127)
+
+
+#define DOUBLE_EXP_MAX				((sint16)+1023)
+#define DOUBLE_EXP_MIN				((sint16)-1022)
+#define DOUBLE_EXP_MAX_PLUS_1		((sint16)+1024)
+#define DOUBLE_EXP_MIN_MINUS_1		((sint16)-1023)
+
+
+#define FLOAT_MANTISSA_POS_START	22
+#define FLOAT_MANTISSA_POS_END		0
+#define FLOAT_MANTISSA_BIT_MASK		0x007FFFFF
+#define GET_FLOAT_MANTISSA_VALUE(x) ( ((FLOAT_MANTISSA_BIT_MASK & (x).binary) >> FLOAT_MANTISSA_POS_END))
+#define GET_FLOAT_MANTISSA_BIT_VALUE(ma, bit_pos) ( ( ((ma) & (1U << (bit_pos)) ) != 0U) ? 1U : 0U )
+
+#define DOUBLE_MANTISSA1_POS_START		19
+#define DOUBLE_MANTISSA1_POS_END		0
+#define DOUBLE_MANTISSA1_BIT_MASK		0x007FFFFF
+
+#define DOUBLE_MANTISSA0_POS_START		31
+#define DOUBLE_MANTISSA0_POS_END		0
+#define DOUBLE_MANTISSA0_BIT_MASK		0xFFFFFFFF
+
+#define GET_DOUBLE_MANTISSA1_VALUE(x) ( ((DOUBLE_MANTISSA1_BIT_MASK & (x).binary[1]) >> DOUBLE_MANTISSA1_POS_END))
+#define GET_DOUBLE_MANTISSA0_VALUE(x) ( ((DOUBLE_MANTISSA0_BIT_MASK & (x).binary[0]) >> DOUBLE_MANTISSA0_POS_END))
+#define GET_DOUBLE_MANTISSA_BIT_VALUE(ma, bit_pos) ( ( ((ma) & (1U << (bit_pos)) ) != 0U) ? 1U : 0U )
+
+
+/*
+ * 種類　　　　指数部　　　仮数部
+ * ------------------------------
+ * ゼロ　　　　０　　　　　　 ０
+ * 非正規化数　０　　　　　　 ０以外
+ * 正規化数　　1～254　　　	  任意
+ * 無限大　　　255　　　　　  ０
+ * NaN　　　　 255　　　　　  ０以外
+ */
+#define FLOAT_IS_ZERO(x)	( (GET_FLOAT_EXP_VALUE(x) == 0)   && (GET_FLOAT_MANTISSA_VALUE(x) == 0  ) )
+#define FLOAT_IS_NORMAL(x)	( (GET_FLOAT_EXP_VALUE(x) >= 1)   && (GET_FLOAT_EXP_VALUE(x)      <= 254) )
+#define FLOAT_IS_SBNORM(x)	( (GET_FLOAT_EXP_VALUE(x) == 0)   && (GET_FLOAT_MANTISSA_VALUE(x) != 0  ) )
+#define FLOAT_IS_INF(x)		( (GET_FLOAT_EXP_VALUE(x) == 255) && (GET_FLOAT_MANTISSA_VALUE(x) == 0  ) )
+#define FLOAT_IS_NAN(x)		( (GET_FLOAT_EXP_VALUE(x) == 255) && (GET_FLOAT_MANTISSA_VALUE(x) != 0  ) )
+#define FLOAT_IS_PLUS(x)	( GET_FLOAT_SIGN_BIT_VALUE(x) == 0 )
+#define FLOAT_IS_MINUS(x)	( GET_FLOAT_SIGN_BIT_VALUE(x) == 1 )
+
+
+#define DOUBLE_IS_ZERO(x)	( (GET_DOUBLE_EXP_VALUE(x) == 0)   && (GET_DOUBLE_MANTISSA0_VALUE(x) == 0  ) && (GET_DOUBLE_MANTISSA1_VALUE(x) == 0  ) )
+#define DOUBLE_IS_NORMAL(x)	( (GET_DOUBLE_EXP_VALUE(x) >= 1)   && (GET_DOUBLE_EXP_VALUE(x)      <= 2046) )
+#define DOUBLE_IS_SBNORM(x)	( (GET_DOUBLE_EXP_VALUE(x) == 0)   && ( (GET_DOUBLE_MANTISSA0_VALUE(x) != 0  ) || (GET_DOUBLE_MANTISSA1_VALUE(x) != 0  )) )
+#define DOUBLE_IS_INF(x)	( (GET_DOUBLE_EXP_VALUE(x) == 2047) && (GET_DOUBLE_MANTISSA0_VALUE(x) == 0  ) && (GET_DOUBLE_MANTISSA1_VALUE(x) == 0  ) )
+#define DOUBLE_IS_NAN(x)	( (GET_DOUBLE_EXP_VALUE(x) == 2047) && ( (GET_DOUBLE_MANTISSA0_VALUE(x) != 0  ) || (GET_DOUBLE_MANTISSA1_VALUE(x) != 0  )) )
+#define DOUBLE_IS_PLUS(x)	( GET_DOUBLE_SIGN_BIT_VALUE(x) == 0 )
+#define DOUBLE_IS_MINUS(x)	( GET_DOUBLE_SIGN_BIT_VALUE(x) == 1 )
+
+
+#define FLOAT_SET_SIGN_REVERSE(x)	\
+do { \
+	if (FLOAT_IS_PLUS(x)) {	\
+		FLOAT_SIGN_BIT_SET(x);	\
+	}	\
+	else {	\
+		FLOAT_SIGN_BIT_CLR(x);	\
+	}	\
+} while (0)
+
+#define DOUBLE_SET_SIGN_REVERSE(x)	\
+do { \
+	if (DOUBLE_IS_PLUS(x)) {	\
+		DOUBLE_SIGN_BIT_SET(x);	\
+	}	\
+	else {	\
+		DOUBLE_SIGN_BIT_CLR(x);	\
+	}	\
+} while (0)
+
+
+typedef union {
+	float32		data;
+	uint32 		binary;
+} FloatBinaryDataType;
+
+typedef union {
+	float64		data;
+	uint32 		binary[2];
+} DoubleBinaryDataType;
+
+static inline bool float_is_qnan(FloatBinaryDataType x)
+{
+	if (!FLOAT_IS_NAN(x)) {
+		return FALSE;
+	}
+	if ((x.binary & (1U << FLOAT_MANTISSA_POS_START)) != 0) {
+		return TRUE;
+	}
+	else {
+		return FALSE;
+	}
+}
+static inline bool float_is_snan(FloatBinaryDataType x)
+{
+	if (!FLOAT_IS_NAN(x)) {
+		return FALSE;
+	}
+	if ((x.binary & (1U << FLOAT_MANTISSA_POS_START)) != 0) {
+		return FALSE;
+	}
+	else {
+		return TRUE;
+	}
+}
+
+static inline void float_get_qnan(FloatBinaryDataType *x)
+{
+	x->binary = 0x7FFFFFFF;
+	return;
+}
+static inline void float_get_snan(FloatBinaryDataType *x)
+{
+	x->binary = ( 0x7FFFFFFF & ~(1U << FLOAT_MANTISSA_POS_START) );
+	return;
+}
+
+
+static inline bool double_is_qnan(DoubleBinaryDataType x)
+{
+	if (!DOUBLE_IS_NAN(x)) {
+		return FALSE;
+	}
+	if ((x.binary[1] & (1U << DOUBLE_MANTISSA1_POS_START)) != 0) {
+		return TRUE;
+	}
+	else {
+		return FALSE;
+	}
+}
+static inline bool double_is_snan(DoubleBinaryDataType x)
+{
+	if (!DOUBLE_IS_NAN(x)) {
+		return FALSE;
+	}
+	if ((x.binary[1] & (1U << DOUBLE_MANTISSA1_POS_START)) != 0) {
+		return FALSE;
+	}
+	else {
+		return TRUE;
+	}
+}
+
+static inline void double_get_qnan(DoubleBinaryDataType *x)
+{
+	x->binary[1] = 0x7FFFFFFF;
+	x->binary[0] = 0xFFFFFFFF;
+	return;
+}
+static inline void double_get_snan(DoubleBinaryDataType *x)
+{
+	x->binary[1] = ( 0x7FFFFFFF & ~(1U << DOUBLE_MANTISSA1_POS_START) );
+	x->binary[0] = 0xFFFFFFFF;
+	return;
+}
+
+/*
+ * (1) 不正確演算例外（ I）
+ * (2) 無効演算例外（ V）
+ * (3) ゼロ除算例外（ Z）
+ * (4) オーバフロー例外（ O）
+ * (5) アンダフロー例外（ U）
+ * (6) 未実装演算例外（ E）
+ */
+ #define FLOAT_EXCEPTION_BIT_I		0U
+ #define FLOAT_EXCEPTION_BIT_V		1U
+ #define FLOAT_EXCEPTION_BIT_Z		2U
+ #define FLOAT_EXCEPTION_BIT_O		3U
+ #define FLOAT_EXCEPTION_BIT_U		4U
+ #define FLOAT_EXCEPTION_BIT_E		5U
+typedef struct {
+	uint32 disable_bits;
+	uint32 intr_bits;
+} FloatExceptionType;
+
+#define FLOAT_EXCEPTION_IS_RAISED(fex, bitpos)	( ( (fex).intr_bits & (1U << (bitops)) ) != 0 )
+#define FLOAT_EXCEPTION_IS_DISABLE(fex, bitpos)	( ( (fex).disable_bits & (1U << (bitops)) ) != 0 )
+
+#define FLOAT_EXCEPTION_BIT_RESET(fex)	\
+do {	\
+	(fex)->disable_bits = 0U;	\
+	(fex)->intr_bits = 0U;	\
+} while (0)
+
+#define FLOAT_EXCEPTION_INTR_BIT_SET(fex, bitpos)	\
+do { \
+	(fex)->intr_bits |= (1U << (bitpos));	\
+} while (0)
+
+#define FLOAT_EXCEPTION_INTR_BIT_CLR(fex, bitpos)	\
+do { \
+	(fex)->intr_bits &= ~(1U << (bitpos));	\
+} while (0)
+
+#define FLOAT_EXCEPTION_DISABLE_BIT_SET(fex, bitpos)	\
+do { \
+	(fex)->disable_bits |= (1U << (bitpos));	\
+} while (0)
+
+#define FLOAT_EXCEPTION_DISABLE_BIT_CLR(fex, bitpos)	\
+do { \
+	(fex)->disable_bits &= ~(1U << (bitpos));	\
+} while (0)
+
+
+static inline void op_absf_s(FloatBinaryDataType *in, FloatBinaryDataType *out)
+{
+	out->binary = (in->binary & FLOAT_SIGN_BIT_MASK);
+	return;
+}
+
+
+/**********************************************
+ * FPSR
+ **********************************************/
+#define SYS_FPSR_CC_BIT_START	24
+#define SYS_FPSR_FN_BIT_START	23
+#define SYS_FPSR_IF_BIT_START	22
+#define SYS_FPSR_PEM_BIT_START	21
+#define SYS_FPSR_RM_BIT_START	18
+#define SYS_FPSR_FS_BIT_START	17
+#define SYS_FPSR_XC_BIT_START	10
+#define SYS_FPSR_XE_BIT_START	 5
+#define SYS_FPSR_XP_BIT_START	 0
+
+#define SYS_FPST_XC_BIT_START	8
+#define SYS_FPST_IF_BIT_START	5
+#define SYS_FPST_XP_BIT_START	0
+
+#define SYS_FPCC_CC_BIT_START	0
+
+#define SYS_FPCFG_RM_BIT_START	8
+#define SYS_FPCFG_XE_BIT_START	0
+
+static inline void sys_set_fpsr_cc(CpuRegisterType *reg, uint8 data)
+{
+	/*
+	 * FPSR
+	 */
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPSR);
+	SYS_SET_DATA8(regp, SYS_FPSR_CC_BIT_START, data);
+
+	/*
+	 * FPCC
+	 */
+	regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPCC);
+	SYS_SET_DATA8(regp, SYS_FPCC_CC_BIT_START, data);
+	return;
+}
+static inline uint8 sys_get_fpsr_cc(CpuRegisterType *reg)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPSR);
+	return SYS_GET_DATA8(regp, SYS_FPSR_CC_BIT_START);
+}
+static inline bool sys_isset_fpsr_fn(CpuRegisterType *reg)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPSR);
+	return (SYS_ISSET_BIT(regp, SYS_FPSR_FN_BIT_START) != 0);
+}
+
+static inline void sys_set_fpsr_fn(CpuRegisterType *reg)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPSR);
+	SYS_SET_BIT(regp, SYS_FPSR_FN_BIT_START);
+	return;
+}
+static inline void sys_clr_fpsr_fn(CpuRegisterType *reg)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPSR);
+	SYS_CLR_BIT(regp, SYS_FPSR_FN_BIT_START);
+	return;
+}
+
+static inline bool sys_isset_fpsr_if(CpuRegisterType *reg)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPSR);
+	return (SYS_ISSET_BIT(regp, SYS_FPSR_IF_BIT_START) != 0);
+}
+static inline void sys_set_fpsr_if(CpuRegisterType *reg)
+{
+	/*
+	 * FPSR
+	 */
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPSR);
+	SYS_SET_BIT(regp, SYS_FPSR_IF_BIT_START);
+
+	/*
+	 * FPST
+	 */
+	regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPST);
+	SYS_SET_BIT(regp, SYS_FPST_IF_BIT_START);
+	return;
+}
+static inline void sys_clr_fpsr_if(CpuRegisterType *reg)
+{
+	/*
+	 * FPSR
+	 */
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPSR);
+	SYS_CLR_BIT(regp, SYS_FPSR_IF_BIT_START);
+
+	/*
+	 * FPST
+	 */
+	regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPST);
+	SYS_CLR_BIT(regp, SYS_FPST_IF_BIT_START);
+	return;
+}
+
+static inline bool sys_isset_fpsr_pem(CpuRegisterType *reg)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPSR);
+	return (SYS_ISSET_BIT(regp, SYS_FPSR_PEM_BIT_START) != 0);
+}
+static inline void sys_set_fpsr_pem(CpuRegisterType *reg)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPSR);
+	SYS_SET_BIT(regp, SYS_FPSR_PEM_BIT_START);
+	return;
+}
+static inline void sys_clr_fpsr_pem(CpuRegisterType *reg)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPSR);
+	SYS_CLR_BIT(regp, SYS_FPSR_PEM_BIT_START);
+	return;
+}
+
+typedef enum {
+	SysFpuRm_RN = 0x00,
+	SysFpuRm_RZ = 0x01,
+	SysFpuRm_RP = 0x10,
+	SysFpuRm_RD = 0x11,
+} SysFpuRmType;
+static inline SysFpuRmType sys_get_fpsr_rm(CpuRegisterType *reg)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPSR);
+	return SYS_GET_DATA2(regp, SYS_FPSR_RM_BIT_START);
+}
+
+static inline void sys_set_fpsr_rm(CpuRegisterType *reg, SysFpuRmType data)
+{
+	/*
+	 * FPSR
+	 */
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPSR);
+	SYS_SET_DATA2(regp, SYS_FPSR_RM_BIT_START, (uint8)data);
+
+	/*
+	 * FPCFG
+	 */
+	regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPCFG);
+	SYS_SET_DATA2(regp, SYS_FPCFG_RM_BIT_START, (uint8)data);
+	return;
+}
+
+static inline bool sys_isset_fpsr_fs(CpuRegisterType *reg)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPSR);
+	return (SYS_ISSET_BIT(regp, SYS_FPSR_FS_BIT_START) != 0);
+}
+static inline void sys_set_fpsr_fs(CpuRegisterType *reg)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPSR);
+	SYS_SET_BIT(regp, SYS_FPSR_FS_BIT_START);
+	return;
+}
+static inline void sys_clr_fpsr_fs(CpuRegisterType *reg)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPSR);
+	SYS_CLR_BIT(regp, SYS_FPSR_FS_BIT_START);
+	return;
+}
+
+#define SYS_FPSR_EXPR_I		(1U << 0U)
+#define SYS_FPSR_EXPR_U		(1U << 1U)
+#define SYS_FPSR_EXPR_O		(1U << 2U)
+#define SYS_FPSR_EXPR_Z		(1U << 3U)
+#define SYS_FPSR_EXPR_V		(1U << 4U)
+#define SYS_FPSR_EXPR_E		(1U << 5U)
+static inline void sys_set_fpsr_xc(CpuRegisterType *reg, uint8 data)
+{
+	/*
+	 * FPSR
+	 */
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPSR);
+	SYS_SET_DATA6(regp, SYS_FPSR_XC_BIT_START, (uint8)data);
+
+	/*
+	 * FPST
+	 */
+	regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPST);
+	SYS_SET_DATA6(regp, SYS_FPST_XC_BIT_START, (uint8)data);
+	return;
+}
+static inline bool sys_isset_fpsr_xc(CpuRegisterType *reg, uint8 data)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPSR);
+	return ((SYS_GET_DATA6(regp, SYS_FPSR_XC_BIT_START) & data) != 0);
+}
+static inline void sys_set_fpsr_xe(CpuRegisterType *reg, uint8 data)
+{
+	/*
+	 * FPSR
+	 */
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPSR);
+	SYS_SET_DATA5(regp, SYS_FPSR_XE_BIT_START, (uint8)data);
+
+	/*
+	 * FPCFG
+	 */
+	regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPCFG);
+	SYS_SET_DATA5(regp, SYS_FPCFG_XE_BIT_START, (uint8)data);
+	return;
+}
+static inline bool sys_isset_fpsr_xe(CpuRegisterType *reg, uint8 data)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPSR);
+	return ((SYS_GET_DATA5(regp, SYS_FPSR_XE_BIT_START) & data) != 0);
+}
+static inline void sys_set_fpsr_xp(CpuRegisterType *reg, uint8 data)
+{
+	/*
+	 * FPSR
+	 */
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPSR);
+	SYS_SET_DATA5(regp, SYS_FPSR_XP_BIT_START, (uint8)data);
+
+	/*
+	 * FPST
+	 */
+	regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPST);
+	SYS_SET_DATA5(regp, SYS_FPST_XP_BIT_START, (uint8)data);
+
+	return;
+}
+static inline bool sys_isset_fpsr_xp(CpuRegisterType *reg, uint8 data)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPSR);
+	return ((SYS_GET_DATA5(regp, SYS_FPSR_XP_BIT_START) & data) != 0);
+}
+
+/**********************************************
+ * FPEPC
+ **********************************************/
+static inline uint32 sys_get_fpepc_pc(CpuRegisterType *reg)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FEPC);
+	return *regp;
+}
+static inline void sys_set_fpepc_pc(CpuRegisterType *reg, uint32 data)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FEPC);
+	*regp = ((data) & 0xFFFFFFFE);
+	return;
+}
+
+/**********************************************
+ * FPST
+ **********************************************/
+static inline void sys_set_fpst_xc(CpuRegisterType *reg, uint8 data)
+{
+	sys_set_fpsr_xc(reg, data);
+	return;
+}
+static inline uint8 sys_get_fpst_xc(CpuRegisterType *reg)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPST);
+	return SYS_GET_DATA6(regp, SYS_FPST_XC_BIT_START);
+}
+static inline bool sys_isset_fpst_xc(CpuRegisterType *reg, uint8 data)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPST);
+	return ((SYS_GET_DATA6(regp, SYS_FPST_XC_BIT_START) & data) != 0);
+}
+
+static inline void sys_set_fpst_xp(CpuRegisterType *reg, uint8 data)
+{
+	sys_set_fpsr_xp(reg, data);
+	return;
+}
+static inline uint8 sys_get_fpst_xp(CpuRegisterType *reg)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPST);
+	return SYS_GET_DATA5(regp, SYS_FPST_XP_BIT_START);
+}
+
+static inline bool sys_isset_fpst_xp(CpuRegisterType *reg, uint8 data)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPST);
+	return ((SYS_GET_DATA5(regp, SYS_FPST_XP_BIT_START) & data) != 0);
+}
+static inline bool sys_isset_fpst_if(CpuRegisterType *reg)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPST);
+	return (SYS_ISSET_BIT(regp, SYS_FPST_IF_BIT_START) != 0);
+}
+static inline void sys_set_fpst_if(CpuRegisterType *reg)
+{
+	sys_set_fpsr_if(reg);
+	return;
+}
+static inline void sys_clr_fpst_if(CpuRegisterType *reg)
+{
+	sys_clr_fpsr_if(reg);
+	return;
+}
+
+/**********************************************
+ * FPCC
+ **********************************************/
+
+static inline void sys_set_fpcc_cc(CpuRegisterType *reg, uint8 data)
+{
+	sys_set_fpsr_cc(reg, data);
+	return;
+}
+static inline uint8 sys_get_fpcc_cc(CpuRegisterType *reg)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPCC);
+	return SYS_GET_DATA8(regp, SYS_FPCC_CC_BIT_START);
+}
+
+/**********************************************
+ * FPCFG
+ **********************************************/
+
+static inline SysFpuRmType sys_get_fpcfg_rm(CpuRegisterType *reg)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPCFG);
+	return SYS_GET_DATA2(regp, SYS_FPCFG_RM_BIT_START);
+}
+static inline void sys_set_fpcfg_rm(CpuRegisterType *reg, SysFpuRmType data)
+{
+	sys_set_fpsr_rm(reg, data);
+	return;
+}
+
+static inline void sys_set_fpcfg_xe(CpuRegisterType *reg, uint8 data)
+{
+	sys_set_fpsr_xe(reg, data);
+	return;
+}
+static inline uint8 sys_get_fpcfg_xe(CpuRegisterType *reg)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPCFG);
+	return SYS_GET_DATA5(regp, SYS_FPCFG_XE_BIT_START);
+}
+
+static inline bool sys_isset_fpcfg_xe(CpuRegisterType *reg, uint8 data)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPCFG);
+	return ((SYS_GET_DATA5(regp, SYS_FPCFG_XE_BIT_START) & data) != 0);
+}
+
+
+/**********************************************
+ * FPEC
+ **********************************************/
+#define SYS_FPEC_XE_BIT_START	0
+
+static inline void sys_set_fpec_fpivd(CpuRegisterType *reg)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPEC);
+	SYS_SET_BIT(regp, SYS_FPEC_XE_BIT_START);
+	return;
+}
+static inline void sys_clr_fpec_fpivd(CpuRegisterType *reg)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPEC);
+	SYS_CLR_BIT(regp, SYS_FPEC_XE_BIT_START);
+	return;
+}
+
+static inline bool sys_isset_fpec_fpivd(CpuRegisterType *reg)
+{
+	uint32 *regp = cpu_get_sysreg2(&reg->sys, SYS_GRP_CPU, SYS_REG_FPEC);
+	return (SYS_ISSET_BIT(regp, SYS_FPEC_XE_BIT_START) != 0);
+}
+
+#endif /* _CPU_FPU_OPS_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_common/cpu_ops.h
@@ -0,0 +1,354 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _CPU_OPS_H_
+#define _CPU_OPS_H_
+#include "target_cpu.h"
+
+#define CPU_PSW_ID		(1 << 5)
+#define CPU_PSW_SAT		(1 << 4)
+#define CPU_PSW_CY		(1 << 3)
+#define CPU_PSW_OV		(1 << 2)
+#define CPU_PSW_S		(1 << 1)
+#define CPU_PSW_Z		(1 << 0)
+
+#define CPU_PSW_EP		(1 << 6)
+#define CPU_PSW_NP		(1 << 7)
+#define CPU_PSW_EBV		(1 << 15)
+#define CPU_PSW_UM		(1 << 30)
+
+#define CPU_SET_EBV(cpu)		sys_get_cpu_base(cpu)->r[SYS_REG_PSW] |= CPU_PSW_EBV
+#define CPU_CLR_EBV(cpu)		sys_get_cpu_base(cpu)->r[SYS_REG_PSW] &= ~CPU_PSW_EBV
+#define CPU_ISSET_EBV(cpu)	( (sys_get_cpu_base(cpu)->r[SYS_REG_PSW] & CPU_PSW_EBV) == CPU_PSW_EBV )
+
+#define CPU_SET_UM(cpu)		sys_get_cpu_base(cpu)->r[SYS_REG_PSW] |= CPU_PSW_UM
+#define CPU_CLR_UM(cpu)		sys_get_cpu_base(cpu)->r[SYS_REG_PSW] &= ~CPU_PSW_UM
+#define CPU_ISSET_UM(cpu)	( (sys_get_cpu_base(cpu)->r[SYS_REG_PSW] & CPU_PSW_UM) == CPU_PSW_UM )
+
+#define CPU_SET_EP(cpu)		sys_get_cpu_base(cpu)->r[SYS_REG_PSW] |= CPU_PSW_EP
+#define CPU_CLR_EP(cpu)		sys_get_cpu_base(cpu)->r[SYS_REG_PSW] &= ~CPU_PSW_EP
+#define CPU_ISSET_EP(cpu)	( (sys_get_cpu_base(cpu)->r[SYS_REG_PSW] & CPU_PSW_EP) == CPU_PSW_EP )
+
+#define CPU_SET_NP(cpu)		sys_get_cpu_base(cpu)->r[SYS_REG_PSW] |= CPU_PSW_NP
+#define CPU_CLR_NP(cpu)		sys_get_cpu_base(cpu)->r[SYS_REG_PSW] &= ~CPU_PSW_NP
+#define CPU_ISSET_NP(cpu)	( (sys_get_cpu_base(cpu)->r[SYS_REG_PSW] & CPU_PSW_NP) == CPU_PSW_NP )
+
+
+#define CPU_SET_ID(cpu)		sys_get_cpu_base(cpu)->r[SYS_REG_PSW] |= CPU_PSW_ID
+#define CPU_CLR_ID(cpu)		sys_get_cpu_base(cpu)->r[SYS_REG_PSW] &= ~CPU_PSW_ID
+#define CPU_ISSET_ID(cpu)	( (sys_get_cpu_base(cpu)->r[SYS_REG_PSW] & CPU_PSW_ID) == CPU_PSW_ID )
+
+#define CPU_SET_SAT(cpu)	sys_get_cpu_base(cpu)->r[SYS_REG_PSW] |= CPU_PSW_SAT
+#define CPU_CLR_SAT(cpu)	sys_get_cpu_base(cpu)->r[SYS_REG_PSW] &= ~CPU_PSW_SAT
+#define CPU_ISSET_SAT(cpu)	( (sys_get_cpu_base(cpu)->r[SYS_REG_PSW] & CPU_PSW_SAT) == CPU_PSW_SAT)
+
+#define CPU_SET_CY(cpu)		sys_get_cpu_base(cpu)->r[SYS_REG_PSW] |= CPU_PSW_CY
+#define CPU_CLR_CY(cpu)		sys_get_cpu_base(cpu)->r[SYS_REG_PSW] &= ~CPU_PSW_CY
+#define CPU_ISSET_CY(cpu)	( (sys_get_cpu_base(cpu)->r[SYS_REG_PSW] & CPU_PSW_CY) == CPU_PSW_CY)
+
+#define CPU_SET_OV(cpu)		sys_get_cpu_base(cpu)->r[SYS_REG_PSW] |= CPU_PSW_OV
+#define CPU_CLR_OV(cpu)		sys_get_cpu_base(cpu)->r[SYS_REG_PSW] &= ~CPU_PSW_OV
+#define CPU_ISSET_OV(cpu)	( (sys_get_cpu_base(cpu)->r[SYS_REG_PSW] & CPU_PSW_OV) == CPU_PSW_OV)
+
+#define CPU_SET_S(cpu)		sys_get_cpu_base(cpu)->r[SYS_REG_PSW] |= CPU_PSW_S
+#define CPU_CLR_S(cpu)		sys_get_cpu_base(cpu)->r[SYS_REG_PSW] &= ~CPU_PSW_S
+#define CPU_ISSET_S(cpu)	( (sys_get_cpu_base(cpu)->r[SYS_REG_PSW] & CPU_PSW_S) == CPU_PSW_S)
+
+#define CPU_SET_Z(cpu)		sys_get_cpu_base(cpu)->r[SYS_REG_PSW] |= CPU_PSW_Z
+#define CPU_CLR_Z(cpu)		sys_get_cpu_base(cpu)->r[SYS_REG_PSW] &= ~CPU_PSW_Z
+#define CPU_ISSET_Z(cpu)	( (sys_get_cpu_base(cpu)->r[SYS_REG_PSW] & CPU_PSW_Z) == CPU_PSW_Z)
+
+
+
+#define CPU_ISSET_INTCFG_ISPC(cpu) ( ((*cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_2, SYS_REG_INTCFG)) & (1U << 0)) != 0 )
+
+#define CPU_ISSET_RBASE_RINT(cpu) ( ((*cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_1, SYS_REG_RBASE)) & (1U << 0)) != 0 )
+#define CPU_ISSET_EBASE_RINT(cpu) ( ((*cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_1, SYS_REG_EBASE)) & (1U << 0)) != 0 )
+#define CPU_RBASE_ADDR(cpu)		( (*cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_1, SYS_REG_RBASE)) & ~(1U << 0) )
+#define CPU_EBASE_ADDR(cpu)		( (*cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_1, SYS_REG_EBASE)) & ~(1U << 0) )
+#define CPU_INTBP_ADDR(cpu)		( (*cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_1, SYS_REG_INTBP)) )
+
+extern int op_chk_and_set_carry(CpuRegisterType *cpu, uint32 a, uint32 b);
+extern int op_chk_and_set_borrow(CpuRegisterType *cpu, uint32 a, uint32 b);
+extern int op_chk_and_set_overflow(CpuRegisterType *cpu, sint64 a, sint64 b);
+extern int op_chk_and_set_zero(CpuRegisterType *cpu, sint32 result);
+extern int op_chk_and_set_sign(CpuRegisterType *cpu, sint32 result);
+extern bool op_exec_cond(TargetCoreType *cpu, uint16 cond);
+
+extern int op_chk_and_set_carry3(CpuRegisterType *cpu, uint32 a, uint32 b, uint32 c);
+extern int op_chk_and_set_borrow3(CpuRegisterType *cpu, uint32 a, uint32 b, uint32 c);
+extern int op_chk_and_set_overflow3(CpuRegisterType *cpu, sint64 a, sint64 b, sint64 c);
+
+static inline sint32 op_addi(
+		CpuRegisterType *cpu,
+		sint32 imm_data, sint32 reg1_data)
+{
+	sint32 result;
+
+	result = reg1_data + imm_data;
+
+	op_chk_and_set_carry(cpu, imm_data, reg1_data);
+	op_chk_and_set_overflow(cpu, imm_data, reg1_data);
+	op_chk_and_set_zero(cpu, result);
+	op_chk_and_set_sign(cpu, result);
+	return result;
+}
+static inline sint32 op_andi(
+		CpuRegisterType *cpu,
+		sint32 imm_data, sint32 reg1_data)
+{
+	sint32 result = reg1_data & imm_data;
+
+	op_chk_and_set_zero(cpu, result);
+	op_chk_and_set_sign(cpu, result);
+	CPU_CLR_OV(cpu);
+	return result;
+}
+static inline sint32 op_and(
+		CpuRegisterType *cpu,
+		sint32 reg2_data, sint32 reg1_data)
+{
+	sint32 result = reg1_data & reg2_data;
+
+	op_chk_and_set_zero(cpu, result);
+	op_chk_and_set_sign(cpu, result);
+	CPU_CLR_OV(cpu);
+	return result;
+}
+static inline sint32 op_or(
+		CpuRegisterType *cpu,
+		sint32 reg2_data, sint32 reg1_data)
+{
+	sint32 result = reg1_data | reg2_data;
+
+	op_chk_and_set_zero(cpu, result);
+	op_chk_and_set_sign(cpu, result);
+	CPU_CLR_OV(cpu);
+	return result;
+}
+
+static inline sint32 op_movea(
+		CpuRegisterType *cpu,
+		sint32 imm_data, sint32 reg1_data)
+{
+	sint32 ret = reg1_data + imm_data;
+	return ret;
+}
+static inline sint32 op_movhi(
+		CpuRegisterType *cpu,
+		sint32 imm_data, sint32 reg1_data)
+{
+	sint32 ret = reg1_data + (imm_data << 16);
+	return ret;
+}
+static inline sint32 op_mulhi(
+		CpuRegisterType *cpu,
+		sint32 imm_data, sint32 reg1_data)
+{
+	sint32 ret = reg1_data * (imm_data);
+	return ret;
+}
+static inline sint32 op_ori(
+		CpuRegisterType *cpu,
+		uint16 imm_data, sint32 reg1_data)
+{
+	sint32 ret = ( reg1_data | ((uint32)(imm_data)) );
+	if (ret == 0) {
+		CPU_SET_Z(cpu);
+	}
+	else {
+		CPU_CLR_Z(cpu);
+	}
+	if (ret & (0x80000000)) {
+		CPU_SET_S(cpu);
+	}
+	else {
+		CPU_CLR_S(cpu);
+	}
+	return ret;
+}
+
+static inline sint32 op_satadd(
+		CpuRegisterType *cpu,
+		sint32 data_l, sint32 data_r)
+{
+	sint32 ret;
+	sint64 data_r64 = data_r;
+	sint64 data_l64 = data_l;
+	sint64 ret64;
+
+	ret64 = data_l64 + data_r64;
+
+	op_chk_and_set_carry(cpu, data_l, data_r);
+	op_chk_and_set_overflow(cpu, data_l, data_r);
+
+	if (ret64 > (sint64)CPU_REG_PLUS_MAX) {
+		CPU_SET_SAT(cpu);
+		ret = CPU_REG_PLUS_MAX;
+	}
+	else if (ret64 < CPU_REG_MINUS_MAX) {
+		CPU_SET_SAT(cpu);
+		ret = CPU_REG_MINUS_MAX;
+	}
+	else {
+		ret = (sint32)ret64;
+	}
+	if (ret64 < 0) {
+		CPU_SET_S(cpu);
+	}
+	else {
+		CPU_CLR_S(cpu);
+	}
+	if (ret64 == 0) {
+		CPU_SET_Z(cpu);
+	}
+	else {
+		CPU_CLR_Z(cpu);
+	}
+	return ret;
+}
+static inline sint32 op_xori(
+		CpuRegisterType *cpu,
+		uint16 imm_data, sint32 reg1_data)
+{
+	sint32 ret = ( reg1_data ^ ((uint32)(imm_data)) );
+	if (ret == 0) {
+		CPU_SET_Z(cpu);
+	}
+	else {
+		CPU_CLR_Z(cpu);
+	}
+	if (ret < 0) {
+		CPU_SET_S(cpu);
+	}
+	else {
+		CPU_CLR_S(cpu);
+	}
+	CPU_CLR_OV(cpu);
+	return ret;
+}
+
+/*
+ * 指定されたbitに符号ビットがある場合は31bitまで1埋めする(符号拡張)
+ */
+static inline sint32 op_sign_extend(uint32 bit, uint32 data)
+{
+	int i;
+	if (data & (1 << bit)) {
+		for (i = bit; i < 32; i++) {
+			data = ( data | (1 << i) );//符号拡張する
+		}
+	}
+	return data;
+}
+#define OP_FORMAT2_IMM_SIGN_EXTEND(data)	op_sign_extend(4, (data))
+
+/*
+ * 指定されたbitから31bitまで０埋めする
+ */
+static inline uint32 op_zero_extend(uint32 bit, uint32 data)
+{
+	int i;
+	for (i = bit; i < 32; i++) {
+		data = ( data & ~(1 << i) );
+	}
+	return data;
+}
+#define OP_FORMAT2_IMM_ZERO_EXTEND(data)	op_zero_extend(5, (data))
+
+static inline char *addr2devregname(uint32 addr)
+{
+	switch (addr) {
+	case 0xFFFFF1FE:
+		return "PSC";
+	case 0xFFFFF308:
+		return "SELCNT0";
+	case 0xFFFFF30A:
+		return "SELCNT1";
+	case 0xFFFFF30C:
+		return "SELCNT2";
+	case 0xFFFFF30E:
+		return "SELCNT3";
+	case 0xFFFFF3F8:
+		return "SELCNT4";
+	case 0xFFFFF3FA:
+		return "SELCNT5";
+	case 0xFFFFF3F0:
+		return "SSCGCTL";
+	case 0xFFFFF3F1:
+		return "SFC0";
+	case 0xFFFFF3F2:
+		return "SFC1";
+	case 0xFFFFF6C0:
+		return "OSTS";
+	case 0xFFFFF6C1:
+		return "PLLS";
+	case 0xFFFFF6C2:
+		return "OSTC";
+	case 0xFFFFF80C:
+		return "RCM";
+	case 0xFFFFF820:
+		return "PSMR";
+	case 0xFFFFF824:
+		return "LOCKR";
+	case 0xFFFFF828:
+		return "PCC";
+	case 0xFFFFF82C:
+		return "PLLCTL";
+	case 0xFFFFF82E:
+		return "CCLS";
+	case 0xFFFFF82F:
+		return "PCLM";
+	case 0xFFFFF860:
+		return "MCM";
+	case 0xFFFFF870:
+		return "CLM";
+	case 0xFFFFF8B0:
+		return "PRSM0";
+	case 0xFFFFF8B1:
+		return "PRSCM0";
+	default:
+		break;
+	}
+	return "NULL";
+}
+
+#endif /* _CPU_OPS_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_dec/op_codeid.h
@@ -0,0 +1,278 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _OP_CODEID_H_
+#define _OP_CODEID_H_
+
+typedef enum {
+	OpCodeId_ABSF_D_F = 0,
+	OpCodeId_ABSF_S_F,
+	OpCodeId_ADD_1,
+	OpCodeId_ADD_2,
+	OpCodeId_ADDF_D_F,
+	OpCodeId_ADDF_S_F,
+	OpCodeId_ADDI_6,
+	OpCodeId_ADF_11,
+	OpCodeId_AND_1,
+	OpCodeId_ANDI_6,
+	OpCodeId_BINS_9,
+	OpCodeId_BSH_12,
+	OpCodeId_BSW_12,
+	OpCodeId_Bcond_3,
+	OpCodeId_Bcond_7,
+	OpCodeId_CALLT_2,
+	OpCodeId_CAXI_11,
+	OpCodeId_CEILF_DL_F,
+	OpCodeId_CEILF_DUL_F,
+	OpCodeId_CEILF_DUW_F,
+	OpCodeId_CEILF_DW_F,
+	OpCodeId_CEILF_SL_F,
+	OpCodeId_CEILF_SUL_F,
+	OpCodeId_CEILF_SUW_F,
+	OpCodeId_CEILF_SW_F,
+	OpCodeId_CLR1_8,
+	OpCodeId_CLR1_9,
+	OpCodeId_CMOV_12,
+	OpCodeId_CMOV_11,
+	OpCodeId_CMOVF_D_F,
+	OpCodeId_CMOVF_S_F,
+	OpCodeId_CMP_1,
+	OpCodeId_CMP_2,
+	OpCodeId_CMPF_D_F,
+	OpCodeId_CMPF_S_F,
+	OpCodeId_CTRET_10,
+	OpCodeId_CVTF_DL_F,
+	OpCodeId_CVTF_DS_F,
+	OpCodeId_CVTF_DUL_F,
+	OpCodeId_CVTF_DUW_F,
+	OpCodeId_CVTF_DW_F,
+	OpCodeId_CVTF_HS_F,
+	OpCodeId_CVTF_LD_F,
+	OpCodeId_CVTF_LS_F,
+	OpCodeId_CVTF_SD_F,
+	OpCodeId_CVTF_SH_F,
+	OpCodeId_CVTF_SL_F,
+	OpCodeId_CVTF_SUL_F,
+	OpCodeId_CVTF_SUW_F,
+	OpCodeId_CVTF_SW_F,
+	OpCodeId_CVTF_ULD_F,
+	OpCodeId_CVTF_ULS_F,
+	OpCodeId_CVTF_UWD_F,
+	OpCodeId_CVTF_UWS_F,
+	OpCodeId_CVTF_WD_F,
+	OpCodeId_CVTF_WS_F,
+	OpCodeId_DBTRAP_1,
+	OpCodeId_DI_10,
+	OpCodeId_DISPOSE_13,
+	OpCodeId_DIV_11,
+	OpCodeId_DIVF_D_F,
+	OpCodeId_DIVF_S_F,
+	OpCodeId_DIVH_1,
+	OpCodeId_DIVH_11,
+	OpCodeId_DIVHU_11,
+	OpCodeId_DIVQ_11,
+	OpCodeId_DIVQU_11,
+	OpCodeId_DIVU_11,
+	OpCodeId_EI_10,
+	OpCodeId_EIRET_10,
+	OpCodeId_FERET_10,
+	OpCodeId_FETRAP_1,
+	OpCodeId_FLOORF_DL_F,
+	OpCodeId_FLOORF_DUL_F,
+	OpCodeId_FLOORF_DUW_F,
+	OpCodeId_FLOORF_DW_F,
+	OpCodeId_FLOORF_SL_F,
+	OpCodeId_FLOORF_SUL_F,
+	OpCodeId_FLOORF_SUW_F,
+	OpCodeId_FLOORF_SW_F,
+	OpCodeId_FMAF_S_F,
+	OpCodeId_FMSF_S_F,
+	OpCodeId_FNMAF_S_F,
+	OpCodeId_FNMSF_S_F,
+	OpCodeId_HALT_10,
+	OpCodeId_HSH_12,
+	OpCodeId_HSW_12,
+	OpCodeId_JARL_6,
+	OpCodeId_JARL_5,
+	OpCodeId_JARL_11,
+	OpCodeId_JMP_1,
+	OpCodeId_JMP_6,
+	OpCodeId_JR_6,
+	OpCodeId_JR_5,
+	OpCodeId_LDL_W_7,
+	OpCodeId_LDSR_9,
+	OpCodeId_LD_B_7,
+	OpCodeId_LD_B_14,
+	OpCodeId_LD_BU_7,
+	OpCodeId_LD_BU_14,
+	OpCodeId_LD_DW_14,
+	OpCodeId_LD_H_7,
+	OpCodeId_LD_H_14,
+	OpCodeId_LD_HU_14,
+	OpCodeId_LD_HU_7,
+	OpCodeId_LD_W_7,
+	OpCodeId_LD_W_14,
+	OpCodeId_LOOP_7,
+	OpCodeId_MAC_11,
+	OpCodeId_MACU_11,
+	OpCodeId_MADDF_S_F,
+	OpCodeId_MAXF_D_F,
+	OpCodeId_MAXF_S_F,
+	OpCodeId_MINF_D_F,
+	OpCodeId_MINF_S_F,
+	OpCodeId_MOV_1,
+	OpCodeId_MOV_2,
+	OpCodeId_MOV_6,
+	OpCodeId_MOVEA_6,
+	OpCodeId_MOVHI_6,
+	OpCodeId_MSUBF_S_F,
+	OpCodeId_MUL_11,
+	OpCodeId_MUL_12,
+	OpCodeId_MULF_D_F,
+	OpCodeId_MULF_S_F,
+	OpCodeId_MULH_1,
+	OpCodeId_MULH_2,
+	OpCodeId_MULHI_6,
+	OpCodeId_MULU_11,
+	OpCodeId_MULU_12,
+	OpCodeId_NEGF_D_F,
+	OpCodeId_NEGF_S_F,
+	OpCodeId_NMADDF_S_F,
+	OpCodeId_NMSUBF_S_F,
+	OpCodeId_NOP_1,
+	OpCodeId_NOT_1,
+	OpCodeId_NOT1_8,
+	OpCodeId_NOT1_9,
+	OpCodeId_OR_1,
+	OpCodeId_ORI_6,
+	OpCodeId_POPSP_11,
+	OpCodeId_PREPARE_13,
+	OpCodeId_PUSHSP_11,
+	OpCodeId_RECIPF_D_F,
+	OpCodeId_RECIPF_S_F,
+	OpCodeId_RETI_10,
+	OpCodeId_RIE_1,
+	OpCodeId_RIE_10,
+	OpCodeId_ROTL_7,
+	OpCodeId_ROUNDF_SL_F,
+	OpCodeId_ROUNDF_SUL_F,
+	OpCodeId_ROUNDF_SUW_F,
+	OpCodeId_ROUNDF_SW_F,
+	OpCodeId_RSQRTF_D_F,
+	OpCodeId_RSQRTF_S_F,
+	OpCodeId_SAR_2,
+	OpCodeId_SAR_9,
+	OpCodeId_SAR_11,
+	OpCodeId_SASF_9,
+	OpCodeId_SATADD_1,
+	OpCodeId_SATADD_2,
+	OpCodeId_SATADD_11,
+	OpCodeId_SATSUB_1,
+	OpCodeId_SATSUB_11,
+	OpCodeId_SATSUBI_6,
+	OpCodeId_SATSUBR_1,
+	OpCodeId_SBF_11,
+	OpCodeId_SCH0L_9,
+	OpCodeId_SCH0R_9,
+	OpCodeId_SCH1L_9,
+	OpCodeId_SCH1R_9,
+	OpCodeId_SET1_8,
+	OpCodeId_SET1_9,
+	OpCodeId_SETF_9,
+	OpCodeId_SHL_2,
+	OpCodeId_SHL_9,
+	OpCodeId_SHL_11,
+	OpCodeId_SHR_2,
+	OpCodeId_SHR_9,
+	OpCodeId_SHR_11,
+	OpCodeId_SLD_B_4,
+	OpCodeId_SLD_BU_4,
+	OpCodeId_SLD_H_4,
+	OpCodeId_SLD_HU_4,
+	OpCodeId_SLD_W_4,
+	OpCodeId_SNOOZE_10,
+	OpCodeId_SQRTF_D_F,
+	OpCodeId_SQRTF_S_F,
+	OpCodeId_SST_B_4,
+	OpCodeId_SST_H_4,
+	OpCodeId_SST_W_4,
+	OpCodeId_STC_W_7,
+	OpCodeId_STSR_9,
+	OpCodeId_ST_B_7,
+	OpCodeId_ST_B_14,
+	OpCodeId_ST_DW_14,
+	OpCodeId_ST_H_7,
+	OpCodeId_ST_H_14,
+	OpCodeId_ST_W_7,
+	OpCodeId_ST_W_14,
+	OpCodeId_SUB_1,
+	OpCodeId_SUBF_D_F,
+	OpCodeId_SUBF_S_F,
+	OpCodeId_SUBR_1,
+	OpCodeId_SWITCH_1,
+	OpCodeId_SXB_1,
+	OpCodeId_SXH_1,
+	OpCodeId_SYNCE_1,
+	OpCodeId_SYNCI_1,
+	OpCodeId_SYNCM_1,
+	OpCodeId_SYNCP_1,
+	OpCodeId_SYSCALL_10,
+	OpCodeId_TRAP_10,
+	OpCodeId_TRFSR_F,
+	OpCodeId_TRNCF_DL_F,
+	OpCodeId_TRNCF_DUL_F,
+	OpCodeId_TRNCF_DUW_F,
+	OpCodeId_TRNCF_DW_F,
+	OpCodeId_TRNCF_SL_F,
+	OpCodeId_TRNCF_SUL_F,
+	OpCodeId_TRNCF_SUW_F,
+	OpCodeId_TRNCF_SW_F,
+	OpCodeId_TST_1,
+	OpCodeId_TST1_8,
+	OpCodeId_TST1_9,
+	OpCodeId_XOR_1,
+	OpCodeId_XORI_6,
+	OpCodeId_ZXB_1,
+	OpCodeId_ZXH_1,
+	OpCodeId_Num,
+} OpCodeId;
+
+#endif /* _OP_CODEID_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_dec/op_dec.c
@@ -0,0 +1,324 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "cpu_dec/op_dec.h"
+
+static int OpDecode1(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code);
+static int OpDecode2(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code);
+static int OpDecode3(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code);
+static int OpDecode4(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code);
+static int OpDecode5(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code);
+static int OpDecode6(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code);
+static int OpDecode7(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code);
+static int OpDecode8(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code);
+static int OpDecode9(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code);
+static int OpDecode10(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code);
+static int OpDecode11(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code);
+static int OpDecode12(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code);
+static int OpDecode13(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code);
+static int OpDecode14(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code);
+static int OpDecode_f(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code);
+OpDecoderType OpDecoder[OP_CODE_FORMAT_NUM] = {
+	{ OpDecode1 },
+	{ OpDecode2 },
+	{ OpDecode3 },
+	{ OpDecode4 },
+	{ OpDecode5 },
+	{ OpDecode6 },
+	{ OpDecode7 },
+	{ OpDecode8 },
+	{ OpDecode9 },
+	{ OpDecode10 },
+	{ OpDecode11 },
+	{ OpDecode12 },
+	{ OpDecode13 },
+	{ OpDecode14 },
+	{ OpDecode_f },
+};
+
+const uint32 OpFormatSize[OP_CODE_FORMAT_NUM] = {
+		2U, /* 1 */
+		2U, /* 2 */
+		2U, /* 3 */
+		2U, /* 4 */
+		4U, /* 5 */
+		4U, /* 6 */
+		4U, /* 7 */
+		4U, /* 8 */
+		4U, /* 9 */
+		4U, /* 10 */
+		4U, /* 11 */
+		4U, /* 12 */
+		4U, /* 13 */
+		6U, /* 14 */
+		4U, /* f */
+};
+
+static int OpDecode1(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code)
+{
+	decoded_code->type1.opcode = ( (code[0] >> 5) & 0x003F );
+	decoded_code->type1.reg1   = ( (code[0]) & 0x001F );
+	decoded_code->type1.reg2   = ( (code[0] >> 11) & 0x001F );
+	return 0;
+}
+static int OpDecode2(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code)
+{
+	decoded_code->type2.opcode = ( (code[0] >> 5) & 0x003F );
+	decoded_code->type2.imm    = ( (code[0]) & 0x001F );
+	decoded_code->type2.reg2   = ( (code[0] >> 11) & 0x001F );
+	return 0;
+}
+
+static int OpDecode3(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code)
+{
+	uint32 tmp1 =  ( (code[0] >> 11) & 0x001F ); /* 5bits */
+	uint32 tmp2 =  ( (code[0] >>  4) & 0x0007 ); /* 3bits */
+
+	decoded_code->type3.opcode = ( (code[0] >> 7) & 0x000F );
+	decoded_code->type3.disp   = ( (tmp1 << 3) | (tmp2) );
+	decoded_code->type3.cond   = ( (code[0]) & 0x000F );
+	return 0;
+}
+
+static int OpDecode4(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code)
+{
+	/* 4_1 */
+	decoded_code->type4_1.opcode = ( (code[0] >> 7)  & 0x000F );
+	decoded_code->type4_1.disp   = ( (code[0] >> 1)  & 0x3F );
+	decoded_code->type4_1.reg2   = ( (code[0] >> 11) & 0x001F );
+	decoded_code->type4_1.gen    = ( (code[0] >>  0) & 0x0001 );
+
+	/* 4_2 */
+	decoded_code->type4_2.opcode = ( (code[0] >> 4)  & 0x007F );
+	decoded_code->type4_2.disp   = ( (sint8)(code[0] >> 0)  & 0x0F );
+	decoded_code->type4_2.reg2   = ( (code[0] >> 11) & 0x001F );
+
+	return 0;
+}
+
+static int OpDecode5(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code)
+{
+	uint32 tmp1 = ( (code[0] >> 0) & 0x003F ); /* 6bits */;
+	uint32 tmp2 = ( (code[1] >> 0) & 0xFFFF );/* 16bits */;
+
+	decoded_code->type5.opcode = ( (code[0] >> 6)  & 0x001F );
+	decoded_code->type5.reg2   = ( (code[0] >> 11) & 0x001F );
+	decoded_code->type5.disp = ( (tmp1 << 16) | tmp2 );
+	return 0;
+}
+
+static int OpDecode6(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code)
+{
+	uint32 tmp2 = ( (code[1] >> 0) & 0xFFFF );/* 16bits */;
+
+	decoded_code->type6.opcode = ( (code[0] >> 5)  & 0x003F );
+	decoded_code->type6.reg2   = ( (code[0] >> 11) & 0x001F );
+	decoded_code->type6.reg1   = ( code[0] & 0x001F );
+	decoded_code->type6.imm   = tmp2;
+
+	return 0;
+}
+
+static int OpDecode7(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code)
+{
+	uint32 tmp2 = ( (code[1] >> 0) & 0xFFFF );/* 16bits */;
+
+	decoded_code->type7.opcode = ( (code[0] >> 5)  & 0x003F );
+	decoded_code->type7.reg2   = ( (code[0] >> 11) & 0x001F );
+	decoded_code->type7.reg1   = ( code[0] & 0x001F );
+	decoded_code->type7.disp   = ( (tmp2 >> 1) & 0x7FFF );
+	decoded_code->type7.gen    = ( tmp2 & 0x0001 );
+
+	return 0;
+}
+
+static int OpDecode8(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code)
+{
+	sint16 tmp2 = ( (code[1] >> 0) & 0xFFFF );/* 16bits */;
+
+	decoded_code->type8.opcode = ( (code[0] >> 5)  & 0x003F );
+	decoded_code->type8.sub   = ( (code[0] >> 14) & 0x0003 );
+	decoded_code->type8.bit   = ( (code[0] >> 11) & 0x0007 );
+	decoded_code->type8.reg1   = ( code[0] & 0x001F );
+	decoded_code->type8.disp   = tmp2;
+
+	return 0;
+}
+
+static int OpDecode9(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code)
+{
+	uint16 tmp1 = ( (code[0] >> 0) & 0xFFFF );/* 16bits */;
+	uint16 tmp2 = ( (code[1] >> 0) & 0xFFFF );/* 16bits */;
+
+	decoded_code->type9.opcode = ( (tmp1 >> 5)  & 0x003F );
+	decoded_code->type9.reg2   = ( (tmp1 >> 11) & 0x001F );
+	decoded_code->type9.gen    = ( tmp1 & 0x001F );
+	decoded_code->type9.rfu1   = ( (tmp2 >>  1) & 0x000F );
+	decoded_code->type9.rfu2   = ( (tmp2 >> 11) & 0x001F );
+	decoded_code->type9.sub    = ( (tmp2 >>  5) & 0x003F );
+
+	return 0;
+}
+
+static int OpDecode10(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code)
+{
+	uint32 tmp2 = ( (code[1] >> 0) & 0xFFFF );/* 16bits */;
+
+	decoded_code->type10.opcode = ( (code[0] >> 5)  & 0x003F );
+	decoded_code->type10.rfu1   = ( (code[0] >> 11) & 0x0003 );
+	decoded_code->type10.gen1   = ( (code[0] >> 13) & 0x0007 );
+	decoded_code->type10.gen2   = ( (code[0] >> 0)  & 0x001F );
+
+	decoded_code->type10.rfu2   = ( (tmp2 >> 11) & 0x001F );
+	decoded_code->type10.rfu3   = ( (tmp2 >>  1) & 0x000F );
+	decoded_code->type10.sub    = ( (tmp2 >>  5) & 0x003F );
+
+	return 0;
+}
+
+static int OpDecode11(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code)
+{
+	uint32 tmp2 = ( (code[1] >> 0) & 0xFFFF );/* 16bits */;
+
+	decoded_code->type11.opcode = ( (code[0] >> 5)  & 0x003F );
+	decoded_code->type11.reg2   = ( (code[0] >> 11) & 0x001F );
+	decoded_code->type11.reg1   = ( (code[0] >>  0) & 0x001F );
+
+	decoded_code->type11.rfu    = ( (tmp2 >>  2) & 0x0007 );
+	decoded_code->type11.reg3   = ( (tmp2 >> 11) & 0x001F );
+	decoded_code->type11.sub1   = ( (tmp2 >>  5) & 0x003F );
+	decoded_code->type11.sub2   = ( (tmp2 >>  1) & 0x0001 );
+
+	return 0;
+}
+
+static int OpDecode12(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code)
+{
+	uint32 tmp2 = ( (code[1] >> 0) & 0xFFFF );/* 16bits */;
+
+	decoded_code->type12.opcode = ( (code[0] >> 5)  & 0x003F );
+	decoded_code->type12.reg2   = ( (code[0] >> 11) & 0x001F );
+	decoded_code->type12.imml    = ( (code[0] >>  0) & 0x001F );
+
+	decoded_code->type12.reg3   = ( (tmp2 >> 11) & 0x001F );
+	decoded_code->type12.sub1   = ( (tmp2 >>  7) & 0x000F );
+	decoded_code->type12.sub2   = ( (tmp2 >>  1) & 0x0001 );
+	decoded_code->type12.immh   = ( (tmp2 >>  2) & 0x001F );
+	return 0;
+}
+
+static int OpDecode13(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code)
+{
+	uint32 tmp2 = ( (code[1] >> 0) & 0xFFFF );/* 16bits */;
+	uint16 t1 = ((code[0]) & 0x0001);
+	uint16 t2 = ((code[1] >> 5) & 0x07FF);
+	uint32 i;
+
+	decoded_code->type13.opcode = ( (code[0] >> 6)  & 0x001F );
+	decoded_code->type13.rfu    = ( (code[0] >> 11) & 0x001F );
+	decoded_code->type13.imm    = ( (code[0] >>  1) & 0x001F );
+
+	decoded_code->type13.gen   = ( (tmp2 >> 0) & 0x001F );
+
+
+	for (i = 0; i < 32; i++) {
+		decoded_code->type13.list[i] = 0;
+	}
+	decoded_code->type13.list[30] = (t1 != 0U) ? 1U : 0U;
+	decoded_code->type13.list[31] = ((t2 & 0x0001) != 0) ? 1U : 0U; /* 21 */
+	decoded_code->type13.list[29] = ((t2 & 0x0002) != 0) ? 1U : 0U; /* 22 */
+	decoded_code->type13.list[28] = ((t2 & 0x0004) != 0) ? 1U : 0U; /* 23 */
+	decoded_code->type13.list[23] = ((t2 & 0x0008) != 0) ? 1U : 0U; /* 24 */
+	decoded_code->type13.list[22] = ((t2 & 0x0010) != 0) ? 1U : 0U; /* 25 */
+	decoded_code->type13.list[21] = ((t2 & 0x0020) != 0) ? 1U : 0U; /* 26 */
+	decoded_code->type13.list[20] = ((t2 & 0x0040) != 0) ? 1U : 0U; /* 27 */
+	decoded_code->type13.list[27] = ((t2 & 0x0080) != 0) ? 1U : 0U; /* 28 */
+	decoded_code->type13.list[26] = ((t2 & 0x0100) != 0) ? 1U : 0U; /* 29 */
+	decoded_code->type13.list[25] = ((t2 & 0x0200) != 0) ? 1U : 0U; /* 30 */
+	decoded_code->type13.list[24] = ((t2 & 0x0400) != 0) ? 1U : 0U; /* 31 */
+
+
+	return 0;
+}
+
+static int OpDecode14(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code)
+{
+#if 0
+	typedef struct {
+		uint16 sub1;	/* 15-11 */
+		uint16 opcode;	/* 10-5 */
+		uint16 reg1;	/* 4-0 */
+		uint16 reg3;	/* 31-27 */
+		uint16 disp_low;	/* 26-20 */
+		uint16 sub2;	/* 19-16 */
+		uint16 disp_high;	/* 47-32 */
+	} OpCodeFormatType14;
+#endif
+	decoded_code->type14.sub1		= ( (code[0] >> 11) & 0x001F );
+	decoded_code->type14.opcode		= ( (code[0] >> 5)  & 0x003F );
+	decoded_code->type14.reg1		= ( (code[0] >>  0) & 0x001F );
+	decoded_code->type14.reg3		= ( (code[1] >> 11) & 0x001F );
+	decoded_code->type14.disp_low	= ( (code[1] >>  4) & 0x007F );
+	decoded_code->type14.sub2		= ( (code[1] >>  0) & 0x000F );
+	decoded_code->type14.disp_high	= code[2];
+
+	return 0;
+}
+
+static int OpDecode_f(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code)
+{
+#if 0
+	typedef struct {
+		uint16 reg2;		/* 15-11 */
+		uint16 opcode;		/* 10-5 */
+		uint16 reg1;		/* 4-0 */
+		uint16 reg3;		/* 31-27 */
+		uint32 subopcode;	/* 26-16 */
+	} OpCodeFormatType_f;
+#endif
+	decoded_code->type_f.reg2		= ( (code[0] >> 11) & 0x001F );
+	decoded_code->type_f.opcode		= ( (code[0] >> 5)  & 0x003F );
+	decoded_code->type_f.reg1		= ( (code[0] >>  0) & 0x001F );
+	decoded_code->type_f.reg3		= ( (code[1] >> 11) & 0x001F );
+	decoded_code->type_f.subopcode	= ( (code[1] >>  0) & 0x03FF );
+
+	return 0;
+}
\ No newline at end of file
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_dec/op_dec.h
@@ -0,0 +1,55 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _OP_DEC_H_
+#define _OP_DEC_H_
+
+#include "cpu_dec/op_dec_types.h"
+
+
+typedef struct {
+	int (*decode) (uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code);
+} OpDecoderType;
+
+extern OpDecoderType OpDecoder[OP_CODE_FORMAT_NUM];
+extern const uint32 OpFormatSize[OP_CODE_FORMAT_NUM];
+
+#endif /* _OP_DEC_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_dec/op_dec_types.h
@@ -0,0 +1,71 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+
+#ifndef _OP_DEC_TYPES_H_
+#define _OP_DEC_TYPES_H_
+
+#include "cpu_dec/op_format.h"
+#include "cpu_dec/op_codeid.h"
+
+#define OP_DECODE_MAX	(3)
+
+typedef struct {
+	OpCodeFormatId type_id;
+	OpCodeFormatType1 type1;
+	OpCodeFormatType2 type2;
+	OpCodeFormatType3 type3;
+	OpCodeFormatType4_1 type4_1;
+	OpCodeFormatType4_2 type4_2;
+	OpCodeFormatType5 type5;
+	OpCodeFormatType6 type6;
+	OpCodeFormatType7 type7;
+	OpCodeFormatType8 type8;
+	OpCodeFormatType9 type9;
+	OpCodeFormatType10 type10;
+	OpCodeFormatType11 type11;
+	OpCodeFormatType12 type12;
+	OpCodeFormatType13 type13;
+	OpCodeFormatType14 type14;
+	OpCodeFormatType_f type_f;
+} OpDecodedCodeType;
+
+#endif /* _OP_DEC_TYPES_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_dec/op_format.h
@@ -0,0 +1,228 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _OP_FORMAT_H_
+#define _OP_FORMAT_H_
+
+#include "std_types.h"
+
+#define OP_CODE_FORMAT_NUM	15
+typedef enum {
+	OP_CODE_FORMAT_1 = 0,
+	OP_CODE_FORMAT_2,
+	OP_CODE_FORMAT_3,
+	OP_CODE_FORMAT_4,
+	OP_CODE_FORMAT_5,
+	OP_CODE_FORMAT_6,
+	OP_CODE_FORMAT_7,
+	OP_CODE_FORMAT_8,
+	OP_CODE_FORMAT_9,
+	OP_CODE_FORMAT_10,
+	OP_CODE_FORMAT_11,
+	OP_CODE_FORMAT_12,
+	OP_CODE_FORMAT_13,
+	OP_CODE_FORMAT_14,
+	OP_CODE_FORMAT_F,
+	OP_CODE_FORMAT_UNKNOWN,
+} OpCodeFormatId;
+
+
+/*
+ * reg-reg命令形式
+ */
+typedef struct {
+	uint16 opcode;	/* 10-5 */
+	uint16 reg1;	/* 4-0 */
+	uint16 reg2;	/* 15-11 */
+} OpCodeFormatType1;
+/*
+ * imm-reg命令形式
+ */
+typedef struct {
+	uint16 opcode;	/* 10-5 */
+	uint32 imm;		/* 4-0 */
+	uint16 reg2;	/* 15-11 */
+} OpCodeFormatType2;
+/*
+ * 条件分岐命令形式
+ */
+typedef struct {
+	uint16 opcode;	/* 10-7 */
+	uint32 disp;	/* 15-11, 6-4 */
+	uint16 cond;	/* 3-0 */
+} OpCodeFormatType3;
+/*
+ * ロード／ストア命令16ビット形式
+ */
+typedef struct {
+	uint16 opcode;	/* 10-7 */
+	uint32 disp;	/* 6-1 */
+	uint16 reg2;	/* 15-11 */
+	uint32 gen;		/* 0 */
+} OpCodeFormatType4_1;
+typedef struct {
+	uint16 opcode;	/* 10-4 */
+	uint32 disp;	/* 3-0 */
+	uint16 reg2;	/* 15-11 */
+} OpCodeFormatType4_2;
+
+/*
+ * ジャンプ命令形式
+ */
+typedef struct {
+	uint16 opcode;	/* 10-6 */
+	uint32 disp;	/* 5-0, 31-17 */
+	uint16 reg2;	/* 15-11 */
+} OpCodeFormatType5;
+/*
+ * 3オペランド命令形式
+ */
+typedef struct {
+	uint16 opcode;	/* 10-4 */
+	uint32 imm;		/* 31-16 */
+	uint16 reg1;	/* 4-0 */
+	uint16 reg2;	/* 15-11 */
+} OpCodeFormatType6;
+
+/*
+ * ロード／ストア命令32ビット形式
+ */
+typedef struct {
+	uint16 opcode;	/* 10-5 */
+	uint32 disp;	/* 31-17 */
+	uint16 reg1;	/* 4-0 */
+	uint16 reg2;	/* 15-11 */
+	uint32 gen;		/* 16 */
+} OpCodeFormatType7;
+
+/*
+ * ビット操作命令形式
+ */
+typedef struct {
+	uint16 opcode;	/* 10-5 */
+	uint16 sub;		/* 15-14 */
+	uint16 bit;		/* 13-11 */
+	uint16 reg1;	/* 4-0 */
+	sint16 disp;	/* 31-16 */
+} OpCodeFormatType8;
+/*
+ * 拡張命令形式1
+ */
+typedef struct {
+	uint16 opcode;	/* 10-5 */
+	uint16 sub;		/* 26-21 */
+	uint16 gen;		/* 4-0 */
+	uint16 reg2;	/* 15-11 */
+	uint16 rfu2;		/* 31-27 */
+	uint16 rfu1;		/* 20-17 */
+} OpCodeFormatType9;
+/*
+ * 拡張命令形式2
+ */
+typedef struct {
+	uint16 opcode;	/* 10-5 */
+	uint16 gen1;	/* 15-13 */
+	uint32 gen2;	/* 4-0 */
+	uint16 sub;		/* 26-21 */
+	uint16 rfu1;		/* 12-11*/
+	uint16 rfu2;		/* 20-17 */
+	uint16 rfu3;		/* 31-27 */
+} OpCodeFormatType10;
+/*
+ * 拡張命令形式3
+ */
+typedef struct {
+	uint16 opcode;	/* 10-5 */
+	uint16 reg1;	/* 4-0 */
+	uint16 reg2;	/* 15-11 */
+	uint16 reg3;	/* 31-27 */
+	uint16 sub1;	/* 26-21 */
+	uint16 sub2;	/* 17 */
+	uint16 rfu;		/* 20-18 */
+} OpCodeFormatType11;
+/*
+ * 拡張命令形式4
+ */
+typedef struct {
+	uint16 opcode;	/* 10-5 */
+	uint16 reg2;	/* 15-11 */
+	uint16 reg3;	/* 31-27 */
+	uint32 imml;		/* 4-0 */
+	uint32 immh;		/* 22-18 */
+	uint16 sub1;	/* 26-23 */
+	uint16 sub2;	/* 17 */
+} OpCodeFormatType12;
+/*
+ * スタック操作命令形式1
+ */
+typedef struct {
+	uint16 opcode;	/* 10-6 */
+	uint32 imm;		/* 5-1 */
+	uint8 list[32U];	/* 0, 31-21 */
+	uint16 gen;		/* 20-16 */
+	uint16 rfu;		/* 15-11 */
+} OpCodeFormatType13;
+
+/*
+ * ロード／ストア命令48ビット形式（Format XIV）
+ */
+typedef struct {
+	uint16 sub1;	/* 15-11 */
+	uint16 opcode;	/* 10-5 */
+	uint16 reg1;	/* 4-0 */
+	uint16 reg3;	/* 31-27 */
+	uint32 disp_low;	/* 26-20 */
+	uint16 sub2;	/* 19-16 */
+	uint32 disp_high;	/* 47-32 */
+} OpCodeFormatType14;
+
+/*
+ * 浮動小数点演算命令(Format F:I)
+ */
+typedef struct {
+	uint16 reg2;		/* 15-11 */
+	uint16 opcode;		/* 10-5 */
+	uint16 reg1;		/* 4-0 */
+	uint16 reg3;		/* 31-27 */
+	uint32 subopcode;	/* 26-16 */
+} OpCodeFormatType_f;
+
+#endif /* _OP_FORMAT_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_dec/op_parse.c
@@ -0,0 +1,79 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "cpu_dec/op_parse.h"
+#include "cpu_dec/op_parse_private.h"
+#include "cpu_dec/op_dec.h"
+
+int op_parse(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code, OperationCodeType *optype)
+{
+	uint16 base_id;
+	uint16 sub_id;
+	uint32 value;
+	int ret;
+
+	value = (((uint32)code[1]) << 16U) | ((uint32)code[0]);
+
+	if (((code[0] & BIT_MASK_10_5) == BIT_UP_10_5)
+		&& ((value & BIT_MASK_16) == BIT_DOWN_16)) {
+		/*
+		 * Extend code
+		 */
+		base_id = GET_VALUE_BIT_26_23(value);
+		sub_id  = GET_VALUE_BIT_22_21(value);
+		ret = op_parse_extend_code_table[OP_PARSE_TABLE_INDEX(base_id, sub_id)].parse(code, optype);
+	}
+	else {
+		/*
+		 * Base code
+		 */
+		base_id = GET_VALUE_BIT_10_7(code[0]);
+		sub_id  = GET_VALUE_BIT_6_5(code[0]);
+		ret = op_parse_base_code_table[OP_PARSE_TABLE_INDEX(base_id, sub_id)].parse(code, optype);
+	}
+	/*
+	 * decode
+	 */
+	if (ret == 0) {
+		ret = OpDecoder[optype->format_id].decode(code, decoded_code);
+	}
+	return ret;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_dec/op_parse.h
@@ -0,0 +1,55 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _OP_PARSE_H_
+#define _OP_PARSE_H_
+
+#include "cpu_dec/op_dec_types.h"
+
+typedef struct {
+	OpCodeFormatId	format_id;
+	OpCodeId		code_id;
+} OperationCodeType;
+
+extern int op_parse(uint16 code[OP_DECODE_MAX], OpDecodedCodeType *decoded_code, OperationCodeType *optype);
+
+
+#endif /* _OP_PARSE_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_dec/op_parse_private.c
@@ -0,0 +1,2919 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "cpu_dec/op_parse.h"
+#include "cpu_dec/op_parse_private.h"
+
+/*
+ * base
+ */
+static int op_parse_base_code_0000_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0000_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0000_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0000_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0001_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0001_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0001_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0001_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0010_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0010_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0010_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0010_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0011_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0011_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0011_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0011_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0100_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0100_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0100_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0100_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0101_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0101_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0101_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0101_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0110_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0110_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0110_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0110_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0111_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0111_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0111_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_0111_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1000_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1000_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1000_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1000_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1001_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1001_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1001_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1001_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1010_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1010_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1010_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1010_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1011_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1011_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1011_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1011_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1100_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1100_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1100_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1100_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1101_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1101_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1101_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1101_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1110_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1110_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1110_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1110_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1111_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1111_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1111_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_base_code_1111_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+
+/*
+ * extend
+ */
+static int op_parse_extend_code_0000_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0000_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0000_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0000_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0001_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0001_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0001_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0001_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0010_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0010_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0010_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0010_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0011_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0011_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0011_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0011_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0100_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0100_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0100_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0100_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0101_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0101_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0101_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0101_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0110_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0110_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0110_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0110_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0111_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0111_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0111_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_0111_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1000_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1000_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1000_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1000_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1001_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1001_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1001_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1001_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1010_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1010_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1010_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1010_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1011_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1011_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1011_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1011_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1100_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1100_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1100_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1100_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1101_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1101_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1101_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1101_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1110_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1110_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1110_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1110_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1111_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1111_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1111_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+static int op_parse_extend_code_1111_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+
+/*
+ * base table
+ */
+OpParserType op_parse_base_code_table[OP_PARSE_CODE_TABLE_NUM] = {
+	{ op_parse_base_code_0000_00 },
+	{ op_parse_base_code_0000_01 },
+	{ op_parse_base_code_0000_10 },
+	{ op_parse_base_code_0000_11 },
+	{ op_parse_base_code_0001_00 },
+	{ op_parse_base_code_0001_01 },
+	{ op_parse_base_code_0001_10 },
+	{ op_parse_base_code_0001_11 },
+	{ op_parse_base_code_0010_00 },
+	{ op_parse_base_code_0010_01 },
+	{ op_parse_base_code_0010_10 },
+	{ op_parse_base_code_0010_11 },
+	{ op_parse_base_code_0011_00 },
+	{ op_parse_base_code_0011_01 },
+	{ op_parse_base_code_0011_10 },
+	{ op_parse_base_code_0011_11 },
+	{ op_parse_base_code_0100_00 },
+	{ op_parse_base_code_0100_01 },
+	{ op_parse_base_code_0100_10 },
+	{ op_parse_base_code_0100_11 },
+	{ op_parse_base_code_0101_00 },
+	{ op_parse_base_code_0101_01 },
+	{ op_parse_base_code_0101_10 },
+	{ op_parse_base_code_0101_11 },
+	{ op_parse_base_code_0110_00 },
+	{ op_parse_base_code_0110_01 },
+	{ op_parse_base_code_0110_10 },
+	{ op_parse_base_code_0110_11 },
+	{ op_parse_base_code_0111_00 },
+	{ op_parse_base_code_0111_01 },
+	{ op_parse_base_code_0111_10 },
+	{ op_parse_base_code_0111_11 },
+	{ op_parse_base_code_1000_00 },
+	{ op_parse_base_code_1000_01 },
+	{ op_parse_base_code_1000_10 },
+	{ op_parse_base_code_1000_11 },
+	{ op_parse_base_code_1001_00 },
+	{ op_parse_base_code_1001_01 },
+	{ op_parse_base_code_1001_10 },
+	{ op_parse_base_code_1001_11 },
+	{ op_parse_base_code_1010_00 },
+	{ op_parse_base_code_1010_01 },
+	{ op_parse_base_code_1010_10 },
+	{ op_parse_base_code_1010_11 },
+	{ op_parse_base_code_1011_00 },
+	{ op_parse_base_code_1011_01 },
+	{ op_parse_base_code_1011_10 },
+	{ op_parse_base_code_1011_11 },
+	{ op_parse_base_code_1100_00 },
+	{ op_parse_base_code_1100_01 },
+	{ op_parse_base_code_1100_10 },
+	{ op_parse_base_code_1100_11 },
+	{ op_parse_base_code_1101_00 },
+	{ op_parse_base_code_1101_01 },
+	{ op_parse_base_code_1101_10 },
+	{ op_parse_base_code_1101_11 },
+	{ op_parse_base_code_1110_00 },
+	{ op_parse_base_code_1110_01 },
+	{ op_parse_base_code_1110_10 },
+	{ op_parse_base_code_1110_11 },
+	{ op_parse_base_code_1111_00 },
+	{ op_parse_base_code_1111_01 },
+	{ op_parse_base_code_1111_10 },
+	{ op_parse_base_code_1111_11 },
+};
+
+/*
+ * extend table
+ */
+OpParserType op_parse_extend_code_table[OP_PARSE_CODE_TABLE_NUM] = {
+	{ op_parse_extend_code_0000_00 },
+	{ op_parse_extend_code_0000_01 },
+	{ op_parse_extend_code_0000_10 },
+	{ op_parse_extend_code_0000_11 },
+	{ op_parse_extend_code_0001_00 },
+	{ op_parse_extend_code_0001_01 },
+	{ op_parse_extend_code_0001_10 },
+	{ op_parse_extend_code_0001_11 },
+	{ op_parse_extend_code_0010_00 },
+	{ op_parse_extend_code_0010_01 },
+	{ op_parse_extend_code_0010_10 },
+	{ op_parse_extend_code_0010_11 },
+	{ op_parse_extend_code_0011_00 },
+	{ op_parse_extend_code_0011_01 },
+	{ op_parse_extend_code_0011_10 },
+	{ op_parse_extend_code_0011_11 },
+	{ op_parse_extend_code_0100_00 },
+	{ op_parse_extend_code_0100_01 },
+	{ op_parse_extend_code_0100_10 },
+	{ op_parse_extend_code_0100_11 },
+	{ op_parse_extend_code_0101_00 },
+	{ op_parse_extend_code_0101_01 },
+	{ op_parse_extend_code_0101_10 },
+	{ op_parse_extend_code_0101_11 },
+	{ op_parse_extend_code_0110_00 },
+	{ op_parse_extend_code_0110_01 },
+	{ op_parse_extend_code_0110_10 },
+	{ op_parse_extend_code_0110_11 },
+	{ op_parse_extend_code_0111_00 },
+	{ op_parse_extend_code_0111_01 },
+	{ op_parse_extend_code_0111_10 },
+	{ op_parse_extend_code_0111_11 },
+	{ op_parse_extend_code_1000_00 },
+	{ op_parse_extend_code_1000_01 },
+	{ op_parse_extend_code_1000_10 },
+	{ op_parse_extend_code_1000_11 },
+	{ op_parse_extend_code_1001_00 },
+	{ op_parse_extend_code_1001_01 },
+	{ op_parse_extend_code_1001_10 },
+	{ op_parse_extend_code_1001_11 },
+	{ op_parse_extend_code_1010_00 },
+	{ op_parse_extend_code_1010_01 },
+	{ op_parse_extend_code_1010_10 },
+	{ op_parse_extend_code_1010_11 },
+	{ op_parse_extend_code_1011_00 },
+	{ op_parse_extend_code_1011_01 },
+	{ op_parse_extend_code_1011_10 },
+	{ op_parse_extend_code_1011_11 },
+	{ op_parse_extend_code_1100_00 },
+	{ op_parse_extend_code_1100_01 },
+	{ op_parse_extend_code_1100_10 },
+	{ op_parse_extend_code_1100_11 },
+	{ op_parse_extend_code_1101_00 },
+	{ op_parse_extend_code_1101_01 },
+	{ op_parse_extend_code_1101_10 },
+	{ op_parse_extend_code_1101_11 },
+	{ op_parse_extend_code_1110_00 },
+	{ op_parse_extend_code_1110_01 },
+	{ op_parse_extend_code_1110_10 },
+	{ op_parse_extend_code_1110_11 },
+	{ op_parse_extend_code_1111_00 },
+	{ op_parse_extend_code_1111_01 },
+	{ op_parse_extend_code_1111_10 },
+	{ op_parse_extend_code_1111_11 },
+};
+
+/*
+ * Base
+ */
+static int op_parse_base_code_0000_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint16 reg1 = GET_REG1(code[0]);
+	uint16 reg2 = GET_REG2(code[0]);
+
+	if (( reg1 == 0 ) && ( reg2 == 0 )) 
+	{
+		optype->code_id = OpCodeId_NOP_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	if (( reg1 == 31 ) && ( reg2 == 0 )) 
+	{
+		optype->code_id = OpCodeId_SYNCP_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	if (( reg1 == 30 ) && ( reg2 == 0 )) 
+	{
+		optype->code_id = OpCodeId_SYNCM_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	if (( reg1 == 29 ) && ( reg2 == 0 )) 
+	{
+		optype->code_id = OpCodeId_SYNCE_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	if (( reg1 == 28 ) && ( reg2 == 0 )) 
+	{
+		optype->code_id = OpCodeId_SYNCI_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	if (( ( reg1 >= 1 ) && ( reg1 <= 27 ) ) && ( reg2 == 0 )) 
+	{
+		optype->code_id = OpCodeId_MOV_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	if (( reg1 == 0 ) && ( reg2 !=  0 )) 
+	{
+		optype->code_id = OpCodeId_MOV_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	if (( reg1 !=  0 ) && ( reg2 !=  0 )) 
+	{
+		optype->code_id = OpCodeId_MOV_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0000_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_NOT_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0000_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint16 reg1 = GET_REG1(code[0]);
+	uint16 reg2 = GET_REG2(code[0]);
+
+	if (( reg1 == 0 ) && ( reg2 == 0 )) 
+	{
+		optype->code_id = OpCodeId_RIE_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	if (( reg1 !=  0 ) && ( reg2 == 0 )) 
+	{
+		optype->code_id = OpCodeId_SWITCH_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	if (( reg1 == 0 ) && ( reg2 == 31 )) 
+	{
+		optype->code_id = OpCodeId_DBTRAP_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	if (( reg1 == 0 ) && ( ( reg2 >= 1 ) && ( reg2 <= 15 ) )) 
+	{
+		optype->code_id = OpCodeId_FETRAP_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	if (( reg1 !=  0 ) && ( reg2 !=  0 )) 
+	{
+		optype->code_id = OpCodeId_DIVH_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0000_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint16 reg2 = GET_REG2(code[0]);
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+
+	if (( reg2 == 0 )) 
+	{
+		optype->code_id = OpCodeId_JMP_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	if (( reg2 !=  0 ) && ( value & ( (1U << 4U) ) ) == ( (0U << 4U) )) 
+	{
+		optype->code_id = OpCodeId_SLD_BU_4;
+		optype->format_id = OP_CODE_FORMAT_4;
+		return 0;
+	}
+	if (( reg2 !=  0 ) && ( value & ( (1U << 4U) ) ) == ( (1U << 4U) )) 
+	{
+		optype->code_id = OpCodeId_SLD_HU_4;
+		optype->format_id = OP_CODE_FORMAT_4;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0001_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint16 reg2 = GET_REG2(code[0]);
+
+	if (( reg2 !=  0 )) 
+	{
+		optype->code_id = OpCodeId_SATSUBR_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	if (( reg2 == 0 )) 
+	{
+		optype->code_id = OpCodeId_ZXB_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0001_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint16 reg2 = GET_REG2(code[0]);
+
+	if (( reg2 !=  0 )) 
+	{
+		optype->code_id = OpCodeId_SATSUB_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	if (( reg2 == 0 )) 
+	{
+		optype->code_id = OpCodeId_SXB_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0001_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint16 reg2 = GET_REG2(code[0]);
+
+	if (( reg2 !=  0 )) 
+	{
+		optype->code_id = OpCodeId_SATADD_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	if (( reg2 == 0 )) 
+	{
+		optype->code_id = OpCodeId_ZXH_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0001_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint16 reg2 = GET_REG2(code[0]);
+
+	if (( reg2 !=  0 )) 
+	{
+		optype->code_id = OpCodeId_MULH_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	if (( reg2 == 0 )) 
+	{
+		optype->code_id = OpCodeId_SXH_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0010_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_OR_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0010_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_XOR_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0010_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_AND_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0010_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_TST_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0011_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_SUBR_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0011_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_SUB_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0011_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_ADD_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0011_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_CMP_1;
+		optype->format_id = OP_CODE_FORMAT_1;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0100_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint16 reg2 = GET_REG2(code[0]);
+
+	if (( reg2 !=  0 )) 
+	{
+		optype->code_id = OpCodeId_MOV_2;
+		optype->format_id = OP_CODE_FORMAT_2;
+		return 0;
+	}
+	if (( reg2 == 0 )) 
+	{
+		optype->code_id = OpCodeId_CALLT_2;
+		optype->format_id = OP_CODE_FORMAT_2;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0100_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint16 reg2 = GET_REG2(code[0]);
+
+	if (( reg2 !=  0 )) 
+	{
+		optype->code_id = OpCodeId_SATADD_2;
+		optype->format_id = OP_CODE_FORMAT_2;
+		return 0;
+	}
+	if (( reg2 == 0 )) 
+	{
+		optype->code_id = OpCodeId_CALLT_2;
+		optype->format_id = OP_CODE_FORMAT_2;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0100_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_ADD_2;
+		optype->format_id = OP_CODE_FORMAT_2;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0100_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_CMP_2;
+		optype->format_id = OP_CODE_FORMAT_2;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0101_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_SHR_2;
+		optype->format_id = OP_CODE_FORMAT_2;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0101_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_SAR_2;
+		optype->format_id = OP_CODE_FORMAT_2;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0101_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_SHL_2;
+		optype->format_id = OP_CODE_FORMAT_2;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0101_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint16 reg1 = GET_REG1(code[0]);
+	uint16 reg2 = GET_REG2(code[0]);
+
+	if (( reg2 !=  0 )) 
+	{
+		optype->code_id = OpCodeId_MULH_2;
+		optype->format_id = OP_CODE_FORMAT_2;
+		return 0;
+	}
+	if (( reg1 == 0 ) && ( reg2 == 0 )) 
+	{
+		optype->code_id = OpCodeId_JR_6;
+		optype->format_id = OP_CODE_FORMAT_6;
+		return 0;
+	}
+	if (( reg1 !=  0 ) && ( reg2 == 0 )) 
+	{
+		optype->code_id = OpCodeId_JARL_6;
+		optype->format_id = OP_CODE_FORMAT_6;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0110_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_SLD_B_4;
+		optype->format_id = OP_CODE_FORMAT_4;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0110_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_SLD_B_4;
+		optype->format_id = OP_CODE_FORMAT_4;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0110_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_SLD_B_4;
+		optype->format_id = OP_CODE_FORMAT_4;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0110_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_SLD_B_4;
+		optype->format_id = OP_CODE_FORMAT_4;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0111_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_SST_B_4;
+		optype->format_id = OP_CODE_FORMAT_4;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0111_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_SST_B_4;
+		optype->format_id = OP_CODE_FORMAT_4;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0111_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_SST_B_4;
+		optype->format_id = OP_CODE_FORMAT_4;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_0111_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_SST_B_4;
+		optype->format_id = OP_CODE_FORMAT_4;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1000_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_SLD_H_4;
+		optype->format_id = OP_CODE_FORMAT_4;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1000_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_SLD_H_4;
+		optype->format_id = OP_CODE_FORMAT_4;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1000_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_SLD_H_4;
+		optype->format_id = OP_CODE_FORMAT_4;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1000_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_SLD_H_4;
+		optype->format_id = OP_CODE_FORMAT_4;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1001_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_SST_H_4;
+		optype->format_id = OP_CODE_FORMAT_4;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1001_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_SST_H_4;
+		optype->format_id = OP_CODE_FORMAT_4;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1001_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_SST_H_4;
+		optype->format_id = OP_CODE_FORMAT_4;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1001_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_SST_H_4;
+		optype->format_id = OP_CODE_FORMAT_4;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1010_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+
+	if (( value & ( (1U << 0U) ) ) == ( (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_SLD_W_4;
+		optype->format_id = OP_CODE_FORMAT_4;
+		return 0;
+	}
+	if (( value & ( (1U << 0U) ) ) == ( (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_SST_W_4;
+		optype->format_id = OP_CODE_FORMAT_4;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1010_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+
+	if (( value & ( (1U << 0U) ) ) == ( (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_SLD_W_4;
+		optype->format_id = OP_CODE_FORMAT_4;
+		return 0;
+	}
+	if (( value & ( (1U << 0U) ) ) == ( (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_SST_W_4;
+		optype->format_id = OP_CODE_FORMAT_4;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1010_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+
+	if (( value & ( (1U << 0U) ) ) == ( (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_SLD_W_4;
+		optype->format_id = OP_CODE_FORMAT_4;
+		return 0;
+	}
+	if (( value & ( (1U << 0U) ) ) == ( (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_SST_W_4;
+		optype->format_id = OP_CODE_FORMAT_4;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1010_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+
+	if (( value & ( (1U << 0U) ) ) == ( (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_SLD_W_4;
+		optype->format_id = OP_CODE_FORMAT_4;
+		return 0;
+	}
+	if (( value & ( (1U << 0U) ) ) == ( (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_SST_W_4;
+		optype->format_id = OP_CODE_FORMAT_4;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1011_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_Bcond_3;
+		optype->format_id = OP_CODE_FORMAT_3;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1011_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_Bcond_3;
+		optype->format_id = OP_CODE_FORMAT_3;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1011_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_Bcond_3;
+		optype->format_id = OP_CODE_FORMAT_3;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1011_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_Bcond_3;
+		optype->format_id = OP_CODE_FORMAT_3;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1100_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_ADDI_6;
+		optype->format_id = OP_CODE_FORMAT_6;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1100_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint16 reg2 = GET_REG2(code[0]);
+
+	if (( reg2 !=  0 )) 
+	{
+		optype->code_id = OpCodeId_MOVEA_6;
+		optype->format_id = OP_CODE_FORMAT_6;
+		return 0;
+	}
+	if (( reg2 == 0 )) 
+	{
+		optype->code_id = OpCodeId_MOV_6;
+		optype->format_id = OP_CODE_FORMAT_6;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1100_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint16 reg2 = GET_REG2(code[0]);
+
+	if (( reg2 !=  0 )) 
+	{
+		optype->code_id = OpCodeId_MOVHI_6;
+		optype->format_id = OP_CODE_FORMAT_6;
+		return 0;
+	}
+	if (( reg2 == 0 )) 
+	{
+		optype->code_id = OpCodeId_DISPOSE_13;
+		optype->format_id = OP_CODE_FORMAT_13;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1100_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint16 reg2 = GET_REG2(code[0]);
+
+	if (( reg2 !=  0 )) 
+	{
+		optype->code_id = OpCodeId_SATSUBI_6;
+		optype->format_id = OP_CODE_FORMAT_6;
+		return 0;
+	}
+	if (( reg2 == 0 )) 
+	{
+		optype->code_id = OpCodeId_DISPOSE_13;
+		optype->format_id = OP_CODE_FORMAT_13;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1101_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_ORI_6;
+		optype->format_id = OP_CODE_FORMAT_6;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1101_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_XORI_6;
+		optype->format_id = OP_CODE_FORMAT_6;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1101_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_ANDI_6;
+		optype->format_id = OP_CODE_FORMAT_6;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1101_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint16 reg2 = GET_REG2(code[0]);
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+
+	if (( reg2 !=  0 )) 
+	{
+		optype->code_id = OpCodeId_MULHI_6;
+		optype->format_id = OP_CODE_FORMAT_6;
+		return 0;
+	}
+	if (( reg2 == 0 ) && ( value & ( (1U << 16U) ) ) == ( (0U << 16U) )) 
+	{
+		optype->code_id = OpCodeId_JMP_6;
+		optype->format_id = OP_CODE_FORMAT_6;
+		return 0;
+	}
+	if (( reg2 == 0 ) && ( value & ( (1U << 16U) ) ) == ( (1U << 16U) )) 
+	{
+		optype->code_id = OpCodeId_LOOP_7;
+		optype->format_id = OP_CODE_FORMAT_7;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1110_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_LD_B_7;
+		optype->format_id = OP_CODE_FORMAT_7;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1110_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+
+	if (( value & ( (1U << 16U) ) ) == ( (0U << 16U) )) 
+	{
+		optype->code_id = OpCodeId_LD_H_7;
+		optype->format_id = OP_CODE_FORMAT_7;
+		return 0;
+	}
+	if (( value & ( (1U << 16U) ) ) == ( (1U << 16U) )) 
+	{
+		optype->code_id = OpCodeId_LD_W_7;
+		optype->format_id = OP_CODE_FORMAT_7;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1110_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_ST_B_7;
+		optype->format_id = OP_CODE_FORMAT_7;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1110_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+
+	if (( value & ( (1U << 16U) ) ) == ( (0U << 16U) )) 
+	{
+		optype->code_id = OpCodeId_ST_H_7;
+		optype->format_id = OP_CODE_FORMAT_7;
+		return 0;
+	}
+	if (( value & ( (1U << 16U) ) ) == ( (1U << 16U) )) 
+	{
+		optype->code_id = OpCodeId_ST_W_7;
+		optype->format_id = OP_CODE_FORMAT_7;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1111_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint16 reg2 = GET_REG2(code[0]);
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+
+	if (( reg2 == 0 ) && ( value & ( (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 16U) | (1U << 5U) ) ) == ( (0U << 19U) | (1U << 18U) | (0U << 17U) | (1U << 16U) | (0U << 5U) )) 
+	{
+		optype->code_id = OpCodeId_LD_B_14;
+		optype->format_id = OP_CODE_FORMAT_14;
+		return 0;
+	}
+	if (( reg2 == 0 ) && ( value & ( (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 16U) | (1U << 5U) ) ) == ( (0U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 16U) | (0U << 5U) )) 
+	{
+		optype->code_id = OpCodeId_LD_H_14;
+		optype->format_id = OP_CODE_FORMAT_14;
+		return 0;
+	}
+	if (( reg2 == 0 ) && ( value & ( (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 16U) | (1U << 5U) ) ) == ( (1U << 19U) | (0U << 18U) | (0U << 17U) | (1U << 16U) | (0U << 5U) )) 
+	{
+		optype->code_id = OpCodeId_LD_W_14;
+		optype->format_id = OP_CODE_FORMAT_14;
+		return 0;
+	}
+	if (( reg2 == 0 ) && ( value & ( (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 16U) | (1U << 5U) ) ) == ( (1U << 19U) | (1U << 18U) | (0U << 17U) | (1U << 16U) | (0U << 5U) )) 
+	{
+		optype->code_id = OpCodeId_ST_B_14;
+		optype->format_id = OP_CODE_FORMAT_14;
+		return 0;
+	}
+	if (( reg2 == 0 ) && ( value & ( (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 16U) | (1U << 5U) ) ) == ( (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 16U) | (0U << 5U) )) 
+	{
+		optype->code_id = OpCodeId_ST_W_14;
+		optype->format_id = OP_CODE_FORMAT_14;
+		return 0;
+	}
+	if (( reg2 == 0 ) && ( value & ( (1U << 16U) ) ) == ( (0U << 16U) )) 
+	{
+		optype->code_id = OpCodeId_JR_5;
+		optype->format_id = OP_CODE_FORMAT_5;
+		return 0;
+	}
+	if (( reg2 !=  0 ) && ( value & ( (1U << 16U) ) ) == ( (0U << 16U) )) 
+	{
+		optype->code_id = OpCodeId_JARL_5;
+		optype->format_id = OP_CODE_FORMAT_5;
+		return 0;
+	}
+	if (( reg2 !=  0 ) && ( value & ( (1U << 16U) ) ) == ( (1U << 16U) )) 
+	{
+		optype->code_id = OpCodeId_LD_BU_7;
+		optype->format_id = OP_CODE_FORMAT_7;
+		return 0;
+	}
+	if (( reg2 == 0 ) && ( value & ( (1U << 18U) | (1U << 17U) | (1U << 16U) ) ) == ( (0U << 18U) | (1U << 17U) | (1U << 16U) )) 
+	{
+		optype->code_id = OpCodeId_PREPARE_13;
+		optype->format_id = OP_CODE_FORMAT_13;
+		return 0;
+	}
+	if (( reg2 == 0 ) && ( value & ( (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 16U) ) ) == ( (0U << 19U) | (0U << 18U) | (0U << 17U) | (1U << 16U) )) 
+	{
+		optype->code_id = OpCodeId_PREPARE_13;
+		optype->format_id = OP_CODE_FORMAT_13;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1111_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint16 reg2 = GET_REG2(code[0]);
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+
+	if (( reg2 == 0 ) && ( value & ( (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 16U) | (1U << 5U) ) ) == ( (0U << 19U) | (1U << 18U) | (0U << 17U) | (1U << 16U) | (1U << 5U) )) 
+	{
+		optype->code_id = OpCodeId_LD_BU_14;
+		optype->format_id = OP_CODE_FORMAT_14;
+		return 0;
+	}
+	if (( reg2 == 0 ) && ( value & ( (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 16U) | (1U << 5U) ) ) == ( (0U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 16U) | (1U << 5U) )) 
+	{
+		optype->code_id = OpCodeId_LD_HU_14;
+		optype->format_id = OP_CODE_FORMAT_14;
+		return 0;
+	}
+	if (( reg2 == 0 ) && ( value & ( (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 16U) | (1U << 5U) ) ) == ( (1U << 19U) | (1U << 18U) | (0U << 17U) | (1U << 16U) | (1U << 5U) )) 
+	{
+		optype->code_id = OpCodeId_ST_H_14;
+		optype->format_id = OP_CODE_FORMAT_14;
+		return 0;
+	}
+	if (( reg2 == 0 ) && ( value & ( (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 16U) | (1U << 5U) ) ) == ( (1U << 19U) | (0U << 18U) | (0U << 17U) | (1U << 16U) | (1U << 5U) )) 
+	{
+		optype->code_id = OpCodeId_LD_DW_14;
+		optype->format_id = OP_CODE_FORMAT_14;
+		return 0;
+	}
+	if (( reg2 == 0 ) && ( value & ( (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 16U) | (1U << 5U) ) ) == ( (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 16U) | (1U << 5U) )) 
+	{
+		optype->code_id = OpCodeId_ST_DW_14;
+		optype->format_id = OP_CODE_FORMAT_14;
+		return 0;
+	}
+	if (( reg2 == 0 ) && ( value & ( (1U << 16U) ) ) == ( (0U << 16U) )) 
+	{
+		optype->code_id = OpCodeId_JR_5;
+		optype->format_id = OP_CODE_FORMAT_5;
+		return 0;
+	}
+	if (( reg2 !=  0 ) && ( value & ( (1U << 16U) ) ) == ( (0U << 16U) )) 
+	{
+		optype->code_id = OpCodeId_JARL_5;
+		optype->format_id = OP_CODE_FORMAT_5;
+		return 0;
+	}
+	if (( reg2 !=  0 ) && ( value & ( (1U << 16U) ) ) == ( (1U << 16U) )) 
+	{
+		optype->code_id = OpCodeId_LD_BU_7;
+		optype->format_id = OP_CODE_FORMAT_7;
+		return 0;
+	}
+	if (( reg2 == 0 ) && ( value & ( (1U << 18U) | (1U << 17U) | (1U << 16U) ) ) == ( (0U << 18U) | (1U << 17U) | (1U << 16U) )) 
+	{
+		optype->code_id = OpCodeId_PREPARE_13;
+		optype->format_id = OP_CODE_FORMAT_13;
+		return 0;
+	}
+	if (( reg2 == 0 ) && ( value & ( (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 16U) ) ) == ( (0U << 19U) | (0U << 18U) | (0U << 17U) | (1U << 16U) )) 
+	{
+		optype->code_id = OpCodeId_PREPARE_13;
+		optype->format_id = OP_CODE_FORMAT_13;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1111_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+
+	if (( value & ( (1U << 15U) | (1U << 14U) ) ) == ( (0U << 15U) | (0U << 14U) )) 
+	{
+		optype->code_id = OpCodeId_SET1_8;
+		optype->format_id = OP_CODE_FORMAT_8;
+		return 0;
+	}
+	if (( value & ( (1U << 15U) | (1U << 14U) ) ) == ( (0U << 15U) | (1U << 14U) )) 
+	{
+		optype->code_id = OpCodeId_NOT1_8;
+		optype->format_id = OP_CODE_FORMAT_8;
+		return 0;
+	}
+	if (( value & ( (1U << 15U) | (1U << 14U) ) ) == ( (1U << 15U) | (0U << 14U) )) 
+	{
+		optype->code_id = OpCodeId_CLR1_8;
+		optype->format_id = OP_CODE_FORMAT_8;
+		return 0;
+	}
+	if (( value & ( (1U << 15U) | (1U << 14U) ) ) == ( (1U << 15U) | (1U << 14U) )) 
+	{
+		optype->code_id = OpCodeId_TST1_8;
+		optype->format_id = OP_CODE_FORMAT_8;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_base_code_1111_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint16 reg2 = GET_REG2(code[0]);
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+
+	if (( reg2 !=  0 ) && ( value & ( (1U << 16U) ) ) == ( (1U << 16U) )) 
+	{
+		optype->code_id = OpCodeId_LD_HU_7;
+		optype->format_id = OP_CODE_FORMAT_7;
+		return 0;
+	}
+	if (( reg2 == 0 ) && ( value & ( (1U << 16U) ) ) == ( (1U << 16U) )) 
+	{
+		optype->code_id = OpCodeId_Bcond_7;
+		optype->format_id = OP_CODE_FORMAT_7;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+
+/*
+ * Extend
+ */
+static int op_parse_extend_code_0000_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+	if (( value & ( (1U << 4U) ) ) == ( (0U << 4U) )) 
+	{
+		optype->code_id = OpCodeId_SETF_9;
+		optype->format_id = OP_CODE_FORMAT_9;
+		return 0;
+	}
+	if (( value & ( (1U << 4U) ) ) == ( (1U << 4U) )) 
+	{
+		optype->code_id = OpCodeId_RIE_10;
+		optype->format_id = OP_CODE_FORMAT_10;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_0000_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_LDSR_9;
+		optype->format_id = OP_CODE_FORMAT_9;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_0000_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_STSR_9;
+		optype->format_id = OP_CODE_FORMAT_9;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_0000_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	return -1;
+}
+
+static int op_parse_extend_code_0001_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+	if (( value & ( (1U << 20U) ) ) == ( (1U << 20U) )) 
+	{
+		optype->code_id = OpCodeId_BINS_9;
+		optype->format_id = OP_CODE_FORMAT_9;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 17U) ) ) == ( (0U << 20U) | (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_SHR_9;
+		optype->format_id = OP_CODE_FORMAT_9;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 17U) ) ) == ( (0U << 20U) | (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_SHR_11;
+		optype->format_id = OP_CODE_FORMAT_11;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_0001_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+	if (( value & ( (1U << 20U) ) ) == ( (1U << 20U) )) 
+	{
+		optype->code_id = OpCodeId_BINS_9;
+		optype->format_id = OP_CODE_FORMAT_9;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 17U) ) ) == ( (0U << 20U) | (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_SAR_9;
+		optype->format_id = OP_CODE_FORMAT_9;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 17U) ) ) == ( (0U << 20U) | (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_SAR_11;
+		optype->format_id = OP_CODE_FORMAT_11;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_0001_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+	if (( value & ( (1U << 20U) ) ) == ( (1U << 20U) )) 
+	{
+		optype->code_id = OpCodeId_BINS_9;
+		optype->format_id = OP_CODE_FORMAT_9;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 18U) | (1U << 17U) ) ) == ( (0U << 20U) | (0U << 18U) | (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_SHL_9;
+		optype->format_id = OP_CODE_FORMAT_9;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 18U) | (1U << 17U) ) ) == ( (0U << 20U) | (0U << 18U) | (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_SHL_11;
+		optype->format_id = OP_CODE_FORMAT_11;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 18U) ) ) == ( (0U << 20U) | (1U << 18U) )) 
+	{
+		optype->code_id = OpCodeId_ROTL_7;
+		optype->format_id = OP_CODE_FORMAT_7;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_0001_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+	if (( value & ( (1U << 18U) | (1U << 17U) ) ) == ( (0U << 18U) | (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_SET1_9;
+		optype->format_id = OP_CODE_FORMAT_9;
+		return 0;
+	}
+	if (( value & ( (1U << 18U) | (1U << 17U) ) ) == ( (0U << 18U) | (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_NOT1_9;
+		optype->format_id = OP_CODE_FORMAT_9;
+		return 0;
+	}
+	if (( value & ( (1U << 18U) | (1U << 17U) ) ) == ( (1U << 18U) | (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_CLR1_9;
+		optype->format_id = OP_CODE_FORMAT_9;
+		return 0;
+	}
+	if (( value & ( (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (0U << 19U) | (1U << 18U) | (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_TST1_9;
+		optype->format_id = OP_CODE_FORMAT_9;
+		return 0;
+	}
+	if (( value & ( (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (1U << 19U) | (1U << 18U) | (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_CAXI_11;
+		optype->format_id = OP_CODE_FORMAT_11;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_0010_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_TRAP_10;
+		optype->format_id = OP_CODE_FORMAT_10;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_0010_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+	if (( value & ( (1U << 11U) ) ) == ( (0U << 11U) )) 
+	{
+		optype->code_id = OpCodeId_HALT_10;
+		optype->format_id = OP_CODE_FORMAT_10;
+		return 0;
+	}
+	if (( value & ( (1U << 11U) ) ) == ( (1U << 11U) )) 
+	{
+		optype->code_id = OpCodeId_SNOOZE_10;
+		optype->format_id = OP_CODE_FORMAT_10;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_0010_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+	if (( value & ( (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (0U << 19U) | (0U << 18U) | (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_RETI_10;
+		optype->format_id = OP_CODE_FORMAT_10;
+		return 0;
+	}
+	if (( value & ( (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (1U << 19U) | (0U << 18U) | (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_EIRET_10;
+		optype->format_id = OP_CODE_FORMAT_10;
+		return 0;
+	}
+	if (( value & ( (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (1U << 19U) | (0U << 18U) | (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_FERET_10;
+		optype->format_id = OP_CODE_FORMAT_10;
+		return 0;
+	}
+	if (( value & ( (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (0U << 19U) | (1U << 18U) | (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_CTRET_10;
+		optype->format_id = OP_CODE_FORMAT_10;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_0010_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+	if (( value & ( (1U << 15U) | (1U << 14U) | (1U << 13U) | (1U << 12U) | (1U << 11U) ) ) == ( (0U << 15U) | (0U << 14U) | (0U << 13U) | (0U << 12U) | (0U << 11U) )) 
+	{
+		optype->code_id = OpCodeId_DI_10;
+		optype->format_id = OP_CODE_FORMAT_10;
+		return 0;
+	}
+	if (( value & ( (1U << 15U) | (1U << 14U) | (1U << 13U) | (1U << 12U) | (1U << 11U) ) ) == ( (0U << 15U) | (1U << 14U) | (0U << 13U) | (0U << 12U) | (0U << 11U) )) 
+	{
+		optype->code_id = OpCodeId_PUSHSP_11;
+		optype->format_id = OP_CODE_FORMAT_11;
+		return 0;
+	}
+	if (( value & ( (1U << 15U) | (1U << 14U) | (1U << 13U) | (1U << 12U) | (1U << 11U) ) ) == ( (0U << 15U) | (1U << 14U) | (1U << 13U) | (0U << 12U) | (0U << 11U) )) 
+	{
+		optype->code_id = OpCodeId_POPSP_11;
+		optype->format_id = OP_CODE_FORMAT_11;
+		return 0;
+	}
+	if (( value & ( (1U << 15U) | (1U << 14U) | (1U << 13U) | (1U << 12U) | (1U << 11U) ) ) == ( (1U << 15U) | (0U << 14U) | (0U << 13U) | (0U << 12U) | (0U << 11U) )) 
+	{
+		optype->code_id = OpCodeId_EI_10;
+		optype->format_id = OP_CODE_FORMAT_10;
+		return 0;
+	}
+	if (( value & ( (1U << 15U) | (1U << 14U) | (1U << 13U) | (1U << 12U) | (1U << 11U) ) ) == ( (1U << 15U) | (1U << 14U) | (0U << 13U) | (1U << 12U) | (0U << 11U) )) 
+	{
+		optype->code_id = OpCodeId_SYSCALL_10;
+		optype->format_id = OP_CODE_FORMAT_10;
+		return 0;
+	}
+	if (( value & ( (1U << 15U) | (1U << 14U) | (1U << 13U) | (1U << 12U) | (1U << 11U) ) ) == ( (1U << 15U) | (1U << 14U) | (0U << 13U) | (0U << 12U) | (0U << 11U) )) 
+	{
+		optype->code_id = OpCodeId_JARL_11;
+		optype->format_id = OP_CODE_FORMAT_11;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_0011_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	return -1;
+}
+
+static int op_parse_extend_code_0011_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	return -1;
+}
+
+static int op_parse_extend_code_0011_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	return -1;
+}
+
+static int op_parse_extend_code_0011_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	return -1;
+}
+
+static int op_parse_extend_code_0100_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_SASF_9;
+		optype->format_id = OP_CODE_FORMAT_9;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_0100_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+	if (( value & ( (1U << 17U) ) ) == ( (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_MUL_11;
+		optype->format_id = OP_CODE_FORMAT_11;
+		return 0;
+	}
+	if (( value & ( (1U << 17U) ) ) == ( (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_MULU_11;
+		optype->format_id = OP_CODE_FORMAT_11;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_0100_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+	if (( value & ( (1U << 17U) ) ) == ( (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_MUL_12;
+		optype->format_id = OP_CODE_FORMAT_12;
+		return 0;
+	}
+	if (( value & ( (1U << 17U) ) ) == ( (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_MULU_12;
+		optype->format_id = OP_CODE_FORMAT_12;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_0100_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+	if (( value & ( (1U << 17U) ) ) == ( (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_MUL_12;
+		optype->format_id = OP_CODE_FORMAT_12;
+		return 0;
+	}
+	if (( value & ( (1U << 17U) ) ) == ( (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_MULU_12;
+		optype->format_id = OP_CODE_FORMAT_12;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_0101_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+	if (( value & ( (1U << 17U) ) ) == ( (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_DIVH_11;
+		optype->format_id = OP_CODE_FORMAT_11;
+		return 0;
+	}
+	if (( value & ( (1U << 17U) ) ) == ( (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_DIVHU_11;
+		optype->format_id = OP_CODE_FORMAT_11;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_0101_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	return -1;
+}
+
+static int op_parse_extend_code_0101_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+	if (( value & ( (1U << 17U) ) ) == ( (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_DIV_11;
+		optype->format_id = OP_CODE_FORMAT_11;
+		return 0;
+	}
+	if (( value & ( (1U << 17U) ) ) == ( (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_DIVU_11;
+		optype->format_id = OP_CODE_FORMAT_11;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_0101_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+	if (( value & ( (1U << 17U) ) ) == ( (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_DIVQ_11;
+		optype->format_id = OP_CODE_FORMAT_11;
+		return 0;
+	}
+	if (( value & ( (1U << 17U) ) ) == ( (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_DIVQU_11;
+		optype->format_id = OP_CODE_FORMAT_11;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_0110_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_CMOV_12;
+		optype->format_id = OP_CODE_FORMAT_12;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_0110_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_CMOV_11;
+		optype->format_id = OP_CODE_FORMAT_11;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_0110_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+	if (( value & ( (1U << 18U) | (1U << 17U) ) ) == ( (0U << 18U) | (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_BSW_12;
+		optype->format_id = OP_CODE_FORMAT_12;
+		return 0;
+	}
+	if (( value & ( (1U << 18U) | (1U << 17U) ) ) == ( (0U << 18U) | (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_BSH_12;
+		optype->format_id = OP_CODE_FORMAT_12;
+		return 0;
+	}
+	if (( value & ( (1U << 18U) | (1U << 17U) ) ) == ( (1U << 18U) | (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_HSW_12;
+		optype->format_id = OP_CODE_FORMAT_12;
+		return 0;
+	}
+	if (( value & ( (1U << 18U) | (1U << 17U) ) ) == ( (1U << 18U) | (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_HSH_12;
+		optype->format_id = OP_CODE_FORMAT_12;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_0110_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (1U << 20U) | (1U << 19U) | (0U << 18U) | (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_LDL_W_7;
+		optype->format_id = OP_CODE_FORMAT_7;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (0U << 20U) | (0U << 19U) | (0U << 18U) | (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_SCH0R_9;
+		optype->format_id = OP_CODE_FORMAT_9;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (0U << 20U) | (0U << 19U) | (0U << 18U) | (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_SCH1R_9;
+		optype->format_id = OP_CODE_FORMAT_9;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (1U << 20U) | (1U << 19U) | (0U << 18U) | (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_STC_W_7;
+		optype->format_id = OP_CODE_FORMAT_7;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (0U << 20U) | (0U << 19U) | (1U << 18U) | (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_SCH0L_9;
+		optype->format_id = OP_CODE_FORMAT_9;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (0U << 20U) | (0U << 19U) | (1U << 18U) | (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_SCH1L_9;
+		optype->format_id = OP_CODE_FORMAT_9;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_0111_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (1U << 20U) | (1U << 19U) | (0U << 18U) | (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_SATSUB_11;
+		optype->format_id = OP_CODE_FORMAT_11;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) != ( (1U << 20U) | (1U << 19U) | (0U << 18U) | (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_SBF_11;
+		optype->format_id = OP_CODE_FORMAT_11;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_0111_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (1U << 20U) | (1U << 19U) | (0U << 18U) | (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_SATADD_11;
+		optype->format_id = OP_CODE_FORMAT_11;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) != ( (1U << 20U) | (1U << 19U) | (0U << 18U) | (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_ADF_11;
+		optype->format_id = OP_CODE_FORMAT_11;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_0111_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_MAC_11;
+		optype->format_id = OP_CODE_FORMAT_11;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_0111_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_MACU_11;
+		optype->format_id = OP_CODE_FORMAT_11;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_1000_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint16 reg3 = GET_REG3(code[1]);
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+	if (( reg3 !=  0 ) && ( value & ( (1U << 20U) ) ) == ( (0U << 20U) )) 
+	{
+		optype->code_id = OpCodeId_CMOVF_S_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( reg3 !=  0 ) && ( value & ( (1U << 20U) ) ) == ( (1U << 20U) )) 
+	{
+		optype->code_id = OpCodeId_CMOVF_D_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( reg3 == 0 ) && ( value & ( (1U << 20U) ) ) == ( (0U << 20U) )) 
+	{
+		optype->code_id = OpCodeId_TRFSR_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_1000_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+	if (( value & ( (1U << 20U) ) ) == ( (0U << 20U) )) 
+	{
+		optype->code_id = OpCodeId_CMPF_S_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) ) ) == ( (1U << 20U) )) 
+	{
+		optype->code_id = OpCodeId_CMPF_D_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_1000_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (1U << 19U) | (0U << 18U) | (0U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_ABSF_S_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (1U << 19U) | (0U << 18U) | (0U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_ABSF_D_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (0U << 19U) | (1U << 18U) | (0U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (1U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CEILF_SL_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (0U << 19U) | (1U << 18U) | (0U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (1U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CEILF_DL_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (0U << 19U) | (1U << 18U) | (0U << 17U) | (1U << 4U) | (0U << 3U) | (0U << 2U) | (1U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CEILF_SUL_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (0U << 19U) | (1U << 18U) | (0U << 17U) | (1U << 4U) | (0U << 3U) | (0U << 2U) | (1U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CEILF_DUL_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (0U << 19U) | (0U << 18U) | (0U << 17U) | (1U << 4U) | (0U << 3U) | (0U << 2U) | (1U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CEILF_SUW_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (0U << 19U) | (0U << 18U) | (0U << 17U) | (1U << 4U) | (0U << 3U) | (0U << 2U) | (1U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CEILF_DUW_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (0U << 19U) | (0U << 18U) | (0U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (1U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CEILF_SW_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (0U << 19U) | (0U << 18U) | (0U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (1U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CEILF_DW_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (0U << 19U) | (0U << 18U) | (1U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (1U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CVTF_HS_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (0U << 19U) | (0U << 18U) | (1U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CVTF_LS_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (0U << 19U) | (1U << 18U) | (0U << 17U) | (0U << 4U) | (0U << 3U) | (1U << 2U) | (0U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CVTF_SL_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (0U << 19U) | (0U << 18U) | (1U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (1U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CVTF_SH_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (0U << 19U) | (1U << 18U) | (0U << 17U) | (1U << 4U) | (0U << 3U) | (1U << 2U) | (0U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CVTF_SUL_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (0U << 19U) | (0U << 18U) | (0U << 17U) | (1U << 4U) | (0U << 3U) | (1U << 2U) | (0U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CVTF_SUW_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (0U << 19U) | (0U << 18U) | (0U << 17U) | (0U << 4U) | (0U << 3U) | (1U << 2U) | (0U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CVTF_SW_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (0U << 19U) | (0U << 18U) | (1U << 17U) | (1U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CVTF_ULS_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (0U << 19U) | (0U << 18U) | (1U << 17U) | (1U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CVTF_UWS_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (0U << 19U) | (0U << 18U) | (1U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CVTF_WS_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (0U << 19U) | (0U << 18U) | (1U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CVTF_LD_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (0U << 19U) | (1U << 18U) | (0U << 17U) | (0U << 4U) | (0U << 3U) | (1U << 2U) | (0U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CVTF_DL_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (0U << 19U) | (1U << 18U) | (0U << 17U) | (1U << 4U) | (0U << 3U) | (1U << 2U) | (0U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CVTF_DUL_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (0U << 19U) | (0U << 18U) | (0U << 17U) | (1U << 4U) | (0U << 3U) | (1U << 2U) | (0U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CVTF_DUW_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (0U << 19U) | (0U << 18U) | (0U << 17U) | (0U << 4U) | (0U << 3U) | (1U << 2U) | (0U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CVTF_DW_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (0U << 19U) | (0U << 18U) | (1U << 17U) | (1U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CVTF_ULD_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (0U << 19U) | (0U << 18U) | (1U << 17U) | (1U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CVTF_UWD_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (0U << 19U) | (0U << 18U) | (1U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CVTF_WD_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (0U << 19U) | (1U << 18U) | (0U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (1U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_FLOORF_SL_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (0U << 19U) | (1U << 18U) | (0U << 17U) | (1U << 4U) | (0U << 3U) | (0U << 2U) | (1U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_FLOORF_SUL_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (0U << 19U) | (0U << 18U) | (0U << 17U) | (1U << 4U) | (0U << 3U) | (0U << 2U) | (1U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_FLOORF_SUW_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (0U << 19U) | (0U << 18U) | (0U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (1U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_FLOORF_SW_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (0U << 19U) | (1U << 18U) | (0U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (1U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_FLOORF_DL_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (0U << 19U) | (1U << 18U) | (0U << 17U) | (1U << 4U) | (0U << 3U) | (0U << 2U) | (1U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_FLOORF_DUL_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (0U << 19U) | (0U << 18U) | (0U << 17U) | (1U << 4U) | (0U << 3U) | (0U << 2U) | (1U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_FLOORF_DUW_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (0U << 19U) | (0U << 18U) | (0U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (1U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_FLOORF_DW_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (1U << 19U) | (0U << 18U) | (0U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_NEGF_S_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (1U << 19U) | (0U << 18U) | (0U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_NEGF_D_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_RECIPF_S_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_RECIPF_D_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (0U << 19U) | (1U << 18U) | (0U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_ROUNDF_SL_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (0U << 19U) | (1U << 18U) | (0U << 17U) | (1U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_ROUNDF_SUL_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (0U << 19U) | (0U << 18U) | (0U << 17U) | (1U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_ROUNDF_SUW_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (0U << 19U) | (0U << 18U) | (0U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_ROUNDF_SW_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (1U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_RSQRTF_S_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (1U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_RSQRTF_D_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_SQRTF_S_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_SQRTF_D_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (0U << 19U) | (0U << 18U) | (1U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (1U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CVTF_DS_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (0U << 19U) | (0U << 18U) | (1U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (1U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CVTF_SD_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (0U << 19U) | (1U << 18U) | (0U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_TRNCF_SL_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (0U << 19U) | (1U << 18U) | (0U << 17U) | (1U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_TRNCF_SUL_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (0U << 19U) | (0U << 18U) | (0U << 17U) | (1U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_TRNCF_SUW_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (0U << 20U) | (0U << 19U) | (0U << 18U) | (0U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_TRNCF_SW_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (0U << 19U) | (1U << 18U) | (0U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_TRNCF_DL_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (0U << 19U) | (1U << 18U) | (0U << 17U) | (1U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_TRNCF_DUL_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (0U << 19U) | (0U << 18U) | (0U << 17U) | (1U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_TRNCF_DUW_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (0U << 19U) | (0U << 18U) | (0U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (0U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_TRNCF_DW_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (0U << 19U) | (0U << 18U) | (1U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (1U << 1U) | (1U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CVTF_DS_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) | (1U << 4U) | (1U << 3U) | (1U << 2U) | (1U << 1U) | (1U << 0U) ) ) == ( (1U << 20U) | (0U << 19U) | (0U << 18U) | (1U << 17U) | (0U << 4U) | (0U << 3U) | (0U << 2U) | (1U << 1U) | (0U << 0U) )) 
+	{
+		optype->code_id = OpCodeId_CVTF_SD_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_1000_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (0U << 20U) | (0U << 19U) | (0U << 18U) | (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_ADDF_S_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (1U << 20U) | (0U << 19U) | (0U << 18U) | (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_ADDF_D_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (0U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_DIVF_S_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_DIVF_D_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (0U << 20U) | (1U << 19U) | (0U << 18U) | (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_MAXF_S_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (1U << 20U) | (1U << 19U) | (0U << 18U) | (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_MAXF_D_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (0U << 20U) | (1U << 19U) | (0U << 18U) | (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_MINF_S_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (1U << 20U) | (1U << 19U) | (0U << 18U) | (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_MINF_D_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (0U << 20U) | (0U << 19U) | (1U << 18U) | (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_MULF_S_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (0U << 20U) | (0U << 19U) | (0U << 18U) | (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_SUBF_S_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (1U << 20U) | (0U << 19U) | (0U << 18U) | (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_SUBF_D_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (1U << 20U) | (0U << 19U) | (1U << 18U) | (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_MULF_D_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (1U << 20U) | (0U << 19U) | (1U << 18U) | (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_MULF_D_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_1001_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	return -1;
+}
+
+static int op_parse_extend_code_1001_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	return -1;
+}
+
+static int op_parse_extend_code_1001_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	return -1;
+}
+
+static int op_parse_extend_code_1001_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	uint32 value = ( (((uint32)code[1]) << 16U) | ((uint32)code[0]) );
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (0U << 20U) | (0U << 19U) | (0U << 18U) | (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_FMAF_S_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (0U << 20U) | (0U << 19U) | (0U << 18U) | (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_FMSF_S_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (0U << 20U) | (0U << 19U) | (1U << 18U) | (0U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_FNMAF_S_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	if (( value & ( (1U << 20U) | (1U << 19U) | (1U << 18U) | (1U << 17U) ) ) == ( (0U << 20U) | (0U << 19U) | (1U << 18U) | (1U << 17U) )) 
+	{
+		optype->code_id = OpCodeId_FNMSF_S_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_1010_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_MADDF_S_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_1010_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_MSUBF_S_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_1010_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_NMADDF_S_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_1010_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_NMSUBF_S_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_1011_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_MADDF_S_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_1011_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_MSUBF_S_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_1011_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_NMADDF_S_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_1011_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	if (TRUE) 
+	{
+		optype->code_id = OpCodeId_NMSUBF_S_F;
+		optype->format_id = OP_CODE_FORMAT_F;
+		return 0;
+	}
+	else {
+		return -1;
+	}
+}
+
+static int op_parse_extend_code_1100_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	return -1;
+}
+
+static int op_parse_extend_code_1100_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	return -1;
+}
+
+static int op_parse_extend_code_1100_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	return -1;
+}
+
+static int op_parse_extend_code_1100_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	return -1;
+}
+
+static int op_parse_extend_code_1101_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	return -1;
+}
+
+static int op_parse_extend_code_1101_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	return -1;
+}
+
+static int op_parse_extend_code_1101_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	return -1;
+}
+
+static int op_parse_extend_code_1101_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	return -1;
+}
+
+static int op_parse_extend_code_1110_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	return -1;
+}
+
+static int op_parse_extend_code_1110_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	return -1;
+}
+
+static int op_parse_extend_code_1110_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	return -1;
+}
+
+static int op_parse_extend_code_1110_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	return -1;
+}
+
+static int op_parse_extend_code_1111_00(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	return -1;
+}
+
+static int op_parse_extend_code_1111_01(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	return -1;
+}
+
+static int op_parse_extend_code_1111_10(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	return -1;
+}
+
+static int op_parse_extend_code_1111_11(uint16 code[OP_DECODE_MAX], OperationCodeType *optype)
+{
+	return -1;
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_dec/op_parse_private.h
@@ -0,0 +1,97 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _OP_PARSE_PRIVATE_H_
+#define _OP_PARSE_PRIVATE_H_
+
+#define BIT_MASK_6_5		( (1U <<  6U) | (1U <<  5U) )
+#define BIT_MASK_22_21		( (1U << 22U) | (1U << 21U) )
+
+#define BIT_MASK_10_7		( (1U << 10U) | (1U <<  9U) | (1U <<  8U) | (1U <<  7U) )
+#define BIT_MASK_26_23		( (1U << 26U) | (1U << 25U) | (1U << 24U) | (1U << 23U) )
+
+#define BIT_MASK_10_5		( (1U << 10U) | (1U << 9U) | (1U << 8U) | (1U << 7U) | (1U << 6U) | (1U << 5U) )
+#define BIT_MASK_16			( (1U << 16U) )
+
+
+/*
+ * 31 ==> 15
+ * 30 ==> 14
+ * 29 ==> 13
+ * 28 ==> 12
+ * 27 ==> 11
+ */
+#define BIT_MASK_31_27		( (1U << 15U) | (1U << 14U) | (1U << 13U) | (1U << 12U) | (1U << 11U) )
+#define BIT_MASK_15_11		( (1U << 15U) | (1U << 14U) | (1U << 13U) | (1U << 12U) | (1U << 11U) )
+#define BIT_MASK_4_0		( (1U <<  4U) | (1U <<  3U) | (1U <<  2U) | (1U <<  1U) | (1U <<  0U) )
+
+
+
+#define BIT_UP_10_5			( (1U << 10U) | (1U << 9U) | (1U << 8U) | (1U << 7U) | (1U << 6U) | (1U << 5U) )
+#define BIT_UP_16			( (1U << 16U) )
+#define BIT_DOWN_16			( (0U << 16U) )
+
+
+#define GET_VALUE_BIT_10_7(data)	( ( (data) & BIT_MASK_10_7 ) >> 7U )
+#define GET_VALUE_BIT_26_23(data)	( ( (data) & BIT_MASK_26_23 ) >> 23U )
+
+#define GET_VALUE_BIT_6_5(data)		( ( (data) & BIT_MASK_6_5 ) >> 5U )
+#define GET_VALUE_BIT_22_21(data)	( ( (data) & BIT_MASK_22_21 ) >> 21U )
+
+#define GET_VALUE_BIT_31_27(data1)	( ( (data1) & BIT_MASK_31_27 ) >> 11U )
+#define GET_VALUE_BIT_15_11(data)	( ( (data) & BIT_MASK_15_11 ) >> 11U )
+#define GET_VALUE_BIT_4_0(data)		( ( (data) & BIT_MASK_4_0 ) >> 0U )
+
+#define GET_REG1(data)	GET_VALUE_BIT_4_0(data)
+#define GET_REG2(data)	GET_VALUE_BIT_15_11(data)
+#define GET_REG3(data1)	GET_VALUE_BIT_31_27(data1)
+
+#define OP_PARSE_CODE_TABLE_NUM		64U
+#define OP_PARSE_TABLE_INDEX(base_id, sub_id)	( ((base_id) << 2U) | (sub_id) )
+
+typedef struct {
+	int (*parse) (uint16 code[OP_DECODE_MAX], OperationCodeType *optype);
+} OpParserType;
+
+extern OpParserType op_parse_extend_code_table[OP_PARSE_CODE_TABLE_NUM];
+extern OpParserType op_parse_base_code_table[OP_PARSE_CODE_TABLE_NUM];
+
+#endif /* _OP_PARSE_PRIVATE_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_exec/op_exec.c
@@ -0,0 +1,275 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "cpu_exec/op_exec.h"
+
+OpExecType op_exec_table[OP_EXEC_TABLE_NUM] = {
+	{ 7, op_exec_absf_d_F },		/* OpCodeId_ABSF_D_F */
+	{ 7, op_exec_absf_s_F },		/* OpCodeId_ABSF_S_F */
+	{ 1, op_exec_add_1 },		/* OpCodeId_ADD_1 */
+	{ 1, op_exec_add_2 },		/* OpCodeId_ADD_2 */
+	{ 7, op_exec_addf_d_F },		/* OpCodeId_ADDF_D_F */
+	{ 7, op_exec_addf_s_F },		/* OpCodeId_ADDF_S_F */
+	{ 1, op_exec_addi_6 },		/* OpCodeId_ADDI_6 */
+	{ 1, op_exec_adf_11 },		/* OpCodeId_ADF_11 */
+	{ 1, op_exec_and_1 },		/* OpCodeId_AND_1 */
+	{ 1, op_exec_andi_6 },		/* OpCodeId_ANDI_6 */
+	{ 1, op_exec_bins_9 },		/* OpCodeId_BINS_9 */
+	{ 1, op_exec_bsh_12 },		/* OpCodeId_BSH_12 */
+	{ 1, op_exec_bsw_12 },		/* OpCodeId_BSW_12 */
+	{ 4, op_exec_bcond_3 },		/* OpCodeId_Bcond_3 */
+	{ 4, op_exec_bcond_7 },		/* OpCodeId_Bcond_7 */
+	{ 10, op_exec_callt_2 },		/* OpCodeId_CALLT_2 */
+	{ 4, op_exec_caxi_11 },		/* OpCodeId_CAXI_11 */
+	{ 7, op_exec_ceilf_dl_F },		/* OpCodeId_CEILF_DL_F */
+	{ 7, op_exec_ceilf_dul_F },		/* OpCodeId_CEILF_DUL_F */
+	{ 7, op_exec_ceilf_duw_F },		/* OpCodeId_CEILF_DUW_F */
+	{ 7, op_exec_ceilf_dw_F },		/* OpCodeId_CEILF_DW_F */
+	{ 7, op_exec_ceilf_sl_F },		/* OpCodeId_CEILF_SL_F */
+	{ 7, op_exec_ceilf_sul_F },		/* OpCodeId_CEILF_SUL_F */
+	{ 7, op_exec_ceilf_suw_F },		/* OpCodeId_CEILF_SUW_F */
+	{ 7, op_exec_ceilf_sw_F },		/* OpCodeId_CEILF_SW_F */
+	{ 4, op_exec_clr1_8 },		/* OpCodeId_CLR1_8 */
+	{ 4, op_exec_clr1_9 },		/* OpCodeId_CLR1_9 */
+	{ 1, op_exec_cmov_12 },		/* OpCodeId_CMOV_12 */
+	{ 1, op_exec_cmov_11 },		/* OpCodeId_CMOV_11 */
+	{ 7, op_exec_cmovf_d_F },		/* OpCodeId_CMOVF_D_F */
+	{ 7, op_exec_cmovf_s_F },		/* OpCodeId_CMOVF_S_F */
+	{ 1, op_exec_cmp_1 },		/* OpCodeId_CMP_1 */
+	{ 1, op_exec_cmp_2 },		/* OpCodeId_CMP_2 */
+	{ 7, op_exec_cmpf_d_F },		/* OpCodeId_CMPF_D_F */
+	{ 7, op_exec_cmpf_s_F },		/* OpCodeId_CMPF_S_F */
+	{ 7, op_exec_ctret_10 },		/* OpCodeId_CTRET_10 */
+	{ 7, op_exec_cvtf_dl_F },		/* OpCodeId_CVTF_DL_F */
+	{ 7, op_exec_cvtf_ds_F },		/* OpCodeId_CVTF_DS_F */
+	{ 7, op_exec_cvtf_dul_F },		/* OpCodeId_CVTF_DUL_F */
+	{ 7, op_exec_cvtf_duw_F },		/* OpCodeId_CVTF_DUW_F */
+	{ 7, op_exec_cvtf_dw_F },		/* OpCodeId_CVTF_DW_F */
+	{ 7, op_exec_cvtf_hs_F },		/* OpCodeId_CVTF_HS_F */
+	{ 7, op_exec_cvtf_ld_F },		/* OpCodeId_CVTF_LD_F */
+	{ 7, op_exec_cvtf_ls_F },		/* OpCodeId_CVTF_LS_F */
+	{ 7, op_exec_cvtf_sd_F },		/* OpCodeId_CVTF_SD_F */
+	{ 7, op_exec_cvtf_sh_F },		/* OpCodeId_CVTF_SH_F */
+	{ 7, op_exec_cvtf_sl_F },		/* OpCodeId_CVTF_SL_F */
+	{ 7, op_exec_cvtf_sul_F },		/* OpCodeId_CVTF_SUL_F */
+	{ 7, op_exec_cvtf_suw_F },		/* OpCodeId_CVTF_SUW_F */
+	{ 7, op_exec_cvtf_sw_F },		/* OpCodeId_CVTF_SW_F */
+	{ 7, op_exec_cvtf_uld_F },		/* OpCodeId_CVTF_ULD_F */
+	{ 7, op_exec_cvtf_uls_F },		/* OpCodeId_CVTF_ULS_F */
+	{ 7, op_exec_cvtf_uwd_F },		/* OpCodeId_CVTF_UWD_F */
+	{ 7, op_exec_cvtf_uws_F },		/* OpCodeId_CVTF_UWS_F */
+	{ 7, op_exec_cvtf_wd_F },		/* OpCodeId_CVTF_WD_F */
+	{ 7, op_exec_cvtf_ws_F },		/* OpCodeId_CVTF_WS_F */
+	{ 3, op_exec_dbtrap_1 },		/* OpCodeId_DBTRAP_1 */
+	{ 3, op_exec_di_10 },		/* OpCodeId_DI_10 */
+	{ 2, op_exec_dispose_13 },		/* OpCodeId_DISPOSE_13 */
+	{ 19, op_exec_div_11 },		/* OpCodeId_DIV_11 */
+	{ 20, op_exec_divf_d_F },		/* OpCodeId_DIVF_D_F */
+	{ 20, op_exec_divf_s_F },		/* OpCodeId_DIVF_S_F */
+	{ 36, op_exec_divh_1 },		/* OpCodeId_DIVH_1 */
+	{ 19, op_exec_divh_11 },		/* OpCodeId_DIVH_11 */
+	{ 19, op_exec_divhu_11 },		/* OpCodeId_DIVHU_11 */
+	{ 19, op_exec_divq_11 },		/* OpCodeId_DIVQ_11 */
+	{ 19, op_exec_divqu_11 },		/* OpCodeId_DIVQU_11 */
+	{ 19, op_exec_divu_11 },		/* OpCodeId_DIVU_11 */
+	{ 3, op_exec_ei_10 },		/* OpCodeId_EI_10 */
+	{ 7, op_exec_eiret_10 },		/* OpCodeId_EIRET_10 */
+	{ 7, op_exec_feret_10 },		/* OpCodeId_FERET_10 */
+	{ 7, op_exec_fetrap_1 },		/* OpCodeId_FETRAP_1 */
+	{ 7, op_exec_floorf_dl_F },		/* OpCodeId_FLOORF_DL_F */
+	{ 7, op_exec_floorf_dul_F },		/* OpCodeId_FLOORF_DUL_F */
+	{ 7, op_exec_floorf_duw_F },		/* OpCodeId_FLOORF_DUW_F */
+	{ 7, op_exec_floorf_dw_F },		/* OpCodeId_FLOORF_DW_F */
+	{ 7, op_exec_floorf_sl_F },		/* OpCodeId_FLOORF_SL_F */
+	{ 7, op_exec_floorf_sul_F },		/* OpCodeId_FLOORF_SUL_F */
+	{ 7, op_exec_floorf_suw_F },		/* OpCodeId_FLOORF_SUW_F */
+	{ 7, op_exec_floorf_sw_F },		/* OpCodeId_FLOORF_SW_F */
+	{ 7, op_exec_fmaf_s_F },		/* OpCodeId_FMAF_S_F */
+	{ 7, op_exec_fmsf_s_F },		/* OpCodeId_FMSF_S_F */
+	{ 7, op_exec_fnmaf_s_F },		/* OpCodeId_FNMAF_S_F */
+	{ 7, op_exec_fnmsf_s_F },		/* OpCodeId_FNMSF_S_F */
+	{ 1, op_exec_halt_10 },		/* OpCodeId_HALT_10 */
+	{ 1, op_exec_hsh_12 },		/* OpCodeId_HSH_12 */
+	{ 1, op_exec_hsw_12 },		/* OpCodeId_HSW_12 */
+	{ 4, op_exec_jarl_6 },		/* OpCodeId_JARL_6 */
+	{ 4, op_exec_jarl_5 },		/* OpCodeId_JARL_5 */
+	{ 3, op_exec_jarl_11 },		/* OpCodeId_JARL_11 */
+	{ 4, op_exec_jmp_1 },		/* OpCodeId_JMP_1 */
+	{ 5, op_exec_jmp_6 },		/* OpCodeId_JMP_6 */
+	{ 4, op_exec_jr_6 },		/* OpCodeId_JR_6 */
+	{ 4, op_exec_jr_5 },		/* OpCodeId_JR_5 */
+	{ 2, op_exec_ldl_w_7 },		/* OpCodeId_LDL_W_7 */
+	{ 3, op_exec_ldsr_9 },		/* OpCodeId_LDSR_9 */
+	{ 3, op_exec_ld_b_7 },		/* OpCodeId_LD_B_7 */
+	{ 3, op_exec_ld_b_14 },		/* OpCodeId_LD_B_14 */
+	{ 3, op_exec_ld_bu_7 },		/* OpCodeId_LD_BU_7 */
+	{ 3, op_exec_ld_bu_14 },		/* OpCodeId_LD_BU_14 */
+	{ 3, op_exec_ld_dw_14 },		/* OpCodeId_LD_DW_14 */
+	{ 3, op_exec_ld_h_7 },		/* OpCodeId_LD_H_7 */
+	{ 3, op_exec_ld_h_14 },		/* OpCodeId_LD_H_14 */
+	{ 3, op_exec_ld_hu_14 },		/* OpCodeId_LD_HU_14 */
+	{ 3, op_exec_ld_hu_7 },		/* OpCodeId_LD_HU_7 */
+	{ 3, op_exec_ld_w_7 },		/* OpCodeId_LD_W_7 */
+	{ 3, op_exec_ld_w_14 },		/* OpCodeId_LD_W_14 */
+	{ 4, op_exec_loop_7 },		/* OpCodeId_LOOP_7 */
+	{ 3, op_exec_mac_11 },		/* OpCodeId_MAC_11 */
+	{ 3, op_exec_macu_11 },		/* OpCodeId_MACU_11 */
+	{ 7, op_exec_maddf_s_F },		/* OpCodeId_MADDF_S_F */
+	{ 7, op_exec_maxf_d_F },		/* OpCodeId_MAXF_D_F */
+	{ 7, op_exec_maxf_s_F },		/* OpCodeId_MAXF_S_F */
+	{ 7, op_exec_minf_d_F },		/* OpCodeId_MINF_D_F */
+	{ 7, op_exec_minf_s_F },		/* OpCodeId_MINF_S_F */
+	{ 1, op_exec_mov_1 },		/* OpCodeId_MOV_1 */
+	{ 1, op_exec_mov_2 },		/* OpCodeId_MOV_2 */
+	{ 1, op_exec_mov_6 },		/* OpCodeId_MOV_6 */
+	{ 1, op_exec_movea_6 },		/* OpCodeId_MOVEA_6 */
+	{ 1, op_exec_movhi_6 },		/* OpCodeId_MOVHI_6 */
+	{ 7, op_exec_msubf_s_F },		/* OpCodeId_MSUBF_S_F */
+	{ 3, op_exec_mul_11 },		/* OpCodeId_MUL_11 */
+	{ 3, op_exec_mul_12 },		/* OpCodeId_MUL_12 */
+	{ 8, op_exec_mulf_d_F },		/* OpCodeId_MULF_D_F */
+	{ 7, op_exec_mulf_s_F },		/* OpCodeId_MULF_S_F */
+	{ 3, op_exec_mulh_1 },		/* OpCodeId_MULH_1 */
+	{ 3, op_exec_mulh_2 },		/* OpCodeId_MULH_2 */
+	{ 3, op_exec_mulhi_6 },		/* OpCodeId_MULHI_6 */
+	{ 3, op_exec_mulu_11 },		/* OpCodeId_MULU_11 */
+	{ 3, op_exec_mulu_12 },		/* OpCodeId_MULU_12 */
+	{ 7, op_exec_negf_d_F },		/* OpCodeId_NEGF_D_F */
+	{ 7, op_exec_negf_s_F },		/* OpCodeId_NEGF_S_F */
+	{ 7, op_exec_nmaddf_s_F },		/* OpCodeId_NMADDF_S_F */
+	{ 7, op_exec_nmsubf_s_F },		/* OpCodeId_NMSUBF_S_F */
+	{ 1, op_exec_nop_1 },		/* OpCodeId_NOP_1 */
+	{ 1, op_exec_not_1 },		/* OpCodeId_NOT_1 */
+	{ 4, op_exec_not1_8 },		/* OpCodeId_NOT1_8 */
+	{ 4, op_exec_not1_9 },		/* OpCodeId_NOT1_9 */
+	{ 1, op_exec_or_1 },		/* OpCodeId_OR_1 */
+	{ 1, op_exec_ori_6 },		/* OpCodeId_ORI_6 */
+	{ 2, op_exec_popsp_11 },		/* OpCodeId_POPSP_11 */
+	{ 2, op_exec_prepare_13 },		/* OpCodeId_PREPARE_13 */
+	{ 2, op_exec_pushsp_11 },		/* OpCodeId_PUSHSP_11 */
+	{ 32, op_exec_recipf_d_F },		/* OpCodeId_RECIPF_D_F */
+	{ 16, op_exec_recipf_s_F },		/* OpCodeId_RECIPF_S_F */
+	{ 7, op_exec_reti_10 },		/* OpCodeId_RETI_10 */
+	{ 7, op_exec_rie_1 },		/* OpCodeId_RIE_1 */
+	{ 7, op_exec_rie_10 },		/* OpCodeId_RIE_10 */
+	{ 1, op_exec_rotl_7 },		/* OpCodeId_ROTL_7 */
+	{ 7, op_exec_roundf_sl_F },		/* OpCodeId_ROUNDF_SL_F */
+	{ 7, op_exec_roundf_sul_F },		/* OpCodeId_ROUNDF_SUL_F */
+	{ 7, op_exec_roundf_suw_F },		/* OpCodeId_ROUNDF_SUW_F */
+	{ 7, op_exec_roundf_sw_F },		/* OpCodeId_ROUNDF_SW_F */
+	{ 42, op_exec_rsqrtf_d_F },		/* OpCodeId_RSQRTF_D_F */
+	{ 20, op_exec_rsqrtf_s_F },		/* OpCodeId_RSQRTF_S_F */
+	{ 1, op_exec_sar_2 },		/* OpCodeId_SAR_2 */
+	{ 1, op_exec_sar_9 },		/* OpCodeId_SAR_9 */
+	{ 1, op_exec_sar_11 },		/* OpCodeId_SAR_11 */
+	{ 1, op_exec_sasf_9 },		/* OpCodeId_SASF_9 */
+	{ 1, op_exec_satadd_1 },		/* OpCodeId_SATADD_1 */
+	{ 1, op_exec_satadd_2 },		/* OpCodeId_SATADD_2 */
+	{ 1, op_exec_satadd_11 },		/* OpCodeId_SATADD_11 */
+	{ 1, op_exec_satsub_1 },		/* OpCodeId_SATSUB_1 */
+	{ 1, op_exec_satsub_11 },		/* OpCodeId_SATSUB_11 */
+	{ 1, op_exec_satsubi_6 },		/* OpCodeId_SATSUBI_6 */
+	{ 1, op_exec_satsubr_1 },		/* OpCodeId_SATSUBR_1 */
+	{ 1, op_exec_sbf_11 },		/* OpCodeId_SBF_11 */
+	{ 1, op_exec_sch0l_9 },		/* OpCodeId_SCH0L_9 */
+	{ 1, op_exec_sch0r_9 },		/* OpCodeId_SCH0R_9 */
+	{ 1, op_exec_sch1l_9 },		/* OpCodeId_SCH1L_9 */
+	{ 1, op_exec_sch1r_9 },		/* OpCodeId_SCH1R_9 */
+	{ 4, op_exec_set1_8 },		/* OpCodeId_SET1_8 */
+	{ 4, op_exec_set1_9 },		/* OpCodeId_SET1_9 */
+	{ 1, op_exec_setf_9 },		/* OpCodeId_SETF_9 */
+	{ 1, op_exec_shl_2 },		/* OpCodeId_SHL_2 */
+	{ 1, op_exec_shl_9 },		/* OpCodeId_SHL_9 */
+	{ 1, op_exec_shl_11 },		/* OpCodeId_SHL_11 */
+	{ 1, op_exec_shr_2 },		/* OpCodeId_SHR_2 */
+	{ 1, op_exec_shr_9 },		/* OpCodeId_SHR_9 */
+	{ 1, op_exec_shr_11 },		/* OpCodeId_SHR_11 */
+	{ 3, op_exec_sld_b_4 },		/* OpCodeId_SLD_B_4 */
+	{ 3, op_exec_sld_bu_4 },		/* OpCodeId_SLD_BU_4 */
+	{ 3, op_exec_sld_h_4 },		/* OpCodeId_SLD_H_4 */
+	{ 3, op_exec_sld_hu_4 },		/* OpCodeId_SLD_HU_4 */
+	{ 3, op_exec_sld_w_4 },		/* OpCodeId_SLD_W_4 */
+	{ 10, op_exec_snooze_10 },		/* OpCodeId_SNOOZE_10 */
+	{ 36, op_exec_sqrtf_d_F },		/* OpCodeId_SQRTF_D_F */
+	{ 20, op_exec_sqrtf_s_F },		/* OpCodeId_SQRTF_S_F */
+	{ 1, op_exec_sst_b_4 },		/* OpCodeId_SST_B_4 */
+	{ 1, op_exec_sst_h_4 },		/* OpCodeId_SST_H_4 */
+	{ 1, op_exec_sst_w_4 },		/* OpCodeId_SST_W_4 */
+	{ 2, op_exec_stc_w_7 },		/* OpCodeId_STC_W_7 */
+	{ 1, op_exec_stsr_9 },		/* OpCodeId_STSR_9 */
+	{ 1, op_exec_st_b_7 },		/* OpCodeId_ST_B_7 */
+	{ 1, op_exec_st_b_14 },		/* OpCodeId_ST_B_14 */
+	{ 1, op_exec_st_dw_14 },		/* OpCodeId_ST_DW_14 */
+	{ 1, op_exec_st_h_7 },		/* OpCodeId_ST_H_7 */
+	{ 1, op_exec_st_h_14 },		/* OpCodeId_ST_H_14 */
+	{ 1, op_exec_st_w_7 },		/* OpCodeId_ST_W_7 */
+	{ 1, op_exec_st_w_14 },		/* OpCodeId_ST_W_14 */
+	{ 1, op_exec_sub_1 },		/* OpCodeId_SUB_1 */
+	{ 7, op_exec_subf_d_F },		/* OpCodeId_SUBF_D_F */
+	{ 7, op_exec_subf_s_F },		/* OpCodeId_SUBF_S_F */
+	{ 1, op_exec_subr_1 },		/* OpCodeId_SUBR_1 */
+	{ 8, op_exec_switch_1 },		/* OpCodeId_SWITCH_1 */
+	{ 1, op_exec_sxb_1 },		/* OpCodeId_SXB_1 */
+	{ 1, op_exec_sxh_1 },		/* OpCodeId_SXH_1 */
+	{ 10, op_exec_synce_1 },		/* OpCodeId_SYNCE_1 */
+	{ 10, op_exec_synci_1 },		/* OpCodeId_SYNCI_1 */
+	{ 10, op_exec_syncm_1 },		/* OpCodeId_SYNCM_1 */
+	{ 10, op_exec_syncp_1 },		/* OpCodeId_SYNCP_1 */
+	{ 10, op_exec_syscall_10 },		/* OpCodeId_SYSCALL_10 */
+	{ 7, op_exec_trap_10 },		/* OpCodeId_TRAP_10 */
+	{ 1, op_exec_trfsr_F },		/* OpCodeId_TRFSR_F */
+	{ 7, op_exec_trncf_dl_F },		/* OpCodeId_TRNCF_DL_F */
+	{ 7, op_exec_trncf_dul_F },		/* OpCodeId_TRNCF_DUL_F */
+	{ 7, op_exec_trncf_duw_F },		/* OpCodeId_TRNCF_DUW_F */
+	{ 7, op_exec_trncf_dw_F },		/* OpCodeId_TRNCF_DW_F */
+	{ 7, op_exec_trncf_sl_F },		/* OpCodeId_TRNCF_SL_F */
+	{ 7, op_exec_trncf_sul_F },		/* OpCodeId_TRNCF_SUL_F */
+	{ 7, op_exec_trncf_suw_F },		/* OpCodeId_TRNCF_SUW_F */
+	{ 7, op_exec_trncf_sw_F },		/* OpCodeId_TRNCF_SW_F */
+	{ 1, op_exec_tst_1 },		/* OpCodeId_TST_1 */
+	{ 4, op_exec_tst1_8 },		/* OpCodeId_TST1_8 */
+	{ 4, op_exec_tst1_9 },		/* OpCodeId_TST1_9 */
+	{ 1, op_exec_xor_1 },		/* OpCodeId_XOR_1 */
+	{ 1, op_exec_xori_6 },		/* OpCodeId_XORI_6 */
+	{ 1, op_exec_zxb_1 },		/* OpCodeId_ZXB_1 */
+	{ 1, op_exec_zxh_1 },		/* OpCodeId_ZXH_1 */
+};
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_exec/op_exec.h
@@ -0,0 +1,257 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _OP_EXEC_H_
+#define _OP_EXEC_H_
+
+#include "target_cpu.h"
+#include "cpu_dec/op_codeid.h"
+#include "cpu_common/cpu_ops.h"
+#include "cpu_exec/op_exec_ops.h"
+
+#define OP_EXEC_TABLE_NUM		OpCodeId_Num
+
+typedef struct {
+	int clocks;
+	int (*exec) (TargetCoreType *cpu);
+} OpExecType;
+
+extern OpExecType op_exec_table[OP_EXEC_TABLE_NUM];
+
+//#define op_exec_add_1 op_exec_add_1
+//#define op_exec_add_2 op_exec_add_2
+#define op_exec_addi_6 op_exec_addi
+#define op_exec_adf_11 op_exec_adf_11
+#define op_exec_and_1 op_exec_and
+#define op_exec_andi_6 op_exec_andi
+#define op_exec_bins_9 op_exec_bins_9
+#define op_exec_bsh_12 op_exec_bsh_12
+#define op_exec_bsw_12 op_exec_bsw_12
+#define op_exec_bcond_3 op_exec_bcond_3
+#define op_exec_bcond_7 op_exec_bcond_7
+#define op_exec_callt_2 NULL /* not supported */
+#define op_exec_caxi_11 op_exec_caxi
+//#define op_exec_clr1_8 op_exec_clr1_8
+//#define op_exec_clr1_9 op_exec_clr1_9
+//#define op_exec_cmov_12 op_exec_cmov_12
+//#define op_exec_cmov_11 op_exec_cmov_11
+//#define op_exec_cmp_1 op_exec_cmp_1
+//#define op_exec_cmp_2 op_exec_cmp_2
+#define op_exec_ctret_10 NULL /* not supported */
+#define op_exec_dbtrap_1 NULL /* not supported */
+#define op_exec_di_10 op_exec_diei
+#define op_exec_dispose_13 op_exec_dispose
+#define op_exec_div_11 op_exec_div
+//#define op_exec_divh_1 op_exec_divh_1
+//#define op_exec_divh_11 op_exec_divh_11
+#define op_exec_divhu_11 op_exec_divhu
+#define op_exec_divq_11 op_exec_div
+#define op_exec_divqu_11 op_exec_divqu_11
+#define op_exec_divu_11 op_exec_divu
+#define op_exec_ei_10 op_exec_diei
+#define op_exec_eiret_10 op_exec_eiret_10
+#define op_exec_feret_10 op_exec_feret_10
+#define op_exec_fetrap_1 op_exec_fetrap_1
+#define op_exec_halt_10 op_exec_halt
+#define op_exec_hsh_12 op_exec_hsh_12
+#define op_exec_hsw_12 op_exec_hsw_12
+#define op_exec_jarl_6 op_exec_jarl_6
+#define op_exec_jarl_5 op_exec_jr
+#define op_exec_jarl_11 op_exec_jarl_11
+#define op_exec_jmp_1 op_exec_jmp
+#define op_exec_jmp_6 op_exec_jmp_6
+#define op_exec_jr_6 op_exec_jr_6
+#define op_exec_jr_5 op_exec_jr
+#define op_exec_ldl_w_7 op_exec_ldhw
+#define op_exec_ldsr_9 op_exec_ldsr
+#define op_exec_ld_b_7 op_exec_ldb
+#define op_exec_ld_b_14 op_exec_ld_b_14
+#define op_exec_ld_bu_7 op_exec_ldbu
+#define op_exec_ld_bu_14 op_exec_ld_bu_14
+#define op_exec_ld_dw_14 op_exec_ld_dw_14
+#define op_exec_ld_h_7 op_exec_ldhw
+#define op_exec_ld_h_14 op_exec_ld_h_14
+#define op_exec_ld_hu_14 op_exec_ld_hu_14
+#define op_exec_ld_hu_7 op_exec_ldhu
+#define op_exec_ld_w_7 op_exec_ldhw
+#define op_exec_ld_w_14 op_exec_ld_w_14
+#define op_exec_loop_7 op_exec_loop_7
+#define op_exec_mac_11 op_exec_mac_11
+#define op_exec_macu_11 op_exec_macu_11
+//#define op_exec_mov_1 op_exec_mov_1
+//#define op_exec_mov_2 op_exec_mov_2
+//#define op_exec_mov_6 op_exec_mov_6
+#define op_exec_movea_6 op_exec_movea
+#define op_exec_movhi_6 op_exec_movhi
+#define op_exec_mul_11 op_exec_mul
+//#define op_exec_mul_12 op_exec_mul_12
+//#define op_exec_mulh_1 op_exec_mulh_1
+//#define op_exec_mulh_2 op_exec_mulh_2
+#define op_exec_mulhi_6 op_exec_mulhi
+#define op_exec_mulu_11 op_exec_mulu
+//#define op_exec_mulu_12 op_exec_mulu_12
+#define op_exec_nop_1 op_exec_nop
+#define op_exec_not_1 op_exec_not
+//#define op_exec_not1_8 op_exec_not1_8
+//#define op_exec_not1_9 op_exec_not1_9
+#define op_exec_or_1 op_exec_or
+#define op_exec_ori_6 op_exec_ori
+#define op_exec_popsp_11 op_exec_popsp_11
+#define op_exec_prepare_13 op_exec_prepare
+#define op_exec_pushsp_11 op_exec_pushsp_11
+#define op_exec_reti_10 op_exec_reti
+#define op_exec_rie_1 NULL /* TODO */
+#define op_exec_rie_10 NULL /* TODO */
+#define op_exec_rotl_7 op_exec_rotl_7
+//#define op_exec_sar_2 op_exec_sar_2
+//#define op_exec_sar_9 op_exec_sar_9
+#define op_exec_sar_11 op_exec_sar_11
+#define op_exec_sasf_9 op_exec_sasf_9
+//#define op_exec_satadd_1 op_exec_satadd_1
+//#define op_exec_satadd_2 op_exec_satadd_2
+#define op_exec_satadd_11 op_exec_satadd_11
+//#define op_exec_satsub_1 op_exec_satsub_1
+#define op_exec_satsub_11 op_exec_satsub_11
+#define op_exec_satsubi_6 op_exec_satsubi
+#define op_exec_satsubr_1 op_exec_satsubr_1
+#define op_exec_sbf_11 op_exec_sbf_11
+#define op_exec_sch0l_9 op_exec_sch0l_9
+#define op_exec_sch0r_9 op_exec_sch0r_9
+#define op_exec_sch1l_9 op_exec_sch1l_9
+#define op_exec_sch1r_9 op_exec_sch1r_9
+//#define op_exec_set1_8 op_exec_set1_8
+//#define op_exec_set1_9 op_exec_set1_9
+#define op_exec_setf_9 op_exec_setf
+//#define op_exec_shl_2 op_exec_shl_2
+//#define op_exec_shl_9 op_exec_shl_9
+#define op_exec_shl_11 op_exec_shl_11
+//#define op_exec_shr_2 op_exec_shr_2
+//#define op_exec_shr_9 op_exec_shr_9
+#define op_exec_shr_11 op_exec_shr_11
+#define op_exec_sld_b_4 op_exec_sldb
+#define op_exec_sld_bu_4 op_exec_sldbu
+#define op_exec_sld_h_4 op_exec_sldh
+#define op_exec_sld_hu_4 op_exec_sldhu
+#define op_exec_sld_w_4 op_exec_sldw
+#define op_exec_snooze_10 NULL /* not supported */
+#define op_exec_sst_b_4 op_exec_sstb
+#define op_exec_sst_h_4 op_exec_ssth
+#define op_exec_sst_w_4 op_exec_sstw
+#define op_exec_stc_w_7 op_exec_st_w_7
+#define op_exec_stsr_9 op_exec_stsr
+#define op_exec_st_b_7 op_exec_stb
+#define op_exec_st_b_14 op_exec_st_b_14
+#define op_exec_st_dw_14 op_exec_st_dw_14
+#define op_exec_st_h_7 op_exec_sthw
+#define op_exec_st_h_14 op_exec_st_h_14
+#define op_exec_st_w_7 op_exec_sthw
+#define op_exec_st_w_14 op_exec_st_w_14
+#define op_exec_sub_1 op_exec_sub
+#define op_exec_subr_1 op_exec_subr
+#define op_exec_switch_1 op_exec_switch
+#define op_exec_sxb_1 op_exec_sxb
+#define op_exec_sxh_1 op_exec_sxh
+#define op_exec_synce_1 op_exec_synce_1
+#define op_exec_synci_1 op_exec_synci_1
+#define op_exec_syncm_1 op_exec_syncm_1
+#define op_exec_syncp_1 op_exec_syncp_1
+#define op_exec_syscall_10 op_exec_syscall_10
+#define op_exec_trap_10 op_exec_trap
+#define op_exec_tst_1 op_exec_tst
+//#define op_exec_tst1_8 op_exec_tst1_8
+//#define op_exec_tst1_9 op_exec_tst1_9
+#define op_exec_xor_1 op_exec_xor
+#define op_exec_xori_6 op_exec_xori
+#define op_exec_zxb_1 op_exec_zxb
+#define op_exec_zxh_1 op_exec_zxh
+
+
+#define op_exec_addf_s_F	op_exec_addf_s_F
+#define op_exec_absf_s_F	op_exec_absf_s_F
+#define op_exec_ceilf_sl_F	NULL /* not supported */
+#define op_exec_ceilf_sul_F	NULL /* not supported */
+#define op_exec_ceilf_suw_F	NULL /* not supported */
+#define op_exec_ceilf_sw_F	NULL /* not supported */
+#define op_exec_cmovf_s_F	op_exec_cmovf_s_F
+#define op_exec_cmpf_s_F	op_exec_cmpf_s_F
+#define op_exec_cvtf_hs_F	NULL /* not supported */
+#define op_exec_cvtf_ls_F	op_exec_cvtf_ls_F
+#define op_exec_cvtf_sh_F	NULL /* not supported */
+#define op_exec_cvtf_sl_F	NULL /* not supported */
+#define op_exec_cvtf_sul_F	NULL /* not supported */
+#define op_exec_cvtf_suw_F	op_exec_cvtf_suw_F
+#define op_exec_cvtf_sw_F	op_exec_cvtf_sw_F
+#define op_exec_cvtf_uls_F	op_exec_cvtf_uls_F
+#define op_exec_cvtf_uws_F	op_exec_cvtf_uws_F
+#define op_exec_cvtf_ws_F	op_exec_cvtf_ws_F
+#define op_exec_divf_s_F	op_exec_divf_s_F
+#define op_exec_floorf_sl_F	NULL /* not supported */
+#define op_exec_floorf_sul_F	NULL /* not supported */
+#define op_exec_floorf_suw_F	NULL /* not supported */
+#define op_exec_floorf_sw_F	NULL /* not supported */
+#define op_exec_fmaf_s_F	op_exec_fmaf_s_F
+#define op_exec_fmsf_s_F	op_exec_fmsf_s_F
+#define op_exec_fnmaf_s_F	op_exec_fnmaf_s_F
+#define op_exec_fnmsf_s_F	op_exec_fnmsf_s_F
+#define op_exec_maxf_s_F	op_exec_maxf_s_F
+#define op_exec_minf_s_F	op_exec_minf_s_F
+#define op_exec_mulf_s_F	op_exec_mulf_s_F
+#define op_exec_negf_s_F	op_exec_negf_s_F
+#define op_exec_recipf_s_F	NULL /* not supported */
+#define op_exec_roundf_sl_F	NULL /* not supported */
+#define op_exec_roundf_sul_F	NULL /* not supported */
+#define op_exec_roundf_suw_F	NULL /* not supported */
+#define op_exec_roundf_sw_F	NULL /* not supported */
+#define op_exec_rsqrtf_s_F	NULL /* not supported */
+#define op_exec_sqrtf_s_F	NULL /* not supported */
+#define op_exec_subf_s_F	op_exec_subf_s_F
+#define op_exec_trfsr_F		op_exec_trfsr_F
+#define op_exec_trncf_sl_F	NULL /* not supported */
+#define op_exec_trncf_sul_F	NULL /* not supported */
+#define op_exec_trncf_suw_F	op_exec_trncf_suw_F
+#define op_exec_trncf_sw_F	op_exec_trncf_sw_F
+
+#define op_exec_mulf_d_F op_exec_mulf_d_F
+#define op_exec_cvtf_ds_F op_exec_cvtf_ds_F
+#define op_exec_cvtf_sd_F op_exec_cvtf_sd_F
+
+
+#endif /* _OP_EXEC_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_exec/op_exec_arithm.c
@@ -0,0 +1,1527 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "cpu_exec/op_exec_ops.h"
+#include "bus.h"
+#include <stdio.h> //TODO
+
+/*
+ * [符号なし加減算]
+ * 加算の場合 A+B=D
+ *  ⇒D<AまたはD<Bのときキャリー発生
+ * 減算の場合 A-B=D
+ *  ⇒A<Bの場合ボロー発生
+ *
+ *  オーバーフローフラグ(OF) ： 同符号どうしの加算結果が異符合
+ *  CF = ( A & B ) | ( A & CY) | ( B & CY )
+ *　　where A=オペランド1のMSB, B=オペランド2のMSB, CY=MSBへの桁上がり
+ *
+ *　　オーバーフローフラグの意味は、元の演算数と被演算数及び演算結果を符号付き２進数と考
+ *  えた時、結果がｎビットの符号付き２進数で表現できる範囲を超えているという意味である。
+ *
+ *  キャリーフラグ(CF) ： MSBからの桁上がり
+ *  OF = ( A & B & (~C) ) | ( (~A) & (~B) & C )
+ *  where A=オペランド1のMSB, B=オペランド2のMSB, C=加算結果のMSB
+ *
+ *  元の演算数と被演算数を符号無し２進数と考え、結果も符合無し２進数として捉える場合、もしキ
+　*  ャリーフラグが１になっていたら、それは「桁溢れ」または「上の桁からの借り」が発生し、結果のｎビッ
+　*  トだけで数学的な結果が表せていないことを意味する。
+ */
+
+/*
+ *  元の演算数と被演算数を符号無し２進数と考え、結果も符合無し２進数として捉える場合、もしキ
+　*  ャリーフラグが１になっていたら、それは「桁溢れ」または「上の桁からの借り」が発生し、結果のｎビッ
+　*  トだけで数学的な結果が表せていないことを意味する。
+ */
+int op_chk_and_set_carry(CpuRegisterType *cpu, uint32 a32, uint32 b32)
+{
+	uint64 tmp1 = a32;
+	uint64 tmp2 = b32;
+	uint64 result = tmp1 + tmp2;
+
+	if (result > CPU_REG_UINT_MAX) {
+		//printf("SET_CY:a32=%llx b32=%llx result=%llx\n", tmp1, tmp2, result);
+		CPU_SET_CY(cpu);
+	}
+	else {
+		//printf("CLR_CY:a32=%llx b32=%llx result=%llx\n", tmp1, tmp2, result);
+		CPU_CLR_CY(cpu);
+	}
+	return 0;
+}
+int op_chk_and_set_carry3(CpuRegisterType *cpu, uint32 a32, uint32 b32, uint32 c32)
+{
+	uint64 tmp1 = a32;
+	uint64 tmp2 = b32;
+	uint64 tmp3 = c32;
+	uint64 result = tmp1 + tmp2 + tmp3;
+
+	if (result > CPU_REG_UINT_MAX) {
+		//printf("SET_CY:a32=%llx b32=%llx result=%llx\n", tmp1, tmp2, result);
+		CPU_SET_CY(cpu);
+	}
+	else {
+		//printf("CLR_CY:a32=%llx b32=%llx result=%llx\n", tmp1, tmp2, result);
+		CPU_CLR_CY(cpu);
+	}
+	return 0;
+}
+
+int op_chk_and_set_borrow(CpuRegisterType *cpu, uint32 a32, uint32 b32)
+{
+	uint64 tmp1 = a32;
+	uint64 tmp2 = b32;
+	uint64 result = tmp1 - tmp2;
+
+	if (result & 0x100000000ULL) {
+		//printf("SET_CY:a32=%llx b32=%llx result=%llx\n", tmp1, tmp2, result);
+		CPU_SET_CY(cpu);
+	}
+	else {
+		//printf("CLR_CY:a32=%llx b32=%llx result=%llx\n", tmp1, tmp2, result);
+		CPU_CLR_CY(cpu);
+	}
+	return 0;
+}
+
+int op_chk_and_set_borrow3(CpuRegisterType *cpu, uint32 a32, uint32 b32, uint32 c32)
+{
+	uint64 tmp1 = a32;
+	uint64 tmp2 = b32;
+	uint64 tmp3 = c32;
+	uint64 result = tmp1 - tmp2 - tmp3;
+
+	if (result & 0x100000000ULL) {
+		//printf("SET_CY:a32=%llx b32=%llx result=%llx\n", tmp1, tmp2, result);
+		CPU_SET_CY(cpu);
+	}
+	else {
+		//printf("CLR_CY:a32=%llx b32=%llx result=%llx\n", tmp1, tmp2, result);
+		CPU_CLR_CY(cpu);
+	}
+	return 0;
+}
+
+/*
+ *　　オーバーフローフラグの意味は、元の演算数と被演算数及び演算結果を符号付き２進数と考
+ *  えた時、結果がｎビットの符号付き２進数で表現できる範囲を超えているという意味である。
+ */
+int op_chk_and_set_overflow(CpuRegisterType *cpu, sint64 a64, sint64 b64)
+{
+	sint64 result = a64 + b64;
+
+	if (result > (sint64)CPU_REG_PLUS_MAX) {
+		CPU_SET_OV(cpu);
+	}
+	else if (result < (sint64)CPU_REG_MINUS_MAX) {
+		CPU_SET_OV(cpu);
+	}
+	else {
+		CPU_CLR_OV(cpu);
+	}
+	return 0;
+}
+int op_chk_and_set_overflow3(CpuRegisterType *cpu, sint64 a64, sint64 b64, sint64 c64)
+{
+	sint64 result = a64 + b64 + c64;
+
+	if (result > (sint64)CPU_REG_PLUS_MAX) {
+		CPU_SET_OV(cpu);
+	}
+	else if (result < (sint64)CPU_REG_MINUS_MAX) {
+		CPU_SET_OV(cpu);
+	}
+	else {
+		CPU_CLR_OV(cpu);
+	}
+	return 0;
+}
+
+int op_chk_and_set_zero(CpuRegisterType *cpu, sint32 result)
+{
+	if (result == 0) {
+		CPU_SET_Z(cpu);
+	}
+	else {
+		CPU_CLR_Z(cpu);
+	}
+	return 0;
+}
+int op_chk_and_set_sign(CpuRegisterType *cpu, sint32 result)
+{
+	if (result < 0) {
+		CPU_SET_S(cpu);
+	}
+	else {
+		CPU_CLR_S(cpu);
+	}
+	return 0;
+}
+
+/*
+ * Format1
+ */
+int op_exec_sub(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type1.reg1;
+	uint32 reg2 = cpu->decoded_code->type1.reg2;
+	sint32 reg1_data;
+	sint32 reg2_data;
+	sint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data = cpu->reg.r[reg2];
+	reg1_data = cpu->reg.r[reg1];
+	result = reg2_data - reg1_data;
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SUB r%d(%d),r%d(%d):%d\n", cpu->reg.pc, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], result));
+	cpu->reg.r[reg2] = result;
+
+
+	op_chk_and_set_borrow(&cpu->reg, reg2_data, reg1_data);
+	op_chk_and_set_overflow(&cpu->reg, reg2_data, -reg1_data);
+	op_chk_and_set_zero(&cpu->reg, result);
+	op_chk_and_set_sign(&cpu->reg, result);
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+
+int op_exec_subr(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type1.reg1;
+	uint32 reg2 = cpu->decoded_code->type1.reg2;
+	sint32 reg1_data;
+	sint32 reg2_data;
+	sint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data = cpu->reg.r[reg2];
+	reg1_data = cpu->reg.r[reg1];
+	result = reg1_data - reg2_data;
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SUBR r%d(%d),r%d(%d):%d\n", cpu->reg.pc, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], result));
+	cpu->reg.r[reg2] = result;
+
+	op_chk_and_set_borrow(&cpu->reg, reg1_data, reg2_data);
+	op_chk_and_set_overflow(&cpu->reg, reg1_data, -reg2_data);
+	op_chk_and_set_zero(&cpu->reg, result);
+	op_chk_and_set_sign(&cpu->reg, result);
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+int op_exec_cmp_1(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type1.reg1;
+	uint32 reg2 = cpu->decoded_code->type1.reg2;
+	sint32 reg1_data;
+	sint32 reg2_data;
+	sint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data = cpu->reg.r[reg2];
+	reg1_data = cpu->reg.r[reg1];
+	result = reg2_data - reg1_data;
+
+	op_chk_and_set_borrow(&cpu->reg, reg2_data, reg1_data);
+	op_chk_and_set_overflow(&cpu->reg, reg2_data, -reg1_data);
+	op_chk_and_set_zero(&cpu->reg, result);
+	op_chk_and_set_sign(&cpu->reg, result);
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CMP r%d(%d),r%d(%d):%d:psw=0x%x\n", cpu->reg.pc, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], result, sys_get_cpu_base(&cpu->reg)->r[SYS_REG_PSW]));
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+
+int op_exec_add_1(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type1.reg1;
+	uint32 reg2 = cpu->decoded_code->type1.reg2;
+	sint32 reg1_data;
+	sint32 reg2_data;
+	sint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data = cpu->reg.r[reg2];
+	reg1_data = cpu->reg.r[reg1];
+	result = reg2_data + reg1_data;
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: ADD r%d(%d),r%d(%d):%d\n", cpu->reg.pc, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], result));
+
+	cpu->reg.r[reg2] = result;
+
+	op_chk_and_set_carry(&cpu->reg, reg2_data, reg1_data);
+	op_chk_and_set_overflow(&cpu->reg, reg2_data, reg1_data);
+	op_chk_and_set_zero(&cpu->reg, result);
+	op_chk_and_set_sign(&cpu->reg, result);
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+int op_exec_mov_1(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type1.reg1;
+	uint32 reg2 = cpu->decoded_code->type1.reg2;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: MOV r%d(%d),r%d(%d)\n", cpu->reg.pc, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2]));
+
+	cpu->reg.r[reg2] = cpu->reg.r[reg1];
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+int op_exec_mulh_1(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type1.reg1;
+	uint32 reg2 = cpu->decoded_code->type1.reg2;
+	sint16 tmp1;
+	sint16 tmp2;
+	sint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	tmp1 = (sint16)cpu->reg.r[reg1];
+	tmp2 = (sint16)cpu->reg.r[reg2];
+
+	result = (sint32)tmp1 * (sint32)tmp2;
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: MULH r%d(%d),r%d(%d):%d\n", cpu->reg.pc, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], result));
+
+	cpu->reg.r[reg2] = result;
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+
+int op_exec_divh_1(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type1.reg1;
+	uint32 reg2 = cpu->decoded_code->type1.reg2;
+	sint32 reg1_data = cpu->reg.r[reg1];
+	sint32 reg2_data = cpu->reg.r[reg2];
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	/*
+	 * GR [reg2] ← GR [reg2] ÷ GR [reg1]
+	 */
+	if (reg1_data == 0U) {
+		CPU_SET_OV(&cpu->reg);
+	}
+	else {
+		CPU_CLR_OV(&cpu->reg);
+		cpu->reg.r[reg2] = ( (sint32)reg2_data / ((sint32)((sint16)reg1_data)) );
+	}
+
+	/*
+	 * Z 演算結果が0のとき1，そうでないとき0
+	 */
+	op_chk_and_set_zero(&cpu->reg, (sint32)cpu->reg.r[reg2]);
+	/*
+	 * S 演算結果が負のとき1，そうでないとき0
+	 */
+	op_chk_and_set_sign(&cpu->reg, (sint32)cpu->reg.r[reg2]);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: DIVH r%d(%d) r%d(%d):r%d(0x%x))\n",
+			cpu->reg.pc,
+			reg1, reg1_data,
+			reg2, reg2_data,
+			reg2, cpu->reg.r[reg2]));
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+
+/*
+ * Format2
+ */
+int op_exec_cmp_2(TargetCoreType *cpu)
+{
+	uint32 reg2 = cpu->decoded_code->type2.reg2;
+	sint32 imm_data;
+	sint32 reg2_data;
+	sint32 result;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data = cpu->reg.r[reg2];
+	imm_data = OP_FORMAT2_IMM_SIGN_EXTEND(cpu->decoded_code->type2.imm);
+	result = reg2_data - imm_data;
+
+	op_chk_and_set_borrow(&cpu->reg, reg2_data, imm_data);
+	op_chk_and_set_overflow(&cpu->reg, reg2_data, -imm_data);
+	op_chk_and_set_zero(&cpu->reg, result);
+	op_chk_and_set_sign(&cpu->reg, result);
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CMP imm5(%d),r%d(%d):%d:psw=0x%x\n", cpu->reg.pc, imm_data, reg2, cpu->reg.r[reg2], result, sys_get_cpu_base(&cpu->reg)->r[SYS_REG_PSW]));
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+int op_exec_add_2(TargetCoreType *cpu)
+{
+	uint32 reg2 = cpu->decoded_code->type2.reg2;
+	sint32 imm_data;
+	sint32 reg2_data;
+	sint32 result;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data = cpu->reg.r[reg2];
+	imm_data = OP_FORMAT2_IMM_SIGN_EXTEND(cpu->decoded_code->type2.imm);
+	result = reg2_data + imm_data;
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: ADD imm5(%d),r%d(%d):%d\n", cpu->reg.pc, imm_data, reg2, cpu->reg.r[reg2], result));
+
+	cpu->reg.r[reg2] = result;
+	op_chk_and_set_carry(&cpu->reg, reg2_data, imm_data);
+	op_chk_and_set_overflow(&cpu->reg, reg2_data, imm_data);
+	op_chk_and_set_zero(&cpu->reg, result);
+	op_chk_and_set_sign(&cpu->reg, result);
+
+	cpu->reg.pc += 2;
+
+	return 0;
+}
+int op_exec_mov_2(TargetCoreType *cpu)
+{
+	uint32 reg2 = cpu->decoded_code->type2.reg2;
+	sint32 imm_data;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	imm_data = OP_FORMAT2_IMM_SIGN_EXTEND(cpu->decoded_code->type2.imm);
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: MOV imm5(%d),r%d(%d)\n", cpu->reg.pc, imm_data, reg2, cpu->reg.r[reg2]));
+	cpu->reg.r[reg2] = imm_data;
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+int op_exec_mulh_2(TargetCoreType *cpu)
+{
+	uint32 reg2 = cpu->decoded_code->type2.reg2;
+	sint32 imm_data;
+	sint16 tmp2;
+	sint32 result;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	imm_data = OP_FORMAT2_IMM_SIGN_EXTEND(cpu->decoded_code->type2.imm);
+	tmp2 = (sint16)cpu->reg.r[reg2];
+	result = imm_data * ((sint32)tmp2);
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: MULH imm5(%d),r%d(%d):%d\n", cpu->reg.pc, imm_data, reg2, cpu->reg.r[reg2], result));
+
+	cpu->reg.r[reg2] = result;
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+
+/*
+ * Format6
+ */
+int op_exec_addi(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type6.reg1;
+	uint32 reg2 = cpu->decoded_code->type6.reg2;
+	sint32 imm_data = op_sign_extend(15, cpu->decoded_code->type6.imm);
+	sint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	result = op_addi(&cpu->reg, imm_data, cpu->reg.r[reg1]);
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: ADDI imm5(%d),r%d(%d) r%d(%d):%d\n", cpu->reg.pc, imm_data, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], result));
+
+	cpu->reg.r[reg2] = result;
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+int op_exec_movea(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type6.reg1;
+	uint32 reg2 = cpu->decoded_code->type6.reg2;
+	sint32 imm_data = op_sign_extend(15, cpu->decoded_code->type6.imm);
+	sint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	result = op_movea(&cpu->reg, imm_data, cpu->reg.r[reg1]);
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: MOVEA imm16(%d),r%d(%d) r%d(%d):%d\n", cpu->reg.pc, imm_data, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], result));
+	cpu->reg.r[reg2] = result;
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+int op_exec_mov_6(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type6.reg1;
+	uint32 imm_high_addr;
+	uint16 imm_high16;
+	uint32 imm_high;
+	uint32 imm_data = cpu->decoded_code->type6.imm;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	imm_high_addr = cpu->reg.pc + 4U;
+
+	err = bus_get_data16(cpu->core_id, imm_high_addr, &imm_high16);
+	if (err != STD_E_OK) {
+		printf("ERROR:MOV pc=0x%x reg1=%u(0x%x) addr=0x%x\n", cpu->reg.pc, reg1, cpu->reg.r[reg1], imm_high_addr);
+		return -1;
+	}
+
+	imm_high = (uint32)(imm_high16);
+
+	imm_data |= (imm_high << 16U);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: MOV imm32(%d),r%d(%d):%d\n", cpu->reg.pc, imm_data, reg1, cpu->reg.r[reg1], imm_data));
+	cpu->reg.r[reg1] = imm_data;
+
+	cpu->reg.pc += 6;
+	return 0;
+}
+
+
+int op_exec_movhi(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type6.reg1;
+	uint32 reg2 = cpu->decoded_code->type6.reg2;
+	sint32 imm_data = op_sign_extend(15, cpu->decoded_code->type6.imm);
+	sint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	result = op_movhi(&cpu->reg, imm_data, cpu->reg.r[reg1]);
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: MOVHI imm16(%d),r%d(%d) r%d(%d):%d\n", cpu->reg.pc, imm_data, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], result));
+
+	cpu->reg.r[reg2] = result;
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+
+int op_exec_mulhi(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type6.reg1;
+	uint32 reg2 = cpu->decoded_code->type6.reg2;
+	sint32 imm_data = op_sign_extend(15, cpu->decoded_code->type6.imm);
+	sint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	result = op_mulhi(&cpu->reg, imm_data, cpu->reg.r[reg1]);
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: MULHI imm16(%d),r%d(%d) r%d(%d):%d\n", cpu->reg.pc, imm_data, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], result));
+
+	cpu->reg.r[reg2] = result;
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+
+/*
+ * Format9
+ */
+static int setf_chk_cond(TargetCoreType *cpu, uint16 cond)
+{
+	int ret = FALSE;
+	uint16 flg_s = CPU_ISSET_S(&cpu->reg);
+	uint16 flg_ov = CPU_ISSET_OV(&cpu->reg);
+	uint16 flg_z = CPU_ISSET_Z(&cpu->reg);
+	uint16 flg_cy = CPU_ISSET_CY(&cpu->reg);
+	uint16 flg_sat = CPU_ISSET_SAT(&cpu->reg);
+
+	switch (cond) {
+	case 0b0000: //V
+		if (flg_ov == TRUE) {
+			ret = TRUE;
+		}
+		break;
+	case 0b0001: //C/L
+		if (flg_cy == TRUE) {
+			ret = TRUE;
+		}
+		break;
+	case 0b0010: //Z
+		if (flg_z == TRUE) {
+			ret = TRUE;
+		}
+		break;
+	case 0b0011: //NH
+		if ((flg_cy | flg_z) == TRUE) {
+			ret = TRUE;
+		}
+		break;
+	case 0b0100: //S/N
+		if ((flg_s) == TRUE) {
+			ret = TRUE;
+		}
+		break;
+	case 0b0101: //T
+		ret = TRUE;
+		break;
+	case 0b0110: //LT
+		if ((flg_s ^ flg_ov) == TRUE) {
+			ret = TRUE;
+		}
+		break;
+	case 0b0111: //LE
+		if (((flg_s ^ flg_ov) | flg_z) == TRUE) {
+			ret = TRUE;
+		}
+		break;
+	case 0b1000: //NV
+		if (flg_ov == FALSE) {
+			ret = TRUE;
+		}
+		break;
+	case 0b1001: //NC/NL
+		if (flg_cy == FALSE) {
+			ret = TRUE;
+		}
+		break;
+	case 0b1010: //NZ
+		if (flg_z == FALSE) {
+			ret = TRUE;
+		}
+		break;
+	case 0b1011: //H
+		if ((flg_cy | flg_z) == FALSE) {
+			ret = TRUE;
+		}
+		break;
+	case 0b1100: //NS/P
+		if ((flg_s) == FALSE) {
+			ret = TRUE;
+		}
+		break;
+	case 0b1101: //SA
+		if ((flg_sat) == FALSE) {
+			ret = TRUE;
+		}
+		break;
+	case 0b1110: //GE
+		if ((flg_s ^ flg_ov) == FALSE) {
+			ret = TRUE;
+		}
+		break;
+	case 0b1111: //GT
+		if (((flg_s ^ flg_ov) | flg_z) == FALSE) {
+			ret = TRUE;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+int op_exec_setf(TargetCoreType *cpu)
+{
+	uint32 reg2 = cpu->decoded_code->type9.reg2;
+	uint16 cond = cpu->decoded_code->type9.gen;
+	sint32 result;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	if (setf_chk_cond(cpu, cond) == TRUE) {
+		result = 1;
+	}
+	else {
+		result = 0;
+	}
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SETF cond(0x%x),r%d(%d):%d\n", cpu->reg.pc, cond, reg2, cpu->reg.r[reg2], result));
+
+	cpu->reg.r[reg2] = result;
+
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+int op_exec_sasf_9(TargetCoreType *cpu)
+{
+	uint32 reg2 = cpu->decoded_code->type9.reg2;
+	uint16 cond = cpu->decoded_code->type9.gen;
+	sint32 result;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	result = cpu->reg.r[reg2] << 1U;
+	if (op_exec_cond(cpu, cond) == TRUE) {
+		result |= 1;
+	}
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SASF cond(0x%x),r%d(%d):%d\n",
+			cpu->reg.pc, cond, reg2, cpu->reg.r[reg2], result));
+
+	cpu->reg.r[reg2] = result;
+
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+/*
+ * Format 11
+ */
+int op_exec_divu(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type11.reg1;
+	uint32 reg2 = cpu->decoded_code->type11.reg2;
+	uint32 reg3 = cpu->decoded_code->type11.reg3;
+	uint32 reg1_data = cpu->reg.r[reg1];
+	uint32 reg2_data = cpu->reg.r[reg2];
+	uint32 reg3_data = cpu->reg.r[reg3];
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	/*
+	 * GR [reg2] ← GR [reg2] ÷ GR [reg1]
+	 */
+	if (reg1_data == 0U) {
+		CPU_SET_OV(&cpu->reg);
+	}
+	else {
+		CPU_CLR_OV(&cpu->reg);
+		cpu->reg.r[reg2] = reg2_data / reg1_data;
+		/*
+		 * GR [reg3] ← GR [reg2] % GR [reg1]
+		 */
+		cpu->reg.r[reg3] = reg2_data % reg1_data;
+	}
+
+	/*
+	 * Z 演算結果が0のとき1，そうでないとき0
+	 */
+	op_chk_and_set_zero(&cpu->reg, (sint32)cpu->reg.r[reg2]);
+	/*
+	 * S 演算結果が負のとき1，そうでないとき0
+	 */
+	op_chk_and_set_sign(&cpu->reg, (sint32)cpu->reg.r[reg2]);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: DIVU r%d(%d) r%d(%d) r%d(%d):r%d(0x%x), r%d(0x%x)\n",
+			cpu->reg.pc,
+			reg1, reg1_data,
+			reg2, reg2_data,
+			reg3, reg3_data,
+			reg2, cpu->reg.r[reg2],
+			reg3, cpu->reg.r[reg3]));
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+int op_exec_divhu(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type11.reg1;
+	uint32 reg2 = cpu->decoded_code->type11.reg2;
+	uint32 reg3 = cpu->decoded_code->type11.reg3;
+	uint32 reg1_data = cpu->reg.r[reg1];
+	uint32 reg2_data = cpu->reg.r[reg2];
+	uint32 reg3_data = cpu->reg.r[reg3];
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	/*
+	 * GR [reg2] ← GR [reg2] ÷ GR [reg1]
+	 */
+	if (reg1_data == 0U) {
+		CPU_SET_OV(&cpu->reg);
+	}
+	else {
+		CPU_CLR_OV(&cpu->reg);
+		cpu->reg.r[reg2] = ( (uint32)reg2_data / ((uint32)((uint16)reg1_data)) );
+		/*
+		 * GR [reg3] ← GR [reg2] % GR [reg1]
+		 */
+		cpu->reg.r[reg3] = ( (uint32)reg2_data % ((uint32)((uint16)reg1_data)) );
+	}
+
+	/*
+	 * Z 演算結果が0のとき1，そうでないとき0
+	 */
+	op_chk_and_set_zero(&cpu->reg, (sint32)cpu->reg.r[reg2]);
+	/*
+	 * S 演算結果が負のとき1，そうでないとき0
+	 */
+	op_chk_and_set_sign(&cpu->reg, (sint32)cpu->reg.r[reg2]);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: DIVHU r%d(%d) r%d(%d) r%d(%d):r%d(0x%x), r%d(0x%x)\n",
+			cpu->reg.pc,
+			reg1, reg1_data,
+			reg2, reg2_data,
+			reg3, reg3_data,
+			reg2, cpu->reg.r[reg2],
+			reg3, cpu->reg.r[reg3]));
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+int op_exec_divqu_11(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type11.reg1;
+	uint32 reg2 = cpu->decoded_code->type11.reg2;
+	uint32 reg3 = cpu->decoded_code->type11.reg3;
+	uint32 reg1_data = cpu->reg.r[reg1];
+	uint32 reg2_data = cpu->reg.r[reg2];
+	uint32 reg3_data = cpu->reg.r[reg3];
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	/*
+	 * GR [reg2] ← GR [reg2] ÷ GR [reg1]
+	 */
+	if (reg1_data == 0U) {
+		CPU_SET_OV(&cpu->reg);
+	}
+	else {
+		CPU_CLR_OV(&cpu->reg);
+		cpu->reg.r[reg2] = ( (uint32)reg2_data / ((uint32)(reg1_data)) );
+		/*
+		 * GR [reg3] ← GR [reg2] % GR [reg1]
+		 */
+		cpu->reg.r[reg3] = ( (uint32)reg2_data % ((uint32)(reg1_data)) );
+	}
+
+	/*
+	 * Z 演算結果が0のとき1，そうでないとき0
+	 */
+	op_chk_and_set_zero(&cpu->reg, (sint32)cpu->reg.r[reg2]);
+	/*
+	 * S 演算結果が負のとき1，そうでないとき0
+	 */
+	op_chk_and_set_sign(&cpu->reg, (sint32)cpu->reg.r[reg2]);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: DIVQU r%d(%d) r%d(%d) r%d(%d):r%d(0x%x), r%d(0x%x)\n",
+			cpu->reg.pc,
+			reg1, reg1_data,
+			reg2, reg2_data,
+			reg3, reg3_data,
+			reg2, cpu->reg.r[reg2],
+			reg3, cpu->reg.r[reg3]));
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+
+int op_exec_divh_11(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type11.reg1;
+	uint32 reg2 = cpu->decoded_code->type11.reg2;
+	uint32 reg3 = cpu->decoded_code->type11.reg3;
+	sint32 reg1_data = cpu->reg.r[reg1];
+	sint32 reg2_data = cpu->reg.r[reg2];
+	sint32 reg3_data = cpu->reg.r[reg3];
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	/*
+	 * GR [reg2] ← GR [reg2] ÷ GR [reg1]
+	 */
+	if (reg1_data == 0U) {
+		CPU_SET_OV(&cpu->reg);
+	}
+	else {
+		CPU_CLR_OV(&cpu->reg);
+		cpu->reg.r[reg2] = ( (sint32)reg2_data / ((sint32)((sint16)reg1_data)) );
+		/*
+		 * GR [reg3] ← GR [reg2] % GR [reg1]
+		 */
+		cpu->reg.r[reg3] = ( (sint32)reg2_data % ((sint32)((sint16)reg1_data)) );
+	}
+
+	/*
+	 * Z 演算結果が0のとき1，そうでないとき0
+	 */
+	op_chk_and_set_zero(&cpu->reg, (sint32)cpu->reg.r[reg2]);
+	/*
+	 * S 演算結果が負のとき1，そうでないとき0
+	 */
+	op_chk_and_set_sign(&cpu->reg, (sint32)cpu->reg.r[reg2]);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: DIVH r%d(%d) r%d(%d) r%d(%d):r%d(0x%x), r%d(0x%x)\n",
+			cpu->reg.pc,
+			reg1, reg1_data,
+			reg2, reg2_data,
+			reg3, reg3_data,
+			reg2, cpu->reg.r[reg2],
+			reg3, cpu->reg.r[reg3]));
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+static int op_exec_div_common(TargetCoreType *cpu, bool isq)
+{
+	uint32 reg1 = cpu->decoded_code->type11.reg1;
+	uint32 reg2 = cpu->decoded_code->type11.reg2;
+	uint32 reg3 = cpu->decoded_code->type11.reg3;
+	sint32 reg1_data = cpu->reg.r[reg1];
+	sint32 reg2_data = cpu->reg.r[reg2];
+	sint32 reg3_data = cpu->reg.r[reg3];
+	char *opname;
+
+	if (isq == TRUE) {
+		opname = "DIVQ";
+	}
+	else {
+		opname = "DIV";
+	}
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	/*
+	 * GR [reg2] ← GR [reg2] ÷ GR [reg1]
+	 */
+	if (reg1_data == 0U) {
+		CPU_SET_OV(&cpu->reg);
+	}
+	else {
+		/*
+		 * オーバフローは負の最大値（ 80000000H）を−1で割ったとき
+		 */
+		if ((reg1_data == -1) && (reg2_data == 0x80000000)) {
+			CPU_SET_OV(&cpu->reg);
+		}
+		else {
+			CPU_CLR_OV(&cpu->reg);
+		}
+		cpu->reg.r[reg2] = reg2_data / reg1_data;
+		/*
+		 * GR [reg3] ← GR [reg2] % GR [reg1]
+		 */
+		cpu->reg.r[reg3] = reg2_data % reg1_data;
+	}
+
+	/*
+	 * Z 演算結果が0のとき1，そうでないとき0
+	 */
+	op_chk_and_set_zero(&cpu->reg, (sint32)cpu->reg.r[reg2]);
+	/*
+	 * S 演算結果が負のとき1，そうでないとき0
+	 */
+	op_chk_and_set_sign(&cpu->reg, (sint32)cpu->reg.r[reg2]);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: %s r%d(%d) r%d(%d) r%d(%d):r%d(0x%x), r%d(0x%x)\n",
+			cpu->reg.pc,
+			opname,
+			reg1, reg1_data,
+			reg2, reg2_data,
+			reg3, reg3_data,
+			reg2, cpu->reg.r[reg2],
+			reg3, cpu->reg.r[reg3]));
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+int op_exec_div(TargetCoreType *cpu)
+{
+	int ret;
+	ret = op_exec_div_common(cpu, FALSE);
+	return ret;
+}
+int op_exec_divq(TargetCoreType *cpu)
+{
+	int ret;
+	ret = op_exec_div_common(cpu, TRUE);
+	return ret;
+}
+int op_exec_mul(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type11.reg1;
+	uint32 reg2 = cpu->decoded_code->type11.reg2;
+	uint32 reg3 = cpu->decoded_code->type11.reg3;
+	sint64 reg1_data = cpu->reg.r[reg1];
+	sint64 reg2_data = cpu->reg.r[reg2];
+	sint64 reg3_data = cpu->reg.r[reg3];
+	sint64 result;
+	uint64 result_u;
+
+	//printf("0x%x:op_exec_divu:reg2_data(%u)=0x%x reg3_data(%u)=0x%x\n", cpu->cpu.pc, reg2, reg2_data, reg3, reg3_data);
+	//fflush(stdout);
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	result = reg1_data * reg2_data;
+	result_u = result;
+	cpu->reg.r[reg2] = (uint32)result_u;
+	cpu->reg.r[reg3] = (uint32)(result_u >> 32U);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(),
+			"0x%x: MUL r%d(%d) r%d(%d) r%d(%d):r%d(0x%x), r%d(0x%x)\n",
+			cpu->reg.pc,
+			reg1, (uint32)reg1_data,
+			reg2, (uint32)reg2_data,
+			reg3, (uint32)reg3_data,
+			reg2, cpu->reg.r[reg2],
+			reg3, cpu->reg.r[reg3]));
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+
+int op_exec_mulu(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type11.reg1;
+	uint32 reg2 = cpu->decoded_code->type11.reg2;
+	uint32 reg3 = cpu->decoded_code->type11.reg3;
+	uint64 reg1_data = cpu->reg.r[reg1];
+	uint64 reg2_data = cpu->reg.r[reg2];
+	uint64 reg3_data = cpu->reg.r[reg3];
+	uint64 result;
+	uint64 result_u;
+
+	//printf("0x%x:op_exec_divu:reg2_data(%u)=0x%x reg3_data(%u)=0x%x\n", cpu->cpu.pc, reg2, reg2_data, reg3, reg3_data);
+	//fflush(stdout);
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	result = reg1_data * reg2_data;
+	result_u = result;
+	cpu->reg.r[reg2] = (uint32)result_u;
+	cpu->reg.r[reg3] = (uint32)(result_u >> 32U);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(),
+			"0x%x: MULU r%d(%d) r%d(%d) r%d(%d):r%d(0x%x), r%d(0x%x)\n",
+			cpu->reg.pc,
+			reg1, (uint32)reg1_data,
+			reg2, (uint32)reg2_data,
+			reg3, (uint32)reg3_data,
+			reg2, cpu->reg.r[reg2],
+			reg3, cpu->reg.r[reg3]));
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+
+int op_exec_cmov_11(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type11.reg1;
+	uint32 reg2 = cpu->decoded_code->type11.reg2;
+	uint32 reg3 = cpu->decoded_code->type11.reg3;
+	uint32 reg1_data = cpu->reg.r[reg1];
+	uint32 reg2_data = cpu->reg.r[reg2];
+	uint32 reg3_data = cpu->reg.r[reg3];
+	uint16 cond = ( (cpu->decoded_code->type11.rfu << 1U) | (cpu->decoded_code->type11.sub2) );
+
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	/*
+	 * if conditions are satisfied
+	 * then GR [reg3] ← GR [reg1]
+	 * else GR [reg3] ← GR [reg2]
+	 */
+	if (setf_chk_cond(cpu, cond) == TRUE) {
+		cpu->reg.r[reg3] = cpu->reg.r[reg1];
+	}
+	else {
+		cpu->reg.r[reg3] = cpu->reg.r[reg2];
+	}
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(),
+			"0x%x: CMOV cond(0x%x) r%d(%d) r%d(%d) r%d(%d):r%d(0x%x)\n",
+			cpu->reg.pc,
+			cond,
+			reg1, reg1_data,
+			reg2, reg2_data,
+			reg3, reg3_data,
+			reg3, cpu->reg.r[reg3]));
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+
+/*
+ * Format 12
+ */
+int op_exec_mulu_12(TargetCoreType *cpu)
+{
+	uint64 imm9;
+	uint32 imm9_low;
+	uint32 imm9_high;
+	uint32 reg2 = cpu->decoded_code->type12.reg2;
+	uint32 reg3 = cpu->decoded_code->type12.reg3;
+	uint64 reg2_data;
+	uint64 result;
+	uint32 result_low;
+	uint32 result_high;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	imm9_low = cpu->decoded_code->type12.imml;
+	imm9_high = (cpu->decoded_code->type12.immh & 0xF);
+	imm9 = (imm9_high << 5U) | imm9_low;
+
+	reg2_data = cpu->reg.r[reg2];
+
+	result = reg2_data * imm9;
+
+	result_low = (uint32)result;
+	result_high = (uint32)(result >> 32U);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: MULU imm9(0x%x),r%d(%d) r%d(%d):0x%x, 0x%x\n", cpu->reg.pc, (uint32)imm9,
+			reg2, cpu->reg.r[reg2],
+			reg3, cpu->reg.r[reg3], result_high, result_low));
+
+	cpu->reg.r[reg2] = result_low;
+	cpu->reg.r[reg3] = result_high;
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+int op_exec_mul_12(TargetCoreType *cpu)
+{
+	sint64 imm9;
+	uint32 imm9_32bit;
+	uint32 imm9_low;
+	uint32 imm9_high;
+	sint32 reg2 = cpu->decoded_code->type12.reg2;
+	sint32 reg3 = cpu->decoded_code->type12.reg3;
+	sint64 reg2_data;
+	sint64 result;
+	sint32 result_low;
+	sint32 result_high;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	imm9_low = cpu->decoded_code->type12.imml;
+	imm9_high = (cpu->decoded_code->type12.immh & 0xF);
+	imm9_32bit = (imm9_high << 5U) | imm9_low;
+	imm9 = (sint64)op_sign_extend(8, imm9_32bit);
+
+	reg2_data = cpu->reg.r[reg2];
+
+	result = reg2_data * imm9;
+
+	result_low = (sint32)result;
+	result_high = (sint32)(result >> 32U);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: MUL imm9(0x%x),r%d(%d) r%d(%d):0x%x, 0x%x\n", cpu->reg.pc, (sint32)imm9,
+			reg2, cpu->reg.r[reg2],
+			reg3, cpu->reg.r[reg3], result_high, result_low));
+
+	cpu->reg.r[reg2] = result_low;
+	cpu->reg.r[reg3] = result_high;
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+
+int op_exec_cmov_12(TargetCoreType *cpu)
+{
+	sint32 imm_data = op_sign_extend(4, cpu->decoded_code->type12.imml);
+	uint32 reg2 = cpu->decoded_code->type12.reg2;
+	uint32 reg3 = cpu->decoded_code->type12.reg3;
+	uint32 reg2_data = cpu->reg.r[reg2];
+	uint32 reg3_data = cpu->reg.r[reg3];
+	uint16 cond = ( ((cpu->decoded_code->type12.immh &  0x07) << 1U) | (cpu->decoded_code->type12.sub2) );
+
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	/*
+	 * if conditions are satisfied
+	 * then GR [reg3] ← sign-extended (imm5)
+	 * else GR [reg3] ← GR [reg2]
+	 */
+	if (setf_chk_cond(cpu, cond) == TRUE) {
+		cpu->reg.r[reg3] = imm_data;
+	}
+	else {
+		cpu->reg.r[reg3] = cpu->reg.r[reg2];
+	}
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(),
+			"0x%x: CMOV cond(0x%x) imm5(%d) r%d(%d) r%d(%d):r%d(0x%x)\n",
+			cpu->reg.pc,
+			cond,
+			imm_data,
+			reg2, reg2_data,
+			reg3, reg3_data,
+			reg3, cpu->reg.r[reg3]));
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+
+
+/*
+ * Format11
+ */
+int op_exec_adf_11(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type11.reg1;
+	uint32 reg2 = cpu->decoded_code->type11.reg2;
+	uint32 reg3 = cpu->decoded_code->type11.reg3;
+	sint32 reg1_data;
+	sint32 reg2_data;
+	sint32 add_data = 0;
+	sint32 result;
+	uint16 cond =
+			  ((cpu->decoded_code->type11.rfu) << 1U)
+			| (cpu->decoded_code->type11.sub2);
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	reg1_data = cpu->reg.r[reg1];
+	reg2_data = cpu->reg.r[reg2];
+	if (op_exec_cond(cpu, cond) == TRUE) {
+		add_data = 1;
+	}
+	else {
+		add_data = 0;
+	}
+	result = reg2_data + reg1_data + add_data;
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: ADF cond=0x%x, r%d(%d),r%d(%d),r%d(%d):%d\n",
+			cpu->reg.pc,
+			cond,
+			reg1, cpu->reg.r[reg1],
+			reg2, cpu->reg.r[reg2],
+			reg3, cpu->reg.r[reg3],
+			result));
+
+	cpu->reg.r[reg3] = result;
+
+	op_chk_and_set_carry3(&cpu->reg, reg2_data, reg1_data, add_data);
+	op_chk_and_set_overflow3(&cpu->reg, reg2_data, reg1_data, add_data);
+	op_chk_and_set_zero(&cpu->reg, result);
+	op_chk_and_set_sign(&cpu->reg, result);
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+int op_exec_sbf_11(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type11.reg1;
+	uint32 reg2 = cpu->decoded_code->type11.reg2;
+	uint32 reg3 = cpu->decoded_code->type11.reg3;
+	sint32 reg1_data;
+	sint32 reg2_data;
+	sint32 add_data = 0;
+	sint32 result;
+	uint16 cond =
+			  ((cpu->decoded_code->type11.rfu) << 1U)
+			| (cpu->decoded_code->type11.sub2);
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (op_exec_cond(cpu, cond) == TRUE) {
+		add_data = 1;
+	}
+	else {
+		add_data = 0;
+	}
+
+	reg2_data = cpu->reg.r[reg2];
+	reg1_data = cpu->reg.r[reg1];
+	result = reg2_data - reg1_data - add_data;
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SBF cond=0x%x, r%d(%d),r%d(%d),r%d(%d):%d\n",
+			cpu->reg.pc,
+			cond,
+			reg1, cpu->reg.r[reg1],
+			reg2, cpu->reg.r[reg2],
+			reg3, cpu->reg.r[reg3],
+			result));
+
+	cpu->reg.r[reg3] = result;
+
+
+	op_chk_and_set_borrow3(&cpu->reg, reg2_data, reg1_data, add_data);
+	op_chk_and_set_overflow3(&cpu->reg, reg2_data, -reg1_data, -add_data);
+	op_chk_and_set_zero(&cpu->reg, result);
+	op_chk_and_set_sign(&cpu->reg, result);
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+
+int op_exec_mac_11(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type11.reg1;
+	uint32 reg2 = cpu->decoded_code->type11.reg2;
+	uint32 reg3 = cpu->decoded_code->type11.reg3;
+	uint32 reg4 = (cpu->decoded_code->type11.rfu << 1U) | cpu->decoded_code->type11.sub2;
+	uint32 reg3plus1 = reg3 + 1;
+	uint32 reg4plus1 = reg4 + 1;
+	sint64 reg1_data = cpu->reg.r[reg1];
+	sint64 reg2_data = cpu->reg.r[reg2];
+	sint64 reg3plus1_data = cpu->reg.r[reg3plus1];
+	sint64 reg3_data  = cpu->reg.r[reg3];
+	sint64 result1;
+	sint64 result2;
+	sint64 result;
+	sint32 *result_data;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg4 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if ((reg3 % 2) != 0) {
+		return -1;
+	}
+	if ((reg4 % 2) != 0) {
+		return -1;
+	}
+	result1 = reg2_data * reg1_data;
+	result2 = (reg3plus1_data << 32U) | reg3_data;
+
+	result = result1 + result2;
+	result_data = (sint32*)&result;
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: MAC r%d(%d),r%d(%d),r%d(%d),r%d(%d):%d, %d\n",
+			cpu->reg.pc,
+			reg1, cpu->reg.r[reg1],
+			reg2, cpu->reg.r[reg2],
+			reg3, cpu->reg.r[reg3],
+			reg4, cpu->reg.r[reg4],
+			result_data[0], result_data[1]));
+
+	cpu->reg.r[reg4] = result_data[0];
+	cpu->reg.r[reg4plus1] = result_data[1];
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+
+int op_exec_macu_11(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type11.reg1;
+	uint32 reg2 = cpu->decoded_code->type11.reg2;
+	uint32 reg3 = cpu->decoded_code->type11.reg3;
+	uint32 reg4 = (cpu->decoded_code->type11.rfu << 1U) | cpu->decoded_code->type11.sub2;
+	uint32 reg3plus1 = reg3 + 1;
+	uint32 reg4plus1 = reg4 + 1;
+	sint64 reg1_data = cpu->reg.r[reg1];
+	sint64 reg2_data = cpu->reg.r[reg2];
+	sint64 reg3plus1_data = cpu->reg.r[reg3plus1];
+	sint64 reg3_data  = cpu->reg.r[reg3];
+	uint64 result1;
+	uint64 result2;
+	uint64 result;
+	uint32 *result_data;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg4 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if ((reg3 % 2) != 0) {
+		return -1;
+	}
+	if ((reg4 % 2) != 0) {
+		return -1;
+	}
+	result1 = reg2_data * reg1_data;
+	result2 = (reg3plus1_data << 32U) | reg3_data;
+
+	result = result1 + result2;
+	result_data = (uint32*)&result;
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: MAC r%d(%u),r%d(%u),r%d(%u),r%d(%u):%u, %u\n",
+			cpu->reg.pc,
+			reg1, cpu->reg.r[reg1],
+			reg2, cpu->reg.r[reg2],
+			reg3, cpu->reg.r[reg3],
+			reg4, cpu->reg.r[reg4],
+			result_data[0], result_data[1]));
+
+	cpu->reg.r[reg4] = result_data[0];
+	cpu->reg.r[reg4plus1] = result_data[1];
+
+	cpu->reg.pc += 4;
+	return 0;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_exec/op_exec_arithm_rh850.c
@@ -0,0 +1,167 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "cpu_exec/op_exec_ops.h"
+#include "bus.h"
+#include <stdio.h> //TODO
+
+
+/*
+ * Format9
+ */
+int op_exec_bins_9(TargetCoreType *cpu)
+{
+	uint32 chk = cpu->decoded_code->type9.sub;
+	uint32 reg1 = cpu->decoded_code->type9.gen;
+	uint32 reg2 = cpu->decoded_code->type9.reg2;
+	uint32 msb = (cpu->decoded_code->type9.rfu2 >> 1U);
+	uint32 lsb = ((cpu->decoded_code->type9.rfu2 & 0x01) << 3U) | (cpu->decoded_code->type9.rfu1 & 0x07);
+	uint32 i;
+	uint32 reg2_data = cpu->reg.r[reg2];
+
+
+	switch (chk) {
+	case 0b100:
+		//(msb ≥ 16, lsb ≥ 16)
+		msb += 16;
+		lsb += 16;
+		break;
+	case 0b101:
+		//(msb ≥ 16, lsb < 16)
+		msb += 16;
+		break;
+	case 0b110:
+		//(msb < 16, lsb < 16)
+		break;
+	default:
+		break;
+	}
+
+	for (i = lsb; i <= msb; i++) {
+		if (cpu->reg.r[reg1] & (1U << i)) {
+			reg2_data |= (1U << i);
+		}
+		else {
+			reg2_data &= ~(1U << i);
+		}
+	}
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: BINS r%d(0x%x), msb(%u), lsb(%u), r%d(0x%x):0x%x\n",
+			cpu->reg.pc,
+			reg1, cpu->reg.r[reg1],
+			msb, lsb,
+			reg2, cpu->reg.r[reg2],
+			reg2_data));
+
+	cpu->reg.r[reg2] = reg2_data;
+
+	CPU_CLR_OV(&cpu->reg);
+	op_chk_and_set_sign(&cpu->reg, cpu->reg.r[reg2]);
+	op_chk_and_set_zero(&cpu->reg, cpu->reg.r[reg2]);
+
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+
+
+/*
+ * Format7
+ */
+int op_exec_rotl_7(TargetCoreType *cpu)
+{
+	uint32 reg2 = cpu->decoded_code->type7.reg2;
+	uint32 reg3 = ( (cpu->decoded_code->type7.disp >> 10U) & 0x1F );
+	uint32 chk = (cpu->decoded_code->type7.disp & 0x03FF);
+	uint32 rotate_size = 0;
+	uint32 reg2_data;
+	uint32 i;
+
+	reg2_data = cpu->reg.r[reg2];
+	switch (chk) {
+	case 0b0001100010:
+		//1）ROTL imm5, reg2, reg3
+		rotate_size = op_zero_extend(5, cpu->decoded_code->type7.reg1);
+		for (i = 0; i < rotate_size; i++) {
+			reg2_data <<= 1U;
+			if (cpu->reg.r[reg2] & (1U << (31U - i))) {
+				reg2_data |= 0x01;
+			}
+		}
+		DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: ROTL imm5(%u) r%d(0x%x), r%d(0x%x):0x%x\n",
+				cpu->reg.pc,
+				rotate_size, reg2, reg2_data, reg3, cpu->reg.r[reg3],
+				reg2_data));
+		break;
+	case 0b0001100011:
+		//2）ROTL reg1,reg2,reg3
+		rotate_size = cpu->reg.r[cpu->decoded_code->type7.reg1];
+		for (i = 0; i < rotate_size; i++) {
+			reg2_data <<= 1U;
+			if (cpu->reg.r[reg2] & (1U << (31U - i))) {
+				reg2_data |= 0x01;
+			}
+		}
+		DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: ROTL r%d(%u), r%d(0x%x), r%d(0x%x):0x%x\n",
+				cpu->reg.pc,
+				cpu->decoded_code->type7.reg1, rotate_size, reg2, reg2_data, reg3, cpu->reg.r[reg3],
+				reg2_data));
+		break;
+	default:
+		break;
+	}
+
+	cpu->reg.r[reg3] = reg2_data;
+
+	if ((rotate_size > 0) && ((cpu->reg.r[reg3] & 0x01) == 0x01)) {
+		CPU_SET_CY(&cpu->reg);
+	}
+	else {
+		CPU_CLR_CY(&cpu->reg);
+	}
+	CPU_CLR_OV(&cpu->reg);
+	op_chk_and_set_sign(&cpu->reg, cpu->reg.r[reg3]);
+	op_chk_and_set_zero(&cpu->reg, cpu->reg.r[reg3]);
+
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_exec/op_exec_bit.c
@@ -0,0 +1,512 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "../cpu_exec/op_exec_ops.h"
+#include "cpu.h"
+#include "bus.h"
+
+
+/*
+ * Format8
+ */
+int op_exec_tst1_8(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type8.reg1;
+	sint32 disp16 = cpu->decoded_code->type8.disp;
+	sint32 bit3 = cpu->decoded_code->type8.bit;
+	uint32 addr;
+	uint8 bit;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	addr = cpu->reg.r[reg1] + disp16;
+
+	err = bus_get_data8(cpu->core_id, addr, &bit);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+
+
+	if ((bit & (1 << bit3)) == (1 << bit3)) {
+		CPU_CLR_Z(&cpu->reg);
+	}
+	else {
+		CPU_SET_Z(&cpu->reg);
+	}
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: TST1 bit#3(%d), disp16(%d),r%d(0x%x):psw=0x%x\n", cpu->reg.pc, bit3, disp16, reg1, cpu->reg.r[reg1], sys_get_cpu_base(&cpu->reg)->r[SYS_REG_PSW]));
+
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+int op_exec_set1_8(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type8.reg1;
+	sint32 disp16 = cpu->decoded_code->type8.disp;
+	sint32 bit3 = cpu->decoded_code->type8.bit;
+	uint32 addr;
+	uint8 org_bit;
+	uint8 bit;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	addr = cpu->reg.r[reg1] + disp16;
+
+	err = bus_get_data8(cpu->core_id, addr, &bit);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+
+
+	org_bit = bit;
+
+	bit |= (1 << bit3);
+	err = bus_put_data8(cpu->core_id, addr, bit);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+
+	if (((org_bit) & (1 << bit3)) == (1 << bit3)) {
+		CPU_CLR_Z(&cpu->reg);
+	}
+	else {
+		CPU_SET_Z(&cpu->reg);
+	}
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SET1 bit#3(%d), disp16(%d), addr=0x%x r%d(0x%x):psw=0x%x, bit=0x%x\n", cpu->reg.pc, bit3, disp16, addr, reg1, cpu->reg.r[reg1], sys_get_cpu_base(&cpu->reg)->r[SYS_REG_PSW], bit));
+
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+
+int op_exec_clr1_8(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type8.reg1;
+	sint32 disp16 = cpu->decoded_code->type8.disp;
+	sint32 bit3 = cpu->decoded_code->type8.bit;
+	uint32 addr;
+	uint8 org_bit;
+	uint8 bit;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	addr = cpu->reg.r[reg1] + disp16;
+	err = bus_get_data8(cpu->core_id, addr, &bit);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+
+	org_bit = bit;
+
+	bit &= ~(1 << bit3);
+	err = bus_put_data8(cpu->core_id, addr, bit);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+
+	if (((org_bit) & (1 << bit3)) == (1 << bit3)) {
+		CPU_CLR_Z(&cpu->reg);
+	}
+	else {
+		CPU_SET_Z(&cpu->reg);
+	}
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CLR1 bit#3(%d), disp16(%d), addr=0x%x r%d(0x%x):psw=0x%x, bit=0x%x\n", cpu->reg.pc, bit3, disp16, addr, reg1, cpu->reg.r[reg1], sys_get_cpu_base(&cpu->reg)->r[SYS_REG_PSW], bit));
+
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+
+int op_exec_not1_8(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type8.reg1;
+	sint32 disp16 = cpu->decoded_code->type8.disp;
+	sint32 bit3 = cpu->decoded_code->type8.bit;
+	uint32 addr;
+	uint8 org_bit;
+	uint8 bit;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	addr = cpu->reg.r[reg1] + disp16;
+	err = bus_get_data8(cpu->core_id, addr, &bit);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+
+	org_bit = bit;
+
+
+	if (((org_bit) & (1 << bit3)) == (1 << bit3)) {
+		CPU_CLR_Z(&cpu->reg);
+		bit &= ~(1 << bit3);
+	}
+	else {
+		CPU_SET_Z(&cpu->reg);
+		bit |= (1 << bit3);
+	}
+	err = bus_put_data8(cpu->core_id, addr, bit);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(),
+			"0x%x: NOT1 bit#3(%d), disp16(%d), addr=0x%x r%d(0x%x):psw=0x%x, bit=0x%x\n",
+			cpu->reg.pc, bit3, disp16, addr, reg1, cpu->reg.r[reg1], sys_get_cpu_base(&cpu->reg)->r[SYS_REG_PSW], bit));
+
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+
+
+/*
+ * Format9
+ */
+int op_exec_set1_9(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type9.gen;
+	sint32 reg2 = cpu->decoded_code->type9.reg2;
+	uint32 addr;
+	uint8 org_bit;
+	uint8 bit3;
+	uint8 bit;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	/*
+	 * （ 2） adr ← GR [reg1]
+	 * Zフラグ ← Not (Load-memory-bit (adr, reg2) )
+	 * Store-memory-bit (adr, reg2, 1)
+	 */
+
+	addr = cpu->reg.r[reg1];
+	err = bus_get_data8(cpu->core_id, addr, &bit);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+
+	org_bit = bit;
+
+	bit3 = (cpu->reg.r[reg2] & 0x07);
+	bit |= (1 << bit3);
+	err = bus_put_data8(cpu->core_id, addr, bit);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+
+	if (((org_bit) & (1 << bit3)) == (1 << bit3)) {
+		CPU_CLR_Z(&cpu->reg);
+	}
+	else {
+		CPU_SET_Z(&cpu->reg);
+	}
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(),
+			"0x%x: SET1 bit#3(%d), addr=0x%x r%d(0x%x) r%d(0x%x):psw=0x%x, bit=0x%x\n",
+			cpu->reg.pc,
+			bit3, addr, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2],sys_get_cpu_base(&cpu->reg)->r[SYS_REG_PSW], bit));
+
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+int op_exec_clr1_9(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type9.gen;
+	sint32 reg2 = cpu->decoded_code->type9.reg2;
+	uint32 addr;
+	uint8 bit;
+	Std_ReturnType err;
+	uint8 org_bit;
+	uint8 bit3;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	/*
+	 * （ 2） adr ← GR [reg1]
+	 * Zフラグ ← Not (Load-memory-bit (adr, reg2) )
+	 * Store-memory-bit (adr, reg2, 0)
+	 */
+
+	addr = cpu->reg.r[reg1];
+	err = bus_get_data8(cpu->core_id, addr, &bit);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+	org_bit = bit;
+
+	bit3 = (cpu->reg.r[reg2] & 0x07);
+	bit &= ~(1 << bit3);
+	err = bus_put_data8(cpu->core_id, addr, bit);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+	if (((org_bit) & (1 << bit3)) == (1 << bit3)) {
+		CPU_CLR_Z(&cpu->reg);
+	}
+	else {
+		CPU_SET_Z(&cpu->reg);
+	}
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(),
+			"0x%x: CLR1 bit#3(%d), addr=0x%x r%d(0x%x) r%d(0x%x):psw=0x%x, bit=0x%x\n",
+			cpu->reg.pc,
+			bit3, addr, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2],sys_get_cpu_base(&cpu->reg)->r[SYS_REG_PSW], bit));
+
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+
+int op_exec_tst1_9(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type9.gen;
+	sint32 reg2 = cpu->decoded_code->type9.reg2;
+	uint32 addr;
+	Std_ReturnType err;
+	uint8 bit3;
+	uint8 bit;
+
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	addr = cpu->reg.r[reg1];
+
+	err = bus_get_data8(cpu->core_id, addr, &bit);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+
+	bit3 = (cpu->reg.r[reg2] & 0x07);
+
+	if ((bit & (1 << bit3)) == (1 << bit3)) {
+		CPU_CLR_Z(&cpu->reg);
+	}
+	else {
+		CPU_SET_Z(&cpu->reg);
+	}
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(),
+			"0x%x: TST1 bit#3(%d), r%d(0x%x),r%d(0x%x):psw=0x%x\n",
+			cpu->reg.pc, bit3, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], sys_get_cpu_base(&cpu->reg)->r[SYS_REG_PSW]));
+
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+int op_exec_not1_9(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type9.gen;
+	sint32 reg2 = cpu->decoded_code->type9.reg2;
+	uint32 addr;
+	Std_ReturnType err;
+	uint8 bit;
+	uint8 org_bit;
+	uint8 bit3;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	/*
+	 * （ 2） adr ← GR [reg1]
+	 * Zフラグ ← Not (Load-memory-bit (adr, reg2) )
+	 * Store-memory-bit (adr, reg2, Zフラグ)
+	 */
+	addr = cpu->reg.r[reg1];
+	err = bus_get_data8(cpu->core_id, addr, &bit);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+
+	org_bit = bit;
+
+	bit3 = (cpu->reg.r[reg2] & 0x07);
+
+	if (((org_bit) & (1 << bit3)) == (1 << bit3)) {
+		CPU_CLR_Z(&cpu->reg);
+		bit &= ~(1 << bit3);
+	}
+	else {
+		CPU_SET_Z(&cpu->reg);
+		bit |= (1 << bit3);
+	}
+	err = bus_put_data8(cpu->core_id, addr, bit);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(),
+			"0x%x: NOT1 bit#3(%d), addr=0x%x r%d(0x%x) r%d(0x%x):psw=0x%x, bit=0x%x\n",
+			cpu->reg.pc,
+			bit3, addr, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2],sys_get_cpu_base(&cpu->reg)->r[SYS_REG_PSW], bit));
+
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+
+static int op_exec_schlr_9(TargetCoreType *cpu, uint32 search_bitval, bool search_left)
+{
+	sint32 reg2 = cpu->decoded_code->type9.reg2;
+	sint32 reg3 = cpu->decoded_code->type9.rfu2;
+	uint32 reg2_data = cpu->reg.r[reg2];
+	uint32 i;
+	uint32 count = 0;
+	bool isFound = FALSE;
+	uint32 result;
+	char *dir = NULL;
+
+	if (search_left == TRUE) {
+		dir = "L";
+		for (i = 0; i < 32; i++) {
+			if ((reg2_data & (1U << (31 - i))) == search_bitval) {
+				isFound = TRUE;
+				break;
+			}
+			else {
+				count++;
+			}
+		}
+	}
+	else {
+		dir = "R";
+		for (i = 0; i < 32; i++) {
+			if ((reg2_data & (1U << (i))) == search_bitval) {
+				isFound = TRUE;
+				break;
+			}
+			else {
+				count++;
+			}
+		}
+		DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(),
+				"0x%x: SCH%dR r%d(0x%x) r%d(0x%x):%u\n",
+				cpu->reg.pc,
+				search_bitval,
+				reg3, cpu->reg.r[reg2], reg3, cpu->reg.r[reg3],
+				count + 1));
+	}
+
+	//CY 最後にビット（search_bitval）が見つかったとき 1，そうでないとき 0
+	if (count == 31) {
+		CPU_SET_CY(&cpu->reg);
+	}
+	else {
+		CPU_SET_CY(&cpu->reg);
+	}
+
+	CPU_CLR_OV(&cpu->reg);
+	CPU_CLR_S(&cpu->reg);
+
+	//ビット（search_bitval）が見つからなかったとき 1，そうでないとき 0
+	if (isFound == FALSE) {
+		CPU_SET_Z(&cpu->reg);
+		result = 0;
+	}
+	else {
+		CPU_CLR_Z(&cpu->reg);
+		result = count + 1;
+	}
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(),
+			"0x%x: SCH%d%s r%d(0x%x) r%d(0x%x):psw=0x%x, %u\n",
+			cpu->reg.pc,
+			search_bitval,
+			dir,
+			reg2, cpu->reg.r[reg2], reg3, cpu->reg.r[reg3],
+			sys_get_cpu_base(&cpu->reg)->r[SYS_REG_PSW], result));
+
+	cpu->reg.r[reg3] = result;
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+
+/*
+ * Format9
+ */
+int op_exec_sch0l_9(TargetCoreType *cpu)
+{
+	return op_exec_schlr_9(cpu, 0, TRUE);
+}
+int op_exec_sch1l_9(TargetCoreType *cpu)
+{
+	return op_exec_schlr_9(cpu, 1, TRUE);
+}
+int op_exec_sch0r_9(TargetCoreType *cpu)
+{
+	return op_exec_schlr_9(cpu, 0, FALSE);
+}
+int op_exec_sch1r_9(TargetCoreType *cpu)
+{
+	return op_exec_schlr_9(cpu, 1, FALSE);
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_exec/op_exec_branch.c
@@ -0,0 +1,272 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "cpu_exec/op_exec_ops.h"
+#include "cpu.h"
+
+bool op_exec_cond(TargetCoreType *cpu, uint16 cond)
+{
+	uint16 is_br = FALSE;
+	uint16 flg_s = CPU_ISSET_S(&cpu->reg);
+	uint16 flg_ov = CPU_ISSET_OV(&cpu->reg);
+	uint16 flg_z = CPU_ISSET_Z(&cpu->reg);
+	uint16 flg_cy = CPU_ISSET_CY(&cpu->reg);
+	uint16 flg_sat = CPU_ISSET_SAT(&cpu->reg);
+
+	switch (cond) {
+	case 0b1110:	//BGE
+		if ((flg_s ^ flg_ov) == FALSE) {
+			is_br = TRUE;
+		}
+		break;
+	case 0b1111:	//BGT
+		if (((flg_s ^ flg_ov) | flg_z ) == FALSE) {
+			is_br = TRUE;
+		}
+		break;
+	case 0b0111:	//BLE
+		if (((flg_s ^ flg_ov) | flg_z ) == TRUE) {
+			is_br = TRUE;
+		}
+		break;
+	case 0b0110:	//BLT
+		if ((flg_s ^ flg_ov) == TRUE) {
+			is_br = TRUE;
+		}
+		break;
+
+	case 0b1011:	//BH
+		if ((flg_cy | flg_z) == FALSE) {
+			is_br = TRUE;
+		}
+		break;
+	case 0b0001:	//BL
+/*	case 0b0001: */	//BC
+		if ((flg_cy) == TRUE) {
+			is_br = TRUE;
+		}
+		break;
+	case 0b0011:	//BNH
+		if ((flg_cy | flg_z) == TRUE) {
+			is_br = TRUE;
+		}
+		break;
+	case 0b1001:	//BNL
+/*	case 0b1001: */	//BNC
+		if ((flg_cy) == FALSE) {
+			is_br = TRUE;
+		}
+		break;
+
+	case 0b0010:	//BE
+/*	case 0b0010: */	//BZ
+		if ((flg_z) == TRUE) {
+			is_br = TRUE;
+		}
+		break;
+	case 0b1010:	//BNZ
+		if ((flg_z) == FALSE) {
+			is_br = TRUE;
+		}
+		break;
+
+	case 0b0100:	//BN
+		if ((flg_s) == TRUE) {
+			is_br = TRUE;
+		}
+		break;
+	case 0b1000:	//BNV
+		if ((flg_ov) == FALSE) {
+			is_br = TRUE;
+		}
+		break;
+	case 0b1100:	//BP
+		if ((flg_s) == FALSE) {
+			is_br = TRUE;
+		}
+		break;
+	case 0b0101:	//BR
+		is_br = TRUE;
+		break;
+	case 0b1101:	//BSA
+		if ((flg_sat) == TRUE) {
+			is_br = TRUE;
+		}
+		break;
+	case 0b0000:	//BV
+		if ((flg_ov) == TRUE) {
+			is_br = TRUE;
+		}
+		break;
+	default:
+		break;
+	}
+	return is_br;
+}
+
+void op_exec_bcond(TargetCoreType *cpu, uint16 cond, sint32 disp, sint32 code_size)
+{
+	uint16 is_br = op_exec_cond(cpu, cond);
+	if (is_br == TRUE) {
+		sint32 pc = cpu->reg.pc;
+		pc = pc + disp;
+		DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: B cond(0x%x):0x%x\n", cpu->reg.pc, cond, pc));
+		cpu->reg.pc = pc;
+	}
+	else {
+		sint32 pc = cpu->reg.pc + code_size;
+		DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: Bcond(0x%x):0x%x\n", cpu->reg.pc, cond, pc));
+		cpu->reg.pc = pc;
+	}
+}
+/*
+ * Format1
+ */
+int op_exec_jmp(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type1.reg1;
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: JMP r%d(0x%x)\n", cpu->reg.pc, reg1, cpu->reg.r[reg1]));
+	cpu->reg.pc = cpu->reg.r[reg1];
+	return 0;
+}
+
+
+/*
+ * Format3
+ */
+int op_exec_bcond_3(TargetCoreType *cpu)
+{
+	uint16 cond = cpu->decoded_code->type3.cond;
+	uint32 disp_u;
+	sint32 disp;
+
+	disp_u = cpu->decoded_code->type3.disp << 1;
+	disp = op_sign_extend(8, disp_u);
+
+	op_exec_bcond(cpu, cond, disp, 2);
+	return 0;
+}
+
+/*
+ * Format5
+ */
+int op_exec_jr(TargetCoreType *cpu)
+{
+	uint32 reg2 = cpu->decoded_code->type5.reg2;
+	sint32 pc = (sint32)cpu->reg.pc;
+	sint32 disp;
+
+	if (reg2 > 0) {
+		cpu->reg.r[reg2] = cpu->reg.pc + 4;
+	}
+	disp = op_sign_extend(21, cpu->decoded_code->type5.disp);
+	pc += disp;
+
+	if (reg2 == 0) {
+		DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: JR disp22(%d):0x%x\n", cpu->reg.pc, disp, pc));
+	}
+	else {
+		DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: JARL disp22(%d):0x%x r%u(0x%x)\n", cpu->reg.pc, disp, pc, reg2, cpu->reg.r[reg2]));
+	}
+
+	cpu->reg.pc = pc;
+	return 0;
+}
+
+
+/*
+ * Format6
+ */
+int op_exec_jmp_6(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type6.reg1;
+	uint32 disp = cpu->decoded_code->type6.imm;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: JMP disp32(%u) r%d(0x%x)\n", cpu->reg.pc, disp, reg1, cpu->reg.r[reg1] + disp));
+	cpu->reg.pc = cpu->reg.r[reg1] + disp;
+
+	return 0;
+}
+
+int op_exec_jarl_6(TargetCoreType *cpu)
+{
+	sint32 reg1 = cpu->decoded_code->type6.reg1;
+	uint32 disp = cpu->decoded_code->type6.imm;
+	uint32 pc = (sint32)cpu->reg.pc;
+
+	pc += disp;
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: JARL disp32(%u) r%u(0x%x):0x%x r%u(0x%x)\n",
+			cpu->reg.pc,
+			disp,
+			reg1, cpu->reg.r[reg1],
+			pc,
+			reg1, cpu->reg.pc + 6));
+
+	cpu->reg.r[reg1] = cpu->reg.pc + 6;
+
+	cpu->reg.pc = pc;
+	return 0;
+}
+
+int op_exec_jr_6(TargetCoreType *cpu)
+{
+	uint32 disp = cpu->decoded_code->type6.imm;
+	uint32 pc = (uint32)cpu->reg.pc;
+
+	pc += disp;
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: JR disp32(%u):0x%x\n",
+			cpu->reg.pc,
+			disp,
+			pc));
+
+	cpu->reg.pc = pc;
+	return 0;
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_exec/op_exec_branch_rh850.c
@@ -0,0 +1,135 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "cpu_exec/op_exec_ops.h"
+#include "cpu.h"
+
+extern void op_exec_bcond(TargetCoreType *cpu, uint16 cond, sint32 disp, sint32 code_size);
+
+/*
+ * Format7
+ */
+int op_exec_bcond_7(TargetCoreType *cpu)
+{
+	uint16 cond = (cpu->decoded_code->type7.reg1 & 0x0F);
+	uint32 disp_u;
+	uint32 disp_D;
+	sint32 disp;
+	disp_u = (cpu->decoded_code->type7.disp);
+	disp_D = (cpu->decoded_code->type7.reg1 & 0x10) >> 4U;
+	disp_u = ((disp_D << 15U) | (disp_u)) << 1U;
+
+	disp = op_sign_extend(16, disp_u);
+
+	op_exec_bcond(cpu, cond, disp, 4);
+	return 0;
+}
+/*
+ * Format11
+ */
+int op_exec_jarl_11(TargetCoreType *cpu)
+{
+	sint32 reg1 = cpu->decoded_code->type11.reg1;
+	uint32 reg3 = cpu->decoded_code->type11.reg3;
+	sint32 pc = (sint32)cpu->reg.pc;
+
+	pc = cpu->reg.r[reg1];
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: JARL [r%u(0x%x)], r%u(0x%x):0x%x r%u(0x%x)\n",
+			cpu->reg.pc,
+			reg1, cpu->reg.r[reg1],
+			reg3, cpu->reg.r[reg3],
+			pc,
+			reg3, cpu->reg.pc + 4));
+
+	cpu->reg.r[reg3] = cpu->reg.pc + 4;
+
+	cpu->reg.pc = pc;
+	return 0;
+}
+
+
+/*
+ * Format7
+ */
+int op_exec_loop_7(TargetCoreType *cpu)
+{
+	sint32 reg1 = cpu->decoded_code->type7.reg1;
+	uint32 disp = 0;
+	uint32 reg1_data = cpu->reg.r[reg1];
+	uint32 result;
+	uint32 add_data = 0xFFFFFFFF;
+	sint32 pc;
+
+	result = reg1_data + add_data;
+	if (result == 0) {
+		pc = cpu->reg.pc + 4;
+		CPU_CLR_CY(&cpu->reg);
+	}
+	else {
+		/*
+		 * 15 ビット・イミーディエトを 1 ビット論理左シフトしてワード長までゼロ拡張した結果を現
+		 * 在の PC から減算した値を PC に設定し，制御を移します。
+		 */
+		disp = op_zero_extend(16, (cpu->decoded_code->type7.disp << 1U));
+		pc = cpu->reg.pc - ((sint32)disp);
+
+		/*
+		 * 汎用レジスタ reg1 の内容に対しては，−1（0xFFFFFFFF）を加算します。キャリー・フラグ
+		 * の更新は SUB 命令ではなく，ADD 命令と同一の動作となります
+		 */
+		op_chk_and_set_carry(&cpu->reg, reg1_data, add_data);
+	}
+	op_chk_and_set_overflow(&cpu->reg, reg1_data, add_data);
+	op_chk_and_set_zero(&cpu->reg, result);
+	op_chk_and_set_sign(&cpu->reg, result);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: LOOP r%u(0x%x), disp=%u:0x%x\n",
+			cpu->reg.pc,
+			reg1, cpu->reg.r[reg1],
+			disp,
+			result));
+
+	cpu->reg.r[reg1] = result;
+	cpu->reg.pc = pc;
+
+	return 0;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_exec/op_exec_dbg.c
@@ -0,0 +1,41 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_exec/op_exec_div.c
@@ -0,0 +1,41 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_exec/op_exec_fpu.c
@@ -0,0 +1,3494 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "cpu_exec/op_exec_ops.h"
+#include "cpu_common/cpu_fpu_ops.h"
+#include <stdlib.h>
+#include <math.h>
+#include <limits.h>
+#define _GNU_SOURCE
+#include <fenv.h>
+#include <float.h>
+
+//#define DEBUG_FPU
+#ifdef DEBUG_FPU
+static void show_float_data(FloatBinaryDataType x)
+{
+	printf("float_data=%e\n", x.data);
+	printf("31:=%u\n", GET_FLOAT_SIGN_BIT_VALUE(x));
+	printf("30-23:=%d\n", GET_FLOAT_EXP_VALUE(x));
+	printf("30-23-127:=%d\n", GET_FLOAT_EXPB_VALUE(x));
+	unsigned int ma = GET_FLOAT_MANTISSA_VALUE(x);
+	int i;
+	for (i = FLOAT_MANTISSA_POS_START; i >= FLOAT_MANTISSA_POS_END; i--) {
+		printf("%2d ", i);
+	}
+	printf("\n");
+	for (i = FLOAT_MANTISSA_POS_START; i >= FLOAT_MANTISSA_POS_END; i--) {
+		printf("%2d ", GET_FLOAT_MANTISSA_BIT_VALUE(ma, i));
+	}
+	printf("\n");
+
+	if (FLOAT_IS_ZERO(x)) {
+		printf("zero\n");
+	}
+	if (FLOAT_IS_NORMAL(x)) {
+		printf("normal\n");
+	}
+	if (FLOAT_IS_SBNORM(x)) {
+		printf("subnormal\n");
+	}
+	if (FLOAT_IS_INF(x)) {
+		printf("inf\n");
+	}
+	if (FLOAT_IS_NAN(x)) {
+		printf("nan\n");
+	}
+	if (FLOAT_IS_PLUS(x)) {
+		printf("+\n");
+	}
+	if (FLOAT_IS_MINUS(x)) {
+		printf("-\n");
+	}
+    return;
+}
+#endif
+
+typedef enum {
+    FpuRounding_RN = 0,
+    FpuRounding_RU,
+    FpuRounding_RD,
+    FpuRounding_RZ,
+} FpuConfigRoundingType;
+
+typedef struct {
+    bool is_FPSR_FS;
+    FpuConfigRoundingType round_type;
+} FpuConfigSettingType;
+
+/*
+ * FPSR.FS = 1 : TRUE
+ * FPSR.FS = 0 : FALSE
+ */
+static void prepare_float_op(TargetCoreType *cpu, FloatExceptionType *exp, FpuConfigSettingType *cp)
+{
+    FLOAT_EXCEPTION_BIT_RESET(exp);
+    cp->is_FPSR_FS = TRUE;
+
+    SysFpuRmType cfg = sys_get_fpsr_rm(&cpu->reg);
+    cp->round_type = FpuRounding_RN;
+    switch (cfg) {
+    case SysFpuRm_RN:
+        cp->round_type = FpuRounding_RN;
+        break;
+    case SysFpuRm_RZ:
+        cp->round_type = FpuRounding_RZ;
+        break;
+    case SysFpuRm_RP:
+        cp->round_type = FpuRounding_RU;
+        break;
+    case SysFpuRm_RD:
+        cp->round_type = FpuRounding_RD;
+        break;
+    default:
+        break;
+    }
+
+    switch (cp->round_type) {
+    case FpuRounding_RN:
+        (void)fesetround(FE_TONEAREST);
+        break;
+    case FpuRounding_RU:
+        (void)fesetround(FE_UPWARD);
+        break;
+    case FpuRounding_RD:
+        (void)fesetround(FE_DOWNWARD);
+        break;
+    case FpuRounding_RZ:
+        (void)fesetround(FE_TOWARDZERO);
+        break;
+    default:
+        (void)fesetround(FE_TONEAREST);
+        break;
+    }
+   	(void)feclearexcept(FE_ALL_EXCEPT);
+    return;
+}
+static void end_float_op(TargetCoreType *cpu, FloatExceptionType *exp)
+{
+    if (fetestexcept(FE_ALL_EXCEPT) == 0) {
+        return;
+    }
+    if (fetestexcept(FE_DIVBYZERO)) {
+        FLOAT_EXCEPTION_INTR_BIT_SET(exp, FLOAT_EXCEPTION_BIT_Z);
+        sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_Z);
+        sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_Z);
+        //printf("FE_DIVBYZERO\n");
+    }
+    if (fetestexcept(FE_INEXACT)) {
+        FLOAT_EXCEPTION_INTR_BIT_SET(exp, FLOAT_EXCEPTION_BIT_I);
+        sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_I);
+        sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_I);
+        //printf("FE_INEXACT\n");
+    }
+    if (fetestexcept(FE_INVALID)) {
+        FLOAT_EXCEPTION_INTR_BIT_SET(exp, FLOAT_EXCEPTION_BIT_V);
+        sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_V);
+        sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_V);
+        //printf("FE_INVALID\n");
+    }
+    if (fetestexcept(FE_OVERFLOW)) {
+        FLOAT_EXCEPTION_INTR_BIT_SET(exp, FLOAT_EXCEPTION_BIT_O);
+        sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_O);
+        sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_O);
+        //printf("FE_OVERFLOW\n");
+    }
+    if (fetestexcept(FE_UNDERFLOW)) {
+        FLOAT_EXCEPTION_INTR_BIT_SET(exp, FLOAT_EXCEPTION_BIT_U);
+        sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_U);
+        sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_U);
+        //printf("FE_UNDERFLOW\n");
+    }
+    return;
+}
+static inline void set_subnormal_operand(TargetCoreType *cpu, FpuConfigSettingType *cp, FloatBinaryDataType *operand)
+{
+    if (!FLOAT_IS_SBNORM(*operand)) {
+        return;
+    }
+    if (cp->is_FPSR_FS == FALSE) {
+        // not supported.
+        return;
+    }
+    // TODO FPSR レジスタの IF ビット
+    if (FLOAT_IS_MINUS(*operand)) {
+        operand->binary = 0;
+        FLOAT_SIGN_BIT_SET(*operand);
+    }
+    else {
+        operand->binary = 0;
+    }
+    return;
+}
+
+static inline void set_subnormal_result(TargetCoreType *cpu, FpuConfigSettingType *cp, FloatBinaryDataType *result)
+{
+    if (!FLOAT_IS_SBNORM(*result)) {
+        return;
+    }
+    if (cp->is_FPSR_FS == FALSE) {
+        // not supported.
+        return;
+    }
+    //TODO FN = 1 未サポート
+    switch (cp->round_type) {
+    case FpuRounding_RN:
+    case FpuRounding_RZ:
+        if (FLOAT_IS_MINUS(*result)) {
+            FLOAT_SIGN_BIT_SET(*result);
+            result->binary = 0;
+        }
+        else {
+            result->binary = 0;
+        }
+        break;
+    case FpuRounding_RU:
+        if (FLOAT_IS_MINUS(*result)) {
+            result->binary = 0;
+            FLOAT_SIGN_BIT_SET(*result);
+        }
+        else {
+            result->data = FLT_MIN;
+        }
+        break;
+    case FpuRounding_RD:
+        if (FLOAT_IS_MINUS(*result)) {
+            result->data = FLT_MIN;
+            FLOAT_SIGN_BIT_SET(*result);
+        }
+        else {
+            result->binary = 0;
+        }
+        break;
+    default:
+        break;
+    }
+
+    return;
+}
+static inline void set_subnormal_operand_double(TargetCoreType *cpu, FpuConfigSettingType *cp, DoubleBinaryDataType *operand)
+{
+    if (!DOUBLE_IS_SBNORM(*operand)) {
+        return;
+    }
+    if (cp->is_FPSR_FS == FALSE) {
+        // not supported.
+        return;
+    }
+    // TODO FPSR レジスタの IF ビット
+    if (DOUBLE_IS_MINUS(*operand)) {
+        operand->binary[0] = 0;
+        operand->binary[1] = 0;
+        DOUBLE_SIGN_BIT_SET(*operand);
+    }
+    else {
+        operand->binary[0] = 0;
+        operand->binary[1] = 0;
+    }
+    return;
+}
+
+static inline void set_subnormal_result_double(TargetCoreType *cpu, FpuConfigSettingType *cp, DoubleBinaryDataType *result)
+{
+    if (!DOUBLE_IS_SBNORM(*result)) {
+        return;
+    }
+    if (cp->is_FPSR_FS == FALSE) {
+        // not supported.
+        return;
+    }
+    //TODO FN = 1 未サポート
+    switch (cp->round_type) {
+    case FpuRounding_RN:
+    case FpuRounding_RZ:
+        if (DOUBLE_IS_MINUS(*result)) {
+            DOUBLE_SIGN_BIT_SET(*result);
+            result->binary[0] = 0;
+            result->binary[1] = 0;
+        }
+        else {
+            result->binary[0] = 0;
+            result->binary[1] = 0;
+        }
+        break;
+    case FpuRounding_RU:
+        if (DOUBLE_IS_MINUS(*result)) {
+            result->binary[0] = 0;
+            result->binary[1] = 0;
+            DOUBLE_SIGN_BIT_SET(*result);
+        }
+        else {
+            result->data = DBL_MIN;
+        }
+        break;
+    case FpuRounding_RD:
+        if (DOUBLE_IS_MINUS(*result)) {
+            result->data = DBL_MIN;
+            DOUBLE_SIGN_BIT_SET(*result);
+        }
+        else {
+            result->binary[0] = 0;
+            result->binary[1] = 0;
+        }
+        break;
+    default:
+        break;
+    }
+
+    return;
+}
+
+int op_exec_absf_s_F(TargetCoreType *cpu)
+{
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+    op_absf_s(&reg2_data, &result_data);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: ABSF_S r%d(%f),r%d(%f):%f\n", 
+        cpu->reg.pc, reg2, reg2_data.data, reg3, reg3_data.data, result_data.data));
+	cpu->reg.r[reg3] = result_data.binary;
+
+    /*
+     * FPSR.FS = 1 でもサブノーマル数の入力はフラッシュされません。
+     */
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+
+int op_exec_addf_s_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg1 = cpu->decoded_code->type_f.reg1;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg1_data;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg1_data.binary = cpu->reg.r[reg1];
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand(cpu, &fpu_config, &reg1_data);
+        set_subnormal_operand(cpu, &fpu_config, &reg2_data);
+        result_data.data = reg1_data.data + reg2_data.data;
+        set_subnormal_result(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: ADDF_S r%d(%f),r%d(%f),r%d(%f):%f\n", 
+        cpu->reg.pc, reg1, reg1_data.data, reg2, reg2_data.data, reg3, reg3_data.data, result_data.data));
+	cpu->reg.r[reg3] = result_data.binary;
+
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+
+int op_exec_mulf_s_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg1 = cpu->decoded_code->type_f.reg1;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg1_data;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg1_data.binary = cpu->reg.r[reg1];
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand(cpu, &fpu_config, &reg1_data);
+        set_subnormal_operand(cpu, &fpu_config, &reg2_data);
+        result_data.data = reg1_data.data * reg2_data.data;
+        set_subnormal_result(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: MULF_S r%d(%f),r%d(%f),r%d(%f):%f\n", 
+        cpu->reg.pc, reg1, reg1_data.data, reg2, reg2_data.data, reg3, reg3_data.data, result_data.data));
+	cpu->reg.r[reg3] = result_data.binary;
+
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+int op_exec_mulf_d_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg1_0 = cpu->decoded_code->type_f.reg1;
+	uint32 reg1_1 = cpu->decoded_code->type_f.reg1 + 1;
+	uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+    DoubleBinaryDataType reg1_data;
+    DoubleBinaryDataType reg2_data;
+    DoubleBinaryDataType reg3_data;
+    DoubleBinaryDataType result_data;
+
+	if (reg1_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg1_data.binary[0] = cpu->reg.r[reg1_0];
+	reg1_data.binary[1] = cpu->reg.r[reg1_1];
+	reg2_data.binary[0] = cpu->reg.r[reg2_0];
+	reg2_data.binary[1] = cpu->reg.r[reg2_1];
+	reg3_data.binary[0] = cpu->reg.r[reg3_0];
+	reg3_data.binary[1] = cpu->reg.r[reg3_1];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand_double(cpu, &fpu_config, &reg1_data);
+        set_subnormal_operand_double(cpu, &fpu_config, &reg2_data);
+        result_data.data = reg1_data.data * reg2_data.data;
+        set_subnormal_result_double(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: MULF_D r%d(%lf),r%d(%lf),r%d(%lf):%lf\n",
+        cpu->reg.pc, reg1_0, reg1_data.data, reg2_0, reg2_data.data, reg3_0, reg3_data.data, result_data.data));
+	cpu->reg.r[reg3_0] = result_data.binary[0];
+	cpu->reg.r[reg3_1] = result_data.binary[1];
+
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+int op_exec_addf_d_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg1_0 = cpu->decoded_code->type_f.reg1;
+	uint32 reg1_1 = cpu->decoded_code->type_f.reg1 + 1;
+	uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+    DoubleBinaryDataType reg1_data;
+    DoubleBinaryDataType reg2_data;
+    DoubleBinaryDataType reg3_data;
+    DoubleBinaryDataType result_data;
+
+	if (reg1_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg1_data.binary[0] = cpu->reg.r[reg1_0];
+	reg1_data.binary[1] = cpu->reg.r[reg1_1];
+	reg2_data.binary[0] = cpu->reg.r[reg2_0];
+	reg2_data.binary[1] = cpu->reg.r[reg2_1];
+	reg3_data.binary[0] = cpu->reg.r[reg3_0];
+	reg3_data.binary[1] = cpu->reg.r[reg3_1];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand_double(cpu, &fpu_config, &reg1_data);
+        set_subnormal_operand_double(cpu, &fpu_config, &reg2_data);
+        result_data.data = reg1_data.data + reg2_data.data;
+        set_subnormal_result_double(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: ADDF_D r%d(%lf),r%d(%lf),r%d(%lf):%lf\n",
+        cpu->reg.pc, reg1_0, reg1_data.data, reg2_0, reg2_data.data, reg3_0, reg3_data.data, result_data.data));
+	cpu->reg.r[reg3_0] = result_data.binary[0];
+	cpu->reg.r[reg3_1] = result_data.binary[1];
+
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+
+int op_exec_divf_s_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg1 = cpu->decoded_code->type_f.reg1;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg1_data;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg1_data.binary = cpu->reg.r[reg1];
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand(cpu, &fpu_config, &reg1_data);
+        set_subnormal_operand(cpu, &fpu_config, &reg2_data);
+        result_data.data = reg2_data.data / reg1_data.data;
+        set_subnormal_result(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: DIVF_S r%d(%f),r%d(%f),r%d(%f):%f\n", 
+        cpu->reg.pc, reg1, reg1_data.data, reg2, reg2_data.data, reg3, reg3_data.data, result_data.data));
+	cpu->reg.r[reg3] = result_data.binary;
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+
+int op_exec_subf_s_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg1 = cpu->decoded_code->type_f.reg1;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg1_data;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg1_data.binary = cpu->reg.r[reg1];
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand(cpu, &fpu_config, &reg1_data);
+        set_subnormal_operand(cpu, &fpu_config, &reg2_data);
+        result_data.data = reg2_data.data - reg1_data.data;
+        set_subnormal_result(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SUBF_S r%d(%f),r%d(%f),r%d(%f):%f\n", 
+        cpu->reg.pc, reg1, reg1_data.data, reg2, reg2_data.data, reg3, reg3_data.data, result_data.data));
+	cpu->reg.r[reg3] = result_data.binary;
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+
+
+int op_exec_maxf_s_F(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type_f.reg1;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg1_data;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg1_data.binary = cpu->reg.r[reg1];
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    if (float_is_snan(reg1_data) || float_is_snan(reg2_data)) {
+        sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_V);
+        sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_V);
+        float_get_qnan(&result_data);
+    }
+    else {
+        if (reg1_data.data > reg2_data.data) {
+            result_data.data = reg1_data.data;
+        }
+        else {
+            result_data.data = reg2_data.data;
+        }
+    }
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: MAX_S r%d(%f),r%d(%f),r%d(%f):%f\n", 
+        cpu->reg.pc, reg1, reg1_data.data, reg2, reg2_data.data, reg3, reg3_data.data, result_data.data));
+	cpu->reg.r[reg3] = result_data.binary;
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+
+int op_exec_minf_s_F(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type_f.reg1;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg1_data;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg1_data.binary = cpu->reg.r[reg1];
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    if (float_is_snan(reg1_data) || float_is_snan(reg2_data)) {
+        sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_V);
+        sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_V);
+        float_get_qnan(&result_data);
+    }
+    else {
+        if (reg1_data.data < reg2_data.data) {
+            result_data.data = reg1_data.data;
+        }
+        else {
+            result_data.data = reg2_data.data;
+        }
+    }
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: MIN_S r%d(%f),r%d(%f),r%d(%f):%f\n", 
+        cpu->reg.pc, reg1, reg1_data.data, reg2, reg2_data.data, reg3, reg3_data.data, result_data.data));
+	cpu->reg.r[reg3] = result_data.binary;
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+
+int op_exec_cmovf_s_F(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type_f.reg1;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    uint32 fcbit = ( (cpu->decoded_code->type_f.subopcode & 0x0000000F) >> 1U );
+    FloatBinaryDataType reg1_data;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+    uint8 data;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg1_data.binary = cpu->reg.r[reg1];
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    data = sys_get_fpsr_cc(&cpu->reg);
+    if ((data & (1U << (uint8)fcbit)) != 0) {
+        result_data.data = reg1_data.data;
+    }
+    else {
+        result_data.data = reg2_data.data;
+    }
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CMOVF_S fcbit(%u) r%d(%f),r%d(%f),r%d(%f):%f\n", 
+        cpu->reg.pc, fcbit, reg1, reg1_data.data, reg2, reg2_data.data, reg3, reg3_data.data, result_data.data));
+
+	cpu->reg.r[reg3] = result_data.binary;
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+
+int op_exec_negf_s_F(TargetCoreType *cpu)
+{
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    result_data.data = - reg2_data.data;
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: NEGF_S r%d(%f),r%d(%f):%f\n", 
+        cpu->reg.pc, reg2, reg2_data.data, reg3, reg3_data.data, result_data.data));
+	cpu->reg.r[reg3] = result_data.binary;
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+
+int op_exec_trfsr_F(TargetCoreType *cpu)
+{
+    uint32 fcbit = ( (cpu->decoded_code->type_f.subopcode & 0x0000000F) >> 1U );
+    uint8 data;
+
+    data = sys_get_fpsr_cc(&cpu->reg);
+
+    if ((data & (1U << (uint8)fcbit)) != 0) {
+        CPU_SET_Z(&cpu->reg);
+    }
+    else {
+        CPU_CLR_Z(&cpu->reg);
+    }
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: TRFSR_S fcbit(%d)\n", 
+        cpu->reg.pc, fcbit));
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+
+typedef enum {
+    FpucCmpFcond_F = 0,
+    FpucCmpFcond_UN,
+    FpucCmpFcond_EQ,
+    FpucCmpFcond_UEQ,
+    FpucCmpFcond_OLT,
+    FpucCmpFcond_ULT,
+    FpucCmpFcond_OLE,
+    FpucCmpFcond_ULE,
+    FpucCmpFcond_SF,
+    FpucCmpFcond_NGLE,
+    FpucCmpFcond_SEQ,
+    FpucCmpFcond_NGL,
+    FpucCmpFcond_LT,
+    FpucCmpFcond_NGE,
+    FpucCmpFcond_LE,
+    FpucCmpFcond_NGT,
+} FpuCmpFcondType;
+
+int op_exec_cmpf_s_F(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type_f.reg1;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 fcond = cpu->decoded_code->type_f.reg3;
+    uint32 fcbit = ( (cpu->decoded_code->type_f.subopcode & 0x0000000F) >> 1U );
+    FloatBinaryDataType reg1_data;
+    FloatBinaryDataType reg2_data;
+    bool result_less;
+    bool result_equal;
+    bool result_unordered;
+    uint32 result_data;
+    uint8 data;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg1_data.binary = cpu->reg.r[reg1];
+	reg2_data.binary = cpu->reg.r[reg2];
+
+    /*
+    * if isNaN(reg1) or isNaN(reg2) then
+    * result.less ← 0
+    * result.equal ← 0
+    * result.unordered ← 1
+    * if fcond[3] == 1 then
+    * 無効演算例外を検出
+    * endif
+    * else
+    * result.less ← reg2 < reg1
+    * result.equal ← reg2 == reg1
+    * result.unordered ← 0
+    * endif
+    * FPSR.CCn ← (fcond[2] & result.less) | (fcond[1] & result.equal) |
+    * (fcond[0] & result.unordered)
+    */
+    if (FLOAT_IS_NAN(reg1_data) || FLOAT_IS_NAN(reg2_data)) {
+        result_less = FALSE;
+        result_equal = FALSE;
+        result_unordered = TRUE;
+        if ((fcond & 0x00000008) != 0) {
+            sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_V);
+            sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_V);
+        }
+    }
+    else {
+        result_less = (reg2_data.data < reg1_data.data);
+        result_equal = (reg2_data.data == reg1_data.data);
+        result_unordered = FALSE;
+    }
+    result_data =   (result_less << 2U) |
+                    (result_equal << 1U) |
+                    (result_unordered << 0U);
+    data = sys_get_fpsr_cc(&cpu->reg);
+    if ((result_data & (fcond & 0x00000007)) != 0) {
+        data |= (1U << (uint8)fcbit);
+    }
+    else {
+        data &= ~(1U << (uint8)fcbit);
+    }
+    sys_set_fpsr_cc(&cpu->reg,  data);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CMPF_S r%d(%f),r%d(%f),fcond(0x%x), fcbit(%d):0x%x\n", 
+        cpu->reg.pc, reg1, reg1_data.data, reg2, reg2_data.data, fcond, fcbit, data));
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+
+int op_exec_fmaf_s_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg1 = cpu->decoded_code->type_f.reg1;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg1_data;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg1_data.binary = cpu->reg.r[reg1];
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand(cpu, &fpu_config, &reg1_data);
+        set_subnormal_operand(cpu, &fpu_config, &reg2_data);
+        result_data.data = fmaf(reg2_data.data, reg1_data.data, reg3_data.data);
+        set_subnormal_result(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: FMAF_S r%d(%f),r%d(%f),r%d(%f):%f\n", 
+        cpu->reg.pc, reg1, reg1_data.data, reg2, reg2_data.data, reg3, reg3_data.data, result_data.data));
+	cpu->reg.r[reg3] = result_data.binary;
+
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+int op_exec_fmsf_s_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg1 = cpu->decoded_code->type_f.reg1;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg1_data;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg1_data.binary = cpu->reg.r[reg1];
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand(cpu, &fpu_config, &reg1_data);
+        set_subnormal_operand(cpu, &fpu_config, &reg2_data);
+        result_data.data = fmaf(reg2_data.data, reg1_data.data, -reg3_data.data);
+        set_subnormal_result(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: FMSF_S r%d(%f),r%d(%f),r%d(%f):%f\n", 
+        cpu->reg.pc, reg1, reg1_data.data, reg2, reg2_data.data, reg3, reg3_data.data, result_data.data));
+	cpu->reg.r[reg3] = result_data.binary;
+
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+int op_exec_fnmaf_s_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg1 = cpu->decoded_code->type_f.reg1;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg1_data;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg1_data.binary = cpu->reg.r[reg1];
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand(cpu, &fpu_config, &reg1_data);
+        set_subnormal_operand(cpu, &fpu_config, &reg2_data);
+        result_data.data = fmaf(reg2_data.data, reg1_data.data, reg3_data.data);
+        FLOAT_SET_SIGN_REVERSE(result_data);
+        set_subnormal_result(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: FNMAF_S r%d(%f),r%d(%f),r%d(%f):%f\n", 
+        cpu->reg.pc, reg1, reg1_data.data, reg2, reg2_data.data, reg3, reg3_data.data, result_data.data));
+	cpu->reg.r[reg3] = result_data.binary;
+
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+int op_exec_fnmsf_s_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg1 = cpu->decoded_code->type_f.reg1;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg1_data;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg1_data.binary = cpu->reg.r[reg1];
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand(cpu, &fpu_config, &reg1_data);
+        set_subnormal_operand(cpu, &fpu_config, &reg2_data);
+        result_data.data = fmaf(reg2_data.data, reg1_data.data, -reg3_data.data);
+        FLOAT_SET_SIGN_REVERSE(result_data);
+        set_subnormal_result(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: FNMSF_S r%d(%f),r%d(%f),r%d(%f):%f\n", 
+        cpu->reg.pc, reg1, reg1_data.data, reg2, reg2_data.data, reg3, reg3_data.data, result_data.data));
+	cpu->reg.r[reg3] = result_data.binary;
+
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+int op_exec_cvtf_ws_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        result_data.data = (float32)((sint32)reg2_data.binary);
+        set_subnormal_result(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CVTF_WS r%d(%u),r%d(%f):%f\n", 
+        cpu->reg.pc, reg2, reg2_data.binary, reg3, reg3_data.data, result_data.data));
+	cpu->reg.r[reg3] = result_data.binary;
+
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+int op_exec_cvtf_ds_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    DoubleBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+
+	if (reg2_0 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data.binary[0] = cpu->reg.r[reg2_0];
+	reg2_data.binary[1] = cpu->reg.r[reg2_1];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand_double(cpu, &fpu_config, &reg2_data);
+        result_data.data = (float32)(reg2_data.data);
+        set_subnormal_result(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CVTF_DS r%d(%lf),r%d(%f):%f\n", 
+        cpu->reg.pc, reg2_0, reg2_data.data, reg3, reg3_data.data, result_data.data));
+	cpu->reg.r[reg3] = result_data.binary;
+
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+int op_exec_cvtf_sd_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+    DoubleBinaryDataType reg3_data;
+    FloatBinaryDataType reg2_data;
+    DoubleBinaryDataType result_data;
+
+	if (reg3_0 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg3_data.binary[0] = cpu->reg.r[reg3_0];
+	reg3_data.binary[1] = cpu->reg.r[reg3_1];
+	reg2_data.binary = cpu->reg.r[reg2];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand(cpu, &fpu_config, &reg2_data);
+        result_data.data = (float64)(reg2_data.data);
+        set_subnormal_result_double(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CVTF_SD r%d(%f),r%d(%lf):%lf\n", 
+        cpu->reg.pc, reg2, reg2_data.data, reg3_0, reg3_data.data, result_data.data));
+	cpu->reg.r[reg3_0] = result_data.binary[0];
+	cpu->reg.r[reg3_1] = result_data.binary[1];
+
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+int op_exec_cvtf_ls_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg2_0_data;
+    FloatBinaryDataType reg2_1_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+
+	if (reg2_0 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_0_data.binary = cpu->reg.r[reg2_0];
+	reg2_1_data.binary = cpu->reg.r[reg2_1];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        sint64 result;
+        sint32 *result_array = (sint32*)&result;
+        result_array[0] = (sint32)reg2_0_data.binary;
+        result_array[1] = (sint32)reg2_1_data.binary;
+
+        result_data.data = (float32)(result);
+        set_subnormal_result(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CVTF_LS r%d(%d),r%d(%d),r%d(%f):%f\n", 
+        cpu->reg.pc, reg2_0, (sint32)reg2_0_data.binary, reg2_1, (sint32)reg2_1_data.binary, reg3, reg3_data.data, result_data.data));
+	cpu->reg.r[reg3] = result_data.binary;
+
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+int op_exec_cvtf_uls_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg2_0_data;
+    FloatBinaryDataType reg2_1_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+
+	if (reg2_0 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_0_data.binary = cpu->reg.r[reg2_0];
+	reg2_1_data.binary = cpu->reg.r[reg2_1];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        uint64 result;
+        uint32 *result_array = (uint32*)&result;
+        result_array[0] = reg2_0_data.binary;
+        result_array[1] = reg2_1_data.binary;
+
+        result_data.data = (float32)(result);
+        set_subnormal_result(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CVTF_ULS r%d(%f),r%d(%f),r%d(%f):%f\n", 
+        cpu->reg.pc, reg2_0, reg2_0_data.data, reg2_1, reg2_1_data.data, reg3, reg3_data.data, result_data.data));
+	cpu->reg.r[reg3] = result_data.binary;
+
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+
+int op_exec_cvtf_suw_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        uint64 result;
+        bool is_invalid = FALSE;
+        if (FLOAT_IS_NAN(reg2_data) || FLOAT_IS_INF(reg2_data)) {
+            if (FLOAT_IS_PLUS(reg2_data)) {
+                result = (uint64)UINT_MAX;
+            }
+            else {
+                result = 0;
+            }
+            is_invalid = TRUE;
+        }
+        else {
+            result = (uint64)reg2_data.data;
+            if (result > ((uint64)UINT_MAX)) {
+                result = (uint64)UINT_MAX;
+                is_invalid = TRUE;
+            }
+        }
+        if (is_invalid) {
+            sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_V);
+            sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_V);
+        }
+        result_data.binary = (uint32)result;
+
+    }
+    end_float_op(cpu, &ex);
+
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CVTF_SUW r%d(%f),r%d(%f):%u\n", 
+        cpu->reg.pc, reg2, reg2_data.data, reg3, reg3_data.data, (uint32)result_data.binary));
+	cpu->reg.r[reg3] = result_data.binary;
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+
+int op_exec_cvtf_sw_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        sint64 result;
+        bool is_invalid = FALSE;
+        if (FLOAT_IS_NAN(reg2_data) || FLOAT_IS_INF(reg2_data)) {
+            if (FLOAT_IS_PLUS(reg2_data)) {
+                result = (sint64)INT_MAX;
+            }
+            else {
+                result = (sint64)( -((sint32)INT_MAX) );
+            }
+            is_invalid = TRUE;
+        }
+        else {
+            result = (sint64)reg2_data.data;
+            if ( result < ((sint64)( -((sint32)INT_MAX))) ) {
+                result = (sint64)( -((sint32)INT_MAX) );
+                is_invalid = TRUE;
+            } 
+            else if (result > ((sint64)INT_MAX)) {
+                result = (sint64)INT_MAX;
+                is_invalid = TRUE;
+            }
+        }
+        if (is_invalid) {
+            sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_V);
+            sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_V);
+        }
+        result_data.binary = (sint32)result;
+
+    }
+    end_float_op(cpu, &ex);
+
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CVTF_SW r%d(%f),r%d(%f):%d\n", 
+        cpu->reg.pc, reg2, reg2_data.data, reg3, reg3_data.data, (sint32)result_data.binary));
+	cpu->reg.r[reg3] = result_data.binary;
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+int op_exec_cvtf_uws_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        result_data.data = (float32)((uint32)reg2_data.binary);
+        set_subnormal_result(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CVTF_UWS r%d(%f),r%d(%f):%f\n", 
+        cpu->reg.pc, reg2, reg2_data.data, reg3, reg3_data.data, result_data.data));
+	cpu->reg.r[reg3] = result_data.binary;
+
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+
+int op_exec_trncf_sw_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        sint64 result;
+        bool is_invalid = FALSE;
+        if (FLOAT_IS_NAN(reg2_data) || FLOAT_IS_INF(reg2_data)) {
+            if (FLOAT_IS_PLUS(reg2_data)) {
+                result = (sint64)INT_MAX;
+            }
+            else {
+                result = (sint64)( -((sint32)INT_MAX) );
+            }
+            is_invalid = TRUE;
+        }
+        else {
+            result = (sint64)truncf(reg2_data.data);
+            if ( result < ((sint64)( -((sint32)INT_MAX))) ) {
+                result = (sint64)( -((sint32)INT_MAX) );
+                is_invalid = TRUE;
+            } 
+            else if (result > ((sint64)INT_MAX)) {
+                result = (sint64)INT_MAX;
+                is_invalid = TRUE;
+            }
+        }
+        if (is_invalid) {
+            sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_V);
+            sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_V);
+        }
+        result_data.binary = (sint32)result;
+
+    }
+    end_float_op(cpu, &ex);
+
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: TRNCF_SW r%d(%f),r%d(%f):%d\n", 
+        cpu->reg.pc, reg2, reg2_data.data, reg3, reg3_data.data, (sint32)result_data.binary));
+	cpu->reg.r[reg3] = result_data.binary;
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+
+int op_exec_trncf_suw_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        uint64 result;
+        bool is_invalid = FALSE;
+        if (FLOAT_IS_NAN(reg2_data) || FLOAT_IS_INF(reg2_data)) {
+            if (FLOAT_IS_PLUS(reg2_data)) {
+                result = (uint64)UINT_MAX;
+            }
+            else {
+                result = 0;
+            }
+            is_invalid = TRUE;
+        }
+        else {
+            result = (uint64)truncf(reg2_data.data);
+            if (result > ((uint64)UINT_MAX)) {
+                result = (uint64)UINT_MAX;
+                is_invalid = TRUE;
+            }
+        }
+        if (is_invalid) {
+            sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_V);
+            sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_V);
+        }
+        result_data.binary = (uint32)result;
+
+    }
+    end_float_op(cpu, &ex);
+
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: TRNCF_SUW r%d(%f),r%d(%f):%u\n", 
+        cpu->reg.pc, reg2, reg2_data.data, reg3, reg3_data.data, (uint32)result_data.binary));
+	cpu->reg.r[reg3] = result_data.binary;
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+
+
+
+void fpu_sync_sysreg(TargetCoreType *cpu, uint32 regid, uint32 selid)
+{
+    if (selid != SYS_GRP_CPU) {
+        return;
+    }
+
+    switch (regid) {
+    case SYS_REG_FPST:
+    {
+        uint8 data = sys_get_fpst_xc(&cpu->reg);
+        sys_set_fpsr_xc(&cpu->reg, data);
+        data = sys_get_fpst_xp(&cpu->reg);
+        sys_set_fpsr_xp(&cpu->reg, data);
+        if (sys_isset_fpst_if(&cpu->reg)) {
+            sys_set_fpsr_if(&cpu->reg);
+        }
+        else {
+            sys_clr_fpsr_if(&cpu->reg);
+        }
+        break;
+    }
+    case SYS_REG_FPCC:
+    {
+        uint8 data = sys_get_fpcc_cc(&cpu->reg);
+        sys_set_fpsr_cc(&cpu->reg, data);
+        break;
+    }
+    case SYS_REG_FPCFG:
+    {
+        uint8 data = sys_get_fpcfg_rm(&cpu->reg);
+        sys_set_fpsr_rm(&cpu->reg, data);
+        data = sys_get_fpcfg_xe(&cpu->reg);
+        sys_set_fpsr_xe(&cpu->reg, data);
+        break;
+    }
+    case SYS_REG_FPEC:
+    case SYS_REG_FPEPC:
+    case SYS_REG_FPSR:
+    default:
+        break;
+    }
+    return;
+}
+
+int op_exec_maddf_s_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg1 = cpu->decoded_code->type_f.reg1;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg1_data;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+    uint32 subopcode = cpu->decoded_code->type_f.subopcode;
+    /* detect reg4 */
+    uint32 reg4 = ((subopcode & 0x1e) | ((subopcode >> 7) & 1));
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+    if ( reg4 >= CPU_GREG_NUM ) {
+        return -1;
+    }
+	reg1_data.binary = cpu->reg.r[reg1];
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    // TODO: Full NaN/finite operation
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand(cpu, &fpu_config, &reg1_data);
+        set_subnormal_operand(cpu, &fpu_config, &reg2_data);
+        set_subnormal_operand(cpu, &fpu_config, &reg3_data);
+        result_data.data = reg2_data.data * reg1_data.data + reg3_data.data;
+        set_subnormal_result(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: MADD.S_F r%d(%f),r%d(%f),r%d(%f) r%d:%f\n", 
+        cpu->reg.pc, reg1, reg1_data.data, reg2, reg2_data.data, reg3, reg3_data.data, reg4, result_data.data));
+	cpu->reg.r[reg4] = result_data.binary;
+
+//    printf( "0x%x: MADD.S_F r%d(%f),r%d(%f),r%d(%f) r%d:%f\n",  cpu->reg.pc, reg1, reg1_data.data, reg2, reg2_data.data, reg3, reg3_data.data, reg4, result_data.data);
+
+	cpu->reg.pc += 4;
+    
+    return 0;
+}
+int op_exec_msubf_s_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg1 = cpu->decoded_code->type_f.reg1;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg1_data;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+    uint32 subopcode = cpu->decoded_code->type_f.subopcode;
+    /* detect reg4 */
+    uint32 reg4 = ((subopcode & 0x1e) | ((subopcode >> 7) & 1));
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+    if ( reg4 >= CPU_GREG_NUM ) {
+        return -1;
+    }
+	reg1_data.binary = cpu->reg.r[reg1];
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    // TODO: Full NaN/finite operation
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand(cpu, &fpu_config, &reg1_data);
+        set_subnormal_operand(cpu, &fpu_config, &reg2_data);
+        set_subnormal_operand(cpu, &fpu_config, &reg3_data);
+        result_data.data = reg2_data.data * reg1_data.data - reg3_data.data;
+        set_subnormal_result(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: MSUB.S_F r%d(%f),r%d(%f),r%d(%f) r%d:%f\n", 
+        cpu->reg.pc, reg1, reg1_data.data, reg2, reg2_data.data, reg3, reg3_data.data, reg4, result_data.data));
+	cpu->reg.r[reg4] = result_data.binary;
+
+	cpu->reg.pc += 4;
+    
+    return 0;
+}
+int op_exec_nmaddf_s_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg1 = cpu->decoded_code->type_f.reg1;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg1_data;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+    uint32 subopcode = cpu->decoded_code->type_f.subopcode;
+    /* detect reg4 */
+    uint32 reg4 = ((subopcode & 0x1e) | ((subopcode >> 7) & 1));
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+    if ( reg4 >= CPU_GREG_NUM ) {
+        return -1;
+    }
+	reg1_data.binary = cpu->reg.r[reg1];
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    // TODO: Full NaN/finite operation
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand(cpu, &fpu_config, &reg1_data);
+        set_subnormal_operand(cpu, &fpu_config, &reg2_data);
+        set_subnormal_operand(cpu, &fpu_config, &reg3_data);
+        result_data.data = -(reg2_data.data * reg1_data.data + reg3_data.data);
+        set_subnormal_result(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: NMADD.S_F r%d(%f),r%d(%f),r%d(%f) r%d:%f\n", 
+        cpu->reg.pc, reg1, reg1_data.data, reg2, reg2_data.data, reg3, reg3_data.data, reg4, result_data.data));
+
+	cpu->reg.r[reg4] = result_data.binary;
+
+	cpu->reg.pc += 4;
+    
+    return 0;
+
+}
+int op_exec_nmsubf_s_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg1 = cpu->decoded_code->type_f.reg1;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg1_data;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+    uint32 subopcode = cpu->decoded_code->type_f.subopcode;
+    /* detect reg4 */
+    uint32 reg4 = ((subopcode & 0x1e) | ((subopcode >> 7) & 1));
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+    if ( reg4 >= CPU_GREG_NUM ) {
+        return -1;
+    }
+	reg1_data.binary = cpu->reg.r[reg1];
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    // TODO: Full NaN/finite operation
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand(cpu, &fpu_config, &reg1_data);
+        set_subnormal_operand(cpu, &fpu_config, &reg2_data);
+        set_subnormal_operand(cpu, &fpu_config, &reg3_data);
+        result_data.data = -(reg2_data.data * reg1_data.data - reg3_data.data);
+        set_subnormal_result(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: MSUB.S_F r%d(%f),r%d(%f),r%d(%f) r%d:%f\n", 
+        cpu->reg.pc, reg1, reg1_data.data, reg2, reg2_data.data, reg3, reg3_data.data, reg4, result_data.data));
+	cpu->reg.r[reg4] = result_data.binary;
+	cpu->reg.pc += 4;
+    
+    return 0;
+
+}
+
+int op_exec_absf_d_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+    DoubleBinaryDataType reg2_data;
+    DoubleBinaryDataType result_data;
+
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+    reg2_data.binary[0] = cpu->reg.r[reg2_0];
+	reg2_data.binary[1] = cpu->reg.r[reg2_1];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand_double(cpu, &fpu_config, &reg2_data);
+        result_data.data = reg2_data.data;
+        DOUBLE_SIGN_BIT_CLR(result_data);
+        set_subnormal_result_double(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: ABSF_D r%d(%lf) : r%d :%lf\n",
+        cpu->reg.pc, reg2_0, reg2_data.data, reg3_0,result_data.data));
+//	printf( "0x%x: ABSF_D r%d(%lf) r%d(%lf) :%lf\n", cpu->reg.pc, reg2_0, reg2_data.data, reg3_0, reg3_data.data,result_data.data);
+	cpu->reg.r[reg3_0] = result_data.binary[0];
+	cpu->reg.r[reg3_1] = result_data.binary[1];
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+int op_exec_ceilf_dl_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+    DoubleBinaryDataType reg2_data;
+    sint64 result_data;
+
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+    reg2_data.binary[0] = cpu->reg.r[reg2_0];
+	reg2_data.binary[1] = cpu->reg.r[reg2_1];
+    // TODO:Overflow
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand_double(cpu, &fpu_config, &reg2_data);
+        result_data = (sint64)reg2_data.data;
+    }
+    end_float_op(cpu, &ex);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CEILF.DL r%d(%lf) : r%d :%lld\n",
+        cpu->reg.pc, reg2_0, reg2_data.data, reg3_0,result_data));
+//	printf( "0x%x: CEILF.DL r%d(%lf) r%d :%lld\n",cpu->reg.pc, reg2_0, reg2_data.data, reg3_0,result_data);
+	cpu->reg.r[reg3_0] = (uint32)(result_data>>32);
+	cpu->reg.r[reg3_1] = (uint32)(result_data & 0xffffffff);
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+int op_exec_ceilf_dul_F(TargetCoreType *cpu)
+{
+    // double float -> unsigned 64
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+    DoubleBinaryDataType reg2_data;
+    uint64 result_data;
+
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+    reg2_data.binary[0] = cpu->reg.r[reg2_0];
+	reg2_data.binary[1] = cpu->reg.r[reg2_1];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+
+        uint64 result;
+        bool is_invalid = TRUE;
+        if (DOUBLE_IS_NAN(reg2_data) || DOUBLE_IS_INF(reg2_data)) {
+            if (DOUBLE_IS_PLUS(reg2_data) && DOUBLE_IS_INF(reg2_data)) {
+                result = (uint64)ULONG_MAX;
+            }
+            else {
+                result = (uint64)0;
+            }
+        } else if ( trunc(reg2_data.data) < 0 ) {
+            result = (uint64)0;
+        } else if ( trunc(reg2_data.data) > (uint64)ULONG_MAX) {
+            result = (uint64)ULONG_MAX;
+        } else {
+            result = trunc(reg2_data.data);
+            is_invalid = FALSE;
+        }
+        if (is_invalid) {
+            sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_V);
+            sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_V);
+        }
+        result_data  = (uint64)result;
+
+    }
+    end_float_op(cpu, &ex);
+
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CEILF.DUL r%d(%lf) : r%d :%llu\n",
+        cpu->reg.pc, reg2_0, reg2_data.data, reg3_0,result_data));
+//	printf( "0x%x: CEILF.DUL r%d(%lf) r%d :%llu\n",  cpu->reg.pc, reg2_0, reg2_data.data, reg3_0,result_data);
+	cpu->reg.r[reg3_0] = (uint32)(result_data>>32);
+	cpu->reg.r[reg3_1] = (uint32)(result_data & 0xffffffff);
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+
+int op_exec_ceilf_duw_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+   	uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    DoubleBinaryDataType reg2_data;
+    sint32 result_data;
+    sint32 reg3_data;
+
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+    if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data.binary[0] = cpu->reg.r[reg2_0];
+	reg2_data.binary[1] = cpu->reg.r[reg2_1];
+	reg3_data = cpu->reg.r[reg3];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand_double(cpu, &fpu_config, &reg2_data);
+        result_data = (sint32)trunc(reg2_data.data);
+    }
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CEILF.DW r%d(%lf),r%d(%d):%d\n", 
+        cpu->reg.pc, reg2_0, reg2_data.data, reg3, reg3_data, result_data));
+//	printf("0x%x: CEILF.DW r%d(%lf),r%d(%d):%d\n",     cpu->reg.pc, reg2_0, reg2_data.data, reg3, reg3_data, result_data);
+
+    cpu->reg.r[reg3] = result_data;
+	cpu->reg.pc += 4;
+    return 0;
+
+}
+int op_exec_ceilf_dw_F(TargetCoreType *cpu)
+{
+	printf("ERROR: not supported:%s\n", __FUNCTION__);
+	return -1;
+}
+int op_exec_cmovf_d_F(TargetCoreType *cpu)
+{
+    uint32 reg1_0 = cpu->decoded_code->type_f.reg1;
+	uint32 reg1_1 = cpu->decoded_code->type_f.reg1 + 1;
+	uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+    uint32 fcbit = ( (cpu->decoded_code->type_f.subopcode & 0x0000000F) >> 1U );
+    DoubleBinaryDataType reg1_data;
+    DoubleBinaryDataType reg2_data;
+    DoubleBinaryDataType reg3_data;
+    DoubleBinaryDataType result_data;
+    uint8 data;
+
+	if (reg1_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg1_data.binary[0] = cpu->reg.r[reg1_0];
+	reg1_data.binary[1] = cpu->reg.r[reg1_1];
+	reg2_data.binary[0] = cpu->reg.r[reg2_0];
+	reg2_data.binary[1] = cpu->reg.r[reg2_1];
+	reg3_data.binary[0] = cpu->reg.r[reg3_0];
+	reg3_data.binary[1] = cpu->reg.r[reg3_1];
+
+    data = sys_get_fpsr_cc(&cpu->reg);
+    if ((data & (1U << (uint8)fcbit)) != 0) {
+        result_data.data = reg1_data.data;
+    }
+    else {
+        result_data.data = reg2_data.data;
+    }
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CMOVF_D fcbit(%u) r%d(%lf),r%d(%lf),r%d(%lf):%lf\n", 
+        cpu->reg.pc, fcbit, reg1_0, reg1_data.data, reg2_0, reg2_data.data, reg3_0, reg3_data.data, result_data.data));
+//    printf("0x%x: CMOVF_D fcbit(%u) r%d(%lf),r%d(%lf),r%d(%lf):%lf\n",  cpu->reg.pc, fcbit, reg1_0, reg1_data.data, reg2_0, reg2_data.data, reg3_0, reg3_data.data, result_data.data);
+	cpu->reg.r[reg3_0] = result_data.binary[0];
+	cpu->reg.r[reg3_1] = result_data.binary[1];
+
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+int op_exec_cmpf_d_F(TargetCoreType *cpu)
+{
+	uint32 reg1_0 = cpu->decoded_code->type_f.reg1;
+	uint32 reg1_1 = cpu->decoded_code->type_f.reg1 + 1;
+	uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 fcond = cpu->decoded_code->type_f.reg3;
+    uint32 fcbit = ( (cpu->decoded_code->type_f.subopcode & 0x0000000F) >> 1U );
+    DoubleBinaryDataType reg1_data;
+    DoubleBinaryDataType reg2_data;
+    bool result_less;
+    bool result_equal;
+    bool result_unordered;
+    uint32 result_data;
+    uint8 data;
+
+	if (reg1_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+  	reg1_data.binary[0] = cpu->reg.r[reg1_0];
+	reg1_data.binary[1] = cpu->reg.r[reg1_1];
+	reg2_data.binary[0] = cpu->reg.r[reg2_0];
+	reg2_data.binary[1] = cpu->reg.r[reg2_1];
+
+    /*
+    * if isNaN(reg1) or isNaN(reg2) then
+    * result.less ← 0
+    * result.equal ← 0
+    * result.unordered ← 1
+    * if fcond[3] == 1 then
+    * 無効演算例外を検出
+    * endif
+    * else
+    * result.less ← reg2 < reg1
+    * result.equal ← reg2 == reg1
+    * result.unordered ← 0
+    * endif
+    * FPSR.CCn ← (fcond[2] & result.less) | (fcond[1] & result.equal) |
+    * (fcond[0] & result.unordered)
+    */
+    if (DOUBLE_IS_NAN(reg1_data) || DOUBLE_IS_NAN(reg2_data)) {
+        result_less = FALSE;
+        result_equal = FALSE;
+        result_unordered = TRUE;
+        if ((fcond & 0x00000008) != 0) {
+            sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_V);
+            sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_V);
+        }
+    }
+    else {
+        result_less = (reg2_data.data < reg1_data.data);
+        result_equal = (reg2_data.data == reg1_data.data);
+        result_unordered = FALSE;
+    }
+    result_data =   (result_less << 2U) |
+                    (result_equal << 1U) |
+                    (result_unordered << 0U);
+    data = sys_get_fpsr_cc(&cpu->reg);
+    if ((result_data & (fcond & 0x00000007)) != 0) {
+        data |= (1U << (uint8)fcbit);
+    }
+    else {
+        data &= ~(1U << (uint8)fcbit);
+    }
+    sys_set_fpsr_cc(&cpu->reg,  data);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CMPF_D r%d(%lf),r%d(%lf),fcond(0x%x), fcbit(%d):0x%x\n", 
+        cpu->reg.pc, reg1_0, reg1_data.data, reg2_0, reg2_data.data, fcond, fcbit, data));
+//	printf("0x%x: CMPF_D r%d(%lf),r%d(%lf),fcond(0x%x), fcbit(%d):0x%x\n",  cpu->reg.pc, reg1_0, reg1_data.data, reg2_0, reg2_data.data, fcond, fcbit, data);
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+int op_exec_cvtf_dl_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+    DoubleBinaryDataType reg2_data;
+    sint64 result_data;
+
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data.binary[0] = cpu->reg.r[reg2_0];
+	reg2_data.binary[1] = cpu->reg.r[reg2_1];
+
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand_double(cpu, &fpu_config, &reg2_data);
+        result_data = (sint64)reg2_data.data;
+    }
+    end_float_op(cpu, &ex);   
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CVTF.DL r%d(%lf),r%d:%lld\n", 
+        cpu->reg.pc, reg2_0, reg2_data.data, reg3_0, result_data));
+//    printf( "0x%x: CVTF.DL r%d(%lf),r%d:%lld\n", cpu->reg.pc, reg2_0, reg2_data.data, reg3_0, result_data);
+
+    cpu->reg.r[reg3_0] = (uint32)(result_data >> 32);
+    cpu->reg.r[reg3_1] = (uint32)(result_data & 0xffffffff);
+	cpu->reg.pc += 4;
+    return 0;
+
+}
+int op_exec_cvtf_dul_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+    DoubleBinaryDataType reg2_data;
+    uint64 result_data;
+
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data.binary[0] = cpu->reg.r[reg2_0];
+	reg2_data.binary[1] = cpu->reg.r[reg2_1];
+
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand_double(cpu, &fpu_config, &reg2_data);
+        result_data = (uint64)reg2_data.data;
+    }
+    end_float_op(cpu, &ex);   
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CVTF.DUL r%d(%lf),r%d:%llu\n", 
+        cpu->reg.pc, reg2_0, reg2_data.data, reg3_0, result_data));
+//	printf("0x%x: CVTF.DUL r%d(%lf),r%d:%llu\n",  cpu->reg.pc, reg2_0, reg2_data.data, reg3_0, result_data);
+
+    cpu->reg.r[reg3_0] = (uint32)(result_data >> 32);
+    cpu->reg.r[reg3_1] = (uint32)(result_data & 0xffffffff);
+	cpu->reg.pc += 4;
+    return 0;
+}
+
+int op_exec_cvtf_duw_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3   = cpu->decoded_code->type_f.reg3;
+    DoubleBinaryDataType reg2_data;
+    uint32 result_data;
+
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data.binary[0] = cpu->reg.r[reg2_0];
+	reg2_data.binary[1] = cpu->reg.r[reg2_1];
+
+    // TODO:Overflow / Nan
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand_double(cpu, &fpu_config, &reg2_data);
+        result_data = (uint32)reg2_data.data;
+    }
+    end_float_op(cpu, &ex);   
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CVTF.DUW r%d(%lf),r%d:%u\n", 
+        cpu->reg.pc, reg2_0, reg2_data.data, reg3, result_data));
+//    printf("0x%x: CVTF.DUW r%d(%lf),r%d:%u\n",  cpu->reg.pc, reg2_0, reg2_data.data, reg3, result_data);
+
+    cpu->reg.r[reg3] = (uint32)result_data;
+	cpu->reg.pc += 4;
+    return 0;
+}
+int op_exec_cvtf_dw_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3   = cpu->decoded_code->type_f.reg3;
+    DoubleBinaryDataType reg2_data;
+    sint32 result_data;
+
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data.binary[0] = cpu->reg.r[reg2_0];
+	reg2_data.binary[1] = cpu->reg.r[reg2_1];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand_double(cpu, &fpu_config, &reg2_data);
+        result_data = (sint32)reg2_data.data;
+    }
+    end_float_op(cpu, &ex);   
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CVTF.DUW r%d(%lf),r%d:%d\n", 
+        cpu->reg.pc, reg2_0, reg2_data.data, reg3, result_data));
+//    printf("0x%x: CVTF.DUW r%d(%lf),r%d:%d\n",  cpu->reg.pc, reg2_0, reg2_data.data, reg3, result_data);
+
+    cpu->reg.r[reg3] = (sint32)result_data;
+	cpu->reg.pc += 4;
+    return 0;
+
+}
+int op_exec_cvtf_ld_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+    sint64 reg2_data;
+    DoubleBinaryDataType result_data;
+
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data = (uint64)((uint64)(cpu->reg.r[reg2_0])<<32 | cpu->reg.r[reg2_1]);
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        result_data.data = (double)reg2_data;
+        set_subnormal_result_double(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);   
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CVTF.LD r%d(%lld),r%d:%lf\n", 
+        cpu->reg.pc, reg2_0, reg2_data, reg3_0, result_data.data));
+//    printf("0x%x: CVTF.LD r%d(%lld),r%d:%lf\n", cpu->reg.pc, reg2_0, reg2_data, reg3_0, result_data.data);
+
+    cpu->reg.r[reg3_0] = (uint32)result_data.binary[0];
+    cpu->reg.r[reg3_1] = (uint32)result_data.binary[1];
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+int op_exec_cvtf_uld_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+    uint64 reg2_data;
+    DoubleBinaryDataType result_data;
+
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data = (uint64)((uint64)(cpu->reg.r[reg2_0])<<32 | cpu->reg.r[reg2_1]);
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        result_data.data = (double)reg2_data;
+        set_subnormal_result_double(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);   
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CVTF.ULD r%d(%llu),r%d:%lf\n", 
+        cpu->reg.pc, reg2_0, reg2_data, reg3_0, result_data.data));
+//    printf("0x%x: CVTF.ULD r%d(%llu),r%d:%lf\n", cpu->reg.pc, reg2_0, reg2_data, reg3_0, result_data.data);
+
+    cpu->reg.r[reg3_0] = (uint32)result_data.binary[0];
+    cpu->reg.r[reg3_1] = (uint32)result_data.binary[1];
+
+	cpu->reg.pc += 4;
+    return 0;
+
+}
+int op_exec_cvtf_uwd_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2   = cpu->decoded_code->type_f.reg2;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+    uint32  reg2_data;
+    DoubleBinaryDataType reg3_data;
+    DoubleBinaryDataType result_data;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data          = (uint32)cpu->reg.r[reg2];
+	reg3_data.binary[0] = cpu->reg.r[reg3_0];
+	reg3_data.binary[1] = cpu->reg.r[reg3_1];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        result_data.data = (double)reg2_data;
+        set_subnormal_result_double(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CVTF.UWD r%d(%u),r%d(%lf):%lf\n",
+        cpu->reg.pc, reg2,reg2_data, reg3_0, reg3_data.data,result_data.data));
+//	printf("0x%x: CVTF.UWD r%d(%u),r%d(%lf):%lf\n", cpu->reg.pc, reg2,reg2_data, reg3_0, reg3_data.data, result_data.data);
+	cpu->reg.r[reg3_0] = (uint32)result_data.binary[0];
+	cpu->reg.r[reg3_1] = (uint32)result_data.binary[1];
+	cpu->reg.pc += 4;
+    return 0;
+}
+int op_exec_cvtf_wd_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2   = cpu->decoded_code->type_f.reg2;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+    sint32  reg2_data;
+    DoubleBinaryDataType reg3_data;
+    DoubleBinaryDataType result_data;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data          = cpu->reg.r[reg2];
+	reg3_data.binary[0] = cpu->reg.r[reg3_0];
+	reg3_data.binary[1] = cpu->reg.r[reg3_1];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        result_data.data = (double)reg2_data;
+        set_subnormal_result_double(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CVTF.WD r%d(%d),r%d(%lf):%lf\n",
+        cpu->reg.pc, reg2,reg2_data, reg3_0, reg3_data.data,result_data.data));
+//	printf("0x%x: CVTF.WD r%d(%d),r%d(%lf):%lf\n", cpu->reg.pc, reg2,reg2_data, reg3_0, reg3_data.data, result_data.data);
+	cpu->reg.r[reg3_0] = result_data.binary[0];
+	cpu->reg.r[reg3_1] = result_data.binary[1];
+	cpu->reg.pc += 4;
+    return 0;
+}
+int op_exec_divf_d_F(TargetCoreType *cpu)
+{
+        FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg1_0 = cpu->decoded_code->type_f.reg1;
+	uint32 reg1_1 = cpu->decoded_code->type_f.reg1 + 1;
+	uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+    DoubleBinaryDataType reg1_data;
+    DoubleBinaryDataType reg2_data;
+    DoubleBinaryDataType reg3_data;
+    DoubleBinaryDataType result_data;
+
+	if (reg1_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg1_data.binary[0] = cpu->reg.r[reg1_0];
+	reg1_data.binary[1] = cpu->reg.r[reg1_1];
+	reg2_data.binary[0] = cpu->reg.r[reg2_0];
+	reg2_data.binary[1] = cpu->reg.r[reg2_1];
+	reg3_data.binary[0] = cpu->reg.r[reg3_0];
+	reg3_data.binary[1] = cpu->reg.r[reg3_1];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand_double(cpu, &fpu_config, &reg1_data);
+        set_subnormal_operand_double(cpu, &fpu_config, &reg2_data);
+        result_data.data = reg2_data.data / reg1_data.data;
+        set_subnormal_result_double(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: DIVF_D r%d(%lf),r%d(%lf),r%d(%lf):%lf\n",
+        cpu->reg.pc, reg1_0, reg1_data.data, reg2_0, reg2_data.data, reg3_0, reg3_data.data, result_data.data));
+//	printf("0x%x: DIVF_D r%d(%lf),r%d(%lf),r%d(%lf):%lf\n", cpu->reg.pc, reg1_0, reg1_data.data, reg2_0, reg2_data.data, reg3_0, reg3_data.data, result_data.data);
+
+	cpu->reg.r[reg3_0] = result_data.binary[0];
+	cpu->reg.r[reg3_1] = result_data.binary[1];
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+int op_exec_floorf_dl_F(TargetCoreType *cpu)
+{
+	printf("ERROR: not supported:%s\n", __FUNCTION__);
+	return -1;
+}
+int op_exec_floorf_dul_F(TargetCoreType *cpu)
+{
+	printf("ERROR: not supported:%s\n", __FUNCTION__);
+	return -1;
+}
+int op_exec_floorf_duw_F(TargetCoreType *cpu)
+{
+	printf("ERROR: not supported:%s\n", __FUNCTION__);
+	return -1;
+}
+int op_exec_floorf_dw_F(TargetCoreType *cpu)
+{
+	printf("ERROR: not supported:%s\n", __FUNCTION__);
+	return -1;
+}
+int op_exec_maxf_d_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg1_0 = cpu->decoded_code->type_f.reg1;
+	uint32 reg1_1 = cpu->decoded_code->type_f.reg1 + 1;
+	uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+
+    DoubleBinaryDataType reg1_data;
+    DoubleBinaryDataType reg2_data;
+    DoubleBinaryDataType result_data;
+
+	if (reg1_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg1_data.binary[0] = cpu->reg.r[reg1_0];
+	reg1_data.binary[1] = cpu->reg.r[reg1_1];
+	reg2_data.binary[0] = cpu->reg.r[reg2_0];
+	reg2_data.binary[1] = cpu->reg.r[reg2_1];
+ 
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        DoubleBinaryDataType result;
+        bool is_invalid = FALSE;
+        if ( double_is_snan(reg1_data) || double_is_snan(reg2_data)){
+            double_get_qnan(&result);
+            is_invalid = TRUE;
+        } else if ( double_is_qnan(reg1_data) || double_is_qnan(reg2_data)) {
+            double_get_qnan(&result);
+        } else {
+            if ( reg1_data.data > reg2_data.data ) {
+                result = reg1_data;
+            } else {
+                result = reg2_data;
+            }
+        }
+        if (is_invalid) {
+            sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_V);
+            sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_V);
+        }
+        result_data = result;
+    }
+    end_float_op(cpu, &ex);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: MAXF.D r%d(%lf),r%d(%ff) r%d:%lf\n", 
+        cpu->reg.pc, reg1_0, reg1_data.data, reg2_0, reg2_data.data, reg3_0, result_data.data));
+//	printf( "0x%x: MAXF.D r%d(%lf),r%d(%ff) r%d:%lf\n", cpu->reg.pc, reg1_0, reg1_data.data, reg2_0, reg2_data.data, reg3_0, result_data.data);
+
+	cpu->reg.r[reg3_0] = result_data.binary[0];
+	cpu->reg.r[reg3_1] = result_data.binary[1];
+    cpu->reg.pc += 4;
+    return 0;
+
+	
+}
+int op_exec_minf_d_F(TargetCoreType *cpu)
+{
+	uint32 reg1_0 = cpu->decoded_code->type_f.reg1;
+	uint32 reg1_1 = cpu->decoded_code->type_f.reg1 + 1;
+	uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+    DoubleBinaryDataType reg1_data;
+    DoubleBinaryDataType reg2_data;
+    DoubleBinaryDataType reg3_data;
+    DoubleBinaryDataType result_data;
+
+	if (reg1_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg1_data.binary[0] = cpu->reg.r[reg1_0];
+	reg1_data.binary[1] = cpu->reg.r[reg1_1];
+	reg2_data.binary[0] = cpu->reg.r[reg2_0];
+	reg2_data.binary[1] = cpu->reg.r[reg2_1];
+	reg3_data.binary[0] = cpu->reg.r[reg3_0];
+	reg3_data.binary[1] = cpu->reg.r[reg3_1];
+
+    if (double_is_snan(reg1_data) || double_is_snan(reg2_data)) {
+        sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_V);
+        sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_V);
+        double_get_qnan(&result_data);
+    }
+    else {
+        if (reg1_data.data < reg2_data.data) {
+            result_data.data = reg1_data.data;
+        }
+        else {
+            result_data.data = reg2_data.data;
+        }
+    }
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: MIN_D r%d(%lf),r%d(%lf),r%d(%lf):%lf\n", 
+        cpu->reg.pc, reg1_0, reg1_data.data, reg2_0, reg2_data.data, reg3_0, reg3_data.data, result_data.data));
+//	printf("0x%x: MIN_D r%d(%lf),r%d(%lf),r%d(%lf):%lf\n", cpu->reg.pc, reg1_0, reg1_data.data, reg2_0, reg2_data.data, reg3_0, reg3_data.data, result_data.data);
+
+	cpu->reg.r[reg3_0] = result_data.binary[0];
+	cpu->reg.r[reg3_1] = result_data.binary[1];
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+int op_exec_negf_d_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+    DoubleBinaryDataType reg2_data; 
+    DoubleBinaryDataType reg3_data; 
+    DoubleBinaryDataType result_data;
+
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data.binary[0] = cpu->reg.r[reg2_0];
+	reg2_data.binary[1] = cpu->reg.r[reg2_1];
+	reg3_data.binary[0] = cpu->reg.r[reg3_0];
+	reg3_data.binary[1] = cpu->reg.r[reg3_1];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        if ( double_is_qnan(reg2_data) ) {
+            double_get_qnan(&result_data);
+        } else if ( double_is_snan(reg2_data) ) {
+            double_get_snan(&result_data);
+            sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_V);
+            sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_V);
+        } else {
+            result_data = reg2_data;
+            DOUBLE_SET_SIGN_REVERSE(result_data);
+        }
+    }
+    end_float_op(cpu, &ex);
+    DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: NEGF.D r%d(%lf),r%d(%lf):%lf\n", 
+        cpu->reg.pc, reg2_0, reg2_data.data, reg3_0, reg3_data.data, result_data.data));
+//    printf("0x%x: NEGF.D r%d(%lf),r%d(%lf):%lf\n", cpu->reg.pc, reg2_0, reg2_data.data, reg3_0, reg3_data.data, result_data.data);
+    
+    cpu->reg.r[reg3_0] = result_data.binary[0];
+	cpu->reg.r[reg3_1] = result_data.binary[1];
+	cpu->reg.pc += 4;
+    return 0;
+}
+int op_exec_recipf_s_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        if ( float_is_qnan(reg2_data)) {
+            float_get_qnan(&result_data);
+        } else if ( float_is_snan(reg2_data)) {
+            float_get_snan(&result_data);
+            sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_V);
+            sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_V);
+        } else if ( FLOAT_IS_INF(reg2_data) ) {
+            result_data.data = 0;
+            if ( FLOAT_IS_MINUS(reg2_data)){
+                // returns minus 0
+                FLOAT_SIGN_BIT_SET(reg2_data);
+            }
+        } else if ( FLOAT_IS_ZERO(reg2_data) ) {
+            result_data.data = INFINITY;
+            if ( FLOAT_IS_MINUS(reg2_data)){
+                // returns minus inifite
+                FLOAT_SIGN_BIT_SET(reg2_data);
+            }
+            sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_Z);
+            sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_Z);
+        } else {
+            result_data.data = (float)1/reg2_data.data;
+        }
+    }
+    end_float_op(cpu, &ex);
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: RECIPF.S r%d(%f),r%d(%f):%f\n", 
+        cpu->reg.pc, reg2, reg2_data.data, reg3, reg3_data.data, result_data.data));
+//	printf("0x%x: RECIPF.S r%d(%f),r%d(%f):%f\n", cpu->reg.pc, reg2, reg2_data.data, reg3, reg3_data.data, result_data.data);
+
+	cpu->reg.r[reg3] = result_data.binary;
+
+	cpu->reg.pc += 4;
+    return 0;
+
+}
+
+int op_exec_recipf_d_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+    uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+    DoubleBinaryDataType reg2_data;
+    DoubleBinaryDataType reg3_data;
+    DoubleBinaryDataType result_data;
+
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	reg2_data.binary[0] = cpu->reg.r[reg2_0];
+	reg2_data.binary[1] = cpu->reg.r[reg2_1];
+	reg3_data.binary[0] = cpu->reg.r[reg3_0];
+	reg3_data.binary[1] = cpu->reg.r[reg3_1];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        if ( double_is_qnan(reg2_data)) {
+            double_get_qnan(&result_data);
+        } else if ( double_is_snan(reg2_data)) {
+            double_get_snan(&result_data);
+            sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_V);
+            sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_V);
+        } else if ( DOUBLE_IS_INF(reg2_data) ) {
+            result_data.data = 0;
+            if ( DOUBLE_IS_MINUS(reg2_data)){
+                // returns minus 0
+                DOUBLE_SIGN_BIT_SET(reg2_data);
+            }
+        } else if ( DOUBLE_IS_ZERO(reg2_data) ) {
+            result_data.data = (double)INFINITY;
+            if ( DOUBLE_IS_MINUS(reg2_data)){
+                // returns minus inifite
+                DOUBLE_SIGN_BIT_SET(reg2_data);
+            }
+            sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_Z);
+            sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_Z);
+        } else {
+            result_data.data = (double)1/reg2_data.data;
+        }
+    }
+    end_float_op(cpu, &ex);
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: RECIPF.D r%d(%lf),r%d(%fl):%lf\n", 
+        cpu->reg.pc, reg2_0, reg2_data.data, reg3_0, reg3_data.data, result_data.data));
+//	printf("0x%x: RECIPF.D r%d(%lf),r%d(%lf):%lf\n", cpu->reg.pc, reg2_0, reg2_data.data, reg3_0, reg3_data.data, result_data.data);
+
+	cpu->reg.r[reg3_0] = result_data.binary[0];
+	cpu->reg.r[reg3_1] = result_data.binary[1];
+	cpu->reg.pc += 4;
+
+    return 0;
+
+}
+int op_exec_rsqrtf_d_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+    uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+    DoubleBinaryDataType reg2_data;
+    DoubleBinaryDataType reg3_data;
+    DoubleBinaryDataType result_data;
+
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	reg2_data.binary[0] = cpu->reg.r[reg2_0];
+	reg2_data.binary[1] = cpu->reg.r[reg2_1];
+	reg3_data.binary[0] = cpu->reg.r[reg3_0];
+	reg3_data.binary[1] = cpu->reg.r[reg3_1];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand_double(cpu, &fpu_config, &reg2_data);
+        result_data.data = 1/sqrt(reg2_data.data);
+        set_subnormal_result_double(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: RSQRTF.D r%d(%lf),r%d(%fl):%lf\n", 
+        cpu->reg.pc, reg2_0, reg2_data.data, reg3_0, reg3_data.data, result_data.data));
+//	printf("0x%x: RSQRF.D r%d(%lf),r%d(%lf):%lf\n", cpu->reg.pc, reg2_0, reg2_data.data, reg3_0, reg3_data.data, result_data.data);
+
+	cpu->reg.r[reg3_0] = result_data.binary[0];
+	cpu->reg.r[reg3_1] = result_data.binary[1];
+	cpu->reg.pc += 4;
+
+    return 0;
+
+    
+}
+int op_exec_sqrtf_d_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+    uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+    DoubleBinaryDataType reg2_data;
+    DoubleBinaryDataType reg3_data;
+    DoubleBinaryDataType result_data;
+
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	reg2_data.binary[0] = cpu->reg.r[reg2_0];
+	reg2_data.binary[1] = cpu->reg.r[reg2_1];
+	reg3_data.binary[0] = cpu->reg.r[reg3_0];
+	reg3_data.binary[1] = cpu->reg.r[reg3_1];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand_double(cpu, &fpu_config, &reg2_data);
+        result_data.data = sqrt(reg2_data.data);
+        set_subnormal_result_double(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SQRTF.D r%d(%lf),r%d(%fl):%lf\n", 
+        cpu->reg.pc, reg2_0, reg2_data.data, reg3_0, reg3_data.data, result_data.data));
+//	printf("0x%x: SQRF.D r%d(%lf),r%d(%lf):%lf\n", cpu->reg.pc, reg2_0, reg2_data.data, reg3_0, reg3_data.data, result_data.data);
+
+	cpu->reg.r[reg3_0] = result_data.binary[0];
+	cpu->reg.r[reg3_1] = result_data.binary[1];
+	cpu->reg.pc += 4;
+
+    return 0;
+}
+int op_exec_subf_d_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg1_0 = cpu->decoded_code->type_f.reg1;
+	uint32 reg1_1 = cpu->decoded_code->type_f.reg1 + 1;
+	uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+    DoubleBinaryDataType reg1_data;
+    DoubleBinaryDataType reg2_data;
+    DoubleBinaryDataType reg3_data;
+    DoubleBinaryDataType result_data;
+
+	if (reg1_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg1_data.binary[0] = cpu->reg.r[reg1_0];
+	reg1_data.binary[1] = cpu->reg.r[reg1_1];
+	reg2_data.binary[0] = cpu->reg.r[reg2_0];
+	reg2_data.binary[1] = cpu->reg.r[reg2_1];
+	reg3_data.binary[0] = cpu->reg.r[reg3_0];
+	reg3_data.binary[1] = cpu->reg.r[reg3_1];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand_double(cpu, &fpu_config, &reg1_data);
+        set_subnormal_operand_double(cpu, &fpu_config, &reg2_data);
+        result_data.data = reg2_data.data - reg1_data.data;
+        set_subnormal_result_double(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SUBF_D r%d(%lf),r%d(%lf),r%d(%lf):%lf\n",
+        cpu->reg.pc, reg1_0, reg1_data.data, reg2_0, reg2_data.data, reg3_0, reg3_data.data, result_data.data));
+//	printf("0x%x: SUBF_D r%d(%lf),r%d(%lf),r%d(%lf):%lf\n",cpu->reg.pc, reg1_0, reg1_data.data, reg2_0, reg2_data.data, reg3_0, reg3_data.data, result_data.data);
+
+	cpu->reg.r[reg3_0] = result_data.binary[0];
+	cpu->reg.r[reg3_1] = result_data.binary[1];
+
+	cpu->reg.pc += 4;
+    return 0;
+
+}
+int op_exec_trncf_dl_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+    DoubleBinaryDataType reg2_data;
+    sint64 result_data;
+
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+    reg2_data.binary[0] = cpu->reg.r[reg2_0];
+	reg2_data.binary[1] = cpu->reg.r[reg2_1];
+    // TODO:Overflow
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        sint64 result;
+        bool is_invalid = FALSE;
+        if (DOUBLE_IS_NAN(reg2_data) || DOUBLE_IS_INF(reg2_data)) {
+            if (DOUBLE_IS_PLUS(reg2_data)) {
+                result = (sint64)LONG_MAX;
+            }
+            else {
+                result = (sint64)( -((sint64)LONG_MAX) );
+            }
+            is_invalid = TRUE;
+        }
+        else {
+            result = (sint64)trunc(reg2_data.data);
+            if ( result < ((sint64)( -((sint64)LONG_MAX))) ) {
+                result = (sint64)( -((sint64)LONG_MAX) );
+                is_invalid = TRUE;
+            } 
+            else if (result > ((sint64)LONG_MAX)) {
+                result = (sint64)LONG_MAX;
+                is_invalid = TRUE;
+            }
+        }
+        if (is_invalid) {
+            sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_V);
+            sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_V);
+        }
+        result_data = (sint64)result;
+    }
+    end_float_op(cpu, &ex);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: TRNCF.DL r%d(%lf) : r%d :%lld\n",
+        cpu->reg.pc, reg2_0, reg2_data.data, reg3_0,result_data));
+//	printf( "0x%x: TRNCF.DL r%d(%lf) r%d :%lld\n", cpu->reg.pc, reg2_0, reg2_data.data, reg3_0,result_data);
+	cpu->reg.r[reg3_0] = (uint32)(result_data>>32);
+	cpu->reg.r[reg3_1] = (uint32)(result_data & 0xffffffff);
+	cpu->reg.pc += 4;
+
+	return 0;
+
+}
+int op_exec_trncf_dul_F(TargetCoreType *cpu)
+{
+    // Double floating to unsingned long word
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+    DoubleBinaryDataType reg2_data;
+    uint64 result_data;
+
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+    reg2_data.binary[0] = cpu->reg.r[reg2_0];
+	reg2_data.binary[1] = cpu->reg.r[reg2_1];
+ 
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        uint64 result;
+        bool is_invalid = TRUE;
+        if (DOUBLE_IS_NAN(reg2_data)) {
+            result = 0;
+        } else if ( DOUBLE_IS_INF(reg2_data)) {
+            if (DOUBLE_IS_PLUS(reg2_data)) {
+                result = (uint64)ULONG_MAX;
+            } else {
+                result = 0;
+            }
+        } else if ( reg2_data.data < 0 ) {
+            result = 0;
+        } else if ( reg2_data.data > (uint64)ULONG_MAX) {
+            result = (uint64)ULONG_MAX;
+        } else {
+            result = (uint64)trunc(reg2_data.data);
+            is_invalid = FALSE;
+        }
+        if (is_invalid) {
+            sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_V);
+            sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_V);
+        }
+        result_data = (uint64)result;
+    }
+    end_float_op(cpu, &ex);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: TRNCF.DUL r%d(%lf) : r%d :%llu\n",
+        cpu->reg.pc, reg2_0, reg2_data.data, reg3_0,result_data));
+//	printf( "0x%x: TRNCF.DUL r%d(%lf) r%d :%llu\n", cpu->reg.pc, reg2_0, reg2_data.data, reg3_0,result_data);
+	cpu->reg.r[reg3_0] = (uint32)(result_data>>32);
+	cpu->reg.r[reg3_1] = (uint32)(result_data & 0xffffffff);
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+int op_exec_trncf_duw_F(TargetCoreType *cpu)
+{
+    // Double floating to unsingned long word
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3   = cpu->decoded_code->type_f.reg3;
+    DoubleBinaryDataType reg2_data;
+    uint32 result_data;
+
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+    reg2_data.binary[0] = cpu->reg.r[reg2_0];
+	reg2_data.binary[1] = cpu->reg.r[reg2_1];
+ 
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand_double(cpu, &fpu_config, &reg2_data);
+        result_data = (uint32)reg2_data.data;
+    }
+    end_float_op(cpu, &ex);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: TRNCF.DUW r%d(%lf) : r%d :%u\n",
+        cpu->reg.pc, reg2_0, reg2_data.data, reg3,result_data));
+//    printf("0x%x: TRNCF.DW r%d(%lf) : r%d :%u\n", cpu->reg.pc, reg2_0, reg2_data.data, reg3,result_data);
+	cpu->reg.r[reg3] = (uint32)(result_data);
+	cpu->reg.pc += 4;
+
+	return 0;
+
+}
+int op_exec_trncf_dw_F(TargetCoreType *cpu)
+{
+    // Double floating to unsingned long word
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2_0 = cpu->decoded_code->type_f.reg2;
+	uint32 reg2_1 = cpu->decoded_code->type_f.reg2 + 1;
+	uint32 reg3   = cpu->decoded_code->type_f.reg3;
+    DoubleBinaryDataType reg2_data;
+    sint32 result_data;
+
+	if (reg2_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+    reg2_data.binary[0] = cpu->reg.r[reg2_0];
+	reg2_data.binary[1] = cpu->reg.r[reg2_1];
+ 
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand_double(cpu, &fpu_config, &reg2_data);
+        result_data = (sint32)reg2_data.data;
+    }
+    end_float_op(cpu, &ex);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: TRNCF.DW r%d(%lf) : r%d :%d\n",
+        cpu->reg.pc, reg2_0, reg2_data.data, reg3,result_data));
+//    printf("0x%x: TRNCF.DW r%d(%lf) : r%d :%d\n", cpu->reg.pc, reg2_0, reg2_data.data, reg3,result_data);
+	cpu->reg.r[reg3] = (uint32)(result_data);
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+
+int op_exec_trncf_sl_F(TargetCoreType *cpu)
+{
+    // single floating to 64bit fixed-point
+
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+    FloatBinaryDataType reg2_data;
+    sint64 result_data;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+    reg2_data.binary = cpu->reg.r[reg2];
+    
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        bool is_invalid = TRUE;
+        sint64 result;
+        if (FLOAT_IS_NAN(reg2_data) ) {
+            result = (sint64)-LONG_MAX;
+        } else if (FLOAT_IS_INF(reg2_data) ) {
+            result = (sint64)LONG_MAX;
+        } else {
+            result = (sint64)truncf(reg2_data.data);
+            is_invalid = FALSE;
+        }
+        if (is_invalid) {
+            sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_V);
+            sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_V);
+        }
+        result_data = (sint64)result;
+    }
+    end_float_op(cpu, &ex);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: TRNCF.SL r%d(%f) r%d :%lld\n",
+        cpu->reg.pc, reg2, reg2_data.data, reg3_0,result_data));
+//	printf( "0x%x: TRNCF.SL r%d(%f) r%d :%lld\n", cpu->reg.pc, reg2, reg2_data.data, reg3_0,result_data);
+	cpu->reg.r[reg3_0] = (uint32)(result_data>>32);
+	cpu->reg.r[reg3_1] = (uint32)(result_data & 0xffffffff);
+	cpu->reg.pc += 4;
+
+	return 0;
+
+}
+
+int op_exec_trncf_sul_F(TargetCoreType *cpu)
+{
+    // single floating to unsigned 64bit fixed
+
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+    FloatBinaryDataType reg2_data;
+    uint64 result_data;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3_1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+    reg2_data.binary = cpu->reg.r[reg2];
+    
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        bool is_invalid = TRUE;
+        uint64 result;
+        if (FLOAT_IS_NAN(reg2_data) ) {
+            result = 0;
+        } else if (FLOAT_IS_INF(reg2_data) ) {
+            if ( FLOAT_IS_PLUS(reg2_data)) {
+                result = (uint64)ULONG_MAX;
+            } else {   
+                result = 0;
+            }
+        } else {
+            if ( reg2_data.data < 0 ) {
+                result = 0;
+            } else if ( reg2_data.data > (uint64)ULONG_MAX) {
+                result = (uint64)ULONG_MAX;
+            } else {
+                result = (uint64)truncf(reg2_data.data);
+                is_invalid = FALSE;
+            }
+        }
+        if (is_invalid) {
+            sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_V);
+            sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_V);
+        }
+        result_data = (uint64)result;
+    }
+    end_float_op(cpu, &ex);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: TRNCF.SUL r%d(%f) r%d :%llu\n",
+        cpu->reg.pc, reg2, reg2_data.data, reg3_0,result_data));
+//	printf( "0x%x: TRNCF.SUL r%d(%f) r%d :%llu\n", cpu->reg.pc, reg2, reg2_data.data, reg3_0,result_data);
+	cpu->reg.r[reg3_0] = (uint32)(result_data>>32);
+	cpu->reg.r[reg3_1] = (uint32)(result_data & 0xffffffff);
+	cpu->reg.pc += 4;
+
+	return 0;
+
+}
+
+int op_exec_ceilf_sl_F(TargetCoreType *cpu)
+{
+	printf("ERROR: not supported:%s\n", __FUNCTION__);
+	return -1;
+}
+int op_exec_ceilf_sul_F(TargetCoreType *cpu)
+{
+	printf("ERROR: not supported:%s\n", __FUNCTION__);
+	return -1;
+}
+int op_exec_ceilf_suw_F(TargetCoreType *cpu)
+{
+	printf("ERROR: not supported:%s\n", __FUNCTION__);
+	return -1;
+}
+int op_exec_ceilf_sw_F(TargetCoreType *cpu)
+{
+	printf("ERROR: not supported:%s\n", __FUNCTION__);
+	return -1;
+}
+int op_exec_cvtf_sl_F(TargetCoreType *cpu)
+{
+	printf("ERROR: not supported:%s\n", __FUNCTION__);
+	return -1;
+}
+int op_exec_cvtf_sul_F(TargetCoreType *cpu)
+{
+	printf("ERROR: not supported:%s\n", __FUNCTION__);
+	return -1;
+}
+int op_exec_floorf_sl_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+	DoubleBinaryDataType result_data;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand(cpu, &fpu_config, &reg2_data);
+        result_data.data = (float)floorf(reg2_data.data);
+        set_subnormal_result_double(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+	cpu->reg.r[reg3_0] = result_data.binary[0];
+	cpu->reg.r[reg3_1] = result_data.binary[1];
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: FLOORF.S r%d(%f),r%d(%f):%f\n", 
+        cpu->reg.pc, reg2, reg2_data.data, reg3, reg3_data.data, result_data.data));
+	cpu->reg.pc += 4;
+    return 0;
+}
+int op_exec_floorf_sul_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_0 = cpu->decoded_code->type_f.reg3;
+	uint32 reg3_1 = cpu->decoded_code->type_f.reg3 + 1;
+    FloatBinaryDataType reg2_data;
+	uint64 result_data;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	reg2_data.binary = cpu->reg.r[reg2];
+	//reg3_data.binary = cpu->reg.r[reg3];
+
+    // TODO: Overflow and check
+	prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        bool is_invalid = TRUE;
+        uint64 result;
+        if (FLOAT_IS_NAN(reg2_data) ) {
+            result = 0;
+        } else if (FLOAT_IS_INF(reg2_data) ) {
+            if ( FLOAT_IS_PLUS(reg2_data)) {
+                result = (uint64)ULONG_MAX;
+            } else {   
+                result = 0;
+            }
+        } else {
+            if ( reg2_data.data < 0 ) {
+                result = 0;
+            } else if ( reg2_data.data > (uint64)ULONG_MAX) {
+                result = (uint64)ULONG_MAX;
+            } else {
+                (void)floorf(reg2_data.data);
+                result = (uint64)floorf(reg2_data.data);
+                is_invalid = FALSE;
+            }
+        }
+        if (is_invalid) {
+            sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_V);
+            sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_V);
+        }
+        result_data = (uint64)result;
+    }
+    end_float_op(cpu, &ex);
+
+	//DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: FLOORF.SUL r%d(%f) r%d :%llu\n", cpu->reg.pc, reg2, reg2_data.data, reg3_0,result_data));
+  //printf( "0x%x: FLOORF.SUL r%d(%f) r%d :%llu\n", cpu->reg.pc, reg2, reg2_data.data, reg3_0,result_data);
+	cpu->reg.r[reg3_0] = (uint32)(result_data>>32);
+	cpu->reg.r[reg3_1] = (uint32)(result_data & 0xffffffff);
+	printf( "0x%x: FLOORF.SUL r%d(%f) r%d :%llu\n", cpu->reg.pc, reg2, reg2_data.data, reg3_0,result_data);
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+int op_exec_floorf_suw_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+	// TODO :Overflow error check
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        uint64 result;
+        bool is_invalid = FALSE;
+        if (FLOAT_IS_NAN(reg2_data) || FLOAT_IS_INF(reg2_data)) {
+            if (FLOAT_IS_PLUS(reg2_data)) {
+                result = (uint64)UINT_MAX;
+            }
+            else {
+                result = 0;
+            }
+            is_invalid = TRUE;
+        }
+        else {
+            result = (uint64)floorf(reg2_data.data);
+            if (result > ((uint64)UINT_MAX)) {
+                result = (uint64)UINT_MAX;
+                is_invalid = TRUE;
+            }
+        }
+        if (is_invalid) {
+            sys_set_fpst_xc(&cpu->reg, sys_get_fpst_xc(&cpu->reg) | SYS_FPSR_EXPR_V);
+            sys_set_fpst_xp(&cpu->reg, sys_get_fpst_xp(&cpu->reg) | SYS_FPSR_EXPR_V);
+        	result_data.binary = (uint32)result;
+        }
+       	result_data.binary = (uint32)result;
+
+    }
+    end_float_op(cpu, &ex);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: FLOORF.SUW r%d(%f),r%d(%f):%u\n", 
+        cpu->reg.pc, reg2, reg2_data.data, reg3, reg3_data.data, (uint32)result_data.binary));
+	cpu->reg.r[reg3] = result_data.binary;
+    
+	//printf("0x%x: FLOORF.SUW r%d(%f),r%d(%f):%f\n", cpu->reg.pc, reg2, reg2_data.data, reg3, reg3_data.data, (uint32)result_data.data);
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+int op_exec_floorf_sw_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+	FloatBinaryDataType result_data;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand(cpu, &fpu_config, &reg2_data);
+        result_data.data = (float)floorf(reg2_data.data);
+        set_subnormal_result(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: FLOORF.SW r%d(%f),r%d(%f):%f\n", 
+        cpu->reg.pc, reg2, reg2_data.data, reg3, reg3_data.data, result_data.data));
+	cpu->reg.r[reg3] = result_data.binary;
+
+    //printf("0x%x: FLOORF.SW r%d(%f),r%d(%f):%f\n", cpu->reg.pc, reg2, reg2_data.data, reg3, reg3_data.data, result_data.data);
+
+	cpu->reg.pc += 4;
+    return 0;
+}
+int op_exec_rsqrtf_s_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand(cpu, &fpu_config, &reg2_data);
+        result_data.data = (float)1/sqrt(reg2_data.data);
+        set_subnormal_result(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: RSQRTF.S r%d(%f),r%d(%f):%f\n", 
+        cpu->reg.pc, reg2, reg2_data.data, reg3, reg3_data.data, result_data.data));
+	cpu->reg.r[reg3] = result_data.binary;
+
+//    printf("0x%x: RSQRTF.S r%d(%f),r%d(%f):%f\n", cpu->reg.pc, reg2, reg2_data.data, reg3, reg3_data.data, result_data.data);
+
+	cpu->reg.pc += 4;
+    return 0;
+
+
+}
+int op_exec_sqrtf_s_F(TargetCoreType *cpu)
+{
+    FpuConfigSettingType fpu_config;
+    FloatExceptionType ex;
+	uint32 reg2 = cpu->decoded_code->type_f.reg2;
+	uint32 reg3 = cpu->decoded_code->type_f.reg3;
+    FloatBinaryDataType reg2_data;
+    FloatBinaryDataType reg3_data;
+    FloatBinaryDataType result_data;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data.binary = cpu->reg.r[reg2];
+	reg3_data.binary = cpu->reg.r[reg3];
+
+    prepare_float_op(cpu, &ex, &fpu_config);
+    {
+        set_subnormal_operand(cpu, &fpu_config, &reg2_data);
+        result_data.data = (float)sqrtf(reg2_data.data);
+        set_subnormal_result(cpu, &fpu_config, &result_data);
+    }
+    end_float_op(cpu, &ex);
+
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SQRTF.S r%d(%f),r%d(%f):%f\n", 
+        cpu->reg.pc, reg2, reg2_data.data, reg3, reg3_data.data, result_data.data));
+	cpu->reg.r[reg3] = result_data.binary;
+
+    //printf("0x%x: SQRTF.S r%d(%f),r%d(%f):%f\n",         cpu->reg.pc, reg2, reg2_data.data, reg3, reg3_data.data, result_data.data);
+
+	cpu->reg.pc += 4;
+    return 0;
+
+
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_exec/op_exec_load.c
@@ -0,0 +1,556 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include <stdlib.h>
+
+#include "cpu_exec/op_exec_ops.h"
+#include "cpu.h"
+#include "bus.h"
+
+#include "device.h"
+#include "target_mpu_op.h"
+
+/*
+ * Format4
+ */
+int op_exec_sldb(TargetCoreType *cpu)
+{
+	uint32 addr;
+	sint32 ret;
+	uint32 disp;
+	uint32 reg1 = CPU_REG_EP;
+	uint32 reg2 = cpu->decoded_code->type4_1.reg2;
+	sint8 data8;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	disp = cpu->decoded_code->type4_1.disp;
+	disp = (disp << 1) | cpu->decoded_code->type4_1.gen;
+	disp = op_zero_extend(7, disp);
+	addr = cpu->reg.r[reg1] + disp;
+
+	err = bus_get_data8(cpu->core_id, addr, (uint8*)&data8);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+	ret = data8;
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SLD.B disp7(%d),r%d(0x%x), r%d(0x%x):0x%x\n", cpu->reg.pc, disp, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], ret));
+
+	cpu->reg.r[reg2] = ret;
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+int op_exec_sldbu(TargetCoreType *cpu)
+{
+	uint32 addr;
+	uint32 ret;
+	uint32 disp;
+	uint32 reg1 = CPU_REG_EP;
+	uint32 reg2 = cpu->decoded_code->type4_2.reg2;
+	uint8 data8;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	disp = cpu->decoded_code->type4_2.disp;
+	disp = op_zero_extend(3, disp);
+	addr = cpu->reg.r[reg1] + disp;
+
+	err = bus_get_data8(cpu->core_id, addr, &data8);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+	ret = data8;
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SLD.BU disp4(%u),r%d(0x%x), r%d(0x%x):0x%x\n", cpu->reg.pc, disp, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], ret));
+
+	cpu->reg.r[reg2] = ret;
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+
+int op_exec_sldhu(TargetCoreType *cpu)
+{
+	uint32 addr;
+	uint32 ret;
+	uint32 disp;
+	uint32 reg1 = CPU_REG_EP;
+	uint32 reg2 = cpu->decoded_code->type4_2.reg2;
+	uint16 data16;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	disp = ( (cpu->decoded_code->type4_2.disp) << 1U );
+	disp = op_zero_extend(4, disp);
+	addr = cpu->reg.r[reg1] + disp;
+
+	err = bus_get_data16(cpu->core_id, addr, &data16);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+	ret = data16;
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SLD.HU disp4(%u),r%d(0x%x), r%d(0x%x):0x%x\n", cpu->reg.pc, disp, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], ret));
+
+	cpu->reg.r[reg2] = ret;
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+
+int op_exec_sldh(TargetCoreType *cpu)
+{
+	uint32 addr;
+	sint32 ret;
+	uint32 disp;
+	uint32 reg1 = CPU_REG_EP;
+	uint32 reg2 = cpu->decoded_code->type4_1.reg2;
+	sint16 data16;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	disp = cpu->decoded_code->type4_1.disp;
+	disp = (disp << 1) | cpu->decoded_code->type4_1.gen;
+	disp = op_zero_extend(7, disp);
+	disp = disp << 1;
+
+
+	addr = cpu->reg.r[reg1] + disp;
+
+	err = bus_get_data16(cpu->core_id, addr, (uint16*)&data16);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+	ret = data16;
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SLD.H disp8(%d),r%d(0x%x), r%d(0x%x):0x%x\n", cpu->reg.pc, disp, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], ret));
+
+	cpu->reg.r[reg2] = ret;
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+
+int op_exec_sldw(TargetCoreType *cpu)
+{
+	uint32 addr;
+	uint32 ret;
+	uint32 disp;
+	uint32 reg1 = CPU_REG_EP;
+	uint32 reg2 = cpu->decoded_code->type4_1.reg2;
+	uint32 data32;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	disp = cpu->decoded_code->type4_1.disp;
+	disp = op_zero_extend(6, disp);
+	disp = disp << 2;
+	addr = cpu->reg.r[reg1] + disp;
+
+	//TODO:comm_hook_load_reg32(cpu, addr);
+
+	err = bus_get_data32(cpu->core_id, addr, &data32);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+	ret = data32;
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SLD.W disp8(%d),r%d(0x%x), r%d(0x%x):0x%x\n", cpu->reg.pc, disp, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], ret));
+
+	cpu->reg.r[reg2] = ret;
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+/*
+ * Format7
+ */
+
+int op_exec_ldb(TargetCoreType *cpu)
+{
+	uint32 addr;
+	sint32 disp;
+	uint32 reg1 = cpu->decoded_code->type7.reg1;
+	uint32 reg2 = cpu->decoded_code->type7.reg2;
+	sint8 data8;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	disp = op_sign_extend(15, (cpu->decoded_code->type7.disp << 1) | cpu->decoded_code->type7.gen);
+
+	addr = cpu->reg.r[reg1] + disp;
+
+	err = bus_get_data8(cpu->core_id, addr, (uint8*)&data8);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: LD.B disp16(%d),r%d(0x%x), r%d(0x%x) addr=0x%x:0x%x\n", cpu->reg.pc, disp, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], addr, data8));
+
+	cpu->reg.r[reg2] = data8;
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+int op_exec_ld_b_14(TargetCoreType *cpu)
+{
+	uint32 addr;
+	sint32 disp;
+	uint32 reg1 = cpu->decoded_code->type14.reg1;
+	uint32 reg3 = cpu->decoded_code->type14.reg3;
+	sint8 data8;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	disp = op_sign_extend(22, (cpu->decoded_code->type14.disp_high << 7U) | cpu->decoded_code->type14.disp_low);
+
+	addr = cpu->reg.r[reg1] + disp;
+
+	err = bus_get_data8(cpu->core_id, addr, (uint8*)&data8);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: LD.B disp23(%d),r%d(0x%x), r%d(0x%x) addr=0x%x:0x%x\n",
+			cpu->reg.pc, disp, reg1, cpu->reg.r[reg1], reg3, cpu->reg.r[reg3], addr, data8));
+
+	cpu->reg.r[reg3] = data8;
+
+	cpu->reg.pc += 6;
+	return 0;
+}
+
+int op_exec_ldbu(TargetCoreType *cpu)
+{
+	uint32 addr;
+	sint32 disp;
+	uint32 reg1 = cpu->decoded_code->type7.reg1;
+	uint32 reg2 = cpu->decoded_code->type7.reg2;
+	sint32 disp_bit;
+	uint8 data8;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	disp_bit = (cpu->decoded_code->type7.opcode & 0x0001);
+	disp = op_sign_extend(15, (cpu->decoded_code->type7.disp << 1) | disp_bit);
+
+	addr = cpu->reg.r[reg1] + disp;
+
+	err = bus_get_data8(cpu->core_id, addr, &data8);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: LD.BU disp16(%d),r%d(0x%x), r%d(0x%x):0x%x\n", cpu->reg.pc, disp, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], data8));
+
+	cpu->reg.r[reg2] = data8;
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+
+int op_exec_ld_bu_14(TargetCoreType *cpu)
+{
+	uint32 addr;
+	sint32 disp;
+	uint32 reg1 = cpu->decoded_code->type14.reg1;
+	uint32 reg3 = cpu->decoded_code->type14.reg3;
+	uint8 data8;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	disp = op_sign_extend(22, (cpu->decoded_code->type14.disp_high << 7U) | cpu->decoded_code->type14.disp_low);
+
+	addr = cpu->reg.r[reg1] + disp;
+
+	err = bus_get_data8(cpu->core_id, addr, &data8);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: LD.BU disp23(%d),r%d(0x%x), r%d(0x%x):0x%x\n",
+			cpu->reg.pc, disp, reg1, cpu->reg.r[reg1], reg3, cpu->reg.r[reg3], data8));
+
+	cpu->reg.r[reg3] = data8;
+
+	cpu->reg.pc += 6;
+	return 0;
+}
+
+int op_exec_ldhw(TargetCoreType *cpu)
+{
+	uint32 addr;
+	sint32 ret;
+	sint32 disp;
+	uint32 reg1 = cpu->decoded_code->type7.reg1;
+	uint32 reg2 = cpu->decoded_code->type7.reg2;
+	sint16 data16;
+	sint32 data32;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+
+	if (cpu->decoded_code->type7.gen == 0x00) {
+		//LD.H
+		disp = op_sign_extend(15, (cpu->decoded_code->type7.disp << 1) );
+		addr = cpu->reg.r[reg1] + disp;
+
+		err = bus_get_data16(cpu->core_id, addr, (uint16*)&data16);
+		if (err != STD_E_OK) {
+			return -1;
+		}
+		DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: LD.H disp16(%d),r%d(0x%x), r%d(0x%x):0x%x\n", cpu->reg.pc, disp, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], data16));
+		ret = data16;
+	}
+	else {
+		//LD.W
+		disp = op_sign_extend(15, (cpu->decoded_code->type7.disp << 1) );
+		addr = cpu->reg.r[reg1] + disp;
+
+		//TODO: comm_hook_load_reg32(cpu, addr);
+
+		err = bus_get_data32(cpu->core_id, addr, (uint32*)&data32);
+		if (err != STD_E_OK) {
+			return -1;
+		}
+
+		DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: LD.W disp16(%d),r%d(0x%x), r%d(0x%x):0x%x\n", cpu->reg.pc, disp, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], data32));
+		ret = data32;
+
+	}
+	cpu->reg.r[reg2] = ret;
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+
+int op_exec_ld_h_14(TargetCoreType *cpu)
+{
+	uint32 addr;
+	sint32 disp;
+	uint32 reg1 = cpu->decoded_code->type14.reg1;
+	uint32 reg3 = cpu->decoded_code->type14.reg3;
+	sint16 data16;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	disp = op_sign_extend(22, (cpu->decoded_code->type14.disp_high << 7U) | cpu->decoded_code->type14.disp_low);
+
+	addr = cpu->reg.r[reg1] + disp;
+
+	err = bus_get_data16(cpu->core_id, addr, (uint16*)&data16);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: LD.H disp23(%d),r%d(0x%x), r%d(0x%x):0x%x\n",
+			cpu->reg.pc, disp, reg1, cpu->reg.r[reg1], reg3, cpu->reg.r[reg3], data16));
+
+	cpu->reg.r[reg3] = data16;
+
+	cpu->reg.pc += 6;
+	return 0;
+}
+
+int op_exec_ld_w_14(TargetCoreType *cpu)
+{
+	uint32 addr;
+	sint32 disp;
+	uint32 reg1 = cpu->decoded_code->type14.reg1;
+	uint32 reg3 = cpu->decoded_code->type14.reg3;
+	sint32 data32;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	disp = op_sign_extend(22, (cpu->decoded_code->type14.disp_high << 7U) | cpu->decoded_code->type14.disp_low);
+
+	addr = cpu->reg.r[reg1] + disp;
+
+	err = bus_get_data32(cpu->core_id, addr, (uint32*)&data32);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: LD.W disp23(%d),r%d(0x%x), r%d(0x%x):0x%x\n",
+			cpu->reg.pc, disp, reg1, cpu->reg.r[reg1], reg3, cpu->reg.r[reg3], data32));
+
+	cpu->reg.r[reg3] = data32;
+
+	cpu->reg.pc += 6;
+	return 0;
+}
+
+
+int op_exec_ldhu(TargetCoreType *cpu)
+{
+	uint32 addr;
+	uint32 ret;
+	uint32 disp;
+	uint32 reg1 = cpu->decoded_code->type7.reg1;
+	uint32 reg2 = cpu->decoded_code->type7.reg2;
+	uint16 data16;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	disp = op_zero_extend(15, (cpu->decoded_code->type7.disp << 1) );
+	addr = cpu->reg.r[reg1] + disp;
+
+	err = bus_get_data16(cpu->core_id, addr, &data16);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: LD.HU disp16(%d),r%d(0x%x), r%d(0x%x):0x%x\n", cpu->reg.pc, disp, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], data16));
+	ret = data16;
+
+	cpu->reg.r[reg2] = ret;
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+int op_exec_ld_hu_14(TargetCoreType *cpu)
+{
+	uint32 addr;
+	sint32 disp;
+	uint32 reg1 = cpu->decoded_code->type14.reg1;
+	uint32 reg3 = cpu->decoded_code->type14.reg3;
+	uint16 data16;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	disp = op_sign_extend(22, (cpu->decoded_code->type14.disp_high << 7U) | cpu->decoded_code->type14.disp_low);
+
+	addr = cpu->reg.r[reg1] + disp;
+
+	err = bus_get_data16(cpu->core_id, addr, (uint16*)&data16);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: LD.HU disp23(%d),r%d(0x%x), r%d(0x%x):0x%x\n",
+			cpu->reg.pc, disp, reg1, cpu->reg.r[reg1], reg3, cpu->reg.r[reg3], data16));
+
+	cpu->reg.r[reg3] = data16;
+
+	cpu->reg.pc += 6;
+	return 0;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_exec/op_exec_load_rh850.c
@@ -0,0 +1,102 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include <stdlib.h>
+
+#include "cpu_exec/op_exec_ops.h"
+#include "cpu.h"
+#include "bus.h"
+
+#include "device.h"
+#include "target_mpu_op.h"
+
+int op_exec_ld_dw_14(TargetCoreType *cpu)
+{
+	uint32 addr;
+	sint32 disp;
+	uint32 reg1 = cpu->decoded_code->type14.reg1;
+	uint32 reg3 = cpu->decoded_code->type14.reg3;
+	sint32 data32[2];
+	Std_ReturnType err;
+
+	bool has_permission;
+
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if ((reg3 % 2) != 0) {
+		return -1;
+	}
+
+	disp = op_sign_extend(22, (cpu->decoded_code->type14.disp_high << 7U) | cpu->decoded_code->type14.disp_low);
+
+	addr = cpu->reg.r[reg1] + disp;
+
+	has_permission = target_mpu_has_permission(cpu, MPU_TARGET_ACCESS_READ, addr, 8U);
+	if (!(has_permission)) {
+		return -1;
+	}
+
+	err = bus_get_data32(cpu->core_id, addr, (uint32*)&data32[0]);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+	err = bus_get_data32(cpu->core_id, addr, (uint32*)&data32[1]);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: LD.DW disp23(%d),r%d(0x%x), r%d(0x%x):0x%x 0x%x\n",
+			cpu->reg.pc,
+			disp, reg1, cpu->reg.r[reg1],
+			reg3, cpu->reg.r[reg3],
+			data32[0], data32[1]));
+
+	cpu->reg.r[reg3 + 0] = data32[0];
+	cpu->reg.r[reg3 + 1] = data32[1];
+
+	cpu->reg.pc += 6;
+	return 0;
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_exec/op_exec_logic.c
@@ -0,0 +1,832 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "cpu_exec/op_exec_ops.h"
+#include "cpu.h"
+
+/*
+ * Format1
+ */
+int op_exec_or(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type1.reg1;
+	uint32 reg2 = cpu->decoded_code->type1.reg2;
+	sint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	result = op_or(&cpu->reg, cpu->reg.r[reg2], cpu->reg.r[reg1]);
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: OR r%d(%d),r%d(%d):%d\n", cpu->reg.pc, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], result));
+
+	cpu->reg.r[reg2] = result;
+
+	cpu->reg.pc += 2;
+	return 0;
+
+}
+int op_exec_zxb(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type1.reg1;
+	uint8 data;
+	uint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	data = (uint8)cpu->reg.r[reg1];
+	result = (uint32)data;
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: ZXB r%d(%d):%d\n", cpu->reg.pc, reg1, cpu->reg.r[reg1],  result));
+
+	cpu->reg.r[reg1] = result;
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+int op_exec_zxh(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type1.reg1;
+	uint16 data;
+	uint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	data = (uint16)cpu->reg.r[reg1];
+	result = (uint32)data;
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: ZXH r%d(%d):%d\n", cpu->reg.pc, reg1, cpu->reg.r[reg1],  result));
+
+	cpu->reg.r[reg1] = result;
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+
+int op_exec_tst(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type1.reg1;
+	uint32 reg2 = cpu->decoded_code->type1.reg2;
+	sint32 result = 0;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	result = op_and(&cpu->reg, cpu->reg.r[reg2], cpu->reg.r[reg1]);
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: TST r%d(%d), r%d(%d):%d\n", cpu->reg.pc, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2],  result));
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+
+int op_exec_and(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type1.reg1;
+	uint32 reg2 = cpu->decoded_code->type1.reg2;
+	sint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	result = op_and(&cpu->reg, cpu->reg.r[reg2], cpu->reg.r[reg1]);
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: AND r%d(%d), r%d(%d):%d\n", cpu->reg.pc, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2],  result));
+	cpu->reg.r[reg2] = result;
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+int op_exec_not(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type1.reg1;
+	uint32 reg2 = cpu->decoded_code->type1.reg2;
+	sint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	result = ~cpu->reg.r[reg1];
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: NOT r%d(%d), r%d(%d):%d\n", cpu->reg.pc, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2],  result));
+
+	cpu->reg.r[reg2] = result;
+	op_chk_and_set_zero(&cpu->reg, cpu->reg.r[reg2]);
+	op_chk_and_set_sign(&cpu->reg, cpu->reg.r[reg2]);
+	CPU_CLR_OV(&cpu->reg);
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+int op_exec_xor(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type1.reg1;
+	uint32 reg2 = cpu->decoded_code->type1.reg2;
+	sint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	result = cpu->reg.r[reg2] ^ cpu->reg.r[reg1];
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: XOR r%d(%d), r%d(%d):%d\n", cpu->reg.pc, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2],  result));
+	cpu->reg.r[reg2] = result;
+
+	op_chk_and_set_zero(&cpu->reg, cpu->reg.r[reg2]);
+	op_chk_and_set_sign(&cpu->reg, cpu->reg.r[reg2]);
+	CPU_CLR_OV(&cpu->reg);
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+int op_exec_sxh(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type1.reg1;
+	sint16 tmp;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	tmp = ((sint16)cpu->reg.r[reg1]);
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SXH r%d(%d):%d\n", cpu->reg.pc, reg1, cpu->reg.r[reg1],  tmp));
+
+	cpu->reg.r[reg1] = (sint32)tmp;
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+int op_exec_sxb(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type1.reg1;
+	sint8 tmp;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	tmp = ((sint8)cpu->reg.r[reg1]);
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SXB r%d(%d):%d\n", cpu->reg.pc, reg1, cpu->reg.r[reg1],  tmp));
+	cpu->reg.r[reg1] = (sint32)tmp;
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+
+/*
+ * Format2
+ */
+static void op_chk_and_set_shl_carry(CpuRegisterType *cpu, uint32 data, uint32 sh)
+{
+	if (sh > 0) {
+		if ( data & (1 << (32 - sh)) ) {
+			CPU_SET_CY(cpu);
+		}
+		else {
+			CPU_CLR_CY(cpu);
+		}
+	}
+	else {
+		CPU_CLR_CY(cpu);
+	}
+	return;
+}
+static void op_chk_and_set_shr_carry(CpuRegisterType *cpu, uint32 data, uint32 sh)
+{
+	if (sh > 0) {
+		if ( data & (1 << (sh - 1)) ) {
+			CPU_SET_CY(cpu);
+		}
+		else {
+			CPU_CLR_CY(cpu);
+		}
+	}
+	else {
+		CPU_CLR_CY(cpu);
+	}
+	return;
+}
+
+int op_exec_shl_2(TargetCoreType *cpu)
+{
+	uint32 reg2 = cpu->decoded_code->type2.reg2;
+	uint32 imm_data;
+	uint32 reg2_data;
+	uint32 result;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data = cpu->reg.r[reg2];
+	imm_data = OP_FORMAT2_IMM_ZERO_EXTEND(cpu->decoded_code->type2.imm);
+
+	result = reg2_data << imm_data;
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SHL imm5(%d),r%d(%d):%d\n", cpu->reg.pc, imm_data, reg2, cpu->reg.r[reg2], result));
+
+	cpu->reg.r[reg2] = (sint32)result;
+
+	CPU_CLR_OV(&cpu->reg);
+	op_chk_and_set_shl_carry(&cpu->reg, reg2_data, imm_data);
+	op_chk_and_set_zero(&cpu->reg, cpu->reg.r[reg2]);
+	op_chk_and_set_sign(&cpu->reg, cpu->reg.r[reg2]);
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+int op_exec_shr_2(TargetCoreType *cpu)
+{
+	uint32 reg2 = cpu->decoded_code->type2.reg2;
+	uint32 imm_data;
+	uint32 reg2_data;
+	uint32 result;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data = cpu->reg.r[reg2];
+	imm_data = OP_FORMAT2_IMM_ZERO_EXTEND(cpu->decoded_code->type2.imm);
+
+	result = reg2_data >> imm_data;
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SHR imm5(%d),r%d(%d):%d\n", cpu->reg.pc, imm_data, reg2, cpu->reg.r[reg2], result));
+	cpu->reg.r[reg2] = (sint32)result;
+
+	CPU_CLR_OV(&cpu->reg);
+	op_chk_and_set_shr_carry(&cpu->reg, reg2_data, imm_data);
+	op_chk_and_set_zero(&cpu->reg, cpu->reg.r[reg2]);
+	op_chk_and_set_sign(&cpu->reg, cpu->reg.r[reg2]);
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+int op_exec_sar_2(TargetCoreType *cpu)
+{
+	uint32 reg2 = cpu->decoded_code->type2.reg2;
+	uint32 imm_data;
+	sint32 reg2_data;
+	sint32 result;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	reg2_data = cpu->reg.r[reg2];
+	imm_data = OP_FORMAT2_IMM_ZERO_EXTEND(cpu->decoded_code->type2.imm);
+
+	result = reg2_data >> imm_data;
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SAR imm5(%d),r%d(%d):%d\n", cpu->reg.pc, imm_data, reg2, cpu->reg.r[reg2], result));
+
+	cpu->reg.r[reg2] = (sint32)result;
+
+	CPU_CLR_OV(&cpu->reg);
+	op_chk_and_set_shr_carry(&cpu->reg, reg2_data, imm_data);
+	op_chk_and_set_zero(&cpu->reg, cpu->reg.r[reg2]);
+	op_chk_and_set_sign(&cpu->reg, cpu->reg.r[reg2]);
+
+	cpu->reg.pc += 2;
+
+	return 0;
+}
+
+
+
+/*
+ * Format6
+ */
+
+int op_exec_andi(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type6.reg1;
+	uint32 reg2 = cpu->decoded_code->type6.reg2;
+	uint32 imm_data = op_zero_extend(16, cpu->decoded_code->type6.imm);
+	sint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	result = op_andi(&cpu->reg, imm_data, cpu->reg.r[reg1]);
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: ANDI imm5(%d),r%d(%d) r%d(%d):%d\n", cpu->reg.pc, imm_data, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], result));
+
+	cpu->reg.r[reg2] = result;
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+
+int op_exec_ori(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type6.reg1;
+	uint32 reg2 = cpu->decoded_code->type6.reg2;
+	uint32 imm_data = op_zero_extend(16, cpu->decoded_code->type6.imm);
+	sint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	result = op_ori(&cpu->reg, imm_data, cpu->reg.r[reg1]);
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: ORI imm5(%d),r%d(%d) r%d(%d):%d\n", cpu->reg.pc, imm_data, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], result));
+	cpu->reg.r[reg2] = result;
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+
+int op_exec_xori(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type6.reg1;
+	uint32 reg2 = cpu->decoded_code->type6.reg2;
+	uint32 imm_data = op_zero_extend(16, cpu->decoded_code->type6.imm);
+	sint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	result = op_xori(&cpu->reg, imm_data, cpu->reg.r[reg1]);
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: XORI imm5(%d),r%d(%d) r%d(%d):%d\n", cpu->reg.pc, imm_data, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], result));
+	cpu->reg.r[reg2] = result;
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+
+/*
+ * Format9
+ */
+int op_exec_shl_9(TargetCoreType *cpu)
+{
+	uint32 reg2 = cpu->decoded_code->type9.reg2;
+	uint32 reg1 = cpu->decoded_code->type9.gen;
+	uint32 reg2_data;
+	uint32 reg1_data;
+	uint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	reg2_data = cpu->reg.r[reg2];
+	reg1_data = (cpu->reg.r[reg1] & 0x0000001F);
+
+	result = reg2_data << reg1_data;
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SHL r%d(%d),r%d(%d):%d\n", cpu->reg.pc, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], result));
+
+	cpu->reg.r[reg2] = (sint32)result;
+
+	CPU_CLR_OV(&cpu->reg);
+	op_chk_and_set_shl_carry(&cpu->reg, reg2_data, reg1_data);
+	op_chk_and_set_zero(&cpu->reg, cpu->reg.r[reg2]);
+	op_chk_and_set_sign(&cpu->reg, cpu->reg.r[reg2]);
+
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+
+int op_exec_shr_9(TargetCoreType *cpu)
+{
+	uint32 reg2 = cpu->decoded_code->type9.reg2;
+	uint32 reg1 = cpu->decoded_code->type9.gen;
+	uint32 reg2_data;
+	uint32 reg1_data;
+	uint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	reg2_data = cpu->reg.r[reg2];
+	reg1_data = (cpu->reg.r[reg1] & 0x0000001F);
+
+	result = reg2_data >> reg1_data;
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SHR r%d(%d),r%d(%d):%d\n", cpu->reg.pc, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], result));
+	cpu->reg.r[reg2] = (sint32)result;
+
+	CPU_CLR_OV(&cpu->reg);
+	op_chk_and_set_shr_carry(&cpu->reg, reg2_data, reg1_data);
+	op_chk_and_set_zero(&cpu->reg, cpu->reg.r[reg2]);
+	op_chk_and_set_sign(&cpu->reg, cpu->reg.r[reg2]);
+
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+
+int op_exec_sar_9(TargetCoreType *cpu)
+{
+	uint32 reg2 = cpu->decoded_code->type9.reg2;
+	uint32 reg1 = cpu->decoded_code->type9.gen;
+	sint32 reg2_data;
+	sint32 reg1_data;
+	sint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	reg2_data = cpu->reg.r[reg2];
+	reg1_data = (cpu->reg.r[reg1] & 0x0000001F);
+
+	result = reg2_data >> reg1_data;
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SAR r%d(%d),r%d(%d):%d\n", cpu->reg.pc, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], result));
+
+	cpu->reg.r[reg2] = (sint32)result;
+
+	CPU_CLR_OV(&cpu->reg);
+	op_chk_and_set_shr_carry(&cpu->reg, reg2_data, reg1_data);
+	op_chk_and_set_zero(&cpu->reg, cpu->reg.r[reg2]);
+	op_chk_and_set_sign(&cpu->reg, cpu->reg.r[reg2]);
+
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+
+/*
+ * Format11
+ */
+int op_exec_shl_11(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type11.reg1;
+	uint32 reg2 = cpu->decoded_code->type11.reg2;
+	uint32 reg3 = cpu->decoded_code->type11.reg3;
+	uint32 reg2_data;
+	uint32 reg1_data;
+	uint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	reg2_data = cpu->reg.r[reg2];
+	reg1_data = (cpu->reg.r[reg1] & 0x0000001F);
+
+	result = reg2_data << reg1_data;
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SHL r%d(0x%x), r%d(0x%x), r%d(0x%x):%d\n",
+			cpu->reg.pc,
+			reg1, cpu->reg.r[reg1],
+			reg2, cpu->reg.r[reg2],
+			reg3, cpu->reg.r[reg3],
+			result));
+
+	cpu->reg.r[reg3] = (sint32)result;
+
+	CPU_CLR_OV(&cpu->reg);
+	op_chk_and_set_shl_carry(&cpu->reg, reg2_data, reg1_data);
+	op_chk_and_set_zero(&cpu->reg, cpu->reg.r[reg2]);
+	op_chk_and_set_sign(&cpu->reg, cpu->reg.r[reg2]);
+
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+int op_exec_shr_11(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type11.reg1;
+	uint32 reg2 = cpu->decoded_code->type11.reg2;
+	uint32 reg3 = cpu->decoded_code->type11.reg3;
+	uint32 reg2_data;
+	uint32 reg1_data;
+	uint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	reg2_data = cpu->reg.r[reg2];
+	reg1_data = (cpu->reg.r[reg1] & 0x0000001F);
+
+	result = reg2_data >> reg1_data;
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SHR r%d(0x%x), r%d(0x%x), r%d(0x%x):0x%x\n",
+			cpu->reg.pc,
+			reg1, cpu->reg.r[reg1],
+			reg2, cpu->reg.r[reg2],
+			reg3, cpu->reg.r[reg3],
+			result));
+
+	cpu->reg.r[reg3] = (sint32)result;
+
+	CPU_CLR_OV(&cpu->reg);
+	op_chk_and_set_shr_carry(&cpu->reg, reg2_data, reg1_data);
+	op_chk_and_set_zero(&cpu->reg, cpu->reg.r[reg2]);
+	op_chk_and_set_sign(&cpu->reg, cpu->reg.r[reg2]);
+
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+
+int op_exec_sar_11(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type11.reg1;
+	uint32 reg2 = cpu->decoded_code->type11.reg2;
+	uint32 reg3 = cpu->decoded_code->type11.reg3;
+	uint32 reg2_data;
+	uint32 reg1_data;
+	uint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	reg2_data = cpu->reg.r[reg2];
+	reg1_data = (cpu->reg.r[reg1] & 0x0000001F);
+
+	result = reg2_data >> reg1_data;
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SAR r%d(0x%x), r%d(0x%x), r%d(0x%x):0x%x\n",
+			cpu->reg.pc,
+			reg1, cpu->reg.r[reg1],
+			reg2, cpu->reg.r[reg2],
+			reg3, cpu->reg.r[reg3],
+			result));
+
+	cpu->reg.r[reg3] = (sint32)result;
+
+	CPU_CLR_OV(&cpu->reg);
+	op_chk_and_set_shr_carry(&cpu->reg, reg2_data, reg1_data);
+	op_chk_and_set_zero(&cpu->reg, cpu->reg.r[reg2]);
+	op_chk_and_set_sign(&cpu->reg, cpu->reg.r[reg2]);
+
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+
+/*
+ * Format12
+ */
+int op_exec_hsh_12(TargetCoreType *cpu)
+{
+	uint32 reg2 = cpu->decoded_code->type12.reg2;
+	uint32 reg3 = cpu->decoded_code->type12.reg3;
+
+	/*
+	 * CY 演算結果の下位ハーフワードが 0 のとき 1，そうでないとき 0
+	 * OV 0
+	 * S 演算結果のワード・データの MSB が 1 のとき 1，そうでないとき 0
+	 * Z 演算結果の下位ハーフワードが 0 のとき 1，そうでないとき 0
+	 */
+	if ((cpu->reg.r[reg2] & 0x0000FFFF) == 0x0) {
+		CPU_SET_CY(&cpu->reg);
+		CPU_SET_Z(&cpu->reg);
+	}
+	else {
+		CPU_CLR_CY(&cpu->reg);
+		CPU_CLR_Z(&cpu->reg);
+	}
+	CPU_CLR_OV(&cpu->reg);
+	if ((cpu->reg.r[reg2] & 0x80000000) == 0x80000000) {
+		CPU_SET_S(&cpu->reg);
+	}
+	else {
+		CPU_CLR_S(&cpu->reg);
+	}
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: HSH r%d(0x%x), r%d(0x%x):psw=0x%x, 0x%x\n",
+			cpu->reg.pc,
+			reg2, cpu->reg.r[reg2],
+			reg3, cpu->reg.r[reg3],
+			sys_get_cpu_base(&cpu->reg)->r[SYS_REG_PSW],
+			cpu->reg.r[reg2]));
+
+	cpu->reg.r[reg3] = cpu->reg.r[reg2];
+
+	return 0;
+}
+int op_exec_hsw_12(TargetCoreType *cpu)
+{
+	uint32 reg2 = cpu->decoded_code->type12.reg2;
+	uint32 reg3 = cpu->decoded_code->type12.reg3;
+	uint32 result_half_up = (cpu->reg.r[reg2] & 0xFFFF0000) >> 16U;
+	uint32 result_half_dw = (cpu->reg.r[reg2] & 0x0000FFFF) << 16U;
+	uint32 result = (result_half_dw | result_half_up);
+
+	/*
+	 * CY 演算結果のワード・データ中に，0 のハーフワードが 1 つ以上含まれるとき 1，
+	 * そうでないとき 0
+	 * OV 0
+	 * S 演算結果のワード・データの MSB が 1 のとき 1，そうでないとき 0
+	 * Z 演算結果のワード・データが 0 のとき 1，そうでないとき 0
+	 */
+	if ((result_half_dw == 0x0) || (result_half_up == 0x0) ) {
+		CPU_SET_CY(&cpu->reg);
+	}
+	else {
+		CPU_CLR_CY(&cpu->reg);
+	}
+	CPU_CLR_OV(&cpu->reg);
+
+	if (result == 0x0) {
+		CPU_SET_Z(&cpu->reg);
+	}
+	else {
+		CPU_CLR_Z(&cpu->reg);
+	}
+
+	if ((result & 0x80000000) == 0x80000000) {
+		CPU_SET_S(&cpu->reg);
+	}
+	else {
+		CPU_CLR_S(&cpu->reg);
+	}
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: HSW r%d(0x%x), r%d(0x%x):psw=0x%x, 0x%x\n",
+			cpu->reg.pc,
+			reg2, cpu->reg.r[reg2],
+			reg3, cpu->reg.r[reg3],
+			sys_get_cpu_base(&cpu->reg)->r[SYS_REG_PSW],
+			result));
+
+	cpu->reg.r[reg3] = result;
+
+	return 0;
+}
+
+/*
+ * Format12
+ */
+int op_exec_bsh_12(TargetCoreType *cpu)
+{
+	uint32 reg2 = cpu->decoded_code->type12.reg2;
+	uint32 reg3 = cpu->decoded_code->type12.reg3;
+	uint32 data_0 = (cpu->reg.r[reg2] & 0x000000FF) >>  0U;
+	uint32 data_1 = (cpu->reg.r[reg2] & 0x0000FF00) >>  8U;
+	uint32 data_2 = (cpu->reg.r[reg2] & 0x00FF0000) >> 16U;
+	uint32 data_3 = (cpu->reg.r[reg2] & 0xFF000000) >> 24U;
+
+	uint32 result =
+			  (data_2 << 24U)
+			| (data_3 << 16U)
+			| (data_0 << 8U)
+			| (data_1 << 0U);
+
+	/*
+	 * CY 演算結果の下位ハーフワード・データ中に，0 のバイトが 1 つ以上含まれるとき 1，
+	 * そうでないとき 0
+	 * OV 0
+	 * S 演算結果のワード・データの MSB が 1 のとき 1，そうでないとき 0
+	 * Z 演算結果の下位ハーフワード・データが 0 のとき 1，そうでないとき 0
+	 */
+	if (((result & 0x000000FF) == 0x0) || ((result & 0x0000FF00) == 0x0)) {
+		CPU_SET_CY(&cpu->reg);
+	}
+	else {
+		CPU_CLR_CY(&cpu->reg);
+	}
+	CPU_CLR_OV(&cpu->reg);
+	if ((result & 0x80000000) == 0x80000000) {
+		CPU_SET_S(&cpu->reg);
+	}
+	else {
+		CPU_CLR_S(&cpu->reg);
+	}
+	if (((result & 0x0000FFFF) == 0x0)) {
+		CPU_SET_Z(&cpu->reg);
+	}
+	else {
+		CPU_CLR_Z(&cpu->reg);
+	}
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: BSH r%d(0x%x), r%d(0x%x):psw=0x%x, 0x%x\n",
+			cpu->reg.pc,
+			reg2, cpu->reg.r[reg2],
+			reg3, cpu->reg.r[reg3],
+			sys_get_cpu_base(&cpu->reg)->r[SYS_REG_PSW],
+			result));
+
+	cpu->reg.r[reg3] = result;
+
+	return 0;
+}
+int op_exec_bsw_12(TargetCoreType *cpu)
+{
+	uint32 reg2 = cpu->decoded_code->type12.reg2;
+	uint32 reg3 = cpu->decoded_code->type12.reg3;
+	uint32 data_0 = (cpu->reg.r[reg2] & 0x000000FF) >>  0U;
+	uint32 data_1 = (cpu->reg.r[reg2] & 0x0000FF00) >>  8U;
+	uint32 data_2 = (cpu->reg.r[reg2] & 0x00FF0000) >> 16U;
+	uint32 data_3 = (cpu->reg.r[reg2] & 0xFF000000) >> 24U;
+
+	uint32 result =
+			  (data_0 << 24U)
+			| (data_1 << 16U)
+			| (data_2 << 8U)
+			| (data_3 << 0U);
+
+	/*
+	 * CY 演算結果のワード・データ中に，0 のバイトが 1 つ以上含まれるとき 1，
+	 * そうでないとき 0
+	 * OV 0
+	 * S 演算結果のワード・データの MSB が 1 のとき 1，そうでないとき 0
+	 * Z 演算結果の下位ハーフワード・データが 0 のとき 1，そうでないとき 0
+	 */
+	if (	   ((result & 0x000000FF) == 0x0)
+			|| ((result & 0x0000FF00) == 0x0)
+			|| ((result & 0x00FF0000) == 0x0)
+			|| ((result & 0xFF000000) == 0x0)
+			) {
+		CPU_SET_CY(&cpu->reg);
+	}
+	else {
+		CPU_CLR_CY(&cpu->reg);
+	}
+	CPU_CLR_OV(&cpu->reg);
+	if ((result & 0x80000000) == 0x80000000) {
+		CPU_SET_S(&cpu->reg);
+	}
+	else {
+		CPU_CLR_S(&cpu->reg);
+	}
+	if (((result & 0x0000FFFF) == 0x0)) {
+		CPU_SET_Z(&cpu->reg);
+	}
+	else {
+		CPU_CLR_Z(&cpu->reg);
+	}
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: BSW r%d(0x%x), r%d(0x%x):psw=0x%x, 0x%x\n",
+			cpu->reg.pc,
+			reg2, cpu->reg.r[reg2],
+			reg3, cpu->reg.r[reg3],
+			sys_get_cpu_base(&cpu->reg)->r[SYS_REG_PSW],
+			result));
+
+	cpu->reg.r[reg3] = result;
+
+	return 0;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_exec/op_exec_ops.h
@@ -0,0 +1,364 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+
+
+#ifndef _OP_EXEC_OPS_H_
+#define _OP_EXEC_OPS_H_
+
+#include "target_cpu.h"
+#include "cpu_common/cpu_ops.h"
+
+/*
+ * ロード命令
+ */
+extern int op_exec_ldb(TargetCoreType *cpu);
+extern int op_exec_ldbu(TargetCoreType *cpu);
+extern int op_exec_ldhu(TargetCoreType *cpu);
+extern int op_exec_ldhw(TargetCoreType *cpu);
+extern int op_exec_sldb(TargetCoreType *cpu);
+extern int op_exec_sldbu(TargetCoreType *cpu);
+extern int op_exec_sldh(TargetCoreType *cpu);
+extern int op_exec_sldhu(TargetCoreType *cpu);
+extern int op_exec_sldw(TargetCoreType *cpu);
+
+extern int op_exec_ld_b_14(TargetCoreType *cpu);
+extern int op_exec_ld_bu_14(TargetCoreType *cpu);
+extern int op_exec_ld_dw_14(TargetCoreType *cpu);
+extern int op_exec_ld_h_14(TargetCoreType *cpu);
+extern int op_exec_ld_hu_14(TargetCoreType *cpu);
+extern int op_exec_ld_w_14(TargetCoreType *cpu);
+
+/*
+ * ストア命令
+ */
+extern int op_exec_sstb(TargetCoreType *cpu);
+extern int op_exec_ssth(TargetCoreType *cpu);
+extern int op_exec_stb(TargetCoreType *cpu);
+extern int op_exec_sthw(TargetCoreType *cpu);
+extern int op_exec_sstw(TargetCoreType *cpu);
+extern int op_exec_st_b_14(TargetCoreType *cpu);
+extern int op_exec_st_dw_14(TargetCoreType *cpu);
+extern int op_exec_st_h_14(TargetCoreType *cpu);
+extern int op_exec_st_w_14(TargetCoreType *cpu);
+//extern int xxx(TargetCoreType *cpu);
+
+/*
+ * 乗算命令
+ */
+extern int op_exec_mulhi(TargetCoreType *cpu);
+extern int op_exec_mulh_1(TargetCoreType *cpu);
+extern int op_exec_mulh_2(TargetCoreType *cpu);
+extern int op_exec_mulu_12(TargetCoreType *cpu);
+extern int op_exec_mul_12(TargetCoreType *cpu);
+
+/*
+ * 除算命令
+ */
+
+/*
+ * 算術演算命令
+ */
+extern int op_exec_addi(TargetCoreType *cpu);
+extern int op_exec_movea(TargetCoreType *cpu);
+extern int op_exec_mov_6(TargetCoreType *cpu);
+extern int op_exec_movhi(TargetCoreType *cpu);
+extern int op_exec_mov_1(TargetCoreType *cpu);
+extern int op_exec_mov_2(TargetCoreType *cpu);
+
+extern int op_exec_add_1(TargetCoreType *cpu);
+extern int op_exec_add_2(TargetCoreType *cpu);
+
+extern int op_exec_sub(TargetCoreType *cpu);
+extern int op_exec_subr(TargetCoreType *cpu);
+extern int op_exec_setf(TargetCoreType *cpu);
+
+extern int op_exec_div(TargetCoreType *cpu);
+extern int op_exec_divu(TargetCoreType *cpu);
+extern int op_exec_divhu(TargetCoreType *cpu);
+extern int op_exec_divqu_11(TargetCoreType *cpu);
+extern int op_exec_divh_11(TargetCoreType *cpu);
+extern int op_exec_divh_1(TargetCoreType *cpu);
+extern int op_exec_mul(TargetCoreType *cpu);
+extern int op_exec_mulu(TargetCoreType *cpu);
+
+extern int op_exec_cmov_11(TargetCoreType *cpu);
+extern int op_exec_cmov_12(TargetCoreType *cpu);
+
+extern int op_exec_bins_9(TargetCoreType *cpu);
+extern int op_exec_rotl_7(TargetCoreType *cpu);
+
+extern int op_exec_adf_11(TargetCoreType *cpu);
+extern int op_exec_sbf_11(TargetCoreType *cpu);
+extern int op_exec_sasf_9(TargetCoreType *cpu);
+
+extern int op_exec_mac_11(TargetCoreType *cpu);
+extern int op_exec_macu_11(TargetCoreType *cpu);
+
+/*
+ * 飽和演算命令
+ */
+extern int op_exec_satsubi(TargetCoreType *cpu);
+extern int op_exec_satadd_1(TargetCoreType *cpu);
+extern int op_exec_satsub_1(TargetCoreType *cpu);
+extern int op_exec_satadd_2(TargetCoreType *cpu);
+
+extern int op_exec_satadd_11(TargetCoreType *cpu);
+extern int op_exec_satsub_11(TargetCoreType *cpu);
+extern int op_exec_satsubr_1(TargetCoreType *cpu);
+
+/*
+ * 論理演算命令
+ */
+extern int op_exec_and(TargetCoreType *cpu);
+extern int op_exec_andi(TargetCoreType *cpu);
+extern int op_exec_ori(TargetCoreType *cpu);
+extern int op_exec_or(TargetCoreType *cpu);
+extern int op_exec_xori(TargetCoreType *cpu);
+extern int op_exec_xor(TargetCoreType *cpu);
+extern int op_exec_not(TargetCoreType *cpu);
+extern int op_exec_sxh(TargetCoreType *cpu);
+extern int op_exec_sxb(TargetCoreType *cpu);
+extern int op_exec_shl_2(TargetCoreType *cpu);
+extern int op_exec_shr_2(TargetCoreType *cpu);
+extern int op_exec_sar_2(TargetCoreType *cpu);
+extern int op_exec_shl_9(TargetCoreType *cpu);
+extern int op_exec_shr_9(TargetCoreType *cpu);
+extern int op_exec_sar_9(TargetCoreType *cpu);
+extern int op_exec_shl_11(TargetCoreType *cpu);
+extern int op_exec_shr_11(TargetCoreType *cpu);
+extern int op_exec_sar_11(TargetCoreType *cpu);
+extern int op_exec_hsh_12(TargetCoreType *cpu);
+extern int op_exec_hsw_12(TargetCoreType *cpu);
+extern int op_exec_bsh_12(TargetCoreType *cpu);
+extern int op_exec_bsw_12(TargetCoreType *cpu);
+extern int op_exec_tst(TargetCoreType *cpu);
+extern int op_exec_zxb(TargetCoreType *cpu);
+extern int op_exec_zxh(TargetCoreType *cpu);
+
+extern int op_exec_sch0l_9(TargetCoreType *cpu);
+extern int op_exec_sch1l_9(TargetCoreType *cpu);
+extern int op_exec_sch0r_9(TargetCoreType *cpu);
+extern int op_exec_sch1r_9(TargetCoreType *cpu);
+
+/*
+ * 分岐命令
+ */
+extern int op_exec_jr(TargetCoreType *cpu);
+extern int op_exec_jr_6(TargetCoreType *cpu);
+extern int op_exec_jarl_6(TargetCoreType *cpu);
+extern int op_exec_jarl_11(TargetCoreType *cpu);
+extern int op_exec_jmp(TargetCoreType *cpu);
+extern int op_exec_jmp_6(TargetCoreType *cpu);
+extern int op_exec_cmp_1(TargetCoreType *cpu);
+extern int op_exec_cmp_2(TargetCoreType *cpu);
+extern int op_exec_bcond_3(TargetCoreType *cpu);
+extern int op_exec_bcond_7(TargetCoreType *cpu);
+extern int op_exec_loop_7(TargetCoreType *cpu);
+
+/*
+ * ビット命令
+ */
+extern int op_exec_tst1_8(TargetCoreType *cpu);
+extern int op_exec_set1_8(TargetCoreType *cpu);
+extern int op_exec_clr1_8(TargetCoreType *cpu);
+extern int op_exec_not1_8(TargetCoreType *cpu);
+
+
+extern int op_exec_tst1_9(TargetCoreType *cpu);
+extern int op_exec_set1_9(TargetCoreType *cpu);
+extern int op_exec_clr1_9(TargetCoreType *cpu);
+extern int op_exec_not1_9(TargetCoreType *cpu);
+
+/*
+ * 特殊命令
+ */
+extern int op_exec_diei(TargetCoreType *cpu);
+extern int op_exec_ldsr(TargetCoreType *cpu);
+extern int op_exec_stsr(TargetCoreType *cpu);
+extern int op_exec_nop(TargetCoreType *cpu);
+extern int op_exec_reti(TargetCoreType *cpu);
+extern int op_exec_halt(TargetCoreType *cpu);
+extern int op_exec_trap(TargetCoreType *cpu);
+extern int op_exec_fetrap_1(TargetCoreType *cpu);
+extern int op_exec_switch(TargetCoreType *cpu);
+extern int op_exec_prepare(TargetCoreType *cpu);
+extern int op_exec_dispose(TargetCoreType *cpu);
+extern int op_exec_caxi(TargetCoreType *cpu);
+
+extern int op_exec_feret_10(TargetCoreType *cpu);
+extern int op_exec_eiret_10(TargetCoreType *cpu);
+extern int op_exec_syscall_10(TargetCoreType *cpu);
+
+extern int op_exec_pushsp_11(TargetCoreType *cpu);
+extern int op_exec_popsp_11(TargetCoreType *cpu);
+
+
+extern int op_exec_synce_1(TargetCoreType *cpu);
+extern int op_exec_synci_1(TargetCoreType *cpu);
+extern int op_exec_syncm_1(TargetCoreType *cpu);
+extern int op_exec_syncp_1(TargetCoreType *cpu);
+
+
+/*
+ * 浮動小数点演算命令
+ */
+/*
+ * (1) 基本演算命令
+ */
+extern int op_exec_ceilf_sl_F(TargetCoreType *cpu);
+extern int op_exec_ceilf_sul_F(TargetCoreType *cpu);
+extern int op_exec_ceilf_suw_F(TargetCoreType *cpu);
+extern int op_exec_ceilf_sw_F(TargetCoreType *cpu);
+extern int op_exec_cvtf_hs_F(TargetCoreType *cpu);
+extern int op_exec_cvtf_sh_F(TargetCoreType *cpu);
+extern int op_exec_floorf_sl_F(TargetCoreType *cpu);
+extern int op_exec_floorf_sul_F(TargetCoreType *cpu);
+extern int op_exec_floorf_suw_F(TargetCoreType *cpu);
+extern int op_exec_floorf_sw_F(TargetCoreType *cpu);
+extern int op_exec_recipf_s_F(TargetCoreType *cpu);
+extern int op_exec_roundf_sl_F(TargetCoreType *cpu);
+extern int op_exec_roundf_sul_F(TargetCoreType *cpu);
+extern int op_exec_roundf_suw_F(TargetCoreType *cpu);
+extern int op_exec_roundf_sw_F(TargetCoreType *cpu);
+extern int op_exec_rsqrtf_s_F(TargetCoreType *cpu);
+extern int op_exec_sqrtf_s_F(TargetCoreType *cpu);
+
+/*
+ * (2) 拡張基本演算命令
+ */
+extern int op_exec_absf_s_F(TargetCoreType *cpu);
+extern int op_exec_addf_s_F(TargetCoreType *cpu);
+extern int op_exec_mulf_s_F(TargetCoreType *cpu);
+extern int op_exec_mulf_d_F(TargetCoreType *cpu);
+
+extern int op_exec_divf_s_F(TargetCoreType *cpu);
+extern int op_exec_maxf_s_F(TargetCoreType *cpu);
+extern int op_exec_minf_s_F(TargetCoreType *cpu);
+extern int op_exec_cmovf_s_F(TargetCoreType *cpu);
+extern int op_exec_negf_s_F(TargetCoreType *cpu);
+extern int op_exec_subf_s_F(TargetCoreType *cpu);
+
+
+extern int op_exec_fmaf_s_F(TargetCoreType *cpu);
+extern int op_exec_fmsf_s_F(TargetCoreType *cpu);
+extern int op_exec_fnmaf_s_F(TargetCoreType *cpu);
+extern int op_exec_fnmsf_s_F(TargetCoreType *cpu);
+extern int op_exec_cvtf_ws_F(TargetCoreType *cpu);
+extern int op_exec_cvtf_ls_F(TargetCoreType *cpu);
+extern int op_exec_cvtf_sl_F(TargetCoreType *cpu);
+extern int op_exec_cvtf_sd_F(TargetCoreType *cpu);
+extern int op_exec_cvtf_ds_F(TargetCoreType *cpu);
+extern int op_exec_cvtf_sul_F(TargetCoreType *cpu);
+extern int op_exec_cvtf_suw_F(TargetCoreType *cpu);
+extern int op_exec_cvtf_sw_F(TargetCoreType *cpu);
+extern int op_exec_cvtf_uls_F(TargetCoreType *cpu);
+extern int op_exec_cvtf_uws_F(TargetCoreType *cpu);
+
+
+extern int op_exec_trncf_sl_F(TargetCoreType *cpu);
+extern int op_exec_trncf_sw_F(TargetCoreType *cpu);
+extern int op_exec_trncf_sul_F(TargetCoreType *cpu);
+extern int op_exec_trncf_suw_F(TargetCoreType *cpu);
+
+
+extern int op_exec_absf_d_F(TargetCoreType *cpu);
+extern int op_exec_addf_d_F(TargetCoreType *cpu);
+extern int op_exec_ceilf_dl_F(TargetCoreType *cpu);
+extern int op_exec_ceilf_dul_F(TargetCoreType *cpu);
+extern int op_exec_ceilf_duw_F(TargetCoreType *cpu);
+extern int op_exec_ceilf_dw_F(TargetCoreType *cpu);
+extern int op_exec_cmovf_d_F(TargetCoreType *cpu);
+extern int op_exec_cmpf_d_F(TargetCoreType *cpu);
+extern int op_exec_cvtf_dl_F(TargetCoreType *cpu);
+extern int op_exec_cvtf_dul_F(TargetCoreType *cpu);
+extern int op_exec_cvtf_duw_F(TargetCoreType *cpu);
+extern int op_exec_cvtf_dw_F(TargetCoreType *cpu);
+extern int op_exec_cvtf_ld_F(TargetCoreType *cpu);
+extern int op_exec_cvtf_uld_F(TargetCoreType *cpu);
+extern int op_exec_cvtf_uwd_F(TargetCoreType *cpu);
+extern int op_exec_cvtf_wd_F(TargetCoreType *cpu);
+extern int op_exec_divf_d_F(TargetCoreType *cpu);
+extern int op_exec_floorf_dl_F(TargetCoreType *cpu);
+extern int op_exec_floorf_dul_F(TargetCoreType *cpu);
+extern int op_exec_floorf_duw_F(TargetCoreType *cpu);
+extern int op_exec_floorf_dw_F(TargetCoreType *cpu);
+extern int op_exec_maddf_s_F(TargetCoreType *cpu);
+extern int op_exec_maxf_d_F(TargetCoreType *cpu);
+extern int op_exec_minf_d_F(TargetCoreType *cpu);
+extern int op_exec_msubf_s_F(TargetCoreType *cpu);
+extern int op_exec_negf_d_F(TargetCoreType *cpu);
+extern int op_exec_nmaddf_s_F(TargetCoreType *cpu);
+extern int op_exec_nmsubf_s_F(TargetCoreType *cpu);
+extern int op_exec_recipf_d_F(TargetCoreType *cpu);
+extern int op_exec_rsqrtf_d_F(TargetCoreType *cpu);
+extern int op_exec_sqrtf_d_F(TargetCoreType *cpu);
+extern int op_exec_subf_d_F(TargetCoreType *cpu);
+extern int op_exec_trncf_dl_F(TargetCoreType *cpu);
+extern int op_exec_trncf_dul_F(TargetCoreType *cpu);
+extern int op_exec_trncf_duw_F(TargetCoreType *cpu);
+extern int op_exec_trncf_dw_F(TargetCoreType *cpu);
+
+
+/*
+ * (3) 変換命令
+ */
+/*
+ * (4) 比較命令
+ */
+extern int op_exec_cmpf_s_F(TargetCoreType *cpu);
+
+/*
+ * (5) 条件付き転送命令
+ */
+/*
+ * (6) 条件ビット転送命令
+ */
+extern int op_exec_trfsr_F(TargetCoreType *cpu);
+
+/*
+ * ディバッグ機能用命令
+ */
+
+#include "dbg_log.h"
+
+
+#endif /* _OP_EXEC_OPS_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_exec/op_exec_sat.c
@@ -0,0 +1,223 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "cpu_exec/op_exec_ops.h"
+#include "cpu.h"
+
+/*
+ * Format1
+ */
+int op_exec_satadd_1(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type1.reg1;
+	uint32 reg2 = cpu->decoded_code->type1.reg2;
+	sint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	result = op_satadd(&cpu->reg, cpu->reg.r[reg2], cpu->reg.r[reg1]);
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SATADD r%d(%d),r%d(%d):%d\n", cpu->reg.pc, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], result));
+
+	cpu->reg.r[reg2] = result;
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+int op_exec_satsub_1(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type1.reg1;
+	uint32 reg2 = cpu->decoded_code->type1.reg2;
+	sint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	result = op_satadd(&cpu->reg, cpu->reg.r[reg2], -((sint32)cpu->reg.r[reg1]));
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SATSUB r%d(%d),r%d(%d):%d\n", cpu->reg.pc, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], result));
+
+	cpu->reg.r[reg2] = result;
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+int op_exec_satsubr_1(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type1.reg1;
+	uint32 reg2 = cpu->decoded_code->type1.reg2;
+	sint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	result = op_satadd(&cpu->reg, cpu->reg.r[reg1], -((sint32)cpu->reg.r[reg2]));
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SATSUBR r%d(%d),r%d(%d):%d\n",
+			cpu->reg.pc,
+			reg1, cpu->reg.r[reg1],
+			reg2, cpu->reg.r[reg2],
+			result));
+
+	cpu->reg.r[reg2] = result;
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+
+/*
+ * Format2
+ */
+int op_exec_satadd_2(TargetCoreType *cpu)
+{
+	sint32 imm_data = OP_FORMAT2_IMM_SIGN_EXTEND(cpu->decoded_code->type2.imm);
+	uint32 reg2 = cpu->decoded_code->type2.reg2;
+	sint32 result;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	result = op_satadd(&cpu->reg, cpu->reg.r[reg2], imm_data);
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SATADD imm5(%d),r%d(%d):%d\n", cpu->reg.pc, imm_data, reg2, cpu->reg.r[reg2], result));
+
+	cpu->reg.r[reg2] = result;
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+
+
+
+/*
+ * Format6
+ */
+
+int op_exec_satsubi(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type6.reg1;
+	uint32 reg2 = cpu->decoded_code->type6.reg2;
+	sint32 imm_data = op_sign_extend(15, cpu->decoded_code->type6.imm);
+	sint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	result = op_satadd(&cpu->reg, cpu->reg.r[reg1], -imm_data);
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SATSUBI imm16(%d), r%d(%d), r%d(%d):%d\n", cpu->reg.pc, imm_data, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], result));
+
+	cpu->reg.r[reg2] = result;
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+
+/*
+ * Format11
+ */
+int op_exec_satadd_11(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type11.reg1;
+	uint32 reg2 = cpu->decoded_code->type11.reg2;
+	uint32 reg3 = cpu->decoded_code->type11.reg3;
+	sint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	result = op_satadd(&cpu->reg, cpu->reg.r[reg2], cpu->reg.r[reg1]);
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SATADD r%d(%d),r%d(%d), r%d(%d):%d\n",
+			cpu->reg.pc,
+			reg1, cpu->reg.r[reg1],
+			reg2, cpu->reg.r[reg2],
+			reg3, cpu->reg.r[reg3],
+			result));
+
+	cpu->reg.r[reg3] = result;
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+int op_exec_satsub_11(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type11.reg1;
+	uint32 reg2 = cpu->decoded_code->type11.reg2;
+	uint32 reg3 = cpu->decoded_code->type11.reg3;
+	sint32 result;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	result = op_satadd(&cpu->reg, cpu->reg.r[reg2], -((sint32)cpu->reg.r[reg1]));
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SATSUB r%d(%d),r%d(%d), r%d(%d):%d\n",
+			cpu->reg.pc,
+			reg1, cpu->reg.r[reg1],
+			reg2, cpu->reg.r[reg2],
+			reg3, cpu->reg.r[reg3],
+			result));
+
+	cpu->reg.r[reg3] = result;
+
+	cpu->reg.pc += 4;
+	return 0;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_exec/op_exec_spec.c
@@ -0,0 +1,169 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "cpu_exec/op_exec_ops.h"
+#include "cpu.h"
+#include "bus.h"
+#include "device.h"
+#include <stdio.h> //TODO
+
+#include "target_mpu_op.h"
+
+int op_exec_halt(TargetCoreType *cpu)
+{
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: HALT:0x%x\n", cpu->reg.pc, cpu->reg.pc + 4));
+	//printf("0x%x: HALT:0x%x\n", cpu->reg.pc, cpu->reg.pc + 4);
+	//fflush(stdout);
+	cpu->is_halt = TRUE;
+	cpu->reg.pc += 4;
+	return 0;
+}
+
+int op_exec_switch(TargetCoreType *cpu)
+{
+	uint32 reg1 = cpu->decoded_code->type1.reg1;
+	uint32 reg1_data;
+	uint32 addr;
+	sint32 tmp_pc;
+	uint32 next_pc;
+	sint16 data16;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	reg1_data = cpu->reg.r[reg1];
+
+	addr = (cpu->reg.pc + 2U) + (reg1_data << 1U);
+	/*
+	 * Load-memory (adr, Half-word)
+	 */
+	err = bus_get_data16(cpu->core_id, addr, (uint16*)&data16);
+	if (err != STD_E_OK) {
+		printf("ERROR:SWITCH pc=0x%x reg1=%u(0x%x) addr=0x%x\n", cpu->reg.pc, reg1, reg1_data, addr);
+		return -1;
+	}
+	/*
+	 * (sign-extend (Load-memory (adr, Half-word) ))
+	 */
+	tmp_pc = (sint32)( data16 );
+	/*
+	 * (sign-extend (Load-memory (adr, Half-word) ) ) logically shift left by 1
+	 */
+	tmp_pc <<= 1U;
+
+	/*
+	 * (PC + 2) + (sign-extend (Load-memory (adr, Half-word) ) ) logically shift left by 1
+	 */
+	next_pc = (cpu->reg.pc + 2U) + ((uint32)tmp_pc);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SWITCH r%d(%d):%d\n", cpu->reg.pc, reg1, cpu->reg.r[reg1], next_pc));
+
+
+
+	cpu->reg.pc = next_pc;
+	return 0;
+}
+
+/*
+ * ［命令形式］ CAXI [reg1], reg2, reg3
+ *
+ * ［オペレーション］ adr ← GR[reg1]注
+ * token ← Load-memory(adr, Word)
+ * result ← GR[reg2] – token
+ * If result == 0
+ * then Store-memory(adr, GR[reg3],Word)
+ * GR[reg3] ← token
+ * else Store-memory(adr, token,Word)
+ * GR[reg3] ← token
+ * 注 GR[reg1]の下位 2 ビットは， 0 にマスクしadr とします。
+ */
+int op_exec_caxi(TargetCoreType *cpu)
+{
+	Std_ReturnType err;
+	uint16 reg1 = cpu->decoded_code->type11.reg1;;
+	uint16 reg2 = cpu->decoded_code->type11.reg2;
+	uint16 reg3 = cpu->decoded_code->type11.reg3;
+	sint16 token;
+	sint16 result;
+	uint16 put_data;
+
+	uint32 reg1_addr = (cpu->reg.r[reg1] & 0xFFFFFFFC);
+	uint32 reg2_data = cpu->reg.r[reg2];
+	uint32 reg3_data = cpu->reg.r[reg3];
+
+	/*
+	 * Load-memory (adr, Half-word)
+	 */
+	err = bus_get_data16(cpu->core_id, reg1_addr, (uint16*)&token);
+	if (err != STD_E_OK) {
+		printf("ERROR:CAXI pc=0x%x reg1=%u reg1_addr=%d\n", cpu->reg.pc, reg1, reg1_addr);
+		return -1;
+	}
+
+	result = reg2_data - token;
+	if (result == 0) {
+		put_data = (uint16)reg3_data;
+	}
+	else {
+		put_data = (uint16)token;
+	}
+	err = bus_put_data16(cpu->core_id, reg1_addr, put_data);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: CAXI r%d(%d),r%d(0x%x), r%d(0x%x):token=0x%x store=0x%x\n",
+			cpu->reg.pc, reg1, cpu->reg.r[reg1], reg2, cpu->reg.r[reg2], reg3, cpu->reg.r[reg3], token, put_data));
+
+	cpu->reg.r[reg3] = (sint32)((uint32)((uint16)token));
+
+	op_chk_and_set_borrow(&cpu->reg, reg2_data, token);
+	op_chk_and_set_overflow(&cpu->reg, reg2_data, -token);
+	op_chk_and_set_zero(&cpu->reg, result);
+	op_chk_and_set_sign(&cpu->reg, result);
+
+
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_exec/op_exec_spec_rh850.c
@@ -0,0 +1,637 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "cpu_exec/op_exec_ops.h"
+#include "cpu.h"
+#include "bus.h"
+#include "device.h"
+#include <stdio.h> //TODO
+
+#include "target_mpu_op.h"
+
+#define CPU_PSW_UM_MASK		0x0000001F
+
+static bool sys_reg_access_has_permission(TargetCoreType *cpu, uint32 regid, uint32 selid)
+{
+
+	/* PSW  */
+	if (((selid == SYS_GRP_CPU) && (regid == SYS_REG_PSW))) {
+		return TRUE;
+	}
+	else {
+		/* SV Mode check */
+		if (CPU_ISSET_UM(&(cpu->reg))) {
+			return FALSE;
+		}
+		else {
+			return TRUE;
+		}
+	}
+}
+
+static int get_sysreg2(CpuRegisterType *cpu, uint32 regid, uint32 selid, uint32 **regp)
+{
+	if (regid >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	*regp = cpu_get_sysreg2(&cpu->sys, selid, regid);
+
+	return 0;
+}
+
+/*
+ * Format9
+ */
+int op_exec_ldsr(TargetCoreType *cpu)
+{
+	int ret;
+	uint32 *sysreg;
+	uint32 regid = cpu->decoded_code->type9.reg2;
+	uint32 reg2 = cpu->decoded_code->type9.gen;
+	uint32 selid = cpu->decoded_code->type9.rfu2;
+	uint32 data;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		printf("ERROR: ldsr reg=%d regID=%d\n", reg2, regid);
+		return -1;
+	}
+	if (regid >= CPU_GREG_NUM) {
+		printf("ERROR: ldsr reg=%d regID=%d\n", reg2, regid);
+		return -1;
+	}
+
+	/* PIE check */
+	if (!sys_reg_access_has_permission(cpu, regid, selid)) {
+		cpu->current_code_exception.is_code_exception = TRUE;
+		cpu->current_code_exception.exception_type = ExceptionId_PIE;
+		return 0;
+	}
+
+	ret = get_sysreg2(&cpu->reg, regid, selid, &sysreg);
+	if (ret < 0) {
+		printf("ERROR: ldsr reg=%d regID=%d\n", reg2, regid);
+		return -1;
+	}
+
+	if ((selid == SYS_GRP_2) && (regid == SYS_REG_ISPR)) {
+		if (CPU_ISSET_INTCFG_ISPC(cpu)) {
+			*sysreg = cpu->reg.r[reg2];
+		}
+	}
+	else if ((selid == SYS_GRP_CPU) && (regid == SYS_REG_PSW)) {
+		if (CPU_ISSET_UM(&(cpu->reg))){
+			*sysreg |= (cpu->reg.r[reg2] & CPU_PSW_UM_MASK);
+		}
+		else {
+			*sysreg = cpu->reg.r[reg2];
+		}
+	}
+	else if (((selid == SYS_GRP_5) && (regid == SYS_REG_MCC))) {
+		target_mpu_check(cpu);
+	}
+	else if (((selid == SYS_GRP_5) || (selid == SYS_GRP_6) || (selid == SYS_GRP_7))) {
+		data = cpu->reg.r[reg2];
+		target_mpu_hook_access(cpu, &data, MPU_TARGET_ACCESS_WRITE, selid, regid);
+		*sysreg = data;
+		target_mpu_set_config(cpu);
+	}
+	else {
+		*sysreg = cpu->reg.r[reg2];
+	}
+	fpu_sync_sysreg(cpu, regid, selid);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: LDSR r%d(0x%x) regID(%d) selID(%d):0x%x\n",
+		cpu->reg.pc, reg2, cpu->reg.r[reg2], regid, selid, *sysreg));
+
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+
+int op_exec_stsr(TargetCoreType *cpu)
+{
+	int ret;
+	uint32 *sysreg;
+	uint32 regid = cpu->decoded_code->type9.gen;
+	uint32 reg2 = cpu->decoded_code->type9.reg2;
+	uint32 selid = cpu->decoded_code->type9.rfu2;
+
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (regid >= CPU_SYSREG_NUM) {
+		return -1;
+	}
+
+	/* PIE check */
+	if (!sys_reg_access_has_permission(cpu, regid, selid)) {
+		cpu->current_code_exception.is_code_exception = TRUE;
+		cpu->current_code_exception.exception_type = ExceptionId_PIE;
+		return 0;
+	}
+
+	ret = get_sysreg2(&cpu->reg, regid, selid, &sysreg);
+	if (ret < 0) {
+		return -1;
+	}
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: STSR regID(%d) selID(%d) r%d(0x%x):0x%x\n",
+		cpu->reg.pc, regid, selid, reg2, cpu->reg.r[reg2], *sysreg));
+
+	cpu->reg.r[reg2] = *sysreg;
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+
+/*
+ * Format10
+ */
+
+
+int op_exec_diei(TargetCoreType *cpu)
+{
+	if (!(SYS_ISSET_BIT(cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_1, SYS_REG_MCTL), 0))) {
+		if (CPU_ISSET_UM(&cpu->reg) == TRUE) {
+			cpu->current_code_exception.is_code_exception = TRUE;
+			cpu->current_code_exception.exception_type = ExceptionId_PIE;
+			printf("ERROR: invalid ei/di access because of no supervisor mode or usermode MCTL.UIC is not set.\n");
+			return -1;
+		}
+	}
+
+	if (cpu->decoded_code->type10.gen1 == 0x04) {
+		/* EI */
+		CPU_CLR_ID(&cpu->reg);
+		DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: EI\n", cpu->reg.pc));
+	}
+	else {
+		/* DI */
+		CPU_SET_ID(&cpu->reg);
+		DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: DI\n", cpu->reg.pc));
+
+	}
+	cpu->reg.pc += 4;
+
+	return 0;
+}
+
+int op_exec_nop(TargetCoreType *cpu)
+{
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: NOP\n", cpu->reg.pc));
+
+	cpu->reg.pc += 2;
+
+	return 0;
+}
+int op_exec_reti(TargetCoreType *cpu)
+{
+	if (CPU_ISSET_NP(&cpu->reg)) {
+		DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: RETI:0x%x\n", cpu->reg.pc, sys_get_cpu_base(&cpu->reg)->r[SYS_REG_FEPC]));
+		cpu->reg.pc = SYS_REG_FEPC_GET();
+		sys_get_cpu_base(&cpu->reg)->r[SYS_REG_PSW] = sys_get_cpu_base(&cpu->reg)->r[SYS_REG_FEPSW];
+		intc_clr_fe(cpu->core_id);
+	}
+	else {
+		DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: RETI:0x%x\n", cpu->reg.pc, sys_get_cpu_base(&cpu->reg)->r[SYS_REG_EIPC]));
+		//printf("0x%x: RETI:0x%x\n", cpu->cpu.pc, cpu->cpu.eipc);
+		//fflush(stdout);
+		cpu->reg.pc = SYS_REG_EIPC_GET();
+		sys_get_cpu_base(&cpu->reg)->r[SYS_REG_PSW] = sys_get_cpu_base(&cpu->reg)->r[SYS_REG_EIPSW];
+		intc_clr_ei(cpu->core_id);
+	}
+	return 0;
+}
+
+int op_exec_feret_10(TargetCoreType *cpu)
+{
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: FERET:0x%x\n", cpu->reg.pc, sys_get_cpu_base(&cpu->reg)->r[SYS_REG_FEPC]));
+	cpu->reg.pc = SYS_REG_FEPC_GET();
+	sys_get_cpu_base(&cpu->reg)->r[SYS_REG_PSW] = sys_get_cpu_base(&cpu->reg)->r[SYS_REG_FEPSW];
+	intc_clr_fe(cpu->core_id);
+	return 0;
+}
+int op_exec_eiret_10(TargetCoreType *cpu)
+{
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: EIRET:0x%x\n", cpu->reg.pc, sys_get_cpu_base(&cpu->reg)->r[SYS_REG_EIPC]));
+	cpu->reg.pc = SYS_REG_EIPC_GET();
+	sys_get_cpu_base(&cpu->reg)->r[SYS_REG_PSW] = sys_get_cpu_base(&cpu->reg)->r[SYS_REG_EIPSW];
+	intc_clr_ei(cpu->core_id);
+	return 0;
+}
+
+
+int op_exec_trap(TargetCoreType *cpu)
+{
+	int ret = -1;
+	uint32 pc;
+	uint32 eicc;
+	uint32 ecr;
+	uint32 vector = cpu->decoded_code->type10.gen2;
+
+	if (vector <= 0x0F) {
+		ret = 0;
+		pc = 0x40;
+		eicc = 0x40 + vector;
+	}
+	else if (vector <= 0x1F) {
+		ret = 0;
+		pc = 0x50;
+		eicc = 0x50 + (0x0F & vector);
+	}
+
+	if (ret == 0) {
+		DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: TRAP vector(0x%x):0x%x\n", cpu->reg.pc, vector, pc));
+		sys_get_cpu_base(&cpu->reg)->r[SYS_REG_EIPC] = cpu->reg.pc + 4;
+		sys_get_cpu_base(&cpu->reg)->r[SYS_REG_EIPSW] = sys_get_cpu_base(&cpu->reg)->r[SYS_REG_PSW];
+
+		ecr = sys_get_cpu_base(&cpu->reg)->r[SYS_REG_ECR];
+		ecr = ecr & 0x0000FFFF;
+		ecr |= (eicc << 16);
+		sys_get_cpu_base(&cpu->reg)->r[SYS_REG_ECR] = ecr;
+		CPU_SET_EP(&cpu->reg);
+		CPU_SET_ID(&cpu->reg);
+		cpu->reg.pc = pc;
+	}
+
+	return 0;
+}
+
+int op_exec_fetrap_1(TargetCoreType *cpu)
+{
+	uint32 pc = 0x00000030;
+	uint32 fepc;
+	uint32 fecc;
+	uint32 vector = cpu->decoded_code->type1.reg2;
+	uint32 psw = sys_get_cpu_base(&cpu->reg)->r[SYS_REG_PSW];
+	uint32 ecr = sys_get_cpu_base(&cpu->reg)->r[SYS_REG_ECR];
+
+	fepc = cpu->reg.pc + 2U;
+	fecc = 0x30 + vector;
+
+	ecr = ecr & 0x0000FFFF;
+	ecr |= (fecc << 16);
+
+	sys_get_cpu_base(&cpu->reg)->r[SYS_REG_FEPC] = fepc;
+	sys_get_cpu_base(&cpu->reg)->r[SYS_REG_FEIC] = fecc;
+	sys_get_cpu_base(&cpu->reg)->r[SYS_REG_FEPSW] = psw;
+	sys_get_cpu_base(&cpu->reg)->r[SYS_REG_ECR] = ecr;
+
+	CPU_SET_EP(&cpu->reg);
+	CPU_SET_ID(&cpu->reg);
+	CPU_SET_NP(&cpu->reg);
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: FETRAP vector(0x%x):0x%x\n", cpu->reg.pc, vector, pc));
+
+	cpu->reg.pc = pc;
+	return 0;
+}
+
+int op_exec_syscall_10(TargetCoreType *cpu)
+{
+	Std_ReturnType err;
+	uint32 pc;
+	uint32 eipc;
+	uint32 eiic;
+	uint32 ecr;
+	uint32 addr;
+	uint32 data;
+	uint32 psw = sys_get_cpu_base(&cpu->reg)->r[SYS_REG_PSW];
+	uint32 scbp = *cpu_get_sysreg2(&cpu->reg.sys,  SYS_GRP_1, SYS_REG_SCBP);
+	uint32 sccfg_size = ((*cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_1, SYS_REG_SCCFG)) & 0x000000FF);
+	uint32 vector8 = (cpu->decoded_code->type10.rfu3 << 5U)
+		| (cpu->decoded_code->type10.gen2);
+
+	eipc = cpu->reg.pc + 4U;
+	eiic = 0x8000 + vector8;
+	ecr = sys_get_cpu_base(&cpu->reg)->r[SYS_REG_ECR];
+	ecr = ecr & 0xFFFF0000;
+	ecr |= eiic;
+
+	sys_get_cpu_base(&cpu->reg)->r[SYS_REG_EIPC] = eipc;
+	sys_get_cpu_base(&cpu->reg)->r[SYS_REG_EIIC] = eiic;
+	sys_get_cpu_base(&cpu->reg)->r[SYS_REG_EIPSW] = psw;
+	sys_get_cpu_base(&cpu->reg)->r[SYS_REG_ECR] = ecr;
+
+	CPU_CLR_UM(&cpu->reg);
+	CPU_SET_EP(&cpu->reg);
+	CPU_SET_ID(&cpu->reg);
+
+
+	if (vector8 <= sccfg_size) {
+		addr = scbp + (vector8 << 2U);
+	}
+	else {
+		addr = scbp;
+	}
+	err = bus_get_data32(cpu->core_id, addr, (uint32*)&data);
+	if (err != STD_E_OK) {
+		printf("ERROR:SYSCALL pc=0x%x vector8=%u addr=0x%x\n",
+			cpu->reg.pc, vector8, addr);
+		return -1;
+	}
+
+	pc = scbp + data;
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SYSCALL vector8=%u addr=0x%x:0x%x\n",
+		cpu->reg.pc, vector8, addr, pc));
+
+	cpu->reg.pc = pc;
+	return 0;
+}
+
+/*
+ * Format13
+ */
+int op_exec_prepare(TargetCoreType *cpu)
+{
+	uint16 subop = cpu->decoded_code->type13.gen & 0x0007;
+	uint16 ff = cpu->decoded_code->type13.gen >> 3U;
+	uint16 start_reg = 20U;
+	uint16 i;
+	uint32 addr;
+	uint32 *addrp;
+	uint32 *sp = (uint32*)&(cpu->reg.r[3]);	//sp:r3
+	uint32 imm = ( cpu->decoded_code->type13.imm << 2U );
+	Std_ReturnType err;
+
+	bool has_permission;
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: PREPARE sp=0x%x ", cpu->reg.pc, *sp));
+	for (i = start_reg; i < 32; i++) {
+		if (cpu->decoded_code->type13.list[i] == 0) {
+			continue;
+		}
+		DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "r%u(0x%x) ", i, cpu->reg.r[i]));
+
+		addr = (*sp) - 4U;
+
+		has_permission = target_mpu_has_permission(cpu, MPU_TARGET_ACCESS_WRITE, addr, 4U);
+		if (!(has_permission)) {
+			return -1;
+		}
+
+		err = bus_get_pointer(cpu->core_id, addr, (uint8**)&addrp);
+		if (err != STD_E_OK) {
+			printf("ERROR:PREPARE pc=0x%x sp=0x%x\n", cpu->reg.pc, *sp);
+			return -1;
+		}
+		*addrp = cpu->reg.r[i];
+		*sp = addr;
+		cpu->real_elaps += 1U;
+	}
+	*sp = (*sp) - imm;
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "imm5(%u) ", imm));
+
+	if (subop == 1U) {
+		cpu->reg.pc += 4;
+		DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), ":sp=0x%x\n", *sp));
+		return 0;
+	}
+
+	addr = cpu->reg.pc + 4U;
+
+	err = bus_get_pointer(cpu->core_id, addr, (uint8**)&addrp);
+	if (err != STD_E_OK) {
+		printf("ERROR:PREPARE pc=0x%x sp=0x%x\n", cpu->reg.pc, *sp);
+		return -1;
+	}
+
+	switch (ff) {
+	case 0b00:
+		cpu->reg.r[30] = *sp;
+		cpu->reg.pc += 4;
+		DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "ep=0x%x\n", cpu->reg.r[30]));
+		break;
+	case 0b01:
+		cpu->reg.r[30] = (sint32)(*((sint16*)addrp));
+		cpu->reg.pc += 6;
+		DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "ep=0x%x\n", cpu->reg.r[30]));
+		break;
+	case 0b10:
+		cpu->reg.r[30] = ((uint32)(*((uint16*)addrp))) << 16U;
+		cpu->reg.pc += 6;
+		DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "ep=0x%x\n", cpu->reg.r[30]));
+		break;
+	case 0b11:
+		cpu->reg.r[30] = (*((uint32*)addrp));
+		cpu->reg.pc += 8;
+		DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "ep=0x%x\n", cpu->reg.r[30]));
+		break;
+	default:
+		printf("ERROR:PREPARE pc=0x%x sp=0x%x\n", cpu->reg.pc, *sp);
+		return -1;
+	}
+	return 0;
+}
+
+int op_exec_dispose(TargetCoreType *cpu)
+{
+	uint16 reg1 = cpu->decoded_code->type13.gen;
+	uint16 start_reg = 20U;
+	uint16 i;
+	uint32 addr;
+	uint32 *addrp;
+	uint32 *sp = (uint32*)&(cpu->reg.r[3]);	//sp:r3
+	uint32 imm = ( cpu->decoded_code->type13.imm << 2U );
+	Std_ReturnType err;
+
+	bool has_permission;
+
+	cpu->real_elaps = 0U;
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: DISPOSE imm=0x%x sp=0x%x ", cpu->reg.pc, imm, *sp));
+
+	*sp = (*sp) + imm;
+	for (i = 31; i >= start_reg; i--) {
+		if (cpu->decoded_code->type13.list[i] == 0) {
+			continue;
+		}
+
+		addr = (*sp);
+
+		has_permission = target_mpu_has_permission(cpu, MPU_TARGET_ACCESS_READ, addr, 4U);
+		if (!(has_permission)) {
+			return -1;
+		}
+
+		err = bus_get_pointer(cpu->core_id, addr, (uint8**)&addrp);
+		if (err != STD_E_OK) {
+			printf("ERROR:DISPOSE pc=0x%x sp=0x%x\n", cpu->reg.pc, *sp);
+			return -1;
+		}
+		cpu->reg.r[i] = *addrp;
+		DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "r%u(0x%x) ", i, cpu->reg.r[i]));
+		*sp = addr + 4;
+		cpu->real_elaps += 1U;
+	}
+
+	if (reg1 != 0U) {
+		cpu->real_elaps += 6U;
+		DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), ":pc=r%u(0x%x) sp=0x%x\n", reg1, cpu->reg.r[reg1], cpu->reg.r[3]));
+		cpu->reg.pc = cpu->reg.r[reg1];
+	}
+	else {
+		cpu->real_elaps += 2U;
+		DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), ":pc=r%u(0x%x) sp=0x%x\n", reg1, cpu->reg.pc, cpu->reg.r[3]));
+		cpu->reg.pc += 4;
+	}
+
+	return 0;
+}
+
+int op_exec_pushsp_11(TargetCoreType *cpu)
+{
+	uint16 rh = cpu->decoded_code->type11.reg1;
+	uint16 rt = cpu->decoded_code->type11.reg3;
+	uint32 *sp = (uint32*)&(cpu->reg.r[3]);	//sp:r3
+	uint16 cur;
+	uint32 tmp_sp;
+	Std_ReturnType err;
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: PUSHSP rh=%u rt=%u sp=0x%x ",
+		cpu->reg.pc, rh, rt, *sp));
+
+	if (rh > rt) {
+		cpu->reg.pc += 4;
+		return 0;
+	}
+	/*
+	* if rh ≦ rt
+	* then cur ← rh
+	* end ← rt
+	* tmp ← sp
+	* while (cur ≦ end) {
+	* tmp ← tmp – 4
+	* adr ← tmp 注 1, 注 2
+	* Store-memory (adr, GR[cur], Word)
+	* cur ← cur + 1
+	* }
+	* sp ← tmp
+	*/
+	cur = rh;
+	tmp_sp = ((*sp) & 0xFFFFFFFC);
+	while (cur <= rt) {
+		tmp_sp = tmp_sp - 4;
+		err = bus_put_data32(cpu->core_id, tmp_sp, cpu->reg.r[cur]);
+		if (err != STD_E_OK) {
+			printf("ERROR:PUSHSP pc=0x%x sp=0x%x\n", cpu->reg.pc, *sp);
+			return -1;
+		}
+		cur++;
+		cpu->real_elaps += 1U;
+	}
+	*sp = tmp_sp;
+	cpu->reg.pc += 4;
+	return 0;
+}
+
+int op_exec_popsp_11(TargetCoreType *cpu)
+{
+	uint16 rh = cpu->decoded_code->type11.reg1;
+	uint16 rt = cpu->decoded_code->type11.reg3;
+	uint32 *sp = (uint32*)&(cpu->reg.r[3]);	//sp:r3
+	uint16 cur;
+	uint32 tmp_sp;
+	Std_ReturnType err;
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: POPSP rh=%u rt=%u sp=0x%x ",
+		cpu->reg.pc, rh, rt, *sp));
+
+	if (rh > rt) {
+		cpu->reg.pc += 4;
+		return 0;
+	}
+	/*
+	* if rh ≦ rt
+	* then cur ← rt
+	* end ← rh
+	* tmp ← sp
+	* while (cur ≧ end) {
+	* adr ← tmp 注 1, 注 2
+	* GR[cur] ← Load-memory (adr, Word)
+	* cur ← cur – 1
+	* tmp ← tmp + 4
+	* }
+	* sp ← tmp
+	*/
+	cur = rt;
+	tmp_sp = ((*sp) & 0xFFFFFFFC);
+	while (cur >= rh) {
+		err = bus_get_data32(cpu->core_id, tmp_sp, (uint32*)&(cpu->reg.r[cur]));
+		if (err != STD_E_OK) {
+			printf("ERROR:POPSP pc=0x%x sp=0x%x\n", cpu->reg.pc, *sp);
+			return -1;
+		}
+		cur--;
+		tmp_sp = tmp_sp + 4;
+		cpu->real_elaps += 1U;
+	}
+	*sp = tmp_sp;
+	cpu->reg.pc += 4;
+	return 0;
+}
+
+int op_exec_synce_1(TargetCoreType *cpu)
+{
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SYNCE\n", cpu->reg.pc));
+	cpu->reg.pc += 2;
+	return 0;
+}
+int op_exec_synci_1(TargetCoreType *cpu)
+{
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SYNCI\n", cpu->reg.pc));
+	cpu->reg.pc += 2;
+	return 0;
+}
+int op_exec_syncm_1(TargetCoreType *cpu)
+{
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SYNCM\n", cpu->reg.pc));
+	cpu->reg.pc += 2;
+	return 0;
+}
+int op_exec_syncp_1(TargetCoreType *cpu)
+{
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SYNCP\n", cpu->reg.pc));
+	cpu->reg.pc += 2;
+	return 0;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_exec/op_exec_store.c
@@ -0,0 +1,376 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include <stdlib.h>
+
+#include "cpu_exec/op_exec_ops.h"
+#include "cpu.h"
+#include "bus.h"
+
+#include "device.h"
+#include "target_mpu_op.h"
+
+#ifdef SUPRESS_DETECT_ERROR
+#define IS_STACK_OVER(cpu, reg, disp) (FALSE)
+#else
+#define IS_STACK_OVER(cpu, regN, disp) (cpu_may_store_on_stack_overflow((cpu)->reg.r[(regN)], (disp) == TRUE))
+#endif /* SUPRESS_DETECT_ERROR */
+
+/*
+ * Format4
+ */
+int op_exec_sstb(TargetCoreType *cpu)
+{
+	uint32 addr;
+	uint32 disp;
+	uint32 reg1 = CPU_REG_EP;
+	uint32 reg2 = cpu->decoded_code->type4_1.reg2;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	disp = cpu->decoded_code->type4_1.disp;
+	disp = (disp << 1) | cpu->decoded_code->type4_1.gen;
+	disp = op_zero_extend(7, disp);
+	addr = cpu->reg.r[reg1] + disp;
+
+	if ((reg1 == CPU_REG_SP) && IS_STACK_OVER(cpu, reg1, disp)) {
+		printf("ERROR: found stack overflow\n");
+		return -1;
+	}
+
+	err = bus_put_data8(cpu->core_id, addr, (uint8)cpu->reg.r[reg2]);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SST.B r%d(0x%x), disp7(0x%x) r%d(0x%x):0x%x\n", cpu->reg.pc, reg1, cpu->reg.r[reg1], disp, reg2, cpu->reg.r[reg2], (uint8)cpu->reg.r[reg2]));
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+int op_exec_ssth(TargetCoreType *cpu)
+{
+	uint32 addr;
+	uint32 disp;
+	uint32 reg1 = CPU_REG_EP;
+	uint32 reg2 = cpu->decoded_code->type4_1.reg2;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+
+	disp = cpu->decoded_code->type4_1.disp;
+	disp = (disp << 1) | cpu->decoded_code->type4_1.gen;
+	disp = op_zero_extend(7, disp);
+	disp = disp << 1;
+	addr = cpu->reg.r[reg1] + disp;
+	if ((reg1 == CPU_REG_SP) && IS_STACK_OVER(cpu, reg1, disp)) {
+		printf("ERROR: found stack overflow\n");
+		return -1;
+	}
+
+	err = bus_put_data16(cpu->core_id, addr, (uint16)cpu->reg.r[reg2]);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SST.H r%d(0x%x), disp8(0x%x) r%d(0x%x):0x%x\n", cpu->reg.pc, reg1, cpu->reg.r[reg1], disp, reg2, cpu->reg.r[reg2], (uint16)cpu->reg.r[reg2]));
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+
+int op_exec_sstw(TargetCoreType *cpu)
+{
+	uint32 addr;
+	uint32 disp;
+	uint32 reg1 = CPU_REG_EP;
+	uint32 reg2 = cpu->decoded_code->type4_1.reg2;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	disp = cpu->decoded_code->type4_1.disp;
+	disp = op_zero_extend(6, disp);
+	disp = disp << 2;
+	addr = cpu->reg.r[reg1] + disp;
+	if ((reg1 == CPU_REG_SP) && IS_STACK_OVER(cpu, reg1, disp)) {
+		printf("ERROR: found stack overflow\n");
+		return -1;
+	}
+
+	err = bus_put_data32(cpu->core_id, addr, (uint32)cpu->reg.r[reg2]);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: SST.W r%d(0x%x), disp7(0x%x) r%d(0x%x):0x%x\n", cpu->reg.pc, reg1, cpu->reg.r[reg1], disp, reg2, cpu->reg.r[reg2], (uint32)cpu->reg.r[reg2]));
+
+	cpu->reg.pc += 2;
+	return 0;
+}
+
+/*
+ * Format7
+ */
+
+int op_exec_sthw(TargetCoreType *cpu)
+{
+	uint32 addr;
+	sint32 disp;
+	uint32 reg1 = cpu->decoded_code->type7.reg1;
+	uint32 reg2 = cpu->decoded_code->type7.reg2;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+
+	if (cpu->decoded_code->type7.gen == 0x00) {
+		//ST.H
+		disp = op_sign_extend(15, (cpu->decoded_code->type7.disp << 1) );
+		addr = cpu->reg.r[reg1] + disp;
+		if ((reg1 == CPU_REG_SP) && IS_STACK_OVER(cpu, reg1, disp)) {
+			printf("ERROR: found stack overflow\n");
+			return -1;
+		}
+
+		err = bus_put_data16(cpu->core_id, addr, (sint16)cpu->reg.r[reg2]);
+		if (err != STD_E_OK) {
+			return -1;
+		}
+
+		DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: ST.H r%d(0x%x), disp16(%d) r%d(0x%x):0x%x\n", cpu->reg.pc, reg2, cpu->reg.r[reg2], disp, reg1, cpu->reg.r[reg1], (sint16)cpu->reg.r[reg2]));
+	}
+	else {
+		//ST.W
+		disp = op_sign_extend(15, (cpu->decoded_code->type7.disp << 1) );
+		addr = cpu->reg.r[reg1] + disp;
+		if ((reg1 == CPU_REG_SP) && IS_STACK_OVER(cpu, reg1, disp)) {
+			printf("ERROR: found stack overflow\n");
+			return -1;
+		}
+
+		err = bus_put_data32(cpu->core_id, addr, (sint32)cpu->reg.r[reg2]);
+		if (err != STD_E_OK) {
+			return -1;
+		}
+
+		DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: ST.W r%d(0x%x), disp16(%d) r%d(0x%x):0x%x\n", cpu->reg.pc, reg2, cpu->reg.r[reg2], disp, reg1, cpu->reg.r[reg1], (sint32)cpu->reg.r[reg2]));
+	}
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+
+
+int op_exec_stb(TargetCoreType *cpu)
+{
+	uint32 addr;
+	sint32 disp;
+	uint32 reg1 = cpu->decoded_code->type7.reg1;
+	uint32 reg2 = cpu->decoded_code->type7.reg2;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg2 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	disp = op_sign_extend(15, (cpu->decoded_code->type7.disp << 1) | cpu->decoded_code->type7.gen);
+	addr = cpu->reg.r[reg1] + disp;
+	if ((reg1 == CPU_REG_SP) && IS_STACK_OVER(cpu, reg1, disp)) {
+		printf("ERROR: found stack overflow\n");
+		return -1;
+	}
+
+
+	err = bus_put_data8(cpu->core_id, addr, (uint8)cpu->reg.r[reg2]);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: ST.B r%d(0x%x), disp16(%d) r%d(0x%x):0x%x\n", cpu->reg.pc, reg2, cpu->reg.r[reg2], disp, reg1, cpu->reg.r[reg1], (uint8)cpu->reg.r[reg2]));
+
+	cpu->reg.pc += 4;
+	return 0;
+}
+
+int op_exec_st_b_14(TargetCoreType *cpu)
+{
+	uint32 addr;
+	sint32 disp;
+	uint32 reg1 = cpu->decoded_code->type14.reg1;
+	uint32 reg3 = cpu->decoded_code->type14.reg3;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	disp = op_sign_extend(22, (cpu->decoded_code->type14.disp_high << 7U) | cpu->decoded_code->type14.disp_low);
+	addr = cpu->reg.r[reg1] + disp;
+	if ((reg1 == CPU_REG_SP) && IS_STACK_OVER(cpu, reg1, disp)) {
+		printf("ERROR: found stack overflow\n");
+		return -1;
+	}
+
+	err = bus_put_data8(cpu->core_id, addr, (uint8)cpu->reg.r[reg3]);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: ST.B r%d(0x%x), disp23(%d) r%d(0x%x):0x%x\n",
+			cpu->reg.pc,
+			reg3, cpu->reg.r[reg3],
+			disp,
+			reg1, cpu->reg.r[reg1],
+			(uint8)cpu->reg.r[reg3]));
+
+	cpu->reg.pc += 6;
+	return 0;
+}
+
+
+int op_exec_st_h_14(TargetCoreType *cpu)
+{
+	uint32 addr;
+	sint32 disp;
+	uint32 reg1 = cpu->decoded_code->type14.reg1;
+	uint32 reg3 = cpu->decoded_code->type14.reg3;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	disp = op_sign_extend(22, (cpu->decoded_code->type14.disp_high << 7U) | cpu->decoded_code->type14.disp_low);
+	addr = cpu->reg.r[reg1] + disp;
+	if ((reg1 == CPU_REG_SP) && IS_STACK_OVER(cpu, reg1, disp)) {
+		printf("ERROR: found stack overflow\n");
+		return -1;
+	}
+
+	err = bus_put_data16(cpu->core_id, addr, (sint16)cpu->reg.r[reg3]);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: ST.H r%d(0x%x), disp23(%d) r%d(0x%x):0x%x\n",
+			cpu->reg.pc,
+			reg3, cpu->reg.r[reg3],
+			disp,
+			reg1, cpu->reg.r[reg1],
+			(sint16)cpu->reg.r[reg3]));
+
+	cpu->reg.pc += 6;
+	return 0;
+}
+
+int op_exec_st_w_14(TargetCoreType *cpu)
+{
+	uint32 addr;
+	sint32 disp;
+	uint32 reg1 = cpu->decoded_code->type14.reg1;
+	uint32 reg3 = cpu->decoded_code->type14.reg3;
+	Std_ReturnType err;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+
+	disp = op_sign_extend(22, (cpu->decoded_code->type14.disp_high << 7U) | cpu->decoded_code->type14.disp_low);
+	addr = cpu->reg.r[reg1] + disp;
+	if ((reg1 == CPU_REG_SP) && IS_STACK_OVER(cpu, reg1, disp)) {
+		printf("ERROR: found stack overflow\n");
+		return -1;
+	}
+
+	err = bus_put_data32(cpu->core_id, addr, (sint32)cpu->reg.r[reg3]);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: ST.W r%d(0x%x), disp23(%d) r%d(0x%x):0x%x\n",
+			cpu->reg.pc,
+			reg3, cpu->reg.r[reg3],
+			disp,
+			reg1, cpu->reg.r[reg1],
+			(sint32)cpu->reg.r[reg3]));
+
+	cpu->reg.pc += 6;
+	return 0;
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/cpu_exec/op_exec_store_rh850.c
@@ -0,0 +1,103 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include <stdlib.h>
+
+#include "cpu_exec/op_exec_ops.h"
+#include "cpu.h"
+#include "bus.h"
+
+#include "device.h"
+#include "target_mpu_op.h"
+
+int op_exec_st_dw_14(TargetCoreType *cpu)
+{
+	uint32 addr;
+	sint32 disp;
+	uint32 reg1 = cpu->decoded_code->type14.reg1;
+	uint32 reg3 = cpu->decoded_code->type14.reg3;
+	uint32 reg3plus1 = reg3 + 1;
+	Std_ReturnType err;
+	bool has_permission;
+
+	if (reg1 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if (reg3 >= CPU_GREG_NUM) {
+		return -1;
+	}
+	if ((reg3 % 2) != 0) {
+		return -1;
+	}
+
+	disp = op_sign_extend(22, (cpu->decoded_code->type14.disp_high << 7U) | cpu->decoded_code->type14.disp_low);
+	addr = cpu->reg.r[reg1] + disp;
+	if ((reg1 == CPU_REG_SP) && cpu_may_store_on_stack_overflow(cpu->reg.r[reg1], disp) == TRUE) {
+		printf("ERROR: found stack overflow\n");
+		return -1;
+	}
+
+	has_permission = target_mpu_has_permission(cpu, MPU_TARGET_ACCESS_WRITE, addr, 8U);
+	if (!(has_permission)) {
+		return -1;
+	}
+
+	err = bus_put_data32(cpu->core_id, addr, (sint32)cpu->reg.r[reg3]);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+	err = bus_put_data32(cpu->core_id, (addr + 4U), (sint32)cpu->reg.r[reg3plus1]);
+	if (err != STD_E_OK) {
+		return -1;
+	}
+
+	DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "0x%x: ST.W r%d(0x%x), disp23(%d) r%d(0x%x):0x%x 0x%x\n",
+			cpu->reg.pc,
+			reg3, cpu->reg.r[reg3],
+			disp,
+			reg1, cpu->reg.r[reg1],
+			(sint32)cpu->reg.r[reg3],
+			(sint32)cpu->reg.r[reg3plus1]));
+
+	cpu->reg.pc += 6;
+	return 0;
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/mpu/target/rh850f1k/target_mpu.c
@@ -0,0 +1,633 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "target_cpu.h"
+#include "cpu_common/cpu_ops.h"
+
+#include "target_mpu_mei.h"
+
+void mpu_init(TargetCoreType *cpu)
+{
+	uint32* sysreg;
+
+	/* MPM 0000 0000*/
+	sysreg = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_5, SYS_REG_MPM);
+	*sysreg = 0x00;
+
+	/* MPRC 0000 0000*/
+	sysreg = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_5, SYS_REG_MPRC);
+	*sysreg = 0x00;
+
+	/* MPBRGN 0000 0000*/
+	sysreg = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_5, SYS_REG_MPBRGN);
+	*sysreg = 0x00;
+
+	/* MPTRGN 0001 0000*/
+	sysreg = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_5, SYS_REG_MPTRGN);
+	*sysreg = 0x10;
+
+	/* MPATn(0~15) 0000 0000 */
+	sysreg = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_6, SYS_REG_MPAT0);
+	*sysreg = 0x00;
+	sysreg = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_6, SYS_REG_MPAT1);
+	*sysreg = 0x00;
+	sysreg = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_6, SYS_REG_MPAT2);
+	*sysreg = 0x00;
+	sysreg = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_6, SYS_REG_MPAT3);
+	*sysreg = 0x00;
+	sysreg = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_6, SYS_REG_MPAT4);
+	*sysreg = 0x00;
+	sysreg = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_6, SYS_REG_MPAT5);
+	*sysreg = 0x00;
+	sysreg = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_6, SYS_REG_MPAT6);
+	*sysreg = 0x00;
+	sysreg = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_6, SYS_REG_MPAT7);
+	*sysreg = 0x00;
+
+	sysreg = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_7, SYS_REG_MPAT8);
+	*sysreg = 0x00;
+	sysreg = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_7, SYS_REG_MPAT9);
+	*sysreg = 0x00;
+	sysreg = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_7, SYS_REG_MPAT10);
+	*sysreg = 0x00;
+	sysreg = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_7, SYS_REG_MPAT11);
+	*sysreg = 0x00;
+	sysreg = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_7, SYS_REG_MPAT12);
+	*sysreg = 0x00;
+	sysreg = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_7, SYS_REG_MPAT13);
+	*sysreg = 0x00;
+	sysreg = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_7, SYS_REG_MPAT14);
+	*sysreg = 0x00;
+	sysreg = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_7, SYS_REG_MPAT15);
+	*sysreg = 0x00;
+
+	/* MCC 0000 0000 */
+	sysreg = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_5, SYS_REG_MCC);
+	*sysreg = 0x00;
+
+	return;
+}
+
+#define TARGET_MPU_SYSREG6_OFFSET_INDEX		0U
+#define TARGET_MPU_SYSREG7_OFFSET_INDEX		8U
+#define TARGET_MPU_SYSREG_PROTECTION_REGION_BASE(index, offset)		((index - offset) * 4U)
+#define TARGET_MPU_SYSREG_MPLA(base)		(base)
+#define TARGET_MPU_SYSREG_MPUA(base)		(base + 1U)
+#define TARGET_MPU_SYSREG_MPAT(base)		(base + 2U)
+
+
+#define TARGET_MPU_SYSREG_MPM_MPE		0x0001
+#define TARGET_MPU_SYSREG_MPM_SVP		0x0002
+
+#define TARGET_MPU_SYSREG_MPAT_E		0x0080
+#define TARGET_MPU_SYSREG_MPAT_G		0x0040
+#define TARGET_MPU_SYSREG_MPAT_SX		0x0020
+#define TARGET_MPU_SYSREG_MPAT_SW		0x0010
+#define TARGET_MPU_SYSREG_MPAT_SR		0x0008
+#define TARGET_MPU_SYSREG_MPAT_UX		0x0004
+#define TARGET_MPU_SYSREG_MPAT_UW		0x0002
+#define TARGET_MPU_SYSREG_MPAT_UR		0x0001
+#define TARGET_MPU_SYSREG_MPAT_ASID		0x03FF0000
+
+#define TARGET_MPU_SYSREG_IS_BIT_SET(sysregp, bit)		((*sysregp & bit) == bit)
+#define TARGET_MPU_SYSREG_MPAT_GET_ASID(sysregp)	((*sysregp & TARGET_MPU_SYSREG_MPAT_ASID) >> 16U)
+
+#define TARGET_MPU_ADDR_START_MASK(addr)	((addr) & 0xFFFFFFFC)
+#define TARGET_MPU_ADDR_END_MASK(addr)	((addr) | 0x3)
+
+void mpu_set_config(TargetCoreType *cpu)
+{
+	TargetMpuConfigType* mpu_config_obj;
+	uint32* sysregp;
+	uint8 index;
+	uint8 base;
+	uint8 regid;
+	uint8 selid;
+
+
+	/* MPM */
+	sysregp = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_5, SYS_REG_MPM);
+	cpu->mpu.is_enable_mpu = TARGET_MPU_SYSREG_IS_BIT_SET(sysregp, TARGET_MPU_SYSREG_MPM_MPE);
+	cpu->mpu.is_enable_sv = TARGET_MPU_SYSREG_IS_BIT_SET(sysregp, TARGET_MPU_SYSREG_MPM_SVP);
+	cpu->mpu.is_enable_outside_protection_region.exec = FALSE;
+	cpu->mpu.is_enable_outside_protection_region.read = FALSE;
+	cpu->mpu.is_enable_outside_protection_region.write = FALSE;
+
+	for(index = 0U; index < TARGET_MPU_CONFIG_NUM; index++){
+		mpu_config_obj = (TargetMpuConfigType*)object_container_get_element(cpu->mpu.permission_region, index);
+		if (index < TARGET_MPU_SYSREG7_OFFSET_INDEX) {
+			selid = SYS_GRP_6;
+			base = TARGET_MPU_SYSREG_PROTECTION_REGION_BASE(index, TARGET_MPU_SYSREG6_OFFSET_INDEX);
+		}
+		else {
+			selid = SYS_GRP_7;
+			base = TARGET_MPU_SYSREG_PROTECTION_REGION_BASE(index, TARGET_MPU_SYSREG7_OFFSET_INDEX);
+		}
+
+		/* MPLA */
+		regid = TARGET_MPU_SYSREG_MPLA(base);
+		sysregp = cpu_get_sysreg2(&cpu->reg.sys, selid, regid);
+		mpu_config_obj->addr_start = TARGET_MPU_ADDR_START_MASK(*sysregp);
+
+		/* MPUA */
+		regid = TARGET_MPU_SYSREG_MPUA(base);
+		sysregp = cpu_get_sysreg2(&cpu->reg.sys, selid, regid);
+		mpu_config_obj->addr_end = TARGET_MPU_ADDR_END_MASK(*sysregp);
+
+		/* MPAT */
+		regid = TARGET_MPU_SYSREG_MPAT(base);
+		sysregp = cpu_get_sysreg2(&cpu->reg.sys, selid, regid);
+		mpu_config_obj->is_enable = TARGET_MPU_SYSREG_IS_BIT_SET(sysregp, TARGET_MPU_SYSREG_MPAT_E);
+		mpu_config_obj->is_enable_apply_config = TARGET_MPU_SYSREG_IS_BIT_SET(sysregp, TARGET_MPU_SYSREG_MPAT_G);
+		mpu_config_obj->is_enable_access_sv.exec = TARGET_MPU_SYSREG_IS_BIT_SET(sysregp, TARGET_MPU_SYSREG_MPAT_SX);
+		mpu_config_obj->is_enable_access_sv.write = TARGET_MPU_SYSREG_IS_BIT_SET(sysregp, TARGET_MPU_SYSREG_MPAT_SW);
+		mpu_config_obj->is_enable_access_sv.read = TARGET_MPU_SYSREG_IS_BIT_SET(sysregp, TARGET_MPU_SYSREG_MPAT_SR);
+		mpu_config_obj->is_enable_access_um.exec = TARGET_MPU_SYSREG_IS_BIT_SET(sysregp, TARGET_MPU_SYSREG_MPAT_UX);
+		mpu_config_obj->is_enable_access_um.write = TARGET_MPU_SYSREG_IS_BIT_SET(sysregp, TARGET_MPU_SYSREG_MPAT_UW);
+		mpu_config_obj->is_enable_access_um.read = TARGET_MPU_SYSREG_IS_BIT_SET(sysregp, TARGET_MPU_SYSREG_MPAT_UR);
+		mpu_config_obj->asid = TARGET_MPU_SYSREG_MPAT_GET_ASID(sysregp);
+
+	}
+	return;
+}
+
+bool mpu_is_enable_protection_region(TargetCoreType *cpu, TargetMpuConfigType* region_config)
+{
+	/* enable check */
+	if (!(region_config->is_enable)) {
+		return FALSE;
+	}
+
+	/* enable set region */
+	if (region_config->addr_end < region_config->addr_start) {
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+bool mpu_is_apply_protection_region(TargetCoreType *cpu, TargetMpuConfigType* region_config)
+{
+	uint32* sysregp;
+	if (!region_config->is_enable_apply_config) {
+		return FALSE;
+	}
+
+	/* ASID */
+	sysregp = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_2, SYS_REG_ASID);
+	if (region_config->asid == *sysregp) {
+		return TRUE;
+	}
+	else{
+		return FALSE;
+	}
+
+}
+
+bool mpu_has_permission_access_type(TargetCoreType *cpu, TargetMpuAccessType access_type, TargetMpuConfigType* region_config)
+{
+	TargetMpuEnableAccessType *is_enable_access;
+
+	if (CPU_ISSET_UM(&(cpu->reg))) {
+		is_enable_access = &(region_config->is_enable_access_um);
+	}
+	else {
+		is_enable_access = &(region_config->is_enable_access_sv);
+	}
+
+	switch (access_type) {
+	case MPU_TARGET_ACCESS_READ:
+		return is_enable_access->read;
+	case MPU_TARGET_ACCESS_WRITE:
+		return is_enable_access->write;
+	case MPU_TARGET_ACCESS_EXEC:
+		return is_enable_access->exec;
+	default:
+		break;
+	}
+	return FALSE;
+}
+
+static bool mpu_has_permission_access_region_mdp(uint32 addr, uint32 size, TargetMpuConfigType** region_config, uint8 enable_region_num)
+{
+	uint8 index;
+
+	for (index = 0; index < enable_region_num; index++) {
+		if ((region_config[index]->addr_start <= addr) && ((addr + size - 1) <= region_config[index]->addr_end)) {
+			return TRUE;
+		}
+	}
+	//printf("mpu_has_permission_access_region_mdp:start=0x%x size=%d\n", addr, size);
+	return FALSE;
+}
+
+static bool mpu_has_permission_access_region_mip(uint32 addr, uint32 size, TargetMpuConfigType** region_config, uint8 enable_region_num)
+{
+	uint8 index;
+	uint32 check_addr;
+
+	/*
+	 * Check every byte
+	 */
+	for (check_addr = addr; check_addr < addr + size; check_addr++) {
+		for (index = 0U; index < enable_region_num; index++){
+			if ((region_config[index]->addr_start <= check_addr) && (check_addr <= region_config[index]->addr_end)) {
+				break;
+			}
+		}
+		if (index == enable_region_num) {
+			return FALSE;
+		}
+	}
+
+	return TRUE;
+}
+
+bool mpu_has_permission_access_region(TargetCoreType *cpu, TargetMpuAccessType access_type, uint32 addr, uint32 size, TargetMpuConfigType** region_config, uint8 enable_region_num)
+{
+	bool has_permission;
+
+	if (access_type == MPU_TARGET_ACCESS_EXEC) {
+		has_permission = mpu_has_permission_access_region_mip(addr, size, region_config, enable_region_num);
+	}
+	else {
+		has_permission = mpu_has_permission_access_region_mdp(addr, size, region_config, enable_region_num);
+	}
+
+	return has_permission;
+}
+
+void mpu_set_error(TargetCoreType *cpu)
+{
+	uint32* sysregp;
+	uint32 data;
+	OpCodeId code_id;
+
+	/* MEA */
+	sysregp = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_2, SYS_REG_MEA);
+	*sysregp = cpu->mpu.excption_error_info.error_addr;
+
+	if (cpu->mpu.excption_error_info.intc_error_info.access_type == MPU_TARGET_ACCESS_EXEC){
+		return;
+	}
+
+	/* MEI */
+	code_id = cpu->mpu.excption_error_info.op_codeid;
+
+	data = 0U;
+	/* reg */
+	switch (memory_error_info[code_id].reg) {
+	case TARGET_MPU_MEI_REG_0:
+	case TARGET_MPU_MEI_REG_1:
+	case TARGET_MPU_MEI_REG_2:
+	case TARGET_MPU_MEI_REG_3:
+		data = (memory_error_info[code_id].reg << TARGET_MPU_SYSREG_MEI_REG_OFFSET);
+		break;
+	case TARGET_MPU_MEI_REG_NONE:
+		/* nop */
+		break;
+	default:
+		break;
+	}
+
+	/* ds */
+	data |= (memory_error_info[code_id].data_type << TARGET_MPU_SYSREG_MEI_DS_OFFSET);
+
+	/* u */
+	data |= (memory_error_info[code_id].sign << TARGET_MPU_SYSREG_MEI_U_OFFSET);
+
+	/* itype */
+	data |= (memory_error_info[code_id].itype << TARGET_MPU_SYSREG_MEI_ITYPE_OFFSET);
+
+	/* rw */
+	data |= (memory_error_info[code_id].rw << TARGET_MPU_SYSREG_MEI_RW_OFFSET);
+
+	sysregp = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_2, SYS_REG_MEI);
+	*sysregp = data;
+
+	return;
+}
+
+#define TARGET_MPU_CHECK_ADDR_OFFSET			0x7FFFFFFF
+#define TARGET_MPU_CHECK_SET(permission)		(permission) ? 1U : 0U
+
+#define TARGET_MPU_SYSREG_MCR_OV_OFFSET			8U
+#define TARGET_MPU_SYSREG_MCR_SXE_OFFSET		5U
+#define TARGET_MPU_SYSREG_MCR_SWE_OFFSET		4U
+#define TARGET_MPU_SYSREG_MCR_SRE_OFFSET		3U
+#define TARGET_MPU_SYSREG_MCR_UXE_OFFSET		2U
+#define TARGET_MPU_SYSREG_MCR_UWE_OFFSET		1U
+#define TARGET_MPU_SYSREG_MCR_URE_OFFSET		0U
+
+static void mpu_check_permission(TargetMpuEnableAccessType *permission, TargetMpuEnableAccessType *result)
+{
+	if (permission->exec == TRUE) {
+		result->exec = TRUE;
+	}
+	if (permission->read == TRUE) {
+		result->read = TRUE;
+	}
+	if (permission->write == TRUE) {
+		result->write = TRUE;
+	}
+	return;
+}
+
+void mpu_check(TargetCoreType *cpu)
+{
+	bool ov_flag;
+	uint32 *mcap;
+	uint32 *mcsp;
+	uint32 *mcrp;
+	uint32 addr_start;
+	uint32 addr_end;
+	uint32 data;
+	TargetMpuEnableAccessType sv;
+	TargetMpuEnableAccessType um;
+
+	TargetMpuConfigType* mpu_config_obj;
+	uint8 index;
+
+	mcap = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_2, SYS_REG_MCA);
+	mcsp = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_2, SYS_REG_MCS);
+	mcrp = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_2, SYS_REG_MCR);
+
+	addr_start = *mcap;
+	addr_end = *mcap + *mcsp;
+
+	sv.exec = FALSE;
+	sv.read = FALSE;
+	sv.write = FALSE;
+	um.exec = FALSE;
+	um.read = FALSE;
+	um.write = FALSE;
+
+	data = 0U;
+
+	/* ov */
+	if (addr_start > addr_end) {
+		ov_flag = TRUE;
+	}
+	else if ((addr_start <= TARGET_MPU_CHECK_ADDR_OFFSET) && (addr_end > TARGET_MPU_CHECK_ADDR_OFFSET)) {
+		ov_flag = TRUE;
+	}
+	else {
+		ov_flag = FALSE;
+	}
+
+	/* permission */
+	for(index = 0U; index < TARGET_MPU_CONFIG_NUM; index++){
+		mpu_config_obj = (TargetMpuConfigType*)object_container_get_element(cpu->mpu.permission_region, index);
+		if (!(mpu_config_obj->addr_start <= addr_start) && (addr_end <= mpu_config_obj->addr_end)) {
+			continue;
+		}
+		mpu_check_permission(&(mpu_config_obj->is_enable_access_sv), &sv);
+		mpu_check_permission(&(mpu_config_obj->is_enable_access_um), &um);
+	}
+
+
+	/* MCR */
+	data = (TARGET_MPU_CHECK_SET(ov_flag) << TARGET_MPU_SYSREG_MCR_OV_OFFSET)		|
+			(TARGET_MPU_CHECK_SET(sv.exec) << TARGET_MPU_SYSREG_MCR_SXE_OFFSET)		|
+			(TARGET_MPU_CHECK_SET(sv.read) << TARGET_MPU_SYSREG_MCR_SRE_OFFSET)		|
+			(TARGET_MPU_CHECK_SET(sv.write) << TARGET_MPU_SYSREG_MCR_SWE_OFFSET)	|
+			(TARGET_MPU_CHECK_SET(um.exec) << TARGET_MPU_SYSREG_MCR_UXE_OFFSET)		|
+			(TARGET_MPU_CHECK_SET(um.read) << TARGET_MPU_SYSREG_MCR_URE_OFFSET)		|
+			(TARGET_MPU_CHECK_SET(um.write) << TARGET_MPU_SYSREG_MCR_UWE_OFFSET);
+	*mcrp = data;
+
+	return;
+}
+
+#define TARGET_MPU_IS_MPLA(regid)	((regid % 4U) == 0U)
+#define TARGET_MPU_IS_MPUA(regid)	((regid % 4U) == 1U)
+#define TARGET_MPU_IS_MPTA(regid)	((regid % 4U) == 2U)
+
+#define TARGET_MPU_SYSREG_MPLA_READ_MASK(data)		(data & 0xFFFFFFFC)
+#define TARGET_MPU_SYSREG_MPUA_READ_MASK(data)		(data & 0xFFFFFFFC)
+
+static void mpu_hook_access_read(TargetCoreType *cpu, uint32 *data, uint8 regid, uint8 selid)
+{
+	if ((selid == SYS_GRP_5) && (regid == SYS_REG_MPBRGN)) {
+		*data = 0U;
+		return;
+	}
+	if((selid == SYS_GRP_5) && (regid == SYS_REG_MPTRGN)) {
+		*data = TARGET_MPU_CONFIG_NUM;
+		return;
+	}
+
+	if ((selid == SYS_GRP_6) || (selid == SYS_GRP_7)) {
+		if (TARGET_MPU_IS_MPLA(regid)) {
+			*data = TARGET_MPU_SYSREG_MPLA_READ_MASK(*data);
+			return;
+		}
+		if (TARGET_MPU_IS_MPUA(regid)) {
+			*data = TARGET_MPU_SYSREG_MPUA_READ_MASK(*data);
+			return;
+		}
+	}
+
+	if ((selid == SYS_GRP_5) && (regid == SYS_REG_MCC)) {
+		*data = 0U;
+	}
+
+	return;
+}
+
+#define TARGET_MPU_SYSREG_MPAT_E_OFFSET			7U
+#define TARGET_MPU_SYSREG_MRC_En_IS_ENBALE(index)			((*data & (1U << index)) && (1U << index))
+
+
+static void mpu_hook_access_write_mprc(TargetCoreType *cpu, uint32 *data)
+{
+	uint8 index;
+	uint8 selid;
+	uint8 regid;
+	uint8 base;
+	uint32* sysregp;
+
+	for(index = 0U; index < TARGET_MPU_CONFIG_NUM; index++){
+		if (index < TARGET_MPU_SYSREG7_OFFSET_INDEX) {
+			selid = SYS_GRP_6;
+			base = TARGET_MPU_SYSREG_PROTECTION_REGION_BASE(index, TARGET_MPU_SYSREG6_OFFSET_INDEX);
+		}
+		else {
+			selid = SYS_GRP_7;
+			base = TARGET_MPU_SYSREG_PROTECTION_REGION_BASE(index, TARGET_MPU_SYSREG7_OFFSET_INDEX);
+		}
+
+		regid = TARGET_MPU_SYSREG_MPAT(base);
+		sysregp = cpu_get_sysreg2(&cpu->reg.sys, selid, regid);
+
+		if (TARGET_MPU_SYSREG_MRC_En_IS_ENBALE(index)) {
+			*sysregp |= (1U << TARGET_MPU_SYSREG_MPAT_E_OFFSET);
+		}
+		else {
+			*sysregp &= ~(1U << TARGET_MPU_SYSREG_MPAT_E_OFFSET);
+		}
+
+	}
+
+	return;
+}
+
+#define TARGET_MPU_GET_CONFIG_INDEX(base, regid)	(base + (regid / 4U))
+
+static uint8 mpu_hook_access_write_mpta_get_config_index(uint8 regid, uint8 selid)
+{
+	uint8 base;
+
+	if (selid == SYS_GRP_6) {
+		base = TARGET_MPU_SYSREG6_OFFSET_INDEX;
+	}
+	else{
+		base = TARGET_MPU_SYSREG7_OFFSET_INDEX;
+	}
+
+	return TARGET_MPU_GET_CONFIG_INDEX(base, regid);
+}
+
+static void mpu_hook_access_write_mpta(TargetCoreType *cpu, uint32 *data, uint8 regid, uint8 selid)
+{
+
+	uint32* sysregp;
+	uint8 value;
+	uint8 index;
+	sysregp = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_5, SYS_REG_MPRC);
+
+	value = ((*data & TARGET_MPU_SYSREG_MPAT_E) >> TARGET_MPU_SYSREG_MPAT_E_OFFSET);
+
+	index = mpu_hook_access_write_mpta_get_config_index(regid, selid);
+
+	if (value == 0U) {
+		*sysregp &= ~(1U << index);
+	}
+	else {
+		*sysregp |= (1U << index);
+	}
+
+	return;
+}
+
+static void mpu_hook_access_write(TargetCoreType *cpu, uint32 *data, uint8 regid, uint8 selid)
+{
+
+	if ((selid == SYS_GRP_5) && (regid == SYS_REG_MPRC)) {
+		mpu_hook_access_write_mprc(cpu, data);
+		return;
+	}
+	if ((selid == SYS_GRP_6) || (selid == SYS_GRP_7)) {
+		if (TARGET_MPU_IS_MPTA(regid)) {
+			mpu_hook_access_write_mpta(cpu, data, regid, selid);
+			return;
+		}
+	}
+
+	return;
+}
+
+void mpu_hook_access(TargetCoreType *cpu, uint32 *data, TargetMpuAccessType access_type, uint8 regid, uint8 selid)
+{
+
+	if (access_type == MPU_TARGET_ACCESS_READ) {
+		mpu_hook_access_read(cpu, data, regid, selid);
+	}
+	else {
+		mpu_hook_access_write(cpu, data, regid, selid);
+	}
+
+	return;
+}
+
+static void mpu_debug_print_mpu_status_config(TargetCoreType *cpu, uint8 base, uint8 selid, uint8 reg_num)
+{
+	uint8 regid;
+	uint32* sysreg;
+
+	for (regid = 0U; regid < reg_num; regid++) {
+		if (TARGET_MPU_IS_MPLA(regid)){
+			sysreg = cpu_get_sysreg2(&cpu->reg.sys, selid, regid);
+			printf("MPLA%d		0x%x\n", TARGET_MPU_GET_CONFIG_INDEX(base, regid), *sysreg);
+		}
+		else if (TARGET_MPU_IS_MPUA(regid)) {
+			sysreg = cpu_get_sysreg2(&cpu->reg.sys, selid, regid);
+			printf("MPUA%d		0x%x\n", TARGET_MPU_GET_CONFIG_INDEX(base, regid), *sysreg);
+		}
+		else if (TARGET_MPU_IS_MPTA(regid)) {
+			sysreg = cpu_get_sysreg2(&cpu->reg.sys, selid, regid);
+			printf("MATA%d		0x%x\n", TARGET_MPU_GET_CONFIG_INDEX(base, regid), *sysreg);
+		}
+		else {
+			/* nop */
+		}
+
+	}
+	return;
+
+}
+
+void mpu_debug_print_mpu_status(TargetCoreType *cpu)
+{
+	uint32* sysreg;
+
+	/* MPM 0000 0000*/
+	sysreg = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_5, SYS_REG_MPM);
+	printf("MPM		0x%x\n", *sysreg);
+
+	/* MPRC 0000 0000*/
+	sysreg = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_5, SYS_REG_MPRC);
+	printf("MPRC		0x%x\n", *sysreg);
+
+	/* MPBRGN 0000 0000*/
+	sysreg = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_5, SYS_REG_MPBRGN);
+	printf("MPBRGN		0x%x\n", *sysreg);
+
+	/* MPTRGN 0001 0000*/
+	sysreg = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_5, SYS_REG_MPTRGN);
+	printf("MPTRGN		0x%x\n", *sysreg);
+
+	/* MPATn(0~15) 0000 0000 */
+	mpu_debug_print_mpu_status_config(cpu, TARGET_MPU_SYSREG6_OFFSET_INDEX, SYS_GRP_6, SYS_SEL6_REG_NUM);
+	mpu_debug_print_mpu_status_config(cpu, TARGET_MPU_SYSREG7_OFFSET_INDEX, SYS_GRP_7, SYS_SEL7_REG_NUM);
+
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/mpu/target/rh850f1k/target_mpu.h
@@ -0,0 +1,61 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _TARGET_MPU_H_
+#define _TARGET_MPU_H_
+
+#include "target_cpu.h"
+
+extern void mpu_init(TargetCoreType *cpu);
+extern void mpu_set_config(TargetCoreType *cpu);
+
+extern bool mpu_is_enable_protection_region(TargetCoreType *cpu, TargetMpuConfigType* region_config);
+extern bool mpu_is_apply_protection_region(TargetCoreType *cpu, TargetMpuConfigType* region_config);
+extern bool mpu_has_permission_access_type(TargetCoreType *cpu, TargetMpuAccessType access_type, TargetMpuConfigType* region_config);
+extern bool mpu_has_permission_access_region(TargetCoreType *cpu, TargetMpuAccessType access_type, uint32 addr, uint32 size, TargetMpuConfigType** region_config, uint8 enable_region_num);
+
+extern void mpu_set_error(TargetCoreType *cpu);
+extern void mpu_check(TargetCoreType *cpu);
+extern void mpu_hook_access(TargetCoreType *cpu, uint32 *data, TargetMpuAccessType access_type, uint8 regid, uint8 selid);
+extern void mpu_debug_print_mpu_status(TargetCoreType *cpu);
+
+
+#endif /* _TARGET_MPU_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/mpu/target/rh850f1k/target_mpu_mei.c
@@ -0,0 +1,276 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "target_mpu_mei.h"
+
+#define TARGET_MPU_MEI_NONE		{TARGET_MPU_MEI_REG_NONE, TARGET_MPU_MEI_DATA_TYPE_NONE, TARGET_MPU_MEI_SIGN_NONE, TARGET_MPU_MEI_RW_NONE, TARGET_MPU_MEI_ITYPE_NONE}
+
+const TargetMpuExceptionErrorMemoryErrorInfoType memory_error_info[OpCodeId_Num] = {
+		TARGET_MPU_MEI_NONE,			/* 0: ABSF_D_F */
+		TARGET_MPU_MEI_NONE,			/* 1: ABSF_S_F */
+		TARGET_MPU_MEI_NONE,			/* 2: ADD_1 */
+		TARGET_MPU_MEI_NONE,			/* 3: ADD_2 */
+		TARGET_MPU_MEI_NONE,			/* 4: ADDF_D_F */
+		TARGET_MPU_MEI_NONE,			/* 5: ADDF_S_F */
+		TARGET_MPU_MEI_NONE,			/* 6: ADDI_6 */
+		TARGET_MPU_MEI_NONE,			/* 7: ADF_11 */
+		TARGET_MPU_MEI_NONE,			/* 8: AND_1 */
+		TARGET_MPU_MEI_NONE,			/* 9: ANDI_6 */
+		TARGET_MPU_MEI_NONE,			/* 10: BINS_9 */
+		TARGET_MPU_MEI_NONE,			/* 11: BSH_12 */
+		TARGET_MPU_MEI_NONE,			/* 12: BSW_12 */
+		TARGET_MPU_MEI_NONE,			/* 13: Bcond_3 */
+		TARGET_MPU_MEI_NONE,			/* 14: Bcond_7 */
+		{TARGET_MPU_MEI_REG_0, TARGET_MPU_MEI_DATA_TYPE_HALF_WORD, TARGET_MPU_MEI_SIGN_UNSIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_10001B},			/*15: CALLT_2 */
+		{TARGET_MPU_MEI_REG_3, TARGET_MPU_MEI_DATA_TYPE_WORD, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_01000B},			/*16: CAXI_11 */
+		TARGET_MPU_MEI_NONE,			/* 17: CEILF_DL_F */
+		TARGET_MPU_MEI_NONE,			/* 18: CEILF_DUL_F */
+		TARGET_MPU_MEI_NONE,			/* 19: CEILF_DUW_F */
+		TARGET_MPU_MEI_NONE,			/* 20: CEILF_DW_F */
+		TARGET_MPU_MEI_NONE,			/* 21: CEILF_SL_F */
+		TARGET_MPU_MEI_NONE,			/* 22: CEILF_SUL_F */
+		TARGET_MPU_MEI_NONE,			/* 23: CEILF_SUW_F */
+		TARGET_MPU_MEI_NONE,			/* 24: CEILF_SW_F */
+		{TARGET_MPU_MEI_REG_0, TARGET_MPU_MEI_DATA_TYPE_BYTE, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_01001B},			/*25: CLR1_8 */
+		{TARGET_MPU_MEI_REG_0, TARGET_MPU_MEI_DATA_TYPE_BYTE, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_01001B},			/*26: CLR1_9 */
+		TARGET_MPU_MEI_NONE,			/* 27: CMOV_12 */
+		TARGET_MPU_MEI_NONE,			/* 28: CMOV_11 */
+		TARGET_MPU_MEI_NONE,			/* 29: CMOVF_D_F */
+		TARGET_MPU_MEI_NONE,			/* 30: CMOVF_S_F */
+		TARGET_MPU_MEI_NONE,			/* 31: CMP_1 */
+		TARGET_MPU_MEI_NONE,			/* 32: CMP_2 */
+		TARGET_MPU_MEI_NONE,			/* 33: CMPF_D_F */
+		TARGET_MPU_MEI_NONE,			/* 34: CMPF_S_F */
+		TARGET_MPU_MEI_NONE,			/* 35: CTRET_10 */
+		TARGET_MPU_MEI_NONE,			/* 36: CVTF_DL_F */
+		TARGET_MPU_MEI_NONE,			/* 37: CVTF_DS_F */
+		TARGET_MPU_MEI_NONE,			/* 38: CVTF_DUL_F */
+		TARGET_MPU_MEI_NONE,			/* 39: CVTF_DUW_F */
+		TARGET_MPU_MEI_NONE,			/* 40: CVTF_DW_F */
+		TARGET_MPU_MEI_NONE,			/* 41: CVTF_HS_F */
+		TARGET_MPU_MEI_NONE,			/* 42: CVTF_LD_F */
+		TARGET_MPU_MEI_NONE,			/* 43: CVTF_LS_F */
+		TARGET_MPU_MEI_NONE,			/* 44: CVTF_SD_F */
+		TARGET_MPU_MEI_NONE,			/* 45: CVTF_SH_F */
+		TARGET_MPU_MEI_NONE,			/* 46: CVTF_SL_F */
+		TARGET_MPU_MEI_NONE,			/* 47: CVTF_SUL_F */
+		TARGET_MPU_MEI_NONE,			/* 48: CVTF_SUW_F */
+		TARGET_MPU_MEI_NONE,			/* 49: CVTF_SW_F */
+		TARGET_MPU_MEI_NONE,			/* 50: CVTF_ULD_F */
+		TARGET_MPU_MEI_NONE,			/* 51: CVTF_ULS_F */
+		TARGET_MPU_MEI_NONE,			/* 52: CVTF_UWD_F */
+		TARGET_MPU_MEI_NONE,			/* 53: CVTF_UWS_F */
+		TARGET_MPU_MEI_NONE,			/* 54: CVTF_WD_F */
+		TARGET_MPU_MEI_NONE,			/* 55: CVTF_WS_F */
+		TARGET_MPU_MEI_NONE,			/* 56: DBTRAP_1 */
+		TARGET_MPU_MEI_NONE,			/* 57: DI_10 */
+		{TARGET_MPU_MEI_REG_0, TARGET_MPU_MEI_DATA_TYPE_WORD, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_01100B},			/*58: DISPOSE_13 */
+		TARGET_MPU_MEI_NONE,			/* 59: DIV_11 */
+		TARGET_MPU_MEI_NONE,			/* 60: DIVF_D_F */
+		TARGET_MPU_MEI_NONE,			/* 61: DIVF_S_F */
+		TARGET_MPU_MEI_NONE,			/* 62: DIVH_1 */
+		TARGET_MPU_MEI_NONE,			/* 63: DIVH_11 */
+		TARGET_MPU_MEI_NONE,			/* 64: DIVHU_11 */
+		TARGET_MPU_MEI_NONE,			/* 65: DIVQ_11 */
+		TARGET_MPU_MEI_NONE,			/* 66: DIVQU_11 */
+		TARGET_MPU_MEI_NONE,			/* 67: DIVU_11 */
+		TARGET_MPU_MEI_NONE,			/* 68: EI_10 */
+		TARGET_MPU_MEI_NONE,			/* 69: EIRET_10 */
+		TARGET_MPU_MEI_NONE,			/* 70: FERET_10 */
+		TARGET_MPU_MEI_NONE,			/* 71: FETRAP_1 */
+		TARGET_MPU_MEI_NONE,			/* 72: FLOORF_DL_F */
+		TARGET_MPU_MEI_NONE,			/* 73: FLOORF_DUL_F */
+		TARGET_MPU_MEI_NONE,			/* 74: FLOORF_DUW_F */
+		TARGET_MPU_MEI_NONE,			/* 75: FLOORF_DW_F */
+		TARGET_MPU_MEI_NONE,			/* 76: FLOORF_SL_F */
+		TARGET_MPU_MEI_NONE,			/* 77: FLOORF_SUL_F */
+		TARGET_MPU_MEI_NONE,			/* 78: FLOORF_SUW_F */
+		TARGET_MPU_MEI_NONE,			/* 79: FLOORF_SW_F */
+		TARGET_MPU_MEI_NONE,			/* 80: FMAF_S_F */
+		TARGET_MPU_MEI_NONE,			/* 81: FMSF_S_F */
+		TARGET_MPU_MEI_NONE,			/* 82: FNMAF_S_F */
+		TARGET_MPU_MEI_NONE,			/* 83: FNMSF_S_F */
+		TARGET_MPU_MEI_NONE,			/* 84: HALT_10 */
+		TARGET_MPU_MEI_NONE,			/* 85: HSH_12 */
+		TARGET_MPU_MEI_NONE,			/* 86: HSW_12 */
+		TARGET_MPU_MEI_NONE,			/* 87: JARL_6 */
+		TARGET_MPU_MEI_NONE,			/* 88: JARL_5 */
+		TARGET_MPU_MEI_NONE,			/* 89: JARL_11 */
+		TARGET_MPU_MEI_NONE,			/* 90: JMP_1 */
+		TARGET_MPU_MEI_NONE,			/* 91: JMP_6 */
+		TARGET_MPU_MEI_NONE,			/* 92: JR_6 */
+		TARGET_MPU_MEI_NONE,			/* 93: JR_5 */
+		{TARGET_MPU_MEI_REG_3, TARGET_MPU_MEI_DATA_TYPE_WORD, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_00111B},			/*94: LDL_W_7 */
+		TARGET_MPU_MEI_NONE,			/* 95: LDSR_9 */
+		{TARGET_MPU_MEI_REG_2, TARGET_MPU_MEI_DATA_TYPE_BYTE, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_00001B},			/*96: LD_B_7 */
+		{TARGET_MPU_MEI_REG_3, TARGET_MPU_MEI_DATA_TYPE_BYTE, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_00010B},			/*97: LD_B_14 */
+		{TARGET_MPU_MEI_REG_2, TARGET_MPU_MEI_DATA_TYPE_BYTE, TARGET_MPU_MEI_SIGN_UNSIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_00001B},			/*98: LD_BU_7 */
+		{TARGET_MPU_MEI_REG_3, TARGET_MPU_MEI_DATA_TYPE_BYTE, TARGET_MPU_MEI_SIGN_UNSIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_00010B},			/*99: LD_BU_14 */
+		{TARGET_MPU_MEI_REG_3, TARGET_MPU_MEI_DATA_TYPE_DOUBLE_WORD, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_00010B},			/*100: LD_DW_14 */
+		{TARGET_MPU_MEI_REG_2, TARGET_MPU_MEI_DATA_TYPE_HALF_WORD, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_00001B},			/*101: LD_H_7 */
+		{TARGET_MPU_MEI_REG_3, TARGET_MPU_MEI_DATA_TYPE_HALF_WORD, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_00010B},			/*102: LD_H_14 */
+		{TARGET_MPU_MEI_REG_3, TARGET_MPU_MEI_DATA_TYPE_HALF_WORD, TARGET_MPU_MEI_SIGN_UNSIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_00010B},			/*103: LD_HU_14 */
+		{TARGET_MPU_MEI_REG_2, TARGET_MPU_MEI_DATA_TYPE_HALF_WORD, TARGET_MPU_MEI_SIGN_UNSIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_00001B},			/*104: LD_HU_7 */
+		{TARGET_MPU_MEI_REG_2, TARGET_MPU_MEI_DATA_TYPE_WORD, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_00001B},			/*105: LD_W_7 */
+		{TARGET_MPU_MEI_REG_3, TARGET_MPU_MEI_DATA_TYPE_WORD, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_00010B},			/*106: LD_W_14 */
+		TARGET_MPU_MEI_NONE,			/* 107: LOOP_7 */
+		TARGET_MPU_MEI_NONE,			/* 108: MAC_11 */
+		TARGET_MPU_MEI_NONE,			/* 109: MACU_11 */
+		TARGET_MPU_MEI_NONE,			/* 110: MADDF_S_F */
+		TARGET_MPU_MEI_NONE,			/* 111: MAXF_D_F */
+		TARGET_MPU_MEI_NONE,			/* 112: MAXF_S_F */
+		TARGET_MPU_MEI_NONE,			/* 113: MINF_D_F */
+		TARGET_MPU_MEI_NONE,			/* 114: MINF_S_F */
+		TARGET_MPU_MEI_NONE,			/* 115: MOV_1 */
+		TARGET_MPU_MEI_NONE,			/* 116: MOV_2 */
+		TARGET_MPU_MEI_NONE,			/* 117: MOV_6 */
+		TARGET_MPU_MEI_NONE,			/* 118: MOVEA_6 */
+		TARGET_MPU_MEI_NONE,			/* 119: MOVHI_6 */
+		TARGET_MPU_MEI_NONE,			/* 120: MSUBF_S_F */
+		TARGET_MPU_MEI_NONE,			/* 121: MUL_11 */
+		TARGET_MPU_MEI_NONE,			/* 122: MUL_12 */
+		TARGET_MPU_MEI_NONE,			/* 123: MULF_D_F */
+		TARGET_MPU_MEI_NONE,			/* 124: MULF_S_F */
+		TARGET_MPU_MEI_NONE,			/* 125: MULH_1 */
+		TARGET_MPU_MEI_NONE,			/* 126: MULH_2 */
+		TARGET_MPU_MEI_NONE,			/* 127: MULHI_6 */
+		TARGET_MPU_MEI_NONE,			/* 128: MULU_11 */
+		TARGET_MPU_MEI_NONE,			/* 129: MULU_12 */
+		TARGET_MPU_MEI_NONE,			/* 130: NEGF_D_F */
+		TARGET_MPU_MEI_NONE,			/* 131: NEGF_S_F */
+		TARGET_MPU_MEI_NONE,			/* 132: NMADDF_S_F */
+		TARGET_MPU_MEI_NONE,			/* 133: NMSUBF_S_F */
+		TARGET_MPU_MEI_NONE,			/* 134: NOP_1 */
+		TARGET_MPU_MEI_NONE,			/* 135: NOT_1 */
+		{TARGET_MPU_MEI_REG_0, TARGET_MPU_MEI_DATA_TYPE_BYTE, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_01001B},			/*136: NOT1_8 */
+		{TARGET_MPU_MEI_REG_0, TARGET_MPU_MEI_DATA_TYPE_BYTE, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_01001B},			/*137: NOT1_9 */
+		TARGET_MPU_MEI_NONE,			/* 138: OR_1 */
+		TARGET_MPU_MEI_NONE,			/* 139: ORI_6 */
+		{TARGET_MPU_MEI_REG_0, TARGET_MPU_MEI_DATA_TYPE_WORD, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_01101B},			/*140: POPSP_11 */
+		{TARGET_MPU_MEI_REG_0, TARGET_MPU_MEI_DATA_TYPE_WORD, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_WRITE, TARGET_MPU_MEI_ITYPE_01100B},			/*141: PREPARE_13 */
+		{TARGET_MPU_MEI_REG_0, TARGET_MPU_MEI_DATA_TYPE_WORD, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_WRITE, TARGET_MPU_MEI_ITYPE_01101B},			/*142: PUSHSP_11 */
+		TARGET_MPU_MEI_NONE,			/* 143: RECIPF_D_F */
+		TARGET_MPU_MEI_NONE,			/* 144: RECIPF_S_F */
+		TARGET_MPU_MEI_NONE,			/* 145: RETI_10 */
+		TARGET_MPU_MEI_NONE,			/* 146: RIE_1 */
+		TARGET_MPU_MEI_NONE,			/* 147: RIE_10 */
+		TARGET_MPU_MEI_NONE,			/* 148: ROTL_7 */
+		TARGET_MPU_MEI_NONE,			/* 149: ROUNDF_SL_F */
+		TARGET_MPU_MEI_NONE,			/* 150: ROUNDF_SUL_F */
+		TARGET_MPU_MEI_NONE,			/* 151: ROUNDF_SUW_F */
+		TARGET_MPU_MEI_NONE,			/* 152: ROUNDF_SW_F */
+		TARGET_MPU_MEI_NONE,			/* 153: RSQRTF_D_F */
+		TARGET_MPU_MEI_NONE,			/* 154: RSQRTF_S_F */
+		TARGET_MPU_MEI_NONE,			/* 155: SAR_2 */
+		TARGET_MPU_MEI_NONE,			/* 156: SAR_9 */
+		TARGET_MPU_MEI_NONE,			/* 157: SAR_11 */
+		TARGET_MPU_MEI_NONE,			/* 158: SASF_9 */
+		TARGET_MPU_MEI_NONE,			/* 159: SATADD_1 */
+		TARGET_MPU_MEI_NONE,			/* 160: SATADD_2 */
+		TARGET_MPU_MEI_NONE,			/* 161: SATADD_11 */
+		TARGET_MPU_MEI_NONE,			/* 162: SATSUB_1 */
+		TARGET_MPU_MEI_NONE,			/* 163: SATSUB_11 */
+		TARGET_MPU_MEI_NONE,			/* 164: SATSUBI_6 */
+		TARGET_MPU_MEI_NONE,			/* 165: SATSUBR_1 */
+		TARGET_MPU_MEI_NONE,			/* 166: SBF_11 */
+		TARGET_MPU_MEI_NONE,			/* 167: SCH0L_9 */
+		TARGET_MPU_MEI_NONE,			/* 168: SCH0R_9 */
+		TARGET_MPU_MEI_NONE,			/* 169: SCH1L_9 */
+		TARGET_MPU_MEI_NONE,			/* 170: SCH1R_9 */
+		{TARGET_MPU_MEI_REG_0, TARGET_MPU_MEI_DATA_TYPE_BYTE, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_01001B},			/*171: SET1_8 */
+		{TARGET_MPU_MEI_REG_0, TARGET_MPU_MEI_DATA_TYPE_BYTE, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_01001B},			/*172: SET1_9 */
+		TARGET_MPU_MEI_NONE,			/* 173: SETF_9 */
+		TARGET_MPU_MEI_NONE,			/* 174: SHL_2 */
+		TARGET_MPU_MEI_NONE,			/* 175: SHL_9 */
+		TARGET_MPU_MEI_NONE,			/* 176: SHL_11 */
+		TARGET_MPU_MEI_NONE,			/* 177: SHR_2 */
+		TARGET_MPU_MEI_NONE,			/* 178: SHR_9 */
+		TARGET_MPU_MEI_NONE,			/* 179: SHR_11 */
+		{TARGET_MPU_MEI_REG_2, TARGET_MPU_MEI_DATA_TYPE_BYTE, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_00000B},			/*180: SLD_B_4 */
+		{TARGET_MPU_MEI_REG_2, TARGET_MPU_MEI_DATA_TYPE_BYTE, TARGET_MPU_MEI_SIGN_UNSIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_00000B},			/*181: SLD_BU_4 */
+		{TARGET_MPU_MEI_REG_2, TARGET_MPU_MEI_DATA_TYPE_HALF_WORD, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_00000B},			/*182: SLD_H_4 */
+		{TARGET_MPU_MEI_REG_2, TARGET_MPU_MEI_DATA_TYPE_HALF_WORD, TARGET_MPU_MEI_SIGN_UNSIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_00000B},			/*183: SLD_HU_4 */
+		{TARGET_MPU_MEI_REG_2, TARGET_MPU_MEI_DATA_TYPE_WORD, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_00000B},			/*184: SLD_W_4 */
+		TARGET_MPU_MEI_NONE,			/* 185: SNOOZE_10 */
+		TARGET_MPU_MEI_NONE,			/* 186: SQRTF_D_F */
+		TARGET_MPU_MEI_NONE,			/* 187: SQRTF_S_F */
+		{TARGET_MPU_MEI_REG_2, TARGET_MPU_MEI_DATA_TYPE_BYTE, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_WRITE, TARGET_MPU_MEI_ITYPE_00000B},			/*188: SST_B_4 */
+		{TARGET_MPU_MEI_REG_2, TARGET_MPU_MEI_DATA_TYPE_HALF_WORD, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_WRITE, TARGET_MPU_MEI_ITYPE_00000B},			/*189: SST_H_4 */
+		{TARGET_MPU_MEI_REG_2, TARGET_MPU_MEI_DATA_TYPE_WORD, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_WRITE, TARGET_MPU_MEI_ITYPE_00000B},			/*190: SST_W_4 */
+		{TARGET_MPU_MEI_REG_3, TARGET_MPU_MEI_DATA_TYPE_WORD, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_WRITE, TARGET_MPU_MEI_ITYPE_00111B},			/*191: STC_W_7 */
+		TARGET_MPU_MEI_NONE,			/* 192: STSR_9 */
+		{TARGET_MPU_MEI_REG_2, TARGET_MPU_MEI_DATA_TYPE_BYTE, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_WRITE, TARGET_MPU_MEI_ITYPE_00001B},			/*193: ST_B_7 */
+		{TARGET_MPU_MEI_REG_3, TARGET_MPU_MEI_DATA_TYPE_BYTE, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_WRITE, TARGET_MPU_MEI_ITYPE_00010B},			/*194: ST_B_14 */
+		{TARGET_MPU_MEI_REG_3, TARGET_MPU_MEI_DATA_TYPE_DOUBLE_WORD, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_WRITE, TARGET_MPU_MEI_ITYPE_00010B},			/*195: ST_DW_14 */
+		{TARGET_MPU_MEI_REG_2, TARGET_MPU_MEI_DATA_TYPE_HALF_WORD, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_WRITE, TARGET_MPU_MEI_ITYPE_00001B},			/*196: ST_H_7 */
+		{TARGET_MPU_MEI_REG_3, TARGET_MPU_MEI_DATA_TYPE_HALF_WORD, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_WRITE, TARGET_MPU_MEI_ITYPE_00010B},			/*197: ST_H_14 */
+		{TARGET_MPU_MEI_REG_2, TARGET_MPU_MEI_DATA_TYPE_WORD, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_WRITE, TARGET_MPU_MEI_ITYPE_00001B},			/*198: ST_W_7 */
+		{TARGET_MPU_MEI_REG_3, TARGET_MPU_MEI_DATA_TYPE_WORD, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_WRITE, TARGET_MPU_MEI_ITYPE_00010B},			/*199: ST_W_14 */
+		TARGET_MPU_MEI_NONE,			/* 200: SUB_1 */
+		TARGET_MPU_MEI_NONE,			/* 201: SUBF_D_F */
+		TARGET_MPU_MEI_NONE,			/* 202: SUBF_S_F */
+		TARGET_MPU_MEI_NONE,			/* 203: SUBR_1 */
+		{TARGET_MPU_MEI_REG_0, TARGET_MPU_MEI_DATA_TYPE_HALF_WORD, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_10000B},			/*204: SWITCH_1 */
+		TARGET_MPU_MEI_NONE,			/* 205: SXB_1 */
+		TARGET_MPU_MEI_NONE,			/* 206: SXH_1 */
+		TARGET_MPU_MEI_NONE,			/* 207: SYNCE_1 */
+		TARGET_MPU_MEI_NONE,			/* 208: SYNCI_1 */
+		TARGET_MPU_MEI_NONE,			/* 209: SYNCM_1 */
+		TARGET_MPU_MEI_NONE,			/* 210: SYNCP_1 */
+		{TARGET_MPU_MEI_REG_0, TARGET_MPU_MEI_DATA_TYPE_WORD, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_10010B},			/*211: SYSCALL_10 */
+		TARGET_MPU_MEI_NONE,			/* 212: TRAP_10 */
+		TARGET_MPU_MEI_NONE,			/* 213: TRFSR_F */
+		TARGET_MPU_MEI_NONE,			/* 214: TRNCF_DL_F */
+		TARGET_MPU_MEI_NONE,			/* 215: TRNCF_DUL_F */
+		TARGET_MPU_MEI_NONE,			/* 216: TRNCF_DUW_F */
+		TARGET_MPU_MEI_NONE,			/* 217: TRNCF_DW_F */
+		TARGET_MPU_MEI_NONE,			/* 218: TRNCF_SL_F */
+		TARGET_MPU_MEI_NONE,			/* 219: TRNCF_SUL_F */
+		TARGET_MPU_MEI_NONE,			/* 220: TRNCF_SUW_F */
+		TARGET_MPU_MEI_NONE,			/* 221: TRNCF_SW_F */
+		TARGET_MPU_MEI_NONE,			/* 222: TST_1 */
+		{TARGET_MPU_MEI_REG_0, TARGET_MPU_MEI_DATA_TYPE_BYTE, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_01001B},			/*223: TST1_8 */
+		{TARGET_MPU_MEI_REG_0, TARGET_MPU_MEI_DATA_TYPE_BYTE, TARGET_MPU_MEI_SIGN_SIGNED, TARGET_MPU_MEI_RW_READ, TARGET_MPU_MEI_ITYPE_01001B},			/*224: TST1_9 */
+		TARGET_MPU_MEI_NONE,			/* 225: XOR_1 */
+		TARGET_MPU_MEI_NONE,			/* 226: XORI_6 */
+		TARGET_MPU_MEI_NONE,			/* 227: ZXB_1 */
+		TARGET_MPU_MEI_NONE,			/* 228: ZXH_1 */
+};
\ No newline at end of file
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/mpu/target/rh850f1k/target_mpu_mei.h
@@ -0,0 +1,98 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _TARGET_MPU_MEI_H_
+#define _TARGET_MPU_MEI_H_
+
+#include "std_types.h"
+#include "cpu_dec/op_codeid.h"
+
+typedef struct {
+	uint8	reg;
+	uint8	data_type;
+	uint8	sign;
+	uint8	rw;
+	uint8	itype;
+} TargetMpuExceptionErrorMemoryErrorInfoType;
+
+#define TARGET_MPU_SYSREG_MEI_REG_OFFSET		16U
+#define TARGET_MPU_SYSREG_MEI_DS_OFFSET			9U
+#define TARGET_MPU_SYSREG_MEI_U_OFFSET			8U
+#define TARGET_MPU_SYSREG_MEI_ITYPE_OFFSET		1U
+#define TARGET_MPU_SYSREG_MEI_RW_OFFSET			0U
+
+#define TARGET_MPU_MEI_REG_0					0U
+#define TARGET_MPU_MEI_REG_1					1U
+#define TARGET_MPU_MEI_REG_2					2U
+#define TARGET_MPU_MEI_REG_3					3U
+#define TARGET_MPU_MEI_REG_NONE					4U
+
+#define TARGET_MPU_MEI_DATA_TYPE_BYTE			0U
+#define TARGET_MPU_MEI_DATA_TYPE_HALF_WORD		1U
+#define TARGET_MPU_MEI_DATA_TYPE_WORD			2U
+#define TARGET_MPU_MEI_DATA_TYPE_DOUBLE_WORD	3U
+#define TARGET_MPU_MEI_DATA_TYPE_NONE			4U
+
+#define TARGET_MPU_MEI_SIGN_SIGNED			0U
+#define TARGET_MPU_MEI_SIGN_UNSIGNED		1U
+#define TARGET_MPU_MEI_SIGN_NONE			2U
+
+#define TARGET_MPU_MEI_ITYPE_00000B			0x00
+#define TARGET_MPU_MEI_ITYPE_00001B			0x01
+#define TARGET_MPU_MEI_ITYPE_00010B			0x02
+#define TARGET_MPU_MEI_ITYPE_00111B			0x07
+#define TARGET_MPU_MEI_ITYPE_01000B			0x08
+#define TARGET_MPU_MEI_ITYPE_01001B			0x09
+#define TARGET_MPU_MEI_ITYPE_01100B			0x0C
+#define TARGET_MPU_MEI_ITYPE_01101B			0x0D
+#define TARGET_MPU_MEI_ITYPE_10000B			0x10
+#define TARGET_MPU_MEI_ITYPE_10001B			0x11
+#define TARGET_MPU_MEI_ITYPE_10010B			0x12
+#define TARGET_MPU_MEI_ITYPE_NONE			0x1F
+
+#define TARGET_MPU_MEI_RW_READ				0U
+#define TARGET_MPU_MEI_RW_WRITE				1U
+#define TARGET_MPU_MEI_RW_NONE				2U
+
+extern const TargetMpuExceptionErrorMemoryErrorInfoType memory_error_info[OpCodeId_Num];
+
+
+#endif /* _TARGET_MPU_MEI_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/mpu/target/target_mpu_common.c
@@ -0,0 +1,224 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "target_cpu.h"
+#include "target_mpu.h"
+#include "cpu_common/cpu_ops.h"
+
+
+void target_mpu_init(TargetCoreType *cpu)
+{
+	uint8 index;
+
+	mpu_init(cpu);
+
+	cpu->mpu.permission_region = object_container_create(sizeof(TargetMpuConfigType), TARGET_MPU_CONFIG_NUM);
+	for (index = 0U; index < TARGET_MPU_CONFIG_NUM; index++) {
+		(void)object_container_create_element(cpu->mpu.permission_region);
+	}
+
+	mpu_set_config(cpu);
+
+	cpu->mpu.excption_error_info.intc_error_info.access_type = MPU_TARGET_ACCESS_NONE;
+	cpu->mpu.excption_error_info.intc_error_info.exception_error_code = TARGET_MPU_EXCEPTION_ERROR_CODE_NONE;
+	cpu->mpu.excption_error_info.intc_error_info.is_bl_error = FALSE;
+	cpu->mpu.excption_error_info.intc_error_info.is_ms_error = FALSE;
+	cpu->mpu.excption_error_info.intc_error_info.is_rmw_error = FALSE;
+	cpu->mpu.excption_error_info.intc_error_info.is_sv_mode = FALSE;
+	cpu->mpu.excption_error_info.error_addr = 0U;
+	cpu->mpu.excption_error_info.op_codeid = OpCodeId_Num;
+	cpu->mpu.excption_error_info.is_error_occurred = FALSE;
+
+	return;
+}
+
+void target_mpu_set_config(TargetCoreType *cpu)
+{
+	mpu_set_config(cpu);
+	return;
+}
+
+static void target_mpu_has_permission_set_error(TargetCoreType *cpu, TargetMpuAccessType access_type, uint32 addr)
+{
+
+	cpu->mpu.excption_error_info.error_addr = addr;
+	cpu->mpu.excption_error_info.intc_error_info.access_type = access_type;
+
+	if (access_type == MPU_TARGET_ACCESS_EXEC) {
+		cpu->mpu.excption_error_info.intc_error_info.exception_error_code = TARGET_MPU_EXCEPTION_ERROR_CODE_MIP;
+	}
+	else {
+		cpu->mpu.excption_error_info.intc_error_info.exception_error_code = TARGET_MPU_EXCEPTION_ERROR_CODE_MDP;
+	}
+
+	if ((CPU_ISSET_UM(&(cpu->reg)))) {
+		cpu->mpu.excption_error_info.intc_error_info.is_sv_mode = FALSE;
+	}
+	else {
+		cpu->mpu.excption_error_info.intc_error_info.is_sv_mode = TRUE;
+	}
+
+	return;
+}
+
+bool target_mpu_has_permission(TargetCoreType *cpu, TargetMpuAccessType access_type, uint32 addr, uint32 size)
+{
+	TargetMpuConfigType* enable_region_config[TARGET_MPU_CONFIG_NUM];
+	uint8 enable_region_num = 0;
+	uint8 region_index;
+	TargetMpuConfigType *region_config;
+
+	if (cpu->mpu.is_enable_mpu == FALSE) {
+		return TRUE;
+	}
+
+	if (!(CPU_ISSET_UM(&(cpu->reg)))) {
+		if (cpu->mpu.is_enable_sv == FALSE) {
+			return TRUE;
+		}
+	}
+
+	for (region_index = 0U; region_index < TARGET_MPU_CONFIG_NUM; region_index++) {
+		region_config = (TargetMpuConfigType*)object_container_get_element(cpu->mpu.permission_region, region_index);
+#if 0
+		printf("enable:0x%x\n", region_config->is_enable);
+		printf("apply:0x%x\n", region_config->is_enable_apply_config);
+		printf("start:0x%x\n", region_config->addr_start);
+		printf("end:0x%x\n", region_config->addr_end);
+		printf("um_x:0x%x\n", region_config->is_enable_access_um.exec);
+		printf("um_w:0x%x\n", region_config->is_enable_access_um.write);
+		printf("um_r:0x%x\n", region_config->is_enable_access_um.read);
+		printf("sv_x:0x%x\n", region_config->is_enable_access_sv.exec);
+		printf("sv_w:0x%x\n", region_config->is_enable_access_sv.write);
+		printf("sv_r:0x%x\n", region_config->is_enable_access_sv.read);
+#endif
+		if (!(mpu_is_enable_protection_region(cpu, region_config))) {
+			continue;
+		}
+
+		if (!(mpu_is_apply_protection_region(cpu, region_config))) {
+			continue;
+		}
+
+		if (mpu_has_permission_access_type(cpu, access_type, region_config)) {
+			enable_region_config[enable_region_num] = region_config;
+			enable_region_num++;
+			continue;
+		}
+	}
+#if 0
+	printf("start=0x%x size=%d enable_region_num=%d\n", addr, size, enable_region_num);
+	for (region_index = 0; region_index < enable_region_num; region_index++) {
+		printf("start:0x%x\n", enable_region_config[region_index]->addr_start);
+		printf("end:0x%x\n", enable_region_config[region_index]->addr_end);
+		printf("um_x:0x%x\n", enable_region_config[region_index]->is_enable_access_um.exec);
+		printf("um_w:0x%x\n", enable_region_config[region_index]->is_enable_access_um.write);
+		printf("um_r:0x%x\n", enable_region_config[region_index]->is_enable_access_um.read);
+	}
+#endif
+	if (mpu_has_permission_access_region(cpu, access_type, addr, size, &(enable_region_config[0]), enable_region_num)) {
+		cpu->mpu.excption_error_info.is_error_occurred = FALSE;
+		return TRUE;
+	}
+
+	cpu->mpu.excption_error_info.is_error_occurred = TRUE;
+	//printf("is_error_occurred=TRUE:addr=0x%x size=%d type=%d\n", addr, size, access_type);
+	/* error set */
+	target_mpu_has_permission_set_error(cpu, access_type, addr);
+
+	return FALSE;
+}
+
+void target_mpu_set_error(TargetCoreType *cpu)
+{
+	OpCodeId code_id = cpu->mpu.excption_error_info.op_codeid;
+
+	cpu->mpu.excption_error_info.intc_error_info.is_bl_error = FALSE;
+	cpu->mpu.excption_error_info.intc_error_info.is_rmw_error = FALSE;
+
+	switch (code_id) {
+	case OpCodeId_PREPARE_13:
+	case OpCodeId_DISPOSE_13:
+	case OpCodeId_PUSHSP_11:
+	case OpCodeId_POPSP_11:
+		/* BL */
+		cpu->mpu.excption_error_info.intc_error_info.is_bl_error = TRUE;
+		break;
+	case OpCodeId_SET1_8:
+	case OpCodeId_SET1_9:
+	case OpCodeId_NOT1_8:
+	case OpCodeId_NOT1_9:
+	case OpCodeId_CLR1_8:
+	case OpCodeId_CLR1_9:
+		/* RMW */
+		cpu->mpu.excption_error_info.intc_error_info.is_rmw_error = TRUE;
+		break;
+	default:
+		break;
+
+	}
+
+	/* MS */
+	cpu->mpu.excption_error_info.intc_error_info.is_ms_error = FALSE;
+
+	mpu_set_error(cpu);
+
+	return;
+}
+
+
+void target_mpu_check(TargetCoreType *cpu)
+{
+	mpu_check(cpu);
+	return;
+}
+
+void target_mpu_hook_access(TargetCoreType *cpu, uint32 *data, TargetMpuAccessType access_type, uint8 regid, uint8 selid)
+{
+	mpu_hook_access(cpu, data, access_type, regid, selid);
+	return;
+}
+
+void target_mpu_debug_print_mpu_status(TargetCoreType *cpu)
+{
+	mpu_debug_print_mpu_status(cpu);
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/mpu/target/target_mpu_common.h
@@ -0,0 +1,113 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _TARGET_MPU_COMMON_H_
+#define _TARGET_MPU_COMMON_H_
+
+#include "object_container.h"
+
+
+#define TARGET_MPU_CONFIG_NUM		16U
+
+typedef enum {
+	TARGET_MPU_EXCEPTION_ERROR_CODE_NONE = 0,
+	TARGET_MPU_EXCEPTION_ERROR_CODE_MIP,
+	TARGET_MPU_EXCEPTION_ERROR_CODE_MDP,
+} TargetMpuExceptionErrorCodeType;
+
+typedef enum {
+	MPU_TARGET_ACCESS_NONE = 0,
+	MPU_TARGET_ACCESS_READ,
+	MPU_TARGET_ACCESS_WRITE,
+	MPU_TARGET_ACCESS_EXEC,
+} TargetMpuAccessType;
+
+
+/* mpu type */
+/* common */
+typedef struct {
+	bool		read;
+	bool		write;
+	bool		exec;
+} TargetMpuEnableAccessType;
+
+/* error */
+
+typedef struct {
+	TargetMpuAccessType				access_type;
+	TargetMpuExceptionErrorCodeType	exception_error_code;
+	bool	is_sv_mode;
+	bool	is_bl_error;
+	bool	is_ms_error;
+	bool	is_rmw_error;
+} TargetMpuExceptionErrorintcInfoType;
+
+
+typedef struct {
+	TargetMpuExceptionErrorintcInfoType			intc_error_info;
+	uint32										error_addr;
+	OpCodeId									op_codeid;
+	bool										is_error_occurred;
+} TargetMpuExceptionErrorInfoType;
+
+
+/* set config */
+
+typedef struct {
+	uint32		addr_start;
+	uint32		addr_end;
+	bool		is_enable;
+	TargetMpuEnableAccessType	is_enable_access_sv;
+	TargetMpuEnableAccessType	is_enable_access_um;
+	bool	is_enable_apply_config;
+	uint16	asid;
+} TargetMpuConfigType;
+
+typedef struct {
+	TargetMpuExceptionErrorInfoType		excption_error_info;
+	ObjectContainerType					*permission_region;
+	bool								is_enable_mpu;
+	bool								is_enable_sv;
+	TargetMpuEnableAccessType			is_enable_outside_protection_region;
+} TargetMpuType;
+
+
+#endif /* _TARGET_MPU_COMMON_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/mpu/target/target_mpu_op.h
@@ -0,0 +1,57 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _TARGET_MPU_OP_H_
+#define _TARGET_MPU_OP_H_
+
+#include "target_cpu.h"
+
+extern void target_mpu_init(TargetCoreType *cpu);
+extern void target_mpu_set_config(TargetCoreType *cpu);
+extern bool target_mpu_has_permission(TargetCoreType *cpu, TargetMpuAccessType access_type, uint32 addr, uint32 size);
+extern void target_mpu_set_error(TargetCoreType *cpu);
+extern void target_mpu_check(TargetCoreType *cpu);
+extern void target_mpu_hook_access(TargetCoreType *cpu, uint32 *data, TargetMpuAccessType access_type, uint8 regid, uint8 selid);
+extern void target_mpu_debug_print_mpu_status(TargetCoreType *cpu);
+
+
+
+#endif /* _TARGET_MPU_OP_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/cpu/target_cpu.h
@@ -0,0 +1,519 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _CPU_REGISTER_H_
+#define _CPU_REGISTER_H_
+
+#include "cpu_dec/op_dec.h"
+#include "std_types.h"
+
+#include "mpu/target/target_mpu_common.h"
+
+#define ATHRILL_TARGET_ARCH	"rh850f1x"
+/*
+ * version: X.Y.Z
+ *  X: generation
+ *  Y: function
+ *  Z: bug fix, small changes
+ */
+#define ATHRILL_TARGET_VERSION "0.A.1"
+
+#define CPU_GREG_NUM			(32U)
+
+#define CPU_COMMON_SYSREG_NUM	(4U)
+#define CPU_SYSBNK_NUM			(3U)
+
+typedef enum {
+	SYS_GRP_CPU = 0,
+	SYS_GRP_1,
+	SYS_GRP_2,
+	SYS_GRP_3,
+	SYS_GRP_4,
+	SYS_GRP_5,
+	SYS_GRP_6,
+	SYS_GRP_7,
+	SYS_GRP_NUM,
+} SysGrpuType;
+
+typedef enum {
+	SYS_GRP_CPU_BNK_0 = 0,
+	SYS_GRP_CPU_BNK_1,
+	SYS_GRP_CPU_BNK_2,
+	SYS_GRP_CPU_BNK_NUM,
+} SysGrpCpuBnkType;
+
+typedef enum {
+	SYS_REG_EIPC = 0,
+	SYS_REG_EIPSW,
+	SYS_REG_FEPC,
+	SYS_REG_FEPSW,
+	SYS_SEL0_RESERVE_4,
+	SYS_REG_PSW,
+	SYS_REG_FPSR,
+	SYS_REG_FPEPC,
+	SYS_REG_FPST,
+	SYS_REG_FPCC,
+	SYS_REG_FPCFG,
+	SYS_REG_FPEC,
+	SYS_SEL0_RESERVE_12,
+	SYS_REG_EIIC,
+	SYS_REG_FEIC,
+	SYS_SEL0_RESERVE_15,
+	SYS_REG_CTPC,
+	SYS_REG_CTPSW,
+	SYS_SEL0_RESERVE_18,
+	SYS_SEL0_RESERVE_19,
+	SYS_REG_CTBP,
+	SYS_SEL0_RESERVE_21,
+	SYS_SEL0_RESERVE_22,
+	SYS_SEL0_RESERVE_23,
+	SYS_SEL0_RESERVE_24,
+	SYS_SEL0_RESERVE_25,
+	SYS_SEL0_RESERVE_26,
+	SYS_SEL0_RESERVE_27,
+	SYS_REG_EIWR,
+	SYS_REG_FEWR,
+	SYS_SEL0_RESERVE_30,
+	SYS_SEL0_RESERVE_31,
+	SYS_REG_NUM,
+} SysSel0RegisterType;
+
+#define SYS_REG_ECR	SYS_REG_EIIC
+#define CPU_SYSREG_NUM SYS_REG_NUM
+
+typedef enum {
+	SYS_REG_MCFG0 = 0,
+	SYS_SEL1_RESERVE1,
+	SYS_REG_RBASE,
+	SYS_REG_EBASE,
+	SYS_REG_INTBP,
+	SYS_REG_MCTL,
+	SYS_REG_PID,
+	SYS_SEL1_RESERVE7,
+	SYS_SEL1_RESERVE8,
+	SYS_SEL1_RESERVE9,
+	SYS_SEL1_RESERVE10,
+	SYS_REG_SCCFG,
+	SYS_REG_SCBP,
+	SYS_SEL1_RESERVE13,
+	SYS_SEL1_RESERVE14,
+	SYS_SEL1_RESERVE15,
+	SYS_SEL1_RESERVE16,
+	SYS_SEL1_RESERVE17,
+	SYS_SEL1_RESERVE18,
+	SYS_SEL1_RESERVE19,
+	SYS_SEL1_RESERVE20,
+	SYS_SEL1_RESERVE21,
+	SYS_SEL1_RESERVE22,
+	SYS_SEL1_RESERVE23,
+	SYS_SEL1_RESERVE24,
+	SYS_SEL1_RESERVE25,
+	SYS_SEL1_RESERVE26,
+	SYS_SEL1_RESERVE27,
+	SYS_SEL1_RESERVE28,
+	SYS_SEL1_RESERVE29,
+	SYS_SEL1_RESERVE30,
+	SYS_SEL1_RESERVE31,
+	SYS_SEL1_REG_NUM,
+} SysSel1RegisterType;
+
+
+typedef enum {
+	SYS_REG_HTCFG0 = 0,
+	SYS_SEL2_RESERVE1,
+	SYS_SEL2_RESERVE2,
+	SYS_SEL2_RESERVE3,
+	SYS_SEL2_RESERVE4,
+	SYS_SEL2_RESERVE5,
+	SYS_REG_MEA,
+	SYS_REG_ASID,
+	SYS_REG_MEI,
+	SYS_SEL2_RESERVE9,
+	SYS_REG_ISPR,
+	SYS_REG_PMR,
+	SYS_REG_ICSR,
+	SYS_REG_INTCFG,
+	SYS_SEL2_RESERVE14,
+	SYS_SEL2_RESERVE15,
+	SYS_SEL2_RESERVE16,
+	SYS_SEL2_RESERVE17,
+	SYS_SEL2_RESERVE18,
+	SYS_SEL2_RESERVE19,
+	SYS_SEL2_RESERVE20,
+	SYS_SEL2_RESERVE21,
+	SYS_SEL2_RESERVE22,
+	SYS_SEL2_RESERVE23,
+	SYS_SEL2_RESERVE24,
+	SYS_SEL2_RESERVE25,
+	SYS_SEL2_RESERVE26,
+	SYS_SEL2_RESERVE27,
+	SYS_SEL2_RESERVE28,
+	SYS_SEL2_RESERVE29,
+	SYS_SEL2_RESERVE30,
+	SYS_SEL2_RESERVE31,
+	SYS_SEL2_REG_NUM,
+} SysSel2RegisterType;
+
+
+typedef enum {
+	SYS_SEL3_RESERVE0 = 0,
+	SYS_SEL3_RESERVE1,
+	SYS_SEL3_RESERVE2,
+	SYS_SEL3_RESERVE3,
+	SYS_SEL3_RESERVE4,
+	SYS_SEL3_RESERVE5,
+	SYS_SEL3_RESERVE6,
+	SYS_SEL3_RESERVE7,
+	SYS_SEL3_RESERVE8,
+	SYS_SEL3_RESERVE9,
+	SYS_SEL3_RESERVE10,
+	SYS_SEL3_RESERVE11,
+	SYS_SEL3_RESERVE12,
+	SYS_SEL3_RESERVE13,
+	SYS_SEL3_RESERVE14,
+	SYS_SEL3_RESERVE15,
+	SYS_SEL3_RESERVE16,
+	SYS_SEL3_RESERVE17,
+	SYS_SEL3_RESERVE18,
+	SYS_SEL3_RESERVE19,
+	SYS_SEL3_RESERVE20,
+	SYS_SEL3_RESERVE21,
+	SYS_SEL3_RESERVE22,
+	SYS_SEL3_RESERVE23,
+	SYS_SEL3_RESERVE24,
+	SYS_SEL3_RESERVE25,
+	SYS_SEL3_RESERVE26,
+	SYS_SEL3_RESERVE27,
+	SYS_SEL3_RESERVE28,
+	SYS_SEL3_RESERVE29,
+	SYS_SEL3_RESERVE30,
+	SYS_SEL3_RESERVE31,
+	SYS_SEL3_REG_NUM,
+} SysSel3RegisterType;
+
+
+typedef enum {
+	SYS_SEL4_RESERVE0 = 0,
+	SYS_SEL4_RESERVE1,
+	SYS_SEL4_RESERVE2,
+	SYS_SEL4_RESERVE3,
+	SYS_SEL4_RESERVE4,
+	SYS_SEL4_RESERVE5,
+	SYS_SEL4_RESERVE6,
+	SYS_SEL4_RESERVE7,
+	SYS_SEL4_RESERVE8,
+	SYS_SEL4_RESERVE9,
+	SYS_SEL4_RESERVE10,
+	SYS_SEL4_RESERVE11,
+	SYS_SEL4_RESERVE12,
+	SYS_SEL4_RESERVE13,
+	SYS_SEL4_RESERVE14,
+	SYS_SEL4_RESERVE15,
+	SYS_SEL4_RESERVE16,
+	SYS_SEL4_RESERVE17,
+	SYS_SEL4_RESERVE18,
+	SYS_SEL4_RESERVE19,
+	SYS_SEL4_RESERVE20,
+	SYS_SEL4_RESERVE21,
+	SYS_SEL4_RESERVE22,
+	SYS_SEL4_RESERVE23,
+	SYS_SEL4_RESERVE24,
+	SYS_SEL4_RESERVE25,
+	SYS_SEL4_RESERVE26,
+	SYS_SEL4_RESERVE27,
+	SYS_SEL4_RESERVE28,
+	SYS_SEL4_RESERVE29,
+	SYS_SEL4_RESERVE30,
+	SYS_SEL4_RESERVE31,
+	SYS_SEL4_REG_NUM,
+} SysSel4RegisterType;
+
+
+typedef enum {
+	SYS_REG_MPM = 0,
+	SYS_REG_MPRC,
+	SYS_SEL5_RESERVE2,
+	SYS_SEL5_RESERVE3,
+	SYS_REG_MPBRGN,
+	SYS_REG_MPTRGN,
+	SYS_SEL5_RESERVE6,
+	SYS_SEL5_RESERVE7,
+	SYS_REG_MCA,
+	SYS_REG_MCS,
+	SYS_REG_MCC,
+	SYS_REG_MCR,
+	SYS_SEL5_RESERVE12,
+	SYS_SEL5_RESERVE13,
+	SYS_SEL5_RESERVE14,
+	SYS_SEL5_RESERVE15,
+	SYS_SEL5_RESERVE16,
+	SYS_SEL5_RESERVE17,
+	SYS_SEL5_RESERVE18,
+	SYS_SEL5_RESERVE19,
+	SYS_SEL5_RESERVE20,
+	SYS_SEL5_RESERVE21,
+	SYS_SEL5_RESERVE22,
+	SYS_SEL5_RESERVE23,
+	SYS_SEL5_RESERVE24,
+	SYS_SEL5_RESERVE25,
+	SYS_SEL5_RESERVE26,
+	SYS_SEL5_RESERVE27,
+	SYS_SEL5_RESERVE28,
+	SYS_SEL5_RESERVE29,
+	SYS_SEL5_RESERVE30,
+	SYS_SEL5_RESERVE31,
+	SYS_SEL5_REG_NUM,
+} SysSel5RegisterType;
+
+
+typedef enum {
+	SYS_REG_MPLA0 = 0,
+	SYS_REG_MPUA0,
+	SYS_REG_MPAT0,
+	SYS_SEL6_RESERVE3,
+	SYS_REG_MPLA1,
+	SYS_REG_MPUA1,
+	SYS_REG_MPAT1,
+	SYS_SEL6_RESERVE7,
+	SYS_REG_MPLA2,
+	SYS_REG_MPUA2,
+	SYS_REG_MPAT2,
+	SYS_SEL6_RESERVE11,
+	SYS_REG_MPLA3,
+	SYS_REG_MPUA3,
+	SYS_REG_MPAT3,
+	SYS_SEL6_RESERVE15,
+	SYS_REG_MPLA4,
+	SYS_REG_MPUA4,
+	SYS_REG_MPAT4,
+	SYS_SEL6_RESERVE19,
+	SYS_REG_MPLA5,
+	SYS_REG_MPUA5,
+	SYS_REG_MPAT5,
+	SYS_SEL6_RESERVE23,
+	SYS_REG_MPLA6,
+	SYS_REG_MPUA6,
+	SYS_REG_MPAT6,
+	SYS_SEL6_RESERVE27,
+	SYS_REG_MPLA7,
+	SYS_REG_MPUA7,
+	SYS_REG_MPAT7,
+	SYS_SEL6_RESERVE31,
+	SYS_SEL6_REG_NUM,
+} SysSel6RegisterType;
+
+
+typedef enum {
+	SYS_REG_MPLA8 = 0,
+	SYS_REG_MPUA8,
+	SYS_REG_MPAT8,
+	SYS_SEL7_RESERVE3,
+	SYS_REG_MPLA9,
+	SYS_REG_MPUA9,
+	SYS_REG_MPAT9,
+	SYS_SEL7_RESERVE7,
+	SYS_REG_MPLA10,
+	SYS_REG_MPUA10,
+	SYS_REG_MPAT10,
+	SYS_SEL7_RESERVE11,
+	SYS_REG_MPLA11,
+	SYS_REG_MPUA11,
+	SYS_REG_MPAT11,
+	SYS_SEL7_RESERVE15,
+	SYS_REG_MPLA12,
+	SYS_REG_MPUA12,
+	SYS_REG_MPAT12,
+	SYS_SEL7_RESERVE19,
+	SYS_REG_MPLA13,
+	SYS_REG_MPUA13,
+	SYS_REG_MPAT13,
+	SYS_SEL7_RESERVE23,
+	SYS_REG_MPLA14,
+	SYS_REG_MPUA14,
+	SYS_REG_MPAT14,
+	SYS_SEL7_RESERVE27,
+	SYS_REG_MPLA15,
+	SYS_REG_MPUA15,
+	SYS_REG_MPAT15,
+	SYS_SEL7_RESERVE31,
+	SYS_SEL7_REG_NUM,
+} SysSel7RegisterType;
+
+typedef enum {
+	CpuMemoryAccess_NONE = 0,
+	CpuMemoryAccess_READ,
+	CpuMemoryAccess_WRITE,
+	CpuMemoryAccess_EXEC,
+} CpuMemoryAccessType;
+
+typedef enum {
+	ExceptionId_RESET = 0,
+	ExceptionId_FENMI,
+	ExceptionId_SYSERR1,
+	ExceptionId_FEINT,
+	ExceptionId_FPI,
+	ExceptionId_UserIntr,
+	ExceptionId_MIP,
+	ExceptionId_SYSERR2,
+	ExceptionId_RIE,
+	ExceptionId_UCPOP,
+	ExceptionId_PIE,
+	ExceptionId_MAE,
+	ExceptionId_MDP,
+	ExceptionId_FPP,
+	ExceptionId_SYSCALL,
+	ExceptionId_FETRAP,
+	ExceptionId_TRAP0,
+	ExceptionId_TRAP1,
+	ExceptionId_Num,
+} ExceptionIdType;
+
+#define CPU_REG_UINT_MAX	0xFFFFFFFFULL
+#define CPU_REG_PLUS_MAX	2147483647LL
+#define CPU_REG_MINUS_MAX	-2147483648LL
+
+#define CPU_REG_SP		(3)
+#define CPU_REG_EP		(30)
+#define CPU_REG_LP		(31)
+
+
+typedef struct {
+	uint32 r[SYS_REG_NUM];
+} CpuSystemRegisterDataType;
+
+typedef struct {
+	uint32						current_grp;
+	uint32						current_bnk;
+	CpuSystemRegisterDataType	grp[SYS_GRP_NUM][CPU_SYSBNK_NUM];
+} CpuSystemRegisterType;
+
+typedef struct {
+	uint32 pc;
+	sint32 r[CPU_GREG_NUM];
+	CpuSystemRegisterType	sys;
+} CpuRegisterType;
+
+
+static inline uint32 *cpu_get_sysreg(CpuSystemRegisterType *sys, uint32 regid) {
+	return &sys->grp[sys->current_grp][sys->current_bnk].r[regid];
+}
+
+static inline uint32 *cpu_get_sysreg2(CpuSystemRegisterType *sys, uint32 selid, uint32 regid) {
+	return &sys->grp[selid][sys->current_bnk].r[regid];
+}
+
+static inline CpuSystemRegisterDataType *sys_get_cpu_base(CpuRegisterType *reg) {
+	return &reg->sys.grp[SYS_GRP_CPU][SYS_GRP_CPU_BNK_0];
+}
+
+typedef struct {
+	bool				is_code_exception;
+	ExceptionIdType		exception_type;
+} CodeExceptionType;
+
+typedef struct {
+	uint32					real_elaps;
+	CoreIdType				core_id;
+	CpuRegisterType 		reg;
+	bool					is_halt;
+	uint16 					*current_code;
+	OpDecodedCodeType		*decoded_code;
+	CodeExceptionType		current_code_exception;
+	bool					fatal_error;
+	TargetMpuType			mpu;
+} TargetCoreType;
+
+extern uint32 cpu_get_pc(const TargetCoreType *core);
+extern uint32 cpu_get_sp(const TargetCoreType *core);
+
+extern void fpu_sync_sysreg(TargetCoreType *cpu, uint32 regid, uint32 selid);
+
+#define SYS_ISSET_BIT(data32p, bitpos)                  ( (*(data32p)) & (1U << (bitpos)) )
+#define SYS_SET_BIT(data32p, bitpos)    \
+do {    \
+        *(data32p) |= (1U << (bitpos)); \
+} while (0)
+#define SYS_CLR_BIT(data32p, bitpos)    \
+do {    \
+        *(data32p) &= ~(1U << (bitpos));        \
+} while (0)
+
+#define SYS_GET_DATA2(data32p, bitpos)                  ( ( (uint8)((*(data32p)) >> (bitpos)) ) & 0x0003 )
+#define SYS_SET_DATA2(data32p, bitpos, data8)   \
+do { \
+        uint32 _org_data = *(data32p);  \
+        uint32 _new_data = _org_data & ~((uint32)(0x0003) << (bitpos)); \
+        _new_data |= ( ((uint32)(data8)) << (bitpos)); \
+        *(data32p) = _new_data;  \
+} while(0)
+
+#define SYS_GET_DATA5(data32p, bitpos)                  ( ( (uint8)((*(data32p)) >> (bitpos)) ) & 0x001F )
+#define SYS_SET_DATA5(data32p, bitpos, data8)   \
+do { \
+        uint32 _org_data = *(data32p);  \
+        uint32 _new_data = _org_data & ~((uint32)(0x001F) << (bitpos)); \
+        _new_data |= ( ((uint32)(data8)) << (bitpos)); \
+        *(data32p) = _new_data;  \
+} while(0)
+
+#define SYS_GET_DATA6(data32p, bitpos)                  ( ( (uint8)((*(data32p)) >> (bitpos)) ) & 0x003F )
+#define SYS_SET_DATA6(data32p, bitpos, data8)   \
+do { \
+        uint32 _org_data = *(data32p);  \
+        uint32 _new_data = _org_data & ~((uint32)(0x003F) << (bitpos)); \
+        _new_data |= ( ((uint32)(data8)) << (bitpos)); \
+        *(data32p) = _new_data;  \
+} while(0)
+
+#define SYS_GET_DATA8(data32p, bitpos)                  ( (uint8)((*(data32p)) >> (bitpos)) )
+#define SYS_SET_DATA8(data32p, bitpos, data8)   \
+do { \
+        uint32 _org_data = *(data32p);  \
+        uint32 _new_data = _org_data & ~((uint32)(0xFFFF) << (bitpos)); \
+        _new_data |= ( ((uint32)(data8)) << (bitpos)); \
+        *(data32p) = _new_data;  \
+} while(0)
+
+#define SYS_REG_EIPC_GET()	(sys_get_cpu_base(&cpu->reg)->r[SYS_REG_EIPC] & 0xFFFFFFFE)
+#define SYS_REG_FEPC_GET()	(sys_get_cpu_base(&cpu->reg)->r[SYS_REG_FEPC] & 0xFFFFFFFE)
+
+
+#endif /* _CPU_REGISTER_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/debugger/executor/concrete_executor/dbg_target_cpu.c
@@ -0,0 +1,185 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "concrete_executor/target/dbg_target_cpu.h"
+#include "cpu.h"
+#include "symbol_ops.h"
+
+#include <stdio.h>
+#include "intc.h"
+#include "target_mpu_op.h"
+
+static void print_register(const char* regname, uint32 addr, char* opt)
+{
+	 uint32 funcaddr;
+	 int funcid;
+	 uint32 gladdr;
+	 int glid;
+
+	 funcid = symbol_pc2funcid(addr, &funcaddr);
+	 if (funcid >= 0) {
+		printf("%s		0x%x %s(+0x%x)", regname, addr, symbol_funcid2funcname(funcid), addr - funcaddr);
+	 }
+	 else {
+		glid = symbol_addr2glid(addr, &gladdr);
+		if (glid >= 0) {
+			printf("%s		0x%x %s(+0x%x)", regname, addr, symbol_glid2glname(glid), addr - gladdr);
+		}
+		else {
+			printf("%s		0x%x", regname, addr);
+		}
+	 }
+	 if (opt != NULL) {
+		 printf(" %s\n", opt);
+	 }
+	 else {
+		 printf("\n");
+	 }
+	return;
+}
+
+static const char* intr_status_str[ExceptionRequestStatus_Num] = {
+		"PENDING",
+		"RUNNABLE",
+		"RUNNING",
+		"WAITING",
+};
+
+static void show_intr_info(void)
+{
+	ExceptionRequestEntryType *req;
+	ExceptionRequestEntryType *curr = intc_control[0].current_exception;
+
+	printf("\n**** INTERRUPT CONTROLLER ****\n");
+	if (curr != NULL) {
+		printf("current exception = %s[%s] level=%u intno=%u degree=%x\n",
+				curr->data.req->name,
+				intr_status_str[curr->data.status],
+				curr->data.req->level,
+				curr->data.intno, curr->data.priority_degree);
+	}
+	else {
+		printf("current exception = NONE\n");
+	}
+
+	ListEntry_Foreach(&intc_control[0].user_queue.pending, req) {
+		printf(" *user intr(%s:%s) intno=%u degree=%x\n",
+				req->data.req->name,
+				intr_status_str[req->data.status],
+				req->data.intno, req->data.priority_degree);
+	}
+
+	IntcPriorityLevelType level;
+	for (level = IntcPriorityLevel_0; level < IntcPriorityLevel_Num; level++) {
+		ListEntry_Foreach(&intc_control[0].exception_queue[level].pending, req) {
+			printf(" *exception[%u] intr(%s:%s) intno=%u degree=%x\n",
+					level,
+					req->data.req->name,
+					intr_status_str[req->data.status],
+					req->data.intno, req->data.priority_degree);
+		}
+	}
+}
+
+void dbg_target_print_cpu(uint32 coreId)
+{
+	int i;
+	uint32 pc;
+	char buffer[128];
+
+	printf("***CPU<%d>***\n", coreId);
+	pc = virtual_cpu.cores[coreId].core.reg.pc;
+
+	print_register("PC", pc, NULL);
+	for (i = 0; i < 32; i++) {
+		 char *opt = NULL;
+		 sprintf(buffer, "R%d", i);
+		 switch (i) {
+		 case 3:
+			 opt = "Stack Pointer";
+			 break;
+		 case 10:
+			 opt = "Return Value";
+			 break;
+		 case 6:
+			 opt = "Arg1";
+			 break;
+		 case 7:
+			 opt = "Arg2";
+			 break;
+		 case 8:
+			 opt = "Arg3";
+			 break;
+		 case 9:
+			 opt = "Arg4";
+			 break;
+		 default:
+			 break;
+		 }
+		 print_register(buffer, virtual_cpu.cores[coreId].core.reg.r[i], opt);
+	 }
+	 print_register("EIPC", sys_get_cpu_base(&virtual_cpu.cores[coreId].core.reg)->r[SYS_REG_EIPC], NULL);
+	 printf("EIPSW		0x%x\n", sys_get_cpu_base(&virtual_cpu.cores[coreId].core.reg)->r[SYS_REG_EIPSW]);
+	 printf("ECR		0x%x\n", sys_get_cpu_base(&virtual_cpu.cores[coreId].core.reg)->r[SYS_REG_ECR]);
+	 printf("PSW		0x%x\n", sys_get_cpu_base(&virtual_cpu.cores[coreId].core.reg)->r[SYS_REG_PSW]);
+	 print_register("FEPC", sys_get_cpu_base(&virtual_cpu.cores[coreId].core.reg)->r[SYS_REG_FEPC], NULL);
+	 printf("FEPSW 		0x%x\n", sys_get_cpu_base(&virtual_cpu.cores[coreId].core.reg)->r[SYS_REG_FEPSW]);
+	 printf("CTBP		0x%x\n", sys_get_cpu_base(&virtual_cpu.cores[coreId].core.reg)->r[SYS_REG_CTBP]);
+
+	 printf("FPSR		0x%x\n", sys_get_cpu_base(&virtual_cpu.cores[coreId].core.reg)->r[SYS_REG_FPSR]);
+	 printf("FPEPC		0x%x\n", sys_get_cpu_base(&virtual_cpu.cores[coreId].core.reg)->r[SYS_REG_FPEPC]);
+	 printf("FPST		0x%x\n", sys_get_cpu_base(&virtual_cpu.cores[coreId].core.reg)->r[SYS_REG_FPST]);
+	 printf("FPCC		0x%x\n", sys_get_cpu_base(&virtual_cpu.cores[coreId].core.reg)->r[SYS_REG_FPCC]);
+	 printf("FPCFG		0x%x\n", sys_get_cpu_base(&virtual_cpu.cores[coreId].core.reg)->r[SYS_REG_FPCFG]);
+	 printf("FPEC		0x%x\n", sys_get_cpu_base(&virtual_cpu.cores[coreId].core.reg)->r[SYS_REG_FPEC]);
+
+	 printf("RBASE		0x%x\n", *cpu_get_sysreg2(&virtual_cpu.cores[coreId].core.reg.sys, SYS_GRP_1, SYS_REG_RBASE));
+	 printf("EBASE		0x%x\n", *cpu_get_sysreg2(&virtual_cpu.cores[coreId].core.reg.sys, SYS_GRP_1, SYS_REG_EBASE));
+	 printf("INTBP		0x%x\n", *cpu_get_sysreg2(&virtual_cpu.cores[coreId].core.reg.sys, SYS_GRP_1, SYS_REG_INTBP));
+
+	 printf("ISPR		0x%x\n", *cpu_get_sysreg2(&virtual_cpu.cores[coreId].core.reg.sys, SYS_GRP_2, SYS_REG_ISPR));
+	 printf("PMR		0x%x\n", *cpu_get_sysreg2(&virtual_cpu.cores[coreId].core.reg.sys, SYS_GRP_2, SYS_REG_PMR));
+	 printf("INTCFG		0x%x\n", *cpu_get_sysreg2(&virtual_cpu.cores[coreId].core.reg.sys, SYS_GRP_2, SYS_REG_INTCFG));
+
+	 target_mpu_debug_print_mpu_status(&(virtual_cpu.cores[coreId].core));
+	 show_intr_info();
+	 return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/debugger/executor/concrete_executor/dbg_target_serial.c
@@ -0,0 +1,512 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "concrete_executor/target/dbg_target_serial.h"
+#include "target/target_os_api.h"
+#include <stdio.h>
+
+#define DBG_SERIAL_CHANNEL_NUM	4U
+#define DBG_SERIAL_BUFFER_SIZE	1024U
+
+typedef struct {
+	uint32 count;
+	uint32 write_off;
+	uint32 read_off;
+	uint8  buffer[DBG_SERIAL_BUFFER_SIZE];
+} DbgSerialFifoType;
+
+DbgSerialFifoType dbg_serial_fifo[DBG_SERIAL_CHANNEL_NUM];
+
+Std_ReturnType dbg_serial_in(uint8 channel, uint8 data)
+{
+	DbgSerialFifoType *fifo;
+	if (channel >= DBG_SERIAL_CHANNEL_NUM) {
+		return STD_E_INVALID;
+	}
+	//printf("dbg_serial_in:channel=%d data=%c\n", channel, data);
+	fifo = &dbg_serial_fifo[channel];
+	if (fifo->count >= DBG_SERIAL_BUFFER_SIZE) {
+		return STD_E_LIMIT;
+	}
+	fifo->buffer[fifo->write_off] = data;
+
+	fifo->count++;
+	fifo->write_off++;
+	if (fifo->write_off >= DBG_SERIAL_BUFFER_SIZE) {
+		fifo->write_off = 0U;
+	}
+	return STD_E_OK;
+}
+
+
+bool dbg_serial_getchar(uint8 channel, uint8 *data)
+{
+	DbgSerialFifoType *fifo;
+	if (channel >= DBG_SERIAL_CHANNEL_NUM) {
+		return FALSE;
+	}
+
+	fifo = &dbg_serial_fifo[channel];
+	if (fifo->count == 0U) {
+		return FALSE;
+	}
+	*data = fifo->buffer[fifo->read_off];
+
+	fifo->count--;
+	fifo->read_off++;
+	if (fifo->read_off >= DBG_SERIAL_BUFFER_SIZE) {
+		fifo->read_off = 0U;
+	}
+	return TRUE;
+}
+
+bool dbg_serial_putchar(uint8 channel, uint8 data)
+{
+	if (channel == 0) {
+		printf("%c", data);
+		fflush(stdout);
+	}
+	else {
+		fprintf(stderr, "%c", data);
+		fflush(stderr);
+	}
+	return TRUE;
+}
+
+/*
+ * file
+ */
+
+typedef struct {
+	int isset;
+	char path[4096];
+	int fd;
+} SerialFileType;
+
+typedef struct {
+	SerialFileType 	file;
+	int				read_off;
+} SerialFileReaderType;
+
+typedef struct {
+	SerialFileType 	file;
+	int				write_off;
+} SerialFileWriterType;
+
+typedef struct {
+	SerialFileReaderType in;
+	SerialFileWriterType out;
+} SerialDeviceFileType;
+static SerialDeviceFileType SerialDeviceFile = {
+		.in.file.isset = -1,
+		.in.file.fd = -1,
+		.out.file.isset = -1,
+		.out.file.fd = -1,
+};
+
+//static Std_ReturnType file_write(SerialFileWriterType *wfile, char c);
+//static Std_ReturnType file_read(SerialFileReaderType *rfile, char *c);
+static void file_cache_flush(uint8 channel, SerialFileWriterType *wfile);
+static Std_ReturnType file_cache_write(uint8 channel, SerialFileWriterType *wfile, char c);
+static Std_ReturnType file_cache_read(uint8 channel, SerialFileReaderType *rfile, char *c);
+static Std_ReturnType file_cache_load(uint8 channel, SerialFileReaderType *rfile);
+
+bool dbg_serial_getchar_file(uint8 channel, uint8 *data)
+{
+	char c;
+#if 0
+	if (file_read(&SerialDeviceFile.in, &c) != STD_E_OK) {
+		return FALSE;
+	}
+#else
+	if (file_cache_read(channel, &SerialDeviceFile.in, &c) != STD_E_OK) {
+		return FALSE;
+	}
+#endif
+	else {
+		*data = c;
+	}
+	//printf("getchar=0x%x\n", c);
+	//fflush(stdout);
+	return TRUE;
+}
+bool dbg_serial_putchar_file(uint8 channel, uint8 data)
+{
+	char c = data;
+#if 0
+	if (file_write(&SerialDeviceFile.out, c) != STD_E_OK) {
+		return FALSE;
+	}
+#else
+	if (file_cache_write(channel, &SerialDeviceFile.out, c) != STD_E_OK) {
+		return FALSE;
+	}
+#endif
+	return TRUE;
+}
+void dbg_serial_flush_file(uint8 channel)
+{
+	file_cache_flush(channel, &SerialDeviceFile.out);
+	file_cache_load(channel, &SerialDeviceFile.in);
+	//printf("dbg_serial_flush_file:channel=%d\n", channel);
+
+	return;
+}
+/*
+ * static
+ */
+#include "cpuemu_ops.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+
+#define SERIAL_IN_FILENAME		"serial_out.txt"
+#define SERIAL_OUT_FILENAME		"serial_in.txt"
+
+
+static void file_pathset(SerialFileType *file, const char* filename, int filenamelen)
+{
+	Std_ReturnType ret;
+	char *path;
+	int pathlen = 0;
+	if (file->isset >= 0) {
+		return;
+	}
+
+	ret = cpuemu_get_devcfg_string("SERIAL_FILE_PATH", &path);
+	if (ret != STD_E_OK) {
+		printf("WARNING:can not find SERIAL_FILE_PATH on device_file\n");
+	}
+
+	pathlen = strlen(path);
+	file->isset = 1;
+	memset(file->path, 0, 4096);
+	if (pathlen > 0) {
+		memcpy(file->path, path, pathlen);
+		file->path[pathlen] = '/';
+		memcpy(&file->path[pathlen + 1], filename, filenamelen);
+#ifndef OS_LINUX
+		if (file->path[0] == '/') {
+			file->path[0] = file->path[1];
+			file->path[1] = ':';
+		}
+#endif /* OS_LINUX */
+	}
+	else {
+		memcpy(&file->path, filename, filenamelen);
+	}
+	return;
+}
+
+static void my_file_wopen(SerialFileWriterType *wfile)
+{
+	int err;
+	struct stat buf;
+
+	if (wfile->file.fd >= 0) {
+		return;
+	}
+	file_pathset(&wfile->file, SERIAL_OUT_FILENAME, strlen(SERIAL_OUT_FILENAME));
+	wfile->file.fd = target_os_api_open_w(wfile->file.path);
+	if (wfile->file.fd < 0) {
+		printf("file open error:%s\n", wfile->file.path);
+		exit(1);
+	}
+	err = fstat(wfile->file.fd, &buf);
+	if (err < 0) {
+		printf("fstat error:%s\n", wfile->file.path);
+		exit(1);
+	}
+	wfile->write_off = buf.st_size;
+
+	return;
+}
+static void my_file_ropen(SerialFileReaderType *rfile)
+{
+	int err;
+	struct stat buf;
+
+	if (rfile->file.fd >= 0) {
+		return;
+	}
+	file_pathset(&rfile->file, SERIAL_IN_FILENAME, strlen(SERIAL_IN_FILENAME));
+	rfile->file.fd = target_os_api_open_r(rfile->file.path);
+	if (rfile->file.fd < 0) {
+		printf("file open error:%s errno=%d\n", rfile->file.path, errno);
+		exit(1);
+	}
+	err = fstat(rfile->file.fd, &buf);
+	if (err < 0) {
+		printf("fstat error:%s\n", rfile->file.path);
+		exit(1);
+	}
+	rfile->read_off = buf.st_size;
+
+	return;
+}
+#if 0
+
+static Std_ReturnType file_read(SerialFileReaderType *rfile, char *c)
+{
+	int err;
+	struct stat buf;
+
+	file_ropen(rfile);
+
+	err = fstat(rfile->file.fd, &buf);
+	if (err < 0) {
+		printf("fstat error:%s\n", rfile->file.path);
+		exit(1);
+	}
+
+	if (rfile->read_off >= buf.st_size) {
+		return STD_E_NOENT;
+	}
+
+	err = lseek(rfile->file.fd, rfile->read_off, SEEK_SET);
+	if (err < 0) {
+		printf("lseek error:%s\n", rfile->file.path);
+		exit(1);
+	}
+	err = read(rfile->file.fd, c, 1);
+	if (err < 0) {
+		printf("read error:%s\n", rfile->file.path);
+		exit(1);
+	}
+	rfile->read_off++;
+
+	return STD_E_OK;
+}
+static Std_ReturnType file_write(SerialFileWriterType *wfile, char c)
+{
+	int err;
+	struct stat buf;
+
+	file_wopen(wfile);
+
+	err = fstat(wfile->file.fd, &buf);
+	if (err < 0) {
+		printf("fstat error:%s\n", wfile->file.path);
+		exit(1);
+	}
+	err = lseek(wfile->file.fd, wfile->write_off, SEEK_SET);
+	if (err < 0) {
+		printf("lseek error:%s\n", wfile->file.path);
+		exit(1);
+	}
+
+	err = write(wfile->file.fd, &c, 1);
+	if (err != 1) {
+		printf("write error:%s\n", wfile->file.path);
+		exit(1);
+	}
+	wfile->write_off++;
+
+	err = close(wfile->file.fd);
+	if (err < 0) {
+		printf("lseek error:%s\n", wfile->file.path);
+		exit(1);
+	}
+	wfile->file.fd = -1;
+	return STD_E_OK;
+}
+#endif
+
+#define DBG_SERIAL_CACHE_BUFFER_SIZE	(1024)
+typedef struct {
+	uint32 count;
+	uint32 off;
+	uint32 rcheck_count;
+	uint32 wcheck_count;
+	uint8  buffer[DBG_SERIAL_CACHE_BUFFER_SIZE];
+} DbgSerialCacheBufferType;
+
+static DbgSerialCacheBufferType DbgSerialCacheWriteBuffer[DBG_SERIAL_CHANNEL_NUM];
+static DbgSerialCacheBufferType DbgSerialCacheReadBuffer[DBG_SERIAL_CHANNEL_NUM];
+
+static void file_cache_flush(uint8 channel, SerialFileWriterType *wfile)
+{
+	int err;
+	struct stat buf;
+
+	if (DbgSerialCacheWriteBuffer[channel].count == 0) {
+		return;
+	}
+	else if (DbgSerialCacheWriteBuffer[channel].count < 128) {
+		DbgSerialCacheWriteBuffer[channel].wcheck_count++;
+		if (DbgSerialCacheWriteBuffer[channel].wcheck_count < 10000) {
+			return;
+		}
+		else {
+			DbgSerialCacheWriteBuffer[channel].wcheck_count = 0;
+		}
+	}
+
+	my_file_wopen(wfile);
+
+	err = fstat(wfile->file.fd, &buf);
+	if (err < 0) {
+		printf("fstat error:%s\n", wfile->file.path);
+		exit(1);
+	}
+	err = lseek(wfile->file.fd, wfile->write_off, SEEK_SET);
+	if (err < 0) {
+		printf("lseek error:%s\n", wfile->file.path);
+		exit(1);
+	}
+
+	err = write(wfile->file.fd, (char*)DbgSerialCacheWriteBuffer[channel].buffer, DbgSerialCacheWriteBuffer[channel].count);
+	if (err != DbgSerialCacheWriteBuffer[channel].count) {
+		printf("write error:%s\n", wfile->file.path);
+		exit(1);
+	}
+	//printf("flush_size=%d\n", DbgSerialCacheWriteBuffer[channel].count);
+	DbgSerialCacheWriteBuffer[channel].count = 0;
+	DbgSerialCacheWriteBuffer[channel].off = 0;
+	wfile->write_off++;
+
+	err = close(wfile->file.fd);
+	if (err < 0) {
+		printf("lseek error:%s\n", wfile->file.path);
+		exit(1);
+	}
+	wfile->file.fd = -1;
+	return;
+}
+
+static Std_ReturnType file_cache_load(uint8 channel, SerialFileReaderType *rfile)
+{
+	int err;
+	int read_size;
+	int cache_size;
+	int fread_size;
+	int off;
+	struct stat buf;
+
+	if (DbgSerialCacheReadBuffer[channel].count > 0) {
+		return STD_E_OK;
+	} else {
+		DbgSerialCacheReadBuffer[channel].rcheck_count++;
+		if (DbgSerialCacheReadBuffer[channel].rcheck_count < 100) {
+			return STD_E_NOENT;
+		}
+		else {
+			DbgSerialCacheReadBuffer[channel].rcheck_count = 0;
+		}
+	}
+
+	my_file_ropen(rfile);
+
+	err = fstat(rfile->file.fd, &buf);
+	if (err < 0) {
+		printf("fstat error:%s\n", rfile->file.path);
+		exit(1);
+	}
+
+	if (rfile->read_off >= buf.st_size) {
+		return STD_E_NOENT;
+	}
+	fread_size = buf.st_size - rfile->read_off;
+
+	err = lseek(rfile->file.fd, rfile->read_off, SEEK_SET);
+	if (err < 0) {
+		printf("lseek error:%s\n", rfile->file.path);
+		exit(1);
+	}
+	if (DbgSerialCacheReadBuffer[channel].off >= DBG_SERIAL_CACHE_BUFFER_SIZE) {
+		DbgSerialCacheReadBuffer[channel].off = 0;
+	}
+
+	off = DbgSerialCacheReadBuffer[channel].off;
+	cache_size = DBG_SERIAL_CACHE_BUFFER_SIZE - off;
+	if (cache_size > fread_size) {
+		read_size = fread_size;
+	}
+	else {
+		read_size = cache_size;
+	}
+	if (read_size == 0) {
+		return STD_E_NOENT;
+	}
+
+	err = read(rfile->file.fd, (char*)&DbgSerialCacheReadBuffer[channel].buffer[off], read_size);
+	if (err <= 0) {
+		//TODO printf("read error:%s err=%d errno=%d size=%d off=%d read_size=%d\n", rfile->file.path, err, errno, buf.st_size, rfile->read_off, read_size);
+		exit(1);
+	}
+	rfile->read_off += err;
+	DbgSerialCacheReadBuffer[channel].count += err;
+
+	return STD_E_OK;
+}
+static Std_ReturnType file_cache_write(uint8 channel, SerialFileWriterType *wfile, char c)
+{
+	uint32 off = DbgSerialCacheWriteBuffer[channel].off;
+	if (DbgSerialCacheWriteBuffer[channel].count == DBG_SERIAL_CACHE_BUFFER_SIZE) {
+		file_cache_flush(channel, wfile);
+	}
+	DbgSerialCacheWriteBuffer[channel].buffer[off] = c;
+	DbgSerialCacheWriteBuffer[channel].count++;
+	DbgSerialCacheWriteBuffer[channel].off++;
+	//printf("file_cache_write:c=%c\n", c);
+	return STD_E_OK;
+}
+
+static Std_ReturnType file_cache_read(uint8 channel, SerialFileReaderType *rfile, char *c)
+{
+	uint32 off = DbgSerialCacheReadBuffer[channel].off;
+	if (DbgSerialCacheReadBuffer[channel].count == 0) {
+		return STD_E_NOENT;
+	}
+	*c = DbgSerialCacheReadBuffer[channel].buffer[off];
+	DbgSerialCacheReadBuffer[channel].count--;
+	DbgSerialCacheReadBuffer[channel].off++;
+	if (off >= DBG_SERIAL_CACHE_BUFFER_SIZE) {
+		off = 0;
+	}
+	return STD_E_OK;
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/debugger/executor/concrete_executor/dbg_target_serial_tcp.c
@@ -0,0 +1,181 @@
+#include "concrete_executor/target/dbg_target_serial.h"
+#include "tcp/tcp_server.h"
+#include "tcp/tcp_connection.h"
+#include "comm_buffer.h"
+#include "athrill_mpthread.h"
+#include "assert.h"
+
+#include <unistd.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+typedef struct {
+	MpthrIdType			id;
+	MpthrOperationType	op;
+} DbgSerialTcpThreadType;
+
+typedef struct {
+	DbgSerialTcpThreadType	thread;
+	CommFifoBufferType		fifo;
+	CommBufferType			rcvbuffer;
+	TcpServerType			server;
+	TcpConnectionType		connection;
+} DbgSerialTcpType;
+
+#define DBG_SERIAL_TCP_BUFFER_SIZE	1024
+static uint8 dbg_serial_channel_num = 0;
+static DbgSerialTcpType *dbg_serial_tcp;
+static Std_ReturnType dbg_serail_get_channel(MpthrIdType id, uint8 *channel)
+{
+	uint32 i;
+	for (i = 0; i < dbg_serial_channel_num; i++) {
+		if (dbg_serial_tcp[i].thread.id == id) {
+			*channel = i;
+			return STD_E_OK;
+		}
+	}
+	return STD_E_NOENT;
+}
+
+static Std_ReturnType dbg_serial_op_do_init(MpthrIdType id)
+{
+	return STD_E_OK;
+}
+
+static void dbg_serial_do_transfer(uint8 channel, uint32 size)
+{
+	uint32 off = 0;
+	uint32 res;
+	Std_ReturnType err;
+
+	do {
+		mpthread_lock(dbg_serial_tcp[channel].thread.id);
+		err = comm_fifo_buffer_add(&dbg_serial_tcp[channel].fifo, &dbg_serial_tcp[channel].rcvbuffer.data[off], size, &res);
+		mpthread_unlock(dbg_serial_tcp[channel].thread.id);
+		if (err != STD_E_OK) {
+			usleep(500 * 1000); /* 500msec */
+		}
+		off += res;
+	} while (off < size);
+	return;
+}
+
+static Std_ReturnType dbg_serial_do_recv(uint8 channel)
+{
+	Std_ReturnType err;
+	uint32 res;
+
+	while (TRUE) {
+		err = tcp_connection_receive(&dbg_serial_tcp[channel].connection, dbg_serial_tcp[channel].rcvbuffer.data, dbg_serial_tcp[channel].rcvbuffer.max_size, &res);
+		if (err != STD_E_OK) {
+			printf("SERIAL TCP CONNECTION INFO(channel=%u): receive error\n", channel);
+			return err;
+		}
+		dbg_serial_do_transfer(channel, res);
+	}
+}
+
+static Std_ReturnType dbg_serial_op_do_proc(MpthrIdType id)
+{
+	uint8 channel;
+	Std_ReturnType err;
+
+	err = dbg_serail_get_channel(id, &channel);
+	ASSERT(err == STD_E_OK);
+
+	while (TRUE) {
+		err = tcp_server_accept((const TcpServerType *)&dbg_serial_tcp[channel].server, &dbg_serial_tcp[channel].connection);
+		if (err != STD_E_OK) {
+			continue;
+		}
+		printf("SERIAL TCP SERVER INFO(channel=%u:server-port=%u): connected\n", channel, dbg_serial_tcp[channel].server.config.server_port);
+
+		(void)dbg_serial_do_recv(channel);
+		tcp_connection_close(&dbg_serial_tcp[channel].connection);
+	}
+	return STD_E_OK;
+}
+
+Std_ReturnType dbg_serial_init_tcp(uint8 channel_num)
+{
+	uint32 i;
+
+	dbg_serial_tcp = malloc(sizeof(DbgSerialTcpType) * channel_num);
+	if (dbg_serial_tcp == NULL) {
+		return STD_E_INVALID;
+	}
+	memset(dbg_serial_tcp, 0, sizeof(DbgSerialTcpType) * channel_num);
+	dbg_serial_channel_num = channel_num;
+	for (i = 0; i < channel_num; i++) {
+		dbg_serial_tcp[i].thread.id = -1;
+	}
+	return STD_E_OK;
+}
+
+Std_ReturnType dbg_serial_open_tcp(uint8 channel, uint32 server_portno)
+{
+	Std_ReturnType err;
+	TcpServerConfigType config;
+
+	//buffer
+	err = comm_fifo_buffer_create(DBG_SERIAL_TCP_BUFFER_SIZE, &dbg_serial_tcp[channel].fifo);
+	ASSERT(err == STD_E_OK);
+	err = comm_buffer_create(DBG_SERIAL_TCP_BUFFER_SIZE, &dbg_serial_tcp[channel].rcvbuffer);
+	ASSERT(err == STD_E_OK);
+
+	//server
+	config.server_port = server_portno;
+	err = tcp_server_create((const TcpServerConfigType *)&config, &dbg_serial_tcp[channel].server);
+	ASSERT(err == STD_E_OK);
+
+	//thread
+	dbg_serial_tcp[channel].thread.op.do_init = dbg_serial_op_do_init;
+	dbg_serial_tcp[channel].thread.op.do_proc = dbg_serial_op_do_proc;
+	err = mpthread_register(&dbg_serial_tcp[channel].thread.id, &dbg_serial_tcp[channel].thread.op);
+	ASSERT(err == STD_E_OK);
+
+	err = mpthread_start_proc(dbg_serial_tcp[channel].thread.id);
+	ASSERT(err == STD_E_OK);
+
+	return STD_E_OK;
+}
+
+bool dbg_serial_getchar_tcp(uint8 channel, uint8 *data)
+{
+	Std_ReturnType ret;
+	uint32 res;
+
+	mpthread_lock(dbg_serial_tcp[channel].thread.id);
+	while (TRUE) {
+		ret = comm_fifo_buffer_get(&dbg_serial_tcp[channel].fifo, (char*)data, 1U, &res);
+		if (ret != STD_E_OK) {
+			mpthread_unlock(dbg_serial_tcp[channel].thread.id);
+			return FALSE;
+		}
+		if ((*data) == '\r') {
+			continue;
+		}
+		else {
+			break;
+		}
+	}
+	mpthread_unlock(dbg_serial_tcp[channel].thread.id);
+
+	return TRUE;
+}
+
+bool dbg_serial_putchar_tcp(uint8 channel, uint8 data)
+{
+	Std_ReturnType ret;
+	uint32 res;
+	if (dbg_serial_tcp[channel].connection.connected == FALSE) {
+		return FALSE;
+	}
+	ret = tcp_connection_send(&dbg_serial_tcp[channel].connection, (char*)&data, 1U, &res);
+	if (ret != STD_E_OK) {
+		printf("SERIAL TCP CONNECTION INFO(channel=%u): send error\n", channel);
+		return FALSE;
+	}
+	return TRUE;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/debugger/interaction/inc/dbg_interaction_target_ids.h
@@ -0,0 +1,51 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _DBG_INTERACTION_TARGET_IDS_H_
+#define _DBG_INTERACTION_TARGET_IDS_H_
+
+#include "dbg_interaction_std_ids.h"
+
+typedef enum {
+	DBG_CMD_TARGET_ID_XXX = DBG_CMD_STD_ID_TARGET,
+} DbgCmdTargetIdType;
+
+#endif /* _DBG_INTERACTION_TARGET_IDS_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/device.c
@@ -0,0 +1,178 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "device.h"
+#include "cpuemu_ops.h"
+#include "device_ex_serial_ops.h"
+#include "concrete_executor/target/dbg_target_serial.h"
+#include <stdio.h>
+#include "std_device_ops.h"
+#include "athrill_device.h"
+#ifdef SERIAL_FIFO_ENABLE
+#include "serial_fifo.h"
+#endif /* SERIAL_FIFO_ENABLE */
+
+#ifdef CONFIG_STAT_PERF
+ProfStatType cpuemu_dev_timer_prof;
+ProfStatType cpuemu_dev_serial_prof;
+ProfStatType cpuemu_dev_intr_prof;
+
+#define CPUEMU_DEV_TIMER_PROF_START()	profstat_start(&cpuemu_dev_timer_prof)
+#define CPUEMU_DEV_TIMER_PROF_END()		profstat_end(&cpuemu_dev_timer_prof)
+#define CPUEMU_DEV_SERIAL_PROF_START()	profstat_start(&cpuemu_dev_serial_prof)
+#define CPUEMU_DEV_SERIAL_PROF_END()		profstat_end(&cpuemu_dev_serial_prof)
+#define CPUEMU_DEV_INTR_PROF_START()	profstat_start(&cpuemu_dev_intr_prof)
+#define CPUEMU_DEV_INTR_PROF_END()		profstat_end(&cpuemu_dev_intr_prof)
+#else
+#define CPUEMU_DEV_TIMER_PROF_START()
+#define CPUEMU_DEV_TIMER_PROF_END()
+#define CPUEMU_DEV_SERIAL_PROF_START()
+#define CPUEMU_DEV_SERIAL_PROF_END()
+#define CPUEMU_DEV_INTR_PROF_START()
+#define CPUEMU_DEV_INTR_PROF_END()
+#endif /* CONFIG_STAT_PERF */
+
+static DeviceExSerialOpType device_ex_serial_op = {
+		.putchar = dbg_serial_putchar,
+		.getchar = dbg_serial_getchar,
+		.flush = NULL,
+};
+static DeviceExSerialOpType device_ex_serial_tcp_op = {
+		.putchar = dbg_serial_putchar_tcp,
+		.getchar = dbg_serial_getchar_tcp,
+		.flush = NULL,
+};
+
+static void device_serial_init(CpuType *cpu, DeviceClockType *dev_clock)
+{
+	Std_ReturnType ret;
+	uint32 value;
+
+
+	device_init_serial(&mpu_address_map.map[MPU_ADDRESS_REGION_INX_SERIAL]);
+	ret = cpuemu_get_devcfg_value("DEVICE_CONFIG_SERIAL_CH1_SERVER_PORTNO", &value);
+	if (ret != STD_E_OK) {
+		device_ex_serial_register_ops(1U, &device_ex_serial_op);
+	}
+	else {
+		ret = dbg_serial_init_tcp(2U);
+		ASSERT(ret == STD_E_OK);
+		device_ex_serial_register_ops(1U, &device_ex_serial_tcp_op);
+		printf("device_serial_init: server-portno=%u\n", value);
+		ret = dbg_serial_open_tcp(1U, value);
+		ASSERT(ret == STD_E_OK);
+	}
+	return;
+}
+
+static uint32 enable_mros_can = 0;
+void device_init(CpuType *cpu, DeviceClockType *dev_clock)
+{
+
+	dev_clock->clock = 0;
+	dev_clock->intclock = 0;
+	dev_clock->min_intr_interval = DEVICE_CLOCK_MAX_INTERVAL;
+	dev_clock->can_skip_clock = FALSE;
+
+	device_init_clock(&mpu_address_map.map[MPU_ADDRESS_REGION_INX_CLOCK]);
+	device_init_intc(cpu, &mpu_address_map.map[MPU_ADDRESS_REGION_INX_INTC1]);
+	device_init_timer(&mpu_address_map.map[MPU_ADDRESS_REGION_INX_TIMER]);
+	device_init_digital(NULL);
+
+	device_serial_init(cpu, dev_clock);
+
+	cpuemu_get_devcfg_value("DEBUG_FUNC_ENABLE_CAN", &enable_mros_can);
+	if (enable_mros_can != 0) {
+		device_init_can(&mpu_address_map.map[MPU_ADDRESS_REGION_INX_CAN]);
+	}
+#ifdef SERIAL_FIFO_ENABLE
+	athrill_device_init_serial_fifo();
+#endif /* SERIAL_FIFO_ENABLE */
+
+#ifdef EXDEV_ENABLE
+	device_init_athrill_exdev();
+#endif /* EXDEV_ENABLE */
+	return;
+}
+
+void device_supply_clock(DeviceClockType *dev_clock)
+{
+	dev_clock->min_intr_interval = DEVICE_CLOCK_MAX_INTERVAL;
+	dev_clock->can_skip_clock = TRUE;
+
+	CPUEMU_DEV_TIMER_PROF_START();
+	device_supply_clock_digital(dev_clock);
+	CPUEMU_DEV_TIMER_PROF_END();
+
+	CPUEMU_DEV_TIMER_PROF_START();
+	device_supply_clock_timer(dev_clock);
+	CPUEMU_DEV_TIMER_PROF_END();
+
+	CPUEMU_DEV_SERIAL_PROF_START();
+	device_supply_clock_serial(dev_clock);
+	CPUEMU_DEV_SERIAL_PROF_END();
+
+	if (enable_mros_can != 0) {
+		CPUEMU_DEV_SERIAL_PROF_START();
+		device_supply_clock_can(dev_clock);
+		CPUEMU_DEV_SERIAL_PROF_END();
+	}
+#ifdef SERIAL_FIFO_ENABLE
+	CPUEMU_DEV_INTR_PROF_START();
+	athrill_device_supply_clock_serial_fifo(dev_clock);
+	CPUEMU_DEV_INTR_PROF_END();
+#endif /* SERIAL_FIFO_ENABLE */
+
+#ifdef EXDEV_ENABLE
+	device_supply_clock_exdev(dev_clock);
+#endif /* EXDEV_ENABLE */
+	CPUEMU_DEV_INTR_PROF_START();
+	device_supply_clock_intc(dev_clock);
+	CPUEMU_DEV_INTR_PROF_END();
+	return;
+}
+
+void device_raise_int(uint16 intno)
+{
+	intc_raise_intr(intno);
+}
+
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/device.h
@@ -0,0 +1,126 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _DEVICE_H_
+#define _DEVICE_H_
+
+#include "std_types.h"
+#include "cpu.h"
+#include "mpu_config.h"
+#include "mpu.h"
+#include "mpu_ops.h"
+#include "std_device_ops.h"
+
+/*
+ * デバイス初期化関数
+ */
+extern void device_init_intc(CpuType *cpu, MpuAddressRegionType *region);
+extern void device_init_timer(MpuAddressRegionType *region);
+extern void device_init_serial(MpuAddressRegionType *region);
+extern void device_init_can(MpuAddressRegionType *region);
+extern void device_init_clock(MpuAddressRegionType *region);
+extern void device_init_digital(MpuAddressRegionType *region);
+
+/*
+ * デバイスクロック供給
+ */
+extern void device_supply_clock_intc(DeviceClockType *dev_clock);
+extern void device_supply_clock_timer(DeviceClockType *dev_clock);
+extern void device_supply_clock_serial(DeviceClockType *dev_clock);
+extern void device_supply_clock_can(DeviceClockType *dev_clock);
+extern void device_supply_clock_digital(DeviceClockType *dev_clock);
+
+/*
+ * 割込み関数
+ */
+extern void device_raise_int(uint16 intno);
+
+/*
+ * メモリアクセス関数
+ */
+static inline Std_ReturnType device_get_data8(uint32 addr, uint8 *data)
+{
+	Std_ReturnType err;
+	uint8 *datap;
+
+	err = mpu_get_pointer(0U, addr, (uint8**)&datap);
+	if (err != STD_E_OK) {
+		return err;
+	}
+	*data = *datap;
+	return STD_E_OK;
+}
+
+static inline Std_ReturnType device_get_data16(uint32 addr, uint16 *data)
+{
+	Std_ReturnType err;
+	uint16 *datap;
+
+	err = mpu_get_pointer(0U, addr, (uint8**)&datap);
+	if (err != STD_E_OK) {
+		return err;
+	}
+	*data = *datap;
+	return STD_E_OK;
+}
+
+static inline Std_ReturnType device_put_data8(uint32 addr, uint8 data)
+{
+	Std_ReturnType err;
+	uint8 *datap;
+
+	err = mpu_get_pointer(0U, addr, (uint8**)&datap);
+	if (err != STD_E_OK) {
+		return err;
+	}
+	*datap = data;
+	return STD_E_OK;
+}
+
+/*
+ * 割込みコントローラAPI
+ */
+extern void intc_clr_fe(CoreIdType core_id);
+extern void intc_clr_ei(CoreIdType core_id);
+
+extern int intc_raise_exception(CoreIdType coreId, ExceptionIdType exno);
+
+#endif /* _DEVICE_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/intc/intc.c
@@ -0,0 +1,342 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "intc.h"
+#include "intc_user.h"
+#include "std_device_ops.h"
+#include "cpu_common/cpu_ops.h"
+
+ExceptionControllerType intc_control[CPU_CONFIG_CORE_NUM];
+static ExceptionRequestEntryType* judge_pending_Exception(CoreIdType coreId);
+static void raise_Exception(ExceptionRequestEntryType *exception);
+
+
+void device_init_intc(CpuType *cpu, MpuAddressRegionType *region)
+{
+	CoreIdType coreId = 0;
+	CoreIdType coreId_num = CPU_CONFIG_GET_CORE_ID_NUM();
+
+	intc_region = region;
+
+	/*
+	 * intc_controlの初期化
+	 */
+	for (coreId = 0; coreId < coreId_num; coreId++) {
+		intc_control[coreId].cpu = &cpu->cores[coreId].core;
+		intc_control_register_op.reset_registers(coreId);
+
+		intc_control[coreId].current_exception = NULL;
+		device_init_intc_UserIntr(coreId);
+		IntcPriorityLevelType level;
+		for (level = IntcPriorityLevel_0; level < IntcPriorityLevel_Num; level++) {
+			List_Init(&intc_control[coreId].exception_queue[level].pending, ExceptionRequestEntryType, 512U);
+		}
+	}
+
+	return;
+}
+
+void device_supply_clock_intc(DeviceClockType *dev_clock)
+{
+	CoreIdType coreId;
+	CoreIdType coreId_num = CPU_CONFIG_GET_CORE_ID_NUM();
+	ExceptionRequestEntryType *exception;
+
+#ifndef CPUEMU_CLOCK_BUG_FIX
+	dev_clock->clock++;
+#else
+#endif /* CPUEMU_CLOCK_BUG_FIX */
+
+	for (coreId = 0; coreId < coreId_num; coreId++) {
+		judge_pending_UserIntr(coreId);
+		exception = judge_pending_Exception(coreId);
+		if (exception != NULL) {
+			//DBG_PRINTF(("%s() exp=0x%x\n", __FUNCTION__, exception);
+			raise_Exception(exception);
+		}
+	}
+
+	for (coreId = 0; coreId < coreId_num; coreId++) {
+		if (intc_control[coreId].current_exception != NULL) {
+			dev_clock->intclock++;
+			break;
+		}
+	}
+
+	return;
+}
+
+
+int intc_raise_exception(CoreIdType coreId, ExceptionIdType exno)
+{
+	ExceptionRequestEntryType *req;
+	IntcPriorityLevelType level = intc_control_register_op.get_exception_priority_level(coreId, exno);
+
+	ListEntry_Alloc(&intc_control[coreId].exception_queue[level].pending, ExceptionRequestEntryType, &req);
+
+	req->data.req = &exception_config[exno];
+	req->data.status = ExceptionRequestStatus_RUNNABLE;
+	req->data.coreId = coreId;
+	req->data.exno = exno;
+	req->data.intno = 0;
+	req->data.priority_degree = intc_control_register_op.get_exception_priority_degree(coreId, exno, 0);
+	ListEntry_AddEntry(&intc_control[coreId].exception_queue[level].pending, req);
+	intc_control[coreId].cpu->is_halt = FALSE;
+
+	return 0;
+}
+void intc_clr_fe(CoreIdType coreId)
+{
+	ExceptionRequestEntryType *exp = intc_control[coreId].current_exception;
+	if (exp == NULL) {
+		return;
+	}
+	IntcPriorityLevelType level = intc_control_register_op.get_exception_priority_level(coreId, exp->data.exno);
+	ListEntry_RemoveEntry(&intc_control[coreId].exception_queue[level].pending, exp);
+	intc_control[coreId].current_exception = NULL;
+	return;
+}
+
+void intc_clr_ei(CoreIdType coreId)
+{
+	ExceptionRequestEntryType *exp = intc_control[coreId].current_exception;
+	//DBG_PRINTF(("%s() : exp=0x%x\n", __FUNCTION__, exp);
+	if (exp == NULL) {
+		return;
+	}
+	//DBG_PRINTF(("%s() : exp=0x%x exno=%u intno=%u\n", __FUNCTION__, exp, exp->data.exno, exp->data.intno);
+	if (exp->data.exno == ExceptionId_UserIntr) {
+		intc_control_register_op.set_current_user_intr_priority_degree(coreId, exp->data.intno, FALSE);
+	}
+	IntcPriorityLevelType level = intc_control_register_op.get_exception_priority_level(coreId, exp->data.exno);
+	ListEntry_RemoveEntry(&intc_control[coreId].exception_queue[level].pending, exp);
+	intc_control[coreId].current_exception = NULL;
+	return;
+}
+
+/* ----------------- static -------------------------------- */
+
+static bool can_raise_Exception(ExceptionRequestEntryType *exception);
+
+static bool can_raise_Exception(ExceptionRequestEntryType *exception)
+{
+	TargetCoreType *cpu = intc_control[exception->data.coreId].cpu;
+
+	/*
+	 * PSW.NP
+	 */
+	if ((exception->data.req->cond.NP == FALSE) && (CPU_ISSET_NP(&cpu->reg) == TRUE)) {
+		return FALSE;
+	}
+	/*
+	 * PSW.ID
+	 */
+	if ((exception->data.req->cond.ID == FALSE) && (CPU_ISSET_ID(&cpu->reg) == TRUE)) {
+		if (cpu->is_halt == TRUE) {
+			cpu->is_halt = FALSE;
+			return TRUE;
+		}
+		return FALSE;
+	}
+	return TRUE;
+}
+
+static void raise_Exception(ExceptionRequestEntryType *exception)
+{
+	TargetCoreType *cpu = intc_control[exception->data.coreId].cpu;
+	uint32 wdata32;
+
+	ASSERT(exception == intc_control[exception->data.coreId].current_exception);
+	ASSERT(exception->data.status == ExceptionRequestStatus_RUNNING);
+
+	if (exception->data.exno == ExceptionId_UserIntr) {
+		hook_UserIntr_Raised(exception);
+	}
+
+	if (exception->data.req->level == ExceptionLevel_FE) {
+		sys_get_cpu_base(&cpu->reg)->r[SYS_REG_FEPC] = cpu->reg.pc;
+		sys_get_cpu_base(&cpu->reg)->r[SYS_REG_FEPSW] = sys_get_cpu_base(&cpu->reg)->r[SYS_REG_PSW];
+		wdata32 = intc_control_register_op.get_exception_code(exception->data.coreId, exception->data.exno, 0U);
+		sys_get_cpu_base(&cpu->reg)->r[SYS_REG_FEIC] = wdata32;
+	}
+	else {
+		sys_get_cpu_base(&cpu->reg)->r[SYS_REG_EIPC] = cpu->reg.pc;
+		sys_get_cpu_base(&cpu->reg)->r[SYS_REG_EIPSW] = sys_get_cpu_base(&cpu->reg)->r[SYS_REG_PSW];
+		wdata32 = (sys_get_cpu_base(&cpu->reg)->r[SYS_REG_EIIC] & 0xFFFF0000);
+		wdata32 |= 	intc_control_register_op.get_exception_code(exception->data.coreId, exception->data.exno, exception->data.intno);
+		sys_get_cpu_base(&cpu->reg)->r[SYS_REG_EIIC] = wdata32;
+	}
+
+	/*
+	 * ID
+	 */
+	if (exception->data.req->info.ID == ExceptionUpdatePswOp_SET) {
+		CPU_SET_ID(&cpu->reg);
+	}
+	else if (exception->data.req->info.ID == ExceptionUpdatePswOp_CLR) {
+		CPU_CLR_ID(&cpu->reg);
+	}
+	/*
+	 * NP
+	 */
+	if (exception->data.req->info.NP == ExceptionUpdatePswOp_SET) {
+		CPU_SET_NP(&cpu->reg);
+	}
+	else if (exception->data.req->info.NP == ExceptionUpdatePswOp_CLR) {
+		CPU_CLR_NP(&cpu->reg);
+	}
+	/*
+	 * EP
+	 */
+	if (exception->data.req->info.EP == ExceptionUpdatePswOp_SET) {
+		CPU_SET_EP(&cpu->reg);
+	}
+	else if (exception->data.req->info.EP == ExceptionUpdatePswOp_CLR) {
+		CPU_CLR_EP(&cpu->reg);
+	}
+	/*
+	 * UM
+	 */
+	if (exception->data.req->info.UM == ExceptionUpdatePswOp_SET) {
+		CPU_SET_UM(&cpu->reg);
+	}
+	else if (exception->data.req->info.UM == ExceptionUpdatePswOp_CLR) {
+		CPU_CLR_UM(&cpu->reg);
+	}
+	intc_control[exception->data.coreId].cpu->reg.pc = intc_control_register_op.get_exception_handler_addr(
+			exception->data.coreId, exception->data.exno, exception->data.intno);
+	intc_control[exception->data.coreId].cpu->is_halt = FALSE;
+	return;
+}
+
+
+static ExceptionRequestEntryType* judge_pending_Exception(CoreIdType coreId)
+{
+	ExceptionRequestEntryType *req;
+	ExceptionRequestEntryType *candidate = NULL;
+	IntcPriorityLevelType level;
+	IntcPriorityLevelType current_level = IntcPriorityLevel_Num - 1;
+	uint32 tmpdgree;
+	uint32 mindegree = 0xFFFFFFFF;
+
+	candidate = intc_control[coreId].current_exception;
+	if (candidate != NULL) {
+		//ASSERT(candidate->data.status == ExceptionRequestStatus_RUNNING);
+		DBG_PRINTF(("%s(): already raised exception:exno=%u intno=%u\n", __FUNCTION__, candidate->data.exno, candidate->data.intno));
+		current_level = intc_control_register_op.get_exception_priority_level(coreId, candidate->data.exno);
+		mindegree = candidate->data.priority_degree;
+	}
+	DBG_PRINTF(("%s() current_level=%u\n", __FUNCTION__, current_level));
+	/*
+	 * すでに実行中の例外が新規のものより高ければ検索を打ち切る．
+	 * 同一優先レベルの場合は，優先度が高いものがキューに存在している可能性があるため打ち切らない．
+	 */
+	for (level = IntcPriorityLevel_0; level <= current_level; level++) {
+		//DBG_PRINTF(("level=%u current_level = %u req_num=%u\n", level, current_level, intc_control[coreId].exception_queue[level].pending.entry_num));
+		/*
+		 * すでに実行中の例外よりも新規のものの方が高ければ，検索する．
+		 */
+		ListEntry_Foreach(&intc_control[coreId].exception_queue[level].pending, req) {
+#ifdef USER_INTR_PMR_BUGFIX
+			if (req->data.exno == ExceptionId_UserIntr) {
+				if (is_cpu_mask_UserIntr(req) == TRUE) {
+					continue;
+				}
+			}
+#endif /* USER_INTR_PMR_BUGFIX */
+			tmpdgree = req->data.priority_degree;
+			DBG_PRINTF(("tmpdgree=0x%x mindegree=0x%x\n", tmpdgree, tmpdgree));
+			if (tmpdgree < mindegree) {
+				mindegree = tmpdgree;
+				candidate = req;
+			}
+		}
+		if ((candidate == intc_control[coreId].current_exception)) {
+			continue;
+		}
+		if (candidate != NULL) {
+			break;
+		}
+	}
+
+	if ((candidate == NULL) || (candidate == intc_control[coreId].current_exception)) {
+		/*
+		 * 候補がない，または，現在実行中のものが最高優先度の場合
+		 */
+		DBG_PRINTF(("%s(): can not raise exp=0x%x\n", __FUNCTION__, candidate));
+		return NULL;
+	}
+	if (candidate->data.status == ExceptionRequestStatus_WAITING) {
+		/*
+		 * 多重割り込み復帰した場合は，新規割り込みではないため，割り込みを発生させない．
+		 */
+		candidate->data.status = ExceptionRequestStatus_RUNNING;
+		intc_control[coreId].current_exception = candidate;
+		DBG_PRINTF(("%s(): can not raise because waiting  exp=0x%x\n", __FUNCTION__, candidate));
+		return NULL;
+	}
+	if (intc_control[coreId].current_exception != NULL) {
+		/*
+		 * 多重割り込みが発生したので，既存のものはWAITING状態にし，新規割り込みを発生させる
+		 */
+		intc_control[coreId].current_exception->data.status = ExceptionRequestStatus_WAITING;
+		//intc_control[coreId].current_exception = NULL;
+		DBG_PRINTF(("%s(): raise multi  exp=0x%x\n", __FUNCTION__, candidate));
+	}
+
+	if (can_raise_Exception(candidate)) {
+		DBG_PRINTF(("%s(): raise exp=0x%x\n", __FUNCTION__, candidate));
+		candidate->data.status = ExceptionRequestStatus_RUNNING;
+		intc_control[coreId].current_exception = candidate;
+#ifdef USER_INTR_PMR_BUGFIX
+		if (candidate->data.exno == ExceptionId_UserIntr) {
+			intc_control_register_op.set_user_intr_state_priority_degree_masked(candidate->data.coreId, FALSE);
+		}
+#endif /* USER_INTR_PMR_BUGFIX */
+		return candidate;
+	}
+	else {
+		DBG_PRINTF(("%s(): can not raise exp=0x%x because of psw\n", __FUNCTION__, candidate));
+		return NULL;
+	}
+}
+
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/intc/intc.h
@@ -0,0 +1,111 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _INTC_H_
+#define _INTC_H_
+
+#include "intc_config.h"
+#include "intc_target.h"
+#include "list.h"
+
+typedef enum {
+	ExceptionRequestStatus_PENDING = 0,
+	ExceptionRequestStatus_RUNNABLE,
+	ExceptionRequestStatus_RUNNING,
+	ExceptionRequestStatus_WAITING,
+	ExceptionRequestStatus_Num,
+} ExceptionRequestStatusType;
+
+typedef struct {
+	ExceptionType 				*req;
+	ExceptionRequestStatusType	status;
+	uint32						coreId; // for multi core
+	uint32						exno;
+	uint32						intno; // for EIINTn
+	uint32						priority_degree;
+} ExceptionRequestDataType;
+
+typedef ListEntryType(ExceptionRequestEntryType, ExceptionRequestDataType) ExceptionRequestEntryType;
+typedef ListHeadType(ExceptionRequestEntryType) ExceptionRequestHeaderType;
+
+typedef struct {
+	/*
+	   * 発生した例外実行待ちキュー(優先レベル毎)
+	 */
+	ExceptionRequestHeaderType 	pending;
+} ExceptionRequestQueueType;
+
+
+typedef struct {
+	ExceptionRequestHeaderType 	pending;
+} UserIntrRequestQueueType;
+
+typedef struct {
+	/*
+	 * CPU
+	 */
+	TargetCoreType				*cpu;
+	/*
+	   * 現在実行中の例外
+	 */
+	ExceptionRequestEntryType 	*current_exception;
+	/*
+	   *  例外実行待ちキュー
+	 */
+	ExceptionRequestQueueType 	exception_queue[IntcPriorityLevel_Num];
+
+	/*
+	 * user exception
+	 */
+	UserIntrRequestQueueType	user_queue;
+} ExceptionControllerType;
+
+extern ExceptionControllerType intc_control[CPU_CONFIG_CORE_NUM];;
+
+//#define DEBUG_INTC
+#ifdef DEBUG_INTC
+#define DBG_PRINTF(arg)	printf arg
+#else
+#define DBG_PRINTF(arg)
+#endif
+
+
+#endif /* _INTC_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/intc/intc_target.c
@@ -0,0 +1,136 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "intc_target.h"
+
+MpuAddressRegionType *intc_region;
+
+static Std_ReturnType intc_get_data8(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 *data);
+static Std_ReturnType intc_get_data16(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint16 *data);
+static Std_ReturnType intc_get_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 *data);
+static Std_ReturnType intc_put_data8(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 data);
+static Std_ReturnType intc_put_data16(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint16 data);
+static Std_ReturnType intc_put_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 data);
+
+MpuAddressRegionOperationType	intc_memory_operation = {
+		.get_data8 		= 	intc_get_data8,
+		.get_data16		=	intc_get_data16,
+		.get_data32		=	intc_get_data32,
+
+		.put_data8 		= 	intc_put_data8,
+		.put_data16		=	intc_put_data16,
+		.put_data32		=	intc_put_data32,
+
+		.get_pointer	= 	intc_get_pointer,
+};
+
+
+Std_ReturnType intc_get_data8(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 *data)
+{
+	uint32 off = (addr - region->start);
+	uint8 *datap = &region->data[off + (core_id * (region->size))];
+	*data = *((uint8*)(datap));
+	return STD_E_OK;
+}
+Std_ReturnType intc_get_data16(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint16 *data)
+{
+	uint32 off = (addr - region->start);
+	uint8 *datap = &region->data[off + (core_id * (region->size))];
+	*data = *((uint16*)(datap));
+
+	return STD_E_OK;
+}
+Std_ReturnType intc_get_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 *data)
+{
+	uint32 off = (addr - region->start);
+	uint8 *datap = &region->data[off + (core_id * (region->size))];
+
+	*data = *((uint32*)(datap));
+	return STD_E_OK;
+}
+Std_ReturnType intc_put_data8(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 data)
+{
+	Std_ReturnType err;
+	uint32 off = (addr - region->start);
+	uint8 *datap = &region->data[off + (core_id * (region->size))];
+
+	err = intc_hook_update_reg8(core_id, addr, &data);
+
+	if (err == STD_E_OK) {
+		*((uint8*)(datap)) = data;
+	}
+
+	return err;
+}
+Std_ReturnType intc_put_data16(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint16 data)
+{
+	Std_ReturnType err;
+	uint32 off = (addr - region->start);
+	uint8 *datap = &region->data[off + (core_id * (region->size))];
+
+	err = intc_hook_update_reg16(core_id, addr, &data);
+
+	if(err == STD_E_OK) {
+		*((uint16*)(datap)) = data;
+	}
+	return err;
+}
+Std_ReturnType intc_put_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 data)
+{
+	Std_ReturnType err;
+	uint32 off = (addr - region->start);
+	uint8 *datap = &region->data[off + (core_id * (region->size))];
+
+	err = intc_hook_update_reg32(core_id, addr, &data);
+
+	if (err == STD_E_OK) {
+		*((uint32*)(datap)) = data;
+	}
+	return err;
+}
+Std_ReturnType intc_get_pointer(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 **data)
+{
+	uint32 off = (addr - region->start);
+	uint8 *datap = &region->data[off + (core_id * (region->size))];
+
+	*data = datap;
+	return STD_E_OK;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/intc/intc_target.h
@@ -0,0 +1,143 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _INTC_TARGET_H_
+#define _INTC_TARGET_H_
+
+#include "std_types.h"
+#include "std_errno.h"
+#include "cpu.h"
+#include "intc_config.h"
+
+typedef struct {
+	uint32 level;
+	uint32 degree_custom;
+} ExceptionPriorityType;
+
+typedef struct {
+	uint32 	addr;
+	uint32 	code;
+	bool	is_rbase;
+} ExceptionHandlerType;
+
+typedef enum {
+	ExceptionLevel_FE = 0,
+	ExceptionLevel_EI,
+	ExceptionLevel_RESET,
+} ExceptionLevelType;
+
+typedef enum {
+	ExceptionForm_ABORT = 0,
+	ExceptionForm_REEXEC,
+	ExceptionForm_COMPLETE,
+} ExceptionFormType;
+
+typedef enum {
+	ExceptionRaise_SYSTEM = 0,
+	ExceptionRaise_USER,
+} ExceptionRaiseType;
+
+typedef struct {
+	bool ID;
+	bool NP;
+} ExceptionCanRaiseConditionType;
+
+typedef struct {
+	IntcPriorityLevelType (*get_exception_priority_level) (CoreIdType coreId, uint32 exno);
+	uint32 (*get_exception_priority_degree) (CoreIdType coreId, uint32 exno, uint32 intno);
+	IntcPriorityDegreeType (*get_current_user_intr_priority_degree) (CoreIdType coreId);
+	void (*set_current_user_intr_priority_degree) (CoreIdType coreId, uint32 intno, bool flag);
+
+	IntcPriorityDegreeType (*get_mask_priority_degree) (CoreIdType coreId);
+	void (*set_mask_priority_degree) (CoreIdType coreId, IntcPriorityDegreeType degree);
+
+	void (*set_user_intr_reqflag)(CoreIdType coreId, uint32 intno, bool flag);
+	bool (*isset_user_intr_reqflag)(CoreIdType coreId, uint32 intno);
+	IntcPriorityDegreeType (*get_user_intr_priority_degree)(CoreIdType coreId, uint32 intno);
+	void (*set_user_intr_priority_degree)(CoreIdType coreId, uint32 intno, IntcPriorityDegreeType degree);
+
+	bool (*is_user_intr_masked) (CoreIdType coreId, uint32 intno);
+
+	void (*set_user_intr_state_priority_degree_masked) (CoreIdType coreId, bool flag);
+
+	uint32 (*get_exception_handler_addr) (CoreIdType core, uint32 exno, uint32 intno);
+	uint32 (*get_exception_code) (CoreIdType core, uint32 exno, uint32 intno);
+
+	void (*reset_registers) (CoreIdType coreId);
+} IntcControlRegisterOperationType;
+
+extern IntcControlRegisterOperationType intc_control_register_op;
+
+extern Std_ReturnType intc_hook_update_reg8(CoreIdType core_id, uint32 regaddr, uint8* data);
+extern Std_ReturnType intc_hook_update_reg16(CoreIdType core_id, uint32 regaddr, uint16* data);
+extern Std_ReturnType intc_hook_update_reg32(CoreIdType core_id, uint32 regaddr, uint32* data);
+extern MpuAddressRegionType *intc_region;
+
+typedef enum {
+	ExceptionUpdatePswOp_CLR = 0,
+	ExceptionUpdatePswOp_SET,
+	ExceptionUpdatePswOp_SAVE,
+} ExceptionUpdatePswOpType;
+
+typedef struct {
+	ExceptionUpdatePswOpType UM;
+	ExceptionUpdatePswOpType ID;
+	ExceptionUpdatePswOpType NP;
+	ExceptionUpdatePswOpType EP;
+	ExceptionUpdatePswOpType EBV;
+} ExceptionUpdatePswInfoType;
+
+typedef struct {
+	const char* 					name;
+	ExceptionPriorityType			priority;
+	ExceptionHandlerType			handler;
+	ExceptionLevelType				level;
+	//ExceptionFormType				form;
+	//ExceptionRaiseType				raise_type;
+	ExceptionCanRaiseConditionType	cond;
+	ExceptionUpdatePswInfoType		info;
+} ExceptionType;
+
+extern ExceptionType exception_config[ExceptionId_Num];
+
+extern Std_ReturnType intc_get_pointer(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 **data);
+
+#endif /* _INTC_TARGET_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/intc/intc_user.c
@@ -0,0 +1,253 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "intc_user.h"
+
+#if 0
+#define DBG_IPRINTF(intno, expect, arg) \
+do { \
+	if (intno == expect) {	\
+		printf arg;	\
+	}	\
+} while (0)
+#else
+#define DBG_IPRINTF(intno, expect, arg)
+#endif
+
+static void common_raise_user_intr(uint32 intno, uint32 coreId);
+
+void device_init_intc_UserIntr(CoreIdType coreId)
+{
+	List_Init(&intc_control[coreId].user_queue.pending, ExceptionRequestEntryType, 512U);
+	return;
+}
+
+void intc_cpu_trigger_interrupt(CoreIdType coreId, int intno)
+{
+	uint32 triggered_coreId;
+
+	triggered_coreId = (coreId == 0) ? 1 : 0;
+
+	common_raise_user_intr(intno, triggered_coreId);
+	return;
+}
+
+int intc_raise_intr(uint32 intno)
+{
+	uint32 coreId;
+
+	for (coreId = 0; coreId < CPU_CONFIG_GET_CORE_ID_NUM(); coreId++) {
+		common_raise_user_intr(intno, coreId);
+	}
+	return 0;
+}
+
+
+static ExceptionRequestEntryType *judge_mask_and_priority_UserIntr(CoreIdType coreId);
+static void judge_cpu_mask_UserIntr(ExceptionRequestEntryType *candidate);
+
+void judge_pending_UserIntr(CoreIdType coreId)
+{
+	ExceptionRequestEntryType *candidate;
+
+	candidate = judge_mask_and_priority_UserIntr(coreId);
+	if (candidate != NULL) {
+		DBG_IPRINTF(candidate->data.intno, 35,
+				("%s() candidate=0x%x\n", __FUNCTION__, candidate));
+		judge_cpu_mask_UserIntr(candidate);
+	}
+
+	return;
+}
+
+void hook_UserIntr_Raised(const ExceptionRequestEntryType *exception)
+{
+	CoreIdType coreId = exception->data.coreId;
+	ExceptionRequestEntryType *req;
+	bool req_found = FALSE;
+	ListEntry_Foreach(&intc_control[coreId].user_queue.pending, req) {
+		if (req->data.intno == exception->data.intno) {
+			ListEntry_RemoveEntry(&intc_control[coreId].user_queue.pending, req);
+			ListEntry_Free(&intc_control[coreId].user_queue.pending, req);
+			//DBG_PRINTF(("%s() pending user req removed candidate=0x%x\n", __FUNCTION__, req);
+			DBG_IPRINTF(exception->data.intno, 35,
+					("%s() pending user req removed candidate=0x%x\n", __FUNCTION__, req));
+			req_found = TRUE;
+			break;
+		}
+	}
+	/* ispr update */
+	intc_control_register_op.set_current_user_intr_priority_degree(coreId, exception->data.intno, TRUE);
+
+	/* req cler */
+	if (req_found == TRUE) {
+		intc_control_register_op.set_user_intr_reqflag(req->data.coreId, req->data.intno, FALSE);
+	}
+	else {
+		printf("ERROR:hook_UserIntr_Raised() not found req:intno = %d\n", exception->data.intno);
+	}
+	return;
+}
+
+static void common_raise_user_intr(uint32 intno, uint32 coreId)
+{
+	ExceptionRequestEntryType *req;
+
+	if (intc_control_register_op.isset_user_intr_reqflag(coreId, intno)) {
+		return;
+	}
+
+	ListEntry_Alloc(&intc_control[coreId].user_queue.pending, ExceptionRequestEntryType, &req);
+
+	req->data.req = &exception_config[ExceptionId_UserIntr];
+	req->data.status = ExceptionRequestStatus_PENDING;
+	req->data.coreId = coreId;
+	req->data.exno = ExceptionId_UserIntr;
+	req->data.intno = intno;
+	req->data.priority_degree = intc_control_register_op.get_exception_priority_degree(coreId, ExceptionId_UserIntr, intno);
+	ListEntry_AddEntry(&intc_control[coreId].user_queue.pending, req);
+
+	intc_control_register_op.set_user_intr_reqflag(req->data.coreId, req->data.intno, TRUE);
+	return;
+}
+
+static ExceptionRequestEntryType *judge_mask_and_priority_UserIntr(CoreIdType coreId)
+{
+	ExceptionRequestEntryType *req;
+	ExceptionRequestEntryType *candidate = NULL;
+	uint32 tmp_degree;
+	uint32 mindegree = 0xFFFFFFFF;
+
+	DBG_PRINTF(("%s(): req_num=%u\n", __FUNCTION__,  intc_control[coreId].user_queue.pending.entry_num));
+	ListEntry_Foreach(&intc_control[coreId].user_queue.pending, req) {
+		//mask check
+		if (intc_control_register_op.is_user_intr_masked(coreId, req->data.intno)) {
+			continue;
+		}
+		DBG_IPRINTF(req->data.intno, 35,
+				("req degree=%u \n", req->data.priority_degree));
+
+		tmp_degree = req->data.priority_degree;
+		if (tmp_degree < mindegree) {
+			mindegree = tmp_degree;
+			candidate = req;
+		}
+	}
+	if ((candidate != NULL) && (candidate->data.status == ExceptionRequestStatus_RUNNABLE)) {
+		/*
+		 * すでに例外要求を上げているので，割り込み要求を上げる必要はない．
+		 */
+		DBG_PRINTF(("already raised candidate degree=%u default=%u\n", candidate->data.priority_degree, INTC_DEFAULT_PRIORITY(candidate->data.intno)));
+		DBG_IPRINTF(candidate->data.intno, 35,
+				("already raised candidate degree=%u \n", candidate->data.priority_degree));
+		return NULL;
+	}
+	if (candidate != NULL) {
+		/*
+		 * マスクされている場合はHALT復帰しないので，ここで設定すべき
+		 */
+		intc_control[coreId].cpu->is_halt = FALSE;
+		DBG_IPRINTF(candidate->data.intno, 35, ("raise user interrupt\n"));
+	}
+	return candidate;
+}
+
+std_bool is_cpu_mask_UserIntr(ExceptionRequestEntryType *candidate)
+{
+	/*
+	 * current priority check
+	 */
+	IntcPriorityDegreeType intr_level = intc_control_register_op.get_user_intr_priority_degree(candidate->data.coreId, candidate->data.intno);
+
+	/*
+	 * mask priority check
+	 */
+	IntcPriorityDegreeType mask_level = intc_control_register_op.get_mask_priority_degree(candidate->data.coreId);
+	if (mask_level <= intr_level) {
+		intc_control_register_op.set_user_intr_state_priority_degree_masked(candidate->data.coreId, TRUE);
+		return TRUE;
+	}
+	return FALSE;
+}
+
+
+static void judge_cpu_mask_UserIntr(ExceptionRequestEntryType *candidate)
+{
+	ASSERT(candidate->data.status == ExceptionRequestStatus_PENDING);
+	/*
+	 * current priority check
+	 */
+	IntcPriorityDegreeType curr_level = intc_control_register_op.get_current_user_intr_priority_degree(candidate->data.coreId);
+	IntcPriorityDegreeType intr_level = intc_control_register_op.get_user_intr_priority_degree(candidate->data.coreId, candidate->data.intno);
+
+	if (curr_level <= intr_level) {
+		DBG_PRINTF(("%s() NONE: curr_level = %u intr_level = %u\n", __FUNCTION__, curr_level, intr_level));
+		return;
+	}
+
+	/*
+	 * mask priority check
+	 */
+	IntcPriorityDegreeType mask_level = intc_control_register_op.get_mask_priority_degree(candidate->data.coreId);
+	if (mask_level <= intr_level) {
+		intc_control_register_op.set_user_intr_state_priority_degree_masked(candidate->data.coreId, TRUE);
+		DBG_PRINTF(("%s() NONE: mask_level = %u intr_level = %u\n", __FUNCTION__, mask_level, intr_level));
+		return;
+	}
+	intc_control_register_op.set_user_intr_state_priority_degree_masked(candidate->data.coreId, FALSE);
+
+	/*
+	 * user queue
+	 */
+	IntcPriorityLevelType level = candidate->data.req->priority.level;
+	candidate->data.status = ExceptionRequestStatus_RUNNABLE;
+
+	/*
+	 * system queue
+	 */
+	ExceptionRequestEntryType *exception;
+	ListEntry_Alloc(&intc_control[candidate->data.coreId].exception_queue[level].pending, ExceptionRequestEntryType, &exception);
+	exception->data = candidate->data;
+	ListEntry_AddEntry(&intc_control[candidate->data.coreId].exception_queue[level].pending, exception);
+	DBG_PRINTF(("%s() RAISED: level=%u mask_level = %u intr_level = %u req_num=%u\n", __FUNCTION__, level, mask_level, intr_level, intc_control[candidate->data.coreId].exception_queue[level].pending.entry_num));
+	return;
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/intc/intc_user.h
@@ -0,0 +1,52 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _INTC_USER_H_
+#define _INTC_USER_H_
+
+#include "intc.h"
+
+extern void device_init_intc_UserIntr(CoreIdType coreId);
+extern void judge_pending_UserIntr(CoreIdType coreId);
+extern void hook_UserIntr_Raised(const ExceptionRequestEntryType *exception);
+extern std_bool is_cpu_mask_UserIntr(ExceptionRequestEntryType *candidate);
+
+#endif /* _INTC_USER_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/intc/rh850f1k/intc_config.c
@@ -0,0 +1,913 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "intc.h"
+#include "cpu_common/cpu_ops.h"
+#include "mpu_ops.h"
+#include "device.h"
+
+static IntcPriorityLevelType intc_get_exception_priority_level(CoreIdType coreId, uint32 exno);
+static uint32 intc_get_exception_priority_degree(CoreIdType coreId, uint32 exno, uint32 intno);
+
+static IntcPriorityDegreeType intc_get_current_user_intr_priority_degree(CoreIdType coreId);
+static void intc_set_current_user_intr_priority_degree(CoreIdType coreId, uint32 intno, bool flag);
+static IntcPriorityDegreeType intc_get_mask_priority_degree(CoreIdType coreId);
+static void intc_set_mask_priority(CoreIdType coreId, IntcPriorityDegreeType degree);
+static void intc_reset_registers(CoreIdType coreId);
+static void intc_set_user_intr_reqflag(CoreIdType coreId, uint32 intno, bool flag);
+static bool intc_isset_user_intr_reqflag(CoreIdType coreId, uint32 intno);
+
+static  IntcPriorityDegreeType intc_get_user_intr_priority_degree(CoreIdType coreId, uint32 intno);
+static  void intc_set_user_intr_priority_degree(CoreIdType coreId, uint32 intno, IntcPriorityDegreeType degree);
+
+static  uint32 intc_get_exception_handler_addr(CoreIdType coreId, uint32 exno, uint32 intno);
+static  uint32 intc_get_exception_code(CoreIdType coreId, uint32 exno, uint32 intno);
+
+static bool intc_is_user_intr_masked(CoreIdType coreId, uint32 intno);
+static void intc_set_user_intr_state_priority_degree_masked (CoreIdType coreId, bool flag);
+
+IntcControlRegisterOperationType intc_control_register_op = {
+		.get_exception_priority_level 				= intc_get_exception_priority_level,
+		.get_exception_priority_degree 				= intc_get_exception_priority_degree,
+		.get_current_user_intr_priority_degree		= intc_get_current_user_intr_priority_degree,
+		.set_current_user_intr_priority_degree		= intc_set_current_user_intr_priority_degree,
+		.get_mask_priority_degree					= intc_get_mask_priority_degree,
+		.set_mask_priority_degree					= intc_set_mask_priority,
+		.set_user_intr_reqflag						= intc_set_user_intr_reqflag,
+		.isset_user_intr_reqflag					= intc_isset_user_intr_reqflag,
+		.get_user_intr_priority_degree				= intc_get_user_intr_priority_degree,
+		.set_user_intr_priority_degree				= intc_set_user_intr_priority_degree,
+		.is_user_intr_masked						= intc_is_user_intr_masked,
+		.set_user_intr_state_priority_degree_masked = intc_set_user_intr_state_priority_degree_masked,
+		.get_exception_handler_addr					= intc_get_exception_handler_addr,
+		.get_exception_code							= intc_get_exception_code,
+		.reset_registers							= intc_reset_registers,
+};
+
+ExceptionType exception_config[ExceptionId_Num] = {
+		{
+			.name = "RESET",
+			.priority = { IntcPriorityLevel_0, IntcPriorityDegree_0 },
+			.handler = { .addr = 0x00, .code = 0x00, .is_rbase = FALSE },
+			.level = ExceptionLevel_RESET,
+			.cond = { .ID = TRUE, .NP = TRUE },
+			.info = { .UM = ExceptionUpdatePswOp_CLR, .ID = ExceptionUpdatePswOp_SET, .NP = ExceptionUpdatePswOp_CLR, .EP = ExceptionUpdatePswOp_CLR, .EBV = ExceptionUpdatePswOp_CLR },
+		},
+		{
+			.name = "FENMI",
+			.priority = { IntcPriorityLevel_2, IntcPriorityDegree_0 },
+			.handler = { .addr = 0xE0, .code = 0xE0, .is_rbase = TRUE },
+			.level = ExceptionLevel_FE,
+			.cond = { .ID = TRUE, .NP = TRUE },
+			.info = { .UM = ExceptionUpdatePswOp_CLR, .ID = ExceptionUpdatePswOp_SET, .NP = ExceptionUpdatePswOp_SET, .EP = ExceptionUpdatePswOp_CLR, .EBV = ExceptionUpdatePswOp_SAVE },
+		},
+		{
+			.name = "SYSERR1",
+			.priority = { IntcPriorityLevel_2, IntcPriorityDegree_1 },
+			.handler = { .addr = 0x10, .code = 0x10, .is_rbase = TRUE },
+			.level = ExceptionLevel_FE,
+			.cond = { .ID = TRUE, .NP = TRUE },
+			.info = { .UM = ExceptionUpdatePswOp_CLR, .ID = ExceptionUpdatePswOp_SET, .NP = ExceptionUpdatePswOp_SET, .EP = ExceptionUpdatePswOp_SET, .EBV = ExceptionUpdatePswOp_SAVE },
+		},
+		{
+			.name = "FEINT",
+			.priority = { IntcPriorityLevel_2, IntcPriorityDegree_2 },
+			.handler = { .addr = 0xF0, .code = 0xF0, .is_rbase = TRUE },
+			.level = ExceptionLevel_FE,
+			.cond = { .ID = TRUE, .NP = FALSE },
+			.info = { .UM = ExceptionUpdatePswOp_CLR, .ID = ExceptionUpdatePswOp_SET, .NP = ExceptionUpdatePswOp_SET, .EP = ExceptionUpdatePswOp_CLR, .EBV = ExceptionUpdatePswOp_SAVE },
+		},
+		{
+			.name = "FPI",
+			.priority = { IntcPriorityLevel_3, IntcPriorityDegree_0 },
+			.handler = { .addr = 0x70, .code = 0x72, .is_rbase = TRUE },
+			.level = ExceptionLevel_EI,
+			.cond = { .ID = FALSE, .NP = FALSE },
+			.info = { .UM = ExceptionUpdatePswOp_CLR, .ID = ExceptionUpdatePswOp_SET, .NP = ExceptionUpdatePswOp_SAVE, .EP = ExceptionUpdatePswOp_SET, .EBV = ExceptionUpdatePswOp_SAVE },
+		},
+		{
+			.name = "UserIntr",
+			.priority = { IntcPriorityLevel_3, IntcPriorityDegree_0 },
+			.handler = { .addr = 0x100, .code = 0x1000, .is_rbase = TRUE },
+			.level = ExceptionLevel_EI,
+			.cond = { .ID = FALSE, .NP = FALSE },
+			.info = { .UM = ExceptionUpdatePswOp_CLR, .ID = ExceptionUpdatePswOp_SET, .NP = ExceptionUpdatePswOp_SAVE, .EP = ExceptionUpdatePswOp_CLR, .EBV = ExceptionUpdatePswOp_SAVE },
+		},
+		{
+			.name = "MIP",
+			.priority = { IntcPriorityLevel_9, IntcPriorityDegree_0 },
+			.handler = { .addr = 0x90, .code = 0x90, .is_rbase = TRUE },
+			.level = ExceptionLevel_FE,
+			.cond = { .ID = TRUE, .NP = TRUE },
+			.info = { .UM = ExceptionUpdatePswOp_CLR, .ID = ExceptionUpdatePswOp_SET, .NP = ExceptionUpdatePswOp_SET, .EP = ExceptionUpdatePswOp_SET, .EBV = ExceptionUpdatePswOp_SAVE },
+		},
+		{
+			.name = "SYSERR2",
+			.priority = { IntcPriorityLevel_9, IntcPriorityDegree_2 },
+			.handler = { .addr = 0x10, .code = 0x10, .is_rbase = TRUE },
+			.level = ExceptionLevel_FE,
+			.cond = { .ID = TRUE, .NP = TRUE },
+			.info = { .UM = ExceptionUpdatePswOp_CLR, .ID = ExceptionUpdatePswOp_SET, .NP = ExceptionUpdatePswOp_SET, .EP = ExceptionUpdatePswOp_SET, .EBV = ExceptionUpdatePswOp_SAVE },
+		},
+		{
+			.name = "RIE",
+			.priority = { IntcPriorityLevel_9, IntcPriorityDegree_3 },
+			.handler = { .addr = 0x60, .code = 0x60, .is_rbase = TRUE },
+			.level = ExceptionLevel_FE,
+			.cond = { .ID = TRUE, .NP = TRUE },
+			.info = { .UM = ExceptionUpdatePswOp_CLR, .ID = ExceptionUpdatePswOp_SET, .NP = ExceptionUpdatePswOp_SET, .EP = ExceptionUpdatePswOp_SET, .EBV = ExceptionUpdatePswOp_SAVE },
+		},
+		{
+			.name = "UCPOP",
+			.priority = { IntcPriorityLevel_9, IntcPriorityDegree_4 },
+			.handler = { .addr = 0x80, .code = 0x80, .is_rbase = TRUE },
+			.level = ExceptionLevel_FE,
+			.cond = { .ID = TRUE, .NP = TRUE },
+			.info = { .UM = ExceptionUpdatePswOp_CLR, .ID = ExceptionUpdatePswOp_SET, .NP = ExceptionUpdatePswOp_SET, .EP = ExceptionUpdatePswOp_SET, .EBV = ExceptionUpdatePswOp_SAVE },
+		},
+		{
+			.name = "PIE",
+			.priority = { IntcPriorityLevel_9, IntcPriorityDegree_5 },
+			.handler = { .addr = 0xA0, .code = 0xA0, .is_rbase = TRUE },
+			.level = ExceptionLevel_FE,
+			.cond = { .ID = TRUE, .NP = TRUE },
+			.info = { .UM = ExceptionUpdatePswOp_CLR, .ID = ExceptionUpdatePswOp_SET, .NP = ExceptionUpdatePswOp_SET, .EP = ExceptionUpdatePswOp_SET, .EBV = ExceptionUpdatePswOp_SAVE },
+		},
+		{
+			.name = "MAE",
+			.priority = { IntcPriorityLevel_10, IntcPriorityDegree_0 },
+			.handler = { .addr = 0xC0, .code = 0xC0, .is_rbase = TRUE },
+			.level = ExceptionLevel_FE,
+			.cond = { .ID = TRUE, .NP = TRUE },
+			.info = { .UM = ExceptionUpdatePswOp_CLR, .ID = ExceptionUpdatePswOp_SET, .NP = ExceptionUpdatePswOp_SET, .EP = ExceptionUpdatePswOp_SET, .EBV = ExceptionUpdatePswOp_SAVE },
+		},
+		{
+			.name = "MDP",
+			.priority = { IntcPriorityLevel_10, IntcPriorityDegree_0 },
+			.handler = { .addr = 0x90, .code = 0x91, .is_rbase = TRUE },
+			.level = ExceptionLevel_FE,
+			.cond = { .ID = TRUE, .NP = TRUE },
+			.info = { .UM = ExceptionUpdatePswOp_CLR, .ID = ExceptionUpdatePswOp_SET, .NP = ExceptionUpdatePswOp_SET, .EP = ExceptionUpdatePswOp_SET, .EBV = ExceptionUpdatePswOp_SAVE },
+		},
+		{
+			.name = "FPP",
+			.priority = { IntcPriorityLevel_10, IntcPriorityDegree_0 },
+			.handler = { .addr = 0x70, .code = 0x71, .is_rbase = TRUE },
+			.level = ExceptionLevel_EI,
+			.cond = { .ID = TRUE, .NP = TRUE },
+			.info = { .UM = ExceptionUpdatePswOp_CLR, .ID = ExceptionUpdatePswOp_SET, .NP = ExceptionUpdatePswOp_SAVE, .EP = ExceptionUpdatePswOp_SET, .EBV = ExceptionUpdatePswOp_SAVE },
+		},
+		{
+			.name = "SYSCALL",
+			.priority = { IntcPriorityLevel_11, IntcPriorityDegree_0 },
+			.handler = { .addr = 0x40, .code = 0x8000, .is_rbase = TRUE },
+			.level = ExceptionLevel_EI,
+			.cond = { .ID = TRUE, .NP = TRUE },
+			.info = { .UM = ExceptionUpdatePswOp_CLR, .ID = ExceptionUpdatePswOp_SET, .NP = ExceptionUpdatePswOp_SAVE, .EP = ExceptionUpdatePswOp_SET, .EBV = ExceptionUpdatePswOp_SAVE },
+		},
+		{
+			.name = "FETRAP",
+			.priority = { IntcPriorityLevel_11, IntcPriorityDegree_0 },
+			.handler = { .addr = 0x30, .code = 0x31, .is_rbase = TRUE },
+			.level = ExceptionLevel_FE,
+			.cond = { .ID = TRUE, .NP = TRUE },
+			.info = { .UM = ExceptionUpdatePswOp_CLR, .ID = ExceptionUpdatePswOp_SET, .NP = ExceptionUpdatePswOp_SET, .EP = ExceptionUpdatePswOp_SET, .EBV = ExceptionUpdatePswOp_SAVE },
+		},
+		{
+			.name = "TRAP0",
+			.priority = { IntcPriorityLevel_11, IntcPriorityDegree_0 },
+			.handler = { .addr = 0x40, .code = 0x40, .is_rbase = TRUE },
+			.level = ExceptionLevel_EI,
+			.cond = { .ID = TRUE, .NP = TRUE },
+			.info = { .UM = ExceptionUpdatePswOp_CLR, .ID = ExceptionUpdatePswOp_SET, .NP = ExceptionUpdatePswOp_SAVE, .EP = ExceptionUpdatePswOp_SET, .EBV = ExceptionUpdatePswOp_SAVE },
+		},
+		{
+			.name = "TRAP1",
+			.priority = { IntcPriorityLevel_11, IntcPriorityDegree_0 },
+			.handler = { .addr = 0x50, .code = 0x50, .is_rbase = TRUE },
+			.level = ExceptionLevel_EI,
+			.cond = { .ID = TRUE, .NP = TRUE },
+			.info = { .UM = ExceptionUpdatePswOp_CLR, .ID = ExceptionUpdatePswOp_SET, .NP = ExceptionUpdatePswOp_SAVE, .EP = ExceptionUpdatePswOp_SET, .EBV = ExceptionUpdatePswOp_SAVE },
+		},
+};
+
+typedef enum {
+	HandlerAddressRefMethod_RBASE_RINT0 = 0,
+	HandlerAddressRefMethod_RBASE_RINT1,
+	HandlerAddressRefMethod_EBASE_RINT0,
+	HandlerAddressRefMethod_EBASE_RINT1,
+	HandlerAddressRefMethod_TABLE,
+} HandlerAddressRefMethodType;
+
+static bool intc_is_devsetting_tableref(CoreIdType coreId, uint32 exno, uint32 intno)
+{
+
+	Std_ReturnType err;
+	uint32 base_addr = IC_ADDRESS(intno);
+	uint16 data;
+
+	err = device_get_data16(base_addr, &data);
+	ASSERT(err == 0);
+	return IC_ISSET_TABLEREF(data);
+}
+
+static IntcPriorityDegreeType intc_get_user_intr_priority_degree(CoreIdType coreId, uint32 intno)
+{
+
+	Std_ReturnType err;
+	uint32 base_addr = IC_ADDRESS(intno);
+	uint16 data;
+
+	err = device_get_data16(base_addr, &data);
+	ASSERT(err == 0);
+
+	return (IntcPriorityDegreeType)IC_GET_PRIODEGREE(data);
+}
+static IntcPriorityDegreeType intc_get_user_intr_priority_degree_default(CoreIdType coreId, uint32 intno)
+{
+	return intno;
+}
+static bool intc_is_user_intr_masked(CoreIdType coreId, uint32 intno)
+{
+	Std_ReturnType err;
+	uint32 base_addr = IC_ADDRESS(intno);
+	uint16 data;
+
+	err = device_get_data16(base_addr, &data);
+	ASSERT(err == 0);
+
+	//printf("%s():intno=%u base_addr=0x%x data=0x%x isset=%u\n", __FUNCTION__, intno, base_addr, data, IC_ISSET_INTMASK(data));
+	return IC_ISSET_INTMASK(data);
+}
+
+static void intc_set_user_intr_reqflag(CoreIdType coreId, uint32 intno, bool flag)
+{
+	Std_ReturnType err;
+	uint32 base_addr = IC_ADDRESS(intno);
+	uint16 *datap;
+
+	err = mpu_get_pointer(coreId, base_addr, (uint8**)&datap);
+	ASSERT(err == 0);
+
+	if (flag) {
+		IC_SET_INTREQ(datap);
+	}
+	else {
+		IC_CLR_INTREQ(datap);
+	}
+
+	return;
+}
+static bool intc_isset_user_intr_reqflag(CoreIdType coreId, uint32 intno)
+{
+
+	Std_ReturnType err;
+	uint32 base_addr = IC_ADDRESS(intno);
+	uint16 data;
+
+	err = device_get_data16(base_addr, &data);
+	ASSERT(err == 0);
+
+	if (IC_ISSET_INTREQ(data)) {
+		return TRUE;
+	}
+	else {
+		return FALSE;
+	}
+}
+
+
+static void intc_reset_registers(CoreIdType coreId)
+{
+	uint32 ino, imr_no;
+	Std_ReturnType err;
+
+	for (ino = 0; ino < TNUM_INT; ino++) {
+		uint32 regaddr = IC_ADDRESS(ino);
+		uint32 *pregaddr;
+		err = mpu_get_pointer(coreId, regaddr, (uint8**)&pregaddr);
+		ASSERT(err == 0);
+		uint16* xxIcn = (uint16*)pregaddr;
+
+		*xxIcn = 0x008F;
+	}
+
+	for (imr_no = 0; imr_no < INTC_IMR_NUM; imr_no++) {
+		uint32 regaddr = IMR_ADDRESS(imr_no * INTC2_INTNO_OFFSET);
+		uint32 *pregaddr;
+		err = mpu_get_pointer(coreId, regaddr, (uint8**)&pregaddr);
+		ASSERT(err == 0);
+		uint32* imrp = (uint32*)pregaddr;
+
+		*imrp = 0xFFFFFFFF;
+	}
+	return;
+}
+
+static uint8 intc2_conv_imraddr2imrno(uint32 imr_addr)
+{
+	return ((imr_addr -(INTC2_IMR_ADDR_START)) / IMR_REG_LEN_BYTE);
+}
+
+static Std_ReturnType intc_hook_update_imr(CoreIdType coreId, uint32 regaddr, uint8* data, uint8 len)
+{
+	uint8 imr_no;
+	uint8 byte;
+	uint8 bit;
+	uint8 index;
+	uint8* ic_datap;
+	uint32 intno;
+	Std_ReturnType err;
+
+	TargetCoreType *cpu = intc_control[coreId].cpu;
+
+	/* UM check */
+	if (CPU_ISSET_UM(&(cpu->reg))) {
+		cpu->current_code_exception.is_code_exception = TRUE;
+		cpu->current_code_exception.exception_type = ExceptionId_PIE;
+		return STD_E_PERM;
+	}
+
+	/* prepare */
+	if ((INTC1_IMR_ADDR_START <= regaddr ) && (INTC1_IMR_ADDR_END >= regaddr)) {
+		imr_no = 0U;
+		index = INTC1_IMR_OFFSET_BIT(regaddr);
+	}
+	else {
+		imr_no = intc2_conv_imraddr2imrno(regaddr);
+		index = INTC2_IMR_OFFSET_BIT(regaddr, imr_no);
+	}
+
+	for (byte = 0U; byte < len; byte++) {
+		for (bit = 0U; bit < INTC_ACCESS_REGLEN_8BIT; bit++) {
+			intno = (imr_no * IMR_REG_LEN_BIT) + ((byte * INTC_ACCESS_REGLEN_8BIT) + bit) + index;
+			err = mpu_get_pointer(coreId, (IC_ADDRESS(intno)), (uint8**)&ic_datap);
+			if (err != STD_E_OK) {
+				printf("%s():addr=0x%x\n", __FUNCTION__, regaddr);
+				return err;
+			}
+			if ((data[byte] & (1U << bit)) != 0U) {
+				IC_SET_INTMASK((uint16*)ic_datap);
+			}
+			else {
+				IC_CLR_INTMASK((uint16*)ic_datap);
+			}
+		}
+	}
+	return STD_E_OK;
+}
+
+static Std_ReturnType intc_hook_update_ic_lowerbit(CoreIdType coreId, uint32 regaddr, uint16 data)
+{
+	uint32 intno;
+	uint8* imr_datap;
+	Std_ReturnType err;
+	uint32 min = INTC1_IC_ADDR_START;
+	uint32 max = IC_ADDRESS(INTC1_MAX_INTNO);
+
+	/* IMR register update */
+	/* get intno */
+	if ((min <= regaddr) && (max >= regaddr)) {
+		/* INTC_IC1 */
+		intno = INTC1_ICADDR2INTNO(regaddr);
+	}
+	else {
+		/* INTC_IC2 */
+		intno = INTC2_ICADDR2INTNO(regaddr);
+	}
+
+	err = mpu_get_pointer(coreId, (IMR_ADDRESS(intno)), (uint8**)&imr_datap);
+	if (err != STD_E_OK) {
+		printf("%s():addr=0x%x intno=%u IMR_ADDR=0x%x\n", __FUNCTION__, regaddr, intno, IMR_ADDRESS(intno));
+		return err;
+	}
+	if (IC_ISSET_INTMASK(data)) {
+		*imr_datap |= (1U << (intno % IMR_REG_LEN_BIT));
+	}
+	else {
+		*imr_datap &= ~(1U << (intno % IMR_REG_LEN_BIT));
+	}
+
+	return STD_E_OK;
+}
+
+static void intc_hook_update_ic_upperbit(CoreIdType coreId, uint32 regaddr, uint16 data)
+{
+	uint32 ino_regaddr;
+	uint32 intno;
+	ExceptionRequestEntryType *req;
+	uint32 min = INTC1_IC_ADDR_START;
+	uint32 max = IC_ADDRESS(INTC1_MAX_INTNO);
+
+	/* req set */
+	if (IC_ISSET_INTREQ(data)) {
+		/* get intno */
+		if ((regaddr >= min) && (regaddr <= max)) {
+			/* INTC_IC1 */
+			intno = INTC1_ICADDR2INTNO(regaddr);
+		}
+		else {
+			/* INTC_IC2 */
+			intno = INTC2_ICADDR2INTNO(regaddr);
+		}
+		intc_raise_intr(intno);
+	}
+	else {
+		/* req clr */
+#ifndef FIX_INTR_CPU_RCV_CLR
+		{
+			ListEntry_Foreach(&intc_control[coreId].user_queue.pending, req) {
+				ino_regaddr= IC_ADDRESS(req->data.intno);
+				if ((ino_regaddr == regaddr)) {
+					ListEntry_RemoveEntry(&intc_control[coreId].user_queue.pending, req);
+					ListEntry_Free(&intc_control[coreId].user_queue.pending, req);
+					return;
+				}
+			}
+		}
+		{
+			ListEntry_Foreach(&intc_control[coreId].exception_queue[ExceptionId_UserIntr].pending, req) {
+				ino_regaddr= IC_ADDRESS(req->data.intno);
+				if ((ino_regaddr == regaddr) && req->data.status == ExceptionRequestStatus_RUNNABLE) {
+					ListEntry_RemoveEntry(&intc_control[coreId].exception_queue[ExceptionId_UserIntr].pending, req);
+					ListEntry_Free(&intc_control[coreId].exception_queue[ExceptionId_UserIntr].pending, req);
+					return;
+				}
+			}
+		}
+#else
+		//printf("intc_hook_update_ic_upperbit:addr=0x%x\n", regaddr);
+		{
+			ListEntry_Foreach(&intc_control[coreId].user_queue.pending, req) {
+				//printf("intc_hook_update_ic_upperbit:user:found intno=%d\n", req->data.intno);
+				ino_regaddr= IC_ADDRESS(req->data.intno);
+				if ((ino_regaddr == regaddr)) {
+					ListEntry_RemoveEntry(&intc_control[coreId].user_queue.pending, req);
+					ListEntry_Free(&intc_control[coreId].user_queue.pending, req);
+					//printf("intc_hook_update_ic_upperbit:user:deleted intno=%d\n", req->data.intno);
+					break;
+				}
+			}
+		}
+		IntcPriorityLevelType level;
+		for (level = IntcPriorityLevel_0; level < IntcPriorityLevel_Num; level++)
+		{
+			ListEntry_Foreach(&intc_control[coreId].exception_queue[level].pending, req) {
+				ino_regaddr= IC_ADDRESS(req->data.intno);
+				//printf("intc_hook_update_ic_upperbit:exception:found intno=%d status=%d\n", req->data.intno, req->data.status);
+				if ((ino_regaddr == regaddr) && req->data.status == ExceptionRequestStatus_RUNNABLE) {
+					ListEntry_RemoveEntry(&intc_control[coreId].exception_queue[level].pending, req);
+					ListEntry_Free(&intc_control[coreId].exception_queue[level].pending, req);
+					//printf("intc_hook_update_ic_upperbit:exception:deleted intno=%d\n", req->data.intno);
+					return;
+				}
+			}
+		}
+#endif /* FIX_INTR_CPU_RCV_CLR */
+	}
+}
+
+static Std_ReturnType intc_hook_update_ic_reg8(CoreIdType coreId, uint32 regaddr, uint8 data)
+{
+	uint16 tmp_data;
+	uint32 tmp_regaddr;
+	TargetCoreType *cpu = intc_control[coreId].cpu;
+
+	/* UM check */
+	if (CPU_ISSET_UM(&(cpu->reg))) {
+		cpu->current_code_exception.is_code_exception = TRUE;
+		cpu->current_code_exception.exception_type = ExceptionId_PIE;
+		return STD_E_PERM;
+	}
+
+	if (IS_ICADDR_UPPER(regaddr)) {
+		tmp_data = (((uint16)data) << INTC_ACCESS_REGLEN_8BIT);
+		tmp_regaddr = IC_ADDR_UPPER2LOWER(regaddr);
+		intc_hook_update_ic_upperbit(coreId, tmp_regaddr, tmp_data);
+		return STD_E_OK;
+	}
+	else {
+		return intc_hook_update_ic_lowerbit(coreId, regaddr, (uint16)data);
+	}
+
+}
+
+static Std_ReturnType intc_hook_update_ic_reg16(CoreIdType coreId, uint32 regaddr, uint16* data)
+{
+	TargetCoreType *cpu = intc_control[coreId].cpu;
+
+	/* UM check */
+	if (CPU_ISSET_UM(&(cpu->reg))) {
+		cpu->current_code_exception.is_code_exception = TRUE;
+		cpu->current_code_exception.exception_type = ExceptionId_PIE;
+		return STD_E_PERM;
+	}
+
+	intc_hook_update_ic_lowerbit(coreId, regaddr, *data);
+	intc_hook_update_ic_upperbit(coreId, regaddr, *data);
+
+	return STD_E_OK;
+}
+
+Std_ReturnType intc_hook_update_reg8(CoreIdType core_id, uint32 regaddr, uint8* data)
+{
+	Std_ReturnType err = STD_E_OK;
+
+	/* hook update registers */
+	if (((INTC1_IC_ADDR_START <= regaddr) && (INTC1_IC_ADDR_END >= regaddr)) ||
+		((INTC2_IC_ADDR_START <= regaddr) && (INTC2_IC_ADDR_END >= regaddr))) {
+		/* INTC_IC */
+		err = intc_hook_update_ic_reg8(core_id, regaddr, *data);
+	}
+	else if (((INTC1_IMR_ADDR_START <= regaddr) && (INTC1_IMR_ADDR_END >= regaddr)) ||
+			((INTC2_IMR_ADDR_START <= regaddr) && (INTC2_IMR_ADDR_END >= regaddr))) {
+		/* INTC_IMR */
+		err = intc_hook_update_imr(core_id, regaddr, data, INTC_ACCESS_REGLEN_1BYTE);
+	}
+	else {
+		/* nop */
+	}
+
+	return err;
+}
+
+Std_ReturnType intc_hook_update_reg16(CoreIdType coreId, uint32 regaddr, uint16* data)
+{
+	Std_ReturnType err = STD_E_OK;
+
+	/* hook update registers */
+	if (((INTC1_IC_ADDR_START <= regaddr) && (INTC1_IC_ADDR_END >= regaddr)) ||
+		((INTC2_IC_ADDR_START <= regaddr) && (INTC2_IC_ADDR_END >= regaddr))) {
+		/* INTC_IC */
+		if ((regaddr % INTC_ACCESS_REGLEN_2BYTE) != 0U) {
+			return STD_E_INVALID;
+		}
+		err = intc_hook_update_ic_reg16(coreId, regaddr, data);
+	}
+	else if (((INTC1_IMR_ADDR_START <= regaddr) && (INTC1_IMR_ADDR_END >= regaddr)) ||
+				((INTC2_IMR_ADDR_START <= regaddr) && (INTC2_IMR_ADDR_END >= regaddr))) {
+		/* INTC_IMR */
+		if ((regaddr % INTC_ACCESS_REGLEN_2BYTE) != 0U) {
+			return STD_E_INVALID;
+		}
+		err = intc_hook_update_imr(coreId, regaddr, (uint8*)data, INTC_ACCESS_REGLEN_2BYTE);
+	}
+	else {
+			/* nop */
+	}
+
+	return err;
+}
+
+Std_ReturnType intc_hook_update_reg32(CoreIdType coreId, uint32 regaddr, uint32* data)
+{
+	Std_ReturnType err = STD_E_OK;
+
+	/* hook update registers */
+	if (((INTC1_IMR_ADDR_START <= regaddr) && (INTC1_IMR_ADDR_END >= regaddr)) ||
+			((INTC2_IMR_ADDR_START <= regaddr) && (INTC2_IMR_ADDR_END >= regaddr))) {
+		/* INTC_IMR */
+		if ((regaddr % INTC_ACCESS_REGLEN_4BYTE) != 0U) {
+			return STD_E_INVALID;
+		}
+		err = intc_hook_update_imr(coreId, regaddr, (uint8*)data, INTC_ACCESS_REGLEN_4BYTE);
+	}
+	else {
+		/* nop */
+	}
+
+	return err;
+}
+
+static HandlerAddressRefMethodType intc_get_addr_refmethod(CoreIdType coreId, uint32 exno, uint32 intno)
+{
+	TargetCoreType *cpu = intc_control[coreId].cpu;
+	bool is_ebase = CPU_ISSET_EBV(&cpu->reg);
+	bool is_rint;
+
+	if (is_ebase) {
+		is_rint = CPU_ISSET_EBASE_RINT(cpu);
+	}
+	else {
+		is_rint = CPU_ISSET_RBASE_RINT(cpu);
+	}
+
+	if (is_rint) {
+		if (is_ebase) {
+			return HandlerAddressRefMethod_EBASE_RINT1;
+		}
+		else {
+			return HandlerAddressRefMethod_RBASE_RINT1;
+		}
+	}
+
+	if (!intc_is_devsetting_tableref(coreId, exno, intno)) {
+		if (is_ebase) {
+			return HandlerAddressRefMethod_EBASE_RINT0;
+		}
+		else {
+			return HandlerAddressRefMethod_RBASE_RINT0;
+		}
+	}
+	else {
+		return HandlerAddressRefMethod_TABLE;
+	}
+}
+
+static uint32 intc_get_handler_addr_rbase(CoreIdType coreId, uint32 exno, uint32 intno, bool is_rint)
+{
+	TargetCoreType *cpu = intc_control[coreId].cpu;
+	uint32 base_addr = CPU_RBASE_ADDR(cpu)	+ exception_config[exno].handler.addr;
+	//printf("%s():exno=%u intno=%u base_addr=0x%x\n", __FUNCTION__,  exno, intno, base_addr);
+	if (exno == ExceptionId_UserIntr) {
+		if (is_rint) {
+			return base_addr;
+		}
+		else {
+			return base_addr + (intc_get_user_intr_priority_degree(coreId, intno) * 16U);
+		}
+	}
+	else {
+		return base_addr;
+	}
+}
+static uint32 intc_get_handler_addr_ebase(CoreIdType coreId, uint32 exno, uint32 intno, bool is_rint)
+{
+	TargetCoreType *cpu = intc_control[coreId].cpu;
+	uint32 base_addr = CPU_EBASE_ADDR(cpu)	+ exception_config[exno].handler.addr;
+	//printf("%s():exno=%u intno=%u base_addr=0x%x\n", __FUNCTION__,  exno, intno, base_addr);
+	if (exno == ExceptionId_UserIntr) {
+		if (is_rint) {
+			return base_addr;
+		}
+		else {
+			return base_addr + (intc_get_user_intr_priority_degree(coreId, intno) * 16U);
+		}
+	}
+	else {
+		if (exception_config[exno].handler.is_rbase == TRUE) {
+			return CPU_RBASE_ADDR(cpu)	+ exception_config[exno].handler.addr;
+		}
+		else {
+			return base_addr;
+		}
+	}
+}
+static uint32 intc_get_handler_addr_intbp(CoreIdType coreId, uint32 exno, uint32 intno)
+{
+	Std_ReturnType err;
+	TargetCoreType *cpu = intc_control[coreId].cpu;
+	uint32 base_addr = CPU_INTBP_ADDR(cpu) + (intno * 4U);
+	uint32 data;
+	//printf("%s():exno=%u intno=%u base_addr=0x%x\n", __FUNCTION__,  exno, intno, base_addr);
+
+	ASSERT(exno == ExceptionId_UserIntr);
+
+	err = mpu_get_data32(coreId, base_addr, &data);
+
+	if (err != STD_E_OK) {
+		cpu->fatal_error = TRUE;
+		data = cpu->reg.pc;
+		printf("Exec Error addr = 0x%x has not permission read handler table\n", base_addr);
+	}
+
+	return data;
+}
+
+static  uint32 intc_get_exception_handler_addr(CoreIdType coreId, uint32 exno, uint32 intno)
+{
+	uint32 addr = 0;
+	HandlerAddressRefMethodType method = intc_get_addr_refmethod(coreId, exno, intno);
+
+	//printf("%s():exno=%u intno=%u method=%d\n", __FUNCTION__, exno, intno, method);
+	switch (method) {
+	case HandlerAddressRefMethod_RBASE_RINT0:
+		addr = intc_get_handler_addr_rbase(coreId, exno, intno, FALSE);
+		break;
+	case HandlerAddressRefMethod_RBASE_RINT1:
+		addr = intc_get_handler_addr_rbase(coreId, exno, intno, TRUE);
+		break;
+	case HandlerAddressRefMethod_EBASE_RINT0:
+		addr = intc_get_handler_addr_ebase(coreId, exno, intno, FALSE);
+		break;
+	case HandlerAddressRefMethod_EBASE_RINT1:
+		addr = intc_get_handler_addr_ebase(coreId, exno, intno, TRUE);
+		break;
+	case HandlerAddressRefMethod_TABLE:
+		addr = intc_get_handler_addr_intbp(coreId, exno, intno);
+		break;
+	default:
+		ASSERT(0);
+		break;
+	}
+	return addr;
+}
+
+#define INTC_GET_EXCEPTION_CODE_MPU_SET(result, offset)		(result) ? (1U << (offset)):(0U << (offset))
+#define INTC_GET_EXCEPTION_CODE_MPU_FEIC_MS_OFF				24U
+#define INTC_GET_EXCEPTION_CODE_MPU_FEIC_BL_OFF				23U
+#define INTC_GET_EXCEPTION_CODE_MPU_FEIC_RMW_OFF			22U
+#define INTC_GET_EXCEPTION_CODE_MPU_FEIC_SX_OFF				21U
+#define INTC_GET_EXCEPTION_CODE_MPU_FEIC_SW_OFF				20U
+#define INTC_GET_EXCEPTION_CODE_MPU_FEIC_SR_OFF				19U
+#define INTC_GET_EXCEPTION_CODE_MPU_FEIC_UX_OFF				18U
+#define INTC_GET_EXCEPTION_CODE_MPU_FEIC_UW_OFF				17U
+#define INTC_GET_EXCEPTION_CODE_MPU_FEIC_UR_OFF				16U
+
+#define INTC_GET_EXCEPTION_CODE_MPU_FEIC_MIP				0x90
+#define INTC_GET_EXCEPTION_CODE_MPU_FEIC_MDP				0x91
+
+static uint32 intc_get_exception_code_mpu(CoreIdType coreId)
+{
+
+	uint32 wdata32 = 0U;
+	TargetCoreType *cpu = intc_control[coreId].cpu;
+
+	wdata32 = INTC_GET_EXCEPTION_CODE_MPU_SET(cpu->mpu.excption_error_info.intc_error_info.is_ms_error , INTC_GET_EXCEPTION_CODE_MPU_FEIC_MS_OFF) |
+			INTC_GET_EXCEPTION_CODE_MPU_SET(cpu->mpu.excption_error_info.intc_error_info.is_bl_error, INTC_GET_EXCEPTION_CODE_MPU_FEIC_BL_OFF) |
+			INTC_GET_EXCEPTION_CODE_MPU_SET(cpu->mpu.excption_error_info.intc_error_info.is_rmw_error, INTC_GET_EXCEPTION_CODE_MPU_FEIC_RMW_OFF);
+
+	if (cpu->mpu.excption_error_info.intc_error_info.is_sv_mode) {
+		if (cpu->mpu.excption_error_info.intc_error_info.access_type == MPU_TARGET_ACCESS_READ) {
+			wdata32 |= (1U << INTC_GET_EXCEPTION_CODE_MPU_FEIC_SR_OFF);
+		}
+		else {
+			wdata32 |= (1U << INTC_GET_EXCEPTION_CODE_MPU_FEIC_SW_OFF);
+		}
+	}
+	else{
+		if (cpu->mpu.excption_error_info.intc_error_info.access_type == MPU_TARGET_ACCESS_READ) {
+			wdata32 |= (1U << INTC_GET_EXCEPTION_CODE_MPU_FEIC_UR_OFF);
+		}
+		else {
+			wdata32 |= (1U << INTC_GET_EXCEPTION_CODE_MPU_FEIC_UW_OFF);
+		}
+	}
+
+	if (cpu->mpu.excption_error_info.intc_error_info.exception_error_code == TARGET_MPU_EXCEPTION_ERROR_CODE_MIP) {
+		wdata32 |= INTC_GET_EXCEPTION_CODE_MPU_FEIC_MIP;
+	}
+	else {
+		wdata32 |= INTC_GET_EXCEPTION_CODE_MPU_FEIC_MDP;
+	}
+
+	return wdata32;
+}
+
+static  uint32 intc_get_exception_code(CoreIdType coreId, uint32 exno, uint32 intno)
+{
+	if (exno == ExceptionId_UserIntr) {
+		return exception_config[exno].handler.code + intno;
+	}
+	else if ((exno == ExceptionId_MIP) || (exno == ExceptionId_MDP)) {
+		return intc_get_exception_code_mpu(coreId);
+	}
+	else {
+		return exception_config[exno].handler.code;
+	}
+}
+
+static IntcPriorityLevelType intc_get_exception_priority_level(CoreIdType coreId, uint32 exno)
+{
+	return exception_config[exno].priority.level;
+}
+
+static uint32 intc_get_exception_priority_degree(CoreIdType coreId, uint32 exno, uint32 intno)
+{
+	uint32 degree;
+	if (exno == ExceptionId_UserIntr) {
+		degree = ((uint32)intc_get_user_intr_priority_degree(coreId, intno)) << 16;
+		degree |= ((intc_get_user_intr_priority_degree_default(coreId, intno) << 0));
+	}
+	else {
+		degree = ((uint32)exception_config[exno].priority.degree_custom) << 16;
+		degree |= (uint32)0xFFFF;
+	}
+	return degree;
+}
+
+
+static IntcPriorityDegreeType intc_get_current_user_intr_priority_degree(CoreIdType coreId)
+{
+	TargetCoreType *cpu = intc_control[coreId].cpu;
+	uint32 *ispr = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_2, SYS_REG_ISPR);
+
+	IntcPriorityDegreeType degree;
+	for (degree = IntcPriorityDegree_0; degree < IntcPriorityDegree_Num; degree++) {
+		if (((*ispr) & (1U << (uint32)degree)) != 0) {
+			return degree;
+		}
+	}
+	return IntcPriorityDegree_Num;
+}
+
+static void intc_set_current_user_intr_priority_degree(CoreIdType coreId, uint32 intno, bool flag)
+{
+	TargetCoreType *cpu = intc_control[coreId].cpu;
+	if (CPU_ISSET_INTCFG_ISPC(cpu)) {
+		return;
+	}
+	IntcPriorityDegreeType degree = intc_get_user_intr_priority_degree(coreId, intno);
+	uint32 *ispr = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_2, SYS_REG_ISPR);
+	if (flag == TRUE) {
+		*ispr |= (1U << ((uint32)degree));
+	}
+	else if (!CPU_ISSET_EP(&cpu->reg)) {
+		/*
+		 *  PSW.EP = 0 の場合、 ISP15-0 でセット
+		  * （ 1）されているビットのうち、最も高優先度（ 0 が高優先度側）の
+		  * ビットがクリア（ 0）されます 注 2。
+		 */
+		IntcPriorityDegreeType degree;
+		for (degree = IntcPriorityDegree_0; degree < IntcPriorityDegree_Num; degree++) {
+			if (((*ispr) & (1U << (uint32)degree)) != 0) {
+				*ispr &= ~(1U << ((uint32)degree));
+				break;
+			}
+		}
+	}
+
+	return;
+}
+
+static IntcPriorityDegreeType intc_get_mask_priority_degree(CoreIdType coreId)
+{
+	TargetCoreType *cpu = intc_control[coreId].cpu;
+	uint32 *pmr = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_2, SYS_REG_PMR);
+
+	IntcPriorityDegreeType degree;
+	for (degree = IntcPriorityDegree_0; degree < IntcPriorityDegree_Num; degree++) {
+		if (((*pmr) & (1U << (uint32)degree)) != 0) {
+			return degree;
+		}
+	}
+	return IntcPriorityDegree_Num;
+}
+
+static void intc_set_user_intr_state_priority_degree_masked (CoreIdType coreId, bool flag)
+{
+	TargetCoreType *cpu = intc_control[coreId].cpu;
+	uint32 *icsr = cpu_get_sysreg2(&cpu->reg.sys, SYS_GRP_2, SYS_REG_ICSR);
+
+	if (flag == TRUE) {
+		*icsr |= (uint32)0x0001;
+	}
+	else {
+		*icsr &= (uint32)0xFFFFFFFE;
+	}
+	return;
+}
+
+static void intc_set_mask_priority(CoreIdType coreId, IntcPriorityDegreeType degree)
+{
+	//TODO maybe no use...
+	return;
+}
+
+
+static void intc_set_user_intr_priority_degree(CoreIdType coreId, uint32 intno, IntcPriorityDegreeType degree)
+{
+	//TODO maybe no use...
+	return;
+}
+
+
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/intc/rh850f1k/intc_config.h
@@ -0,0 +1,206 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _INTC_CONFIG_H_
+#define _INTC_CONFIG_H_
+
+#include "std_types.h"
+#include "mpu.h"
+
+typedef enum {
+	IntcPriorityLevel_0 = 0,
+	IntcPriorityLevel_1,
+	IntcPriorityLevel_2,
+	IntcPriorityLevel_3,
+	IntcPriorityLevel_4,
+	IntcPriorityLevel_5,
+	IntcPriorityLevel_6,
+	IntcPriorityLevel_7,
+	IntcPriorityLevel_8,
+	IntcPriorityLevel_9,
+	IntcPriorityLevel_10,
+	IntcPriorityLevel_11,
+	IntcPriorityLevel_12,
+	IntcPriorityLevel_13,
+	IntcPriorityLevel_14,
+	IntcPriorityLevel_15,
+	IntcPriorityLevel_Num,
+} IntcPriorityLevelType;
+
+typedef enum {
+	IntcPriorityDegree_0 = 0,
+	IntcPriorityDegree_1,
+	IntcPriorityDegree_2,
+	IntcPriorityDegree_3,
+	IntcPriorityDegree_4,
+	IntcPriorityDegree_5,
+	IntcPriorityDegree_6,
+	IntcPriorityDegree_7,
+	IntcPriorityDegree_8,
+	IntcPriorityDegree_9,
+	IntcPriorityDegree_10,
+	IntcPriorityDegree_11,
+	IntcPriorityDegree_12,
+	IntcPriorityDegree_13,
+	IntcPriorityDegree_14,
+	IntcPriorityDegree_15,
+	IntcPriorityDegree_Num,
+} IntcPriorityDegreeType;
+
+
+/*
+ *  INTC
+ */
+#define TMIN_INTNO	(0)
+#define TMAX_INTNO	(357)
+#define TNUM_INT	(358)
+
+#define INTC1_BASE  	0xFFFEEA00
+#define INTC2_BASE  	0xFFFFB000
+
+#define INTC1_MIN_INTNO	 TMIN_INTNO
+#define INTC1_MAX_INTNO	 (31)
+#define INTC2_MIN_INTNO	 (32)
+#define INTC2_MAX_INTNO	 TMAX_INTNO
+
+#define INTC_ADDR_END	0xFFFEEE00
+
+#define INTC1_IC_ADDR_START		0xFFFEEA00
+#define INTC1_IC_ADDR_END		0xFFFEEA3F	/* 0xFFFEEA3EH + 0x1 */
+
+#define INTC2_IC_ADDR_START		0xFFFFB040
+#define INTC2_IC_ADDR_END		0xFFFFB2CB	/* 0xFFFFB2CA + 0x1 */
+#define INTC2_INTNO_OFFSET		INTC2_MIN_INTNO
+
+#define IC_REG_LEN_BYTE			0x02
+#define IC_REG_LEN_BIT			(16)
+
+#define IMR_REG_LEN_BYTE		0x04
+#define IMR_REG_LEN_BIT			(32)
+
+#define INTC1_IMR_ADDR_START			0xFFFEEAF0
+#define INTC1_IMR_ADDR_END				0xFFFEEAF3	/* 0xFFFEEAF0H + 0x3 */
+#define INTC1_IMR_OFFSET_BIT(regaddr)	((regaddr - INTC1_IMR_ADDR_START) * 0x8)
+
+#define INTC2_IMR_ADDR_START					0xFFFFB400
+#define INTC2_IMR_ADDR_END						0xFFFFB42F	/* FFFF B400H + (04H × 11) + 0x3 */
+#define INTC2_IMR_ADDR(imr_no)					(INTC2_IMR_ADDR_START + ((imr_no) * IMR_REG_LEN_BYTE))
+#define INTC2_IMR_OFFSET_BIT(regaddr, imr_no)	((regaddr - INTC2_IMR_ADDR(imr_no)) * 0x8)
+
+#define INTC_IMR_NUM			(11)
+#define INTC_ACCESS_REGLEN_8BIT		(8)
+#define INTC_ACCESS_REGLEN_16BIT	(16)
+#define INTC_ACCESS_REGLEN_32BIT	(32)
+
+
+#define INTC_ACCESS_REGLEN_1BYTE	0x01
+#define INTC_ACCESS_REGLEN_2BYTE	0x02
+#define INTC_ACCESS_REGLEN_4BYTE	0x04
+
+/* ICレジスタ8ビットアクセス */
+/* アクセス位置検出 */
+#define IS_ICADDR_UPPER(ic_addr)	(((ic_addr) % IC_REG_LEN_BYTE) == 1U)
+/* 上位アドレスを下位アドレスに変換 */
+#define IC_ADDR_UPPER2LOWER(ic_addr)	((ic_addr) - 0x1)
+
+/* 割り込み番号の取得 */
+/* ICレジスタアドレスから取得 */
+#define INTC1_ICADDR2INTNO(ic_addr)	(((ic_addr) - INTC1_IC_ADDR_START) / IC_REG_LEN_BYTE)
+#define INTC2_ICADDR2INTNO(ic_addr)	((((ic_addr) - (INTC2_IC_ADDR_START)) / IC_REG_LEN_BYTE) + INTC2_INTNO_OFFSET)
+
+
+/* 割り込み番号からレジスタのアドレス取得 */
+#define IC_ADDRESS(intno)	(intno <= INTC1_MAX_INTNO)? (INTC1_IC_ADDR_START + (intno * IC_REG_LEN_BYTE)) : (INTC2_IC_ADDR_START  + ((intno - INTC2_INTNO_OFFSET) * IC_REG_LEN_BYTE))
+#define IMR_ADDRESS(intno)	(intno <= INTC1_MAX_INTNO)? (INTC1_IMR_ADDR_START) : (INTC2_IMR_ADDR_START + ((intno / IMR_REG_LEN_BIT) * IMR_REG_LEN_BYTE))
+
+
+
+// 16bitレジスタ
+//
+// |F|E|D|C|B|A|9|8|7|6|5|4|3|2|1|0|
+// |-------|-------|-------|-------|
+//  J     K         Z X     YYYYYYY
+//
+//    X(6):table-bit(0:none, 1:table)
+//    Y(0-3):優先度(0-15)
+//    Z(7):割込み要求禁止フラグ(0:許可，1:禁止)
+//    K(12):割込み要求(0:なし，1:あり)
+//    J(15):割り込み検出タイプビット
+
+#define IC_GET_PRIODEGREE(data16)		 ((data16) & 0x000F)
+
+#define IC_ISSET_TABLEREF(data16)		 ( ((data16) & (1U << 6)) != 0 )
+#define IC_ISSET_INTMASK(data16)		 ( ((data16) & (1U << 7)) != 0 )
+#define IC_ISSET_INTREQ(data16)		 ( ((data16) & (1U << 12)) != 0 )
+
+#define IC_SET_PRIODEGREE(data16p, pri) \
+do {	\
+	*(data16p) &= ~(3U << 0);	\
+	*(data16p) |= ((pri) & 0x000F);	\
+} while (0)
+
+#define IC_SET_TABLEREF(data16p) \
+do {	\
+	*(data16p) |= (1U << 6);	\
+} while (0)
+#define IC_CLR_INTTABLEREF(data16p) \
+do {	\
+	*(data16p) &= ~(1U << 6);	\
+} while (0)
+#define IC_SET_INTMASK(data16p) \
+do {	\
+	*(data16p) |= (1U << 7);	\
+} while (0)
+#define IC_CLR_INTMASK(data16p) \
+do {	\
+	*(data16p) &= ~(1U << 7);	\
+} while (0)
+
+#define IC_SET_INTREQ(data16p) \
+do {	\
+	*(data16p) |= (1U << 12);	\
+} while (0)
+#define IC_CLR_INTREQ(data16p) \
+do {	\
+	*(data16p) &= ~(1U << 12);	\
+} while (0)
+
+#endif /* _INTC_CONFIG_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/can.c
@@ -0,0 +1,171 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "can.h"
+#include "device.h"
+#include "std_errno.h"
+#include "mpu_types.h"
+#include "cpuemu_ops.h"
+#include "mpu_ops.h"
+#include "assert.h"
+#include "mapping/can_register_mapping_reset.h"
+#include "mapping/can_register_mapping_io.h"
+#include "canbus/can_bus.h"
+#include "can_rx.h"
+#include "can_tx.h"
+#include "can_interrupt.h"
+#include <stdio.h>
+
+static Std_ReturnType can_get_data8(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 *data);
+static Std_ReturnType can_get_data16(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint16 *data);
+static Std_ReturnType can_get_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 *data);
+static Std_ReturnType can_put_data8(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 data);
+static Std_ReturnType can_put_data16(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint16 data);
+static Std_ReturnType can_put_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 data);
+static Std_ReturnType can_get_pointer(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 **data);
+
+MpuAddressRegionOperationType	can_memory_operation = {
+		.get_data8 		= 	can_get_data8,
+		.get_data16		=	can_get_data16,
+		.get_data32		=	can_get_data32,
+
+		.put_data8 		= 	can_put_data8,
+		.put_data16		=	can_put_data16,
+		.put_data32		=	can_put_data32,
+
+		.get_pointer	= can_get_pointer,
+};
+
+void can_reset(void)
+{
+	CanChannelIdType cid;
+
+	can_register_reset_global(CanRegisterResetType_MCU_RESET);
+	for (cid = 0; cid < CAN_CHANNEL_NUM; cid++) {
+		can_register_reset_channel(CanRegisterResetType_MCU_RESET, cid);
+	}
+	can_register_reset_fifo_status(CanRegisterResetType_MCU_RESET);
+	can_register_reset_rx_rule(CanRegisterResetType_MCU_RESET);
+	can_register_reset_rx_buffer(CanRegisterResetType_MCU_RESET);
+	can_register_reset_rx_fifo(CanRegisterResetType_MCU_RESET);
+	can_register_reset_tx_buffer(CanRegisterResetType_MCU_RESET);
+	can_register_reset_tx_buffer_status(CanRegisterResetType_MCU_RESET);
+	can_register_reset_txrx_fifo(CanRegisterResetType_MCU_RESET);
+
+	can_register_reset_tx_queue(CanRegisterResetType_MCU_RESET);
+	can_register_reset_tx_history(CanRegisterResetType_MCU_RESET);
+}
+static uint32 can_clock_fd = 50000;
+
+void device_init_can(MpuAddressRegionType *region)
+{
+	(void)cpuemu_get_devcfg_value("DEVICE_CONFIG_CAN_FD", &can_clock_fd);
+
+	can_reset();
+	can_rx_init(&can_bus_operation_impl_ros);
+	can_tx_init(&can_bus_operation_impl_ros);
+
+	can_bus_operation_impl_ros.init();
+	return;
+}
+
+void device_supply_clock_can(DeviceClockType *dev_clock)
+{
+	if ((dev_clock->clock % can_clock_fd) == 0) {
+		can_rx_proc();
+		can_tx_proc();
+		can_tx_done();
+		can_intr_run();
+	}
+	return;
+}
+
+static Std_ReturnType can_get_data8(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 *data)
+{
+	uint32 off = (addr - region->start);
+	can_register_mapping_read_data(addr, 1U);
+	*data = *((uint8*)(&region->data[off]));
+	return STD_E_OK;
+}
+static Std_ReturnType can_get_data16(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint16 *data)
+{
+	uint32 off = (addr - region->start);
+	can_register_mapping_read_data(addr, 2U);
+	*data = *((uint16*)(&region->data[off]));
+	return STD_E_OK;
+}
+static Std_ReturnType can_get_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 *data)
+{
+	uint32 off = (addr - region->start);
+	can_register_mapping_read_data(addr, 4U);
+	*data = *((uint32*)(&region->data[off]));
+	return STD_E_OK;
+}
+static Std_ReturnType can_put_data8(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 data)
+{
+	uint32 off = (addr - region->start);
+
+	*((uint8*)(&region->data[off])) = data;
+	can_register_mapping_write_data(addr, 1U);
+
+	return STD_E_OK;
+}
+static Std_ReturnType can_put_data16(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint16 data)
+{
+	uint32 off = (addr - region->start);
+	*((uint16*)(&region->data[off])) = data;
+	can_register_mapping_write_data(addr, 2U);
+	return STD_E_OK;
+}
+static Std_ReturnType can_put_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 data)
+{
+	uint32 off = (addr - region->start);
+	*((uint32*)(&region->data[off])) = data;
+	can_register_mapping_write_data(addr, 4U);
+	return STD_E_OK;
+}
+static Std_ReturnType can_get_pointer(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 **data)
+{
+	uint32 off = (addr - region->start);
+	*data = &region->data[off];
+	return STD_E_OK;
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/can.h
@@ -0,0 +1,47 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _CAN_H_
+#define _CAN_H_
+
+extern void can_reset(void);
+
+#endif /* _CAN_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/can_buffer.c
@@ -0,0 +1,100 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "can_buffer.h"
+
+CanRxBufferControlType can_rx_buffer_control;
+CanTxBufferControlType can_tx_buffer_control;
+
+void can_rxbuffer_init(void)
+{
+	return;
+}
+
+Std_ReturnType can_rxbuffer_put_rxdata(CanChannelIdType cid, CanBufferIdType rxbuffer_id, CanDataType *rxdata)
+{
+	uint32 flag_id = CAN_RX_BUFFER_FLAG_ID(rxbuffer_id);
+	uint32 flag_idx = CAN_RX_BUFFER_FLAG_IDX(rxbuffer_id);
+	can_rx_buffer_control.rx_msgin_flag[flag_id] |= (1U << flag_idx);
+
+	can_rxbuffer_set_data(&can_rx_buffer_control.buf[rxbuffer_id], rxdata);
+
+	return STD_E_OK;
+}
+
+Std_ReturnType can_rxbuffer_get_rxdata(CanChannelIdType cid, CanBufferIdType rxbuffer_id, CanDataType *rxdata)
+{
+	can_rxbuffer_ref_data(&can_rx_buffer_control.buf[rxbuffer_id], rxdata);
+	return STD_E_OK;
+}
+
+Std_ReturnType can_txbuffer_put_txdata(CanChannelIdType cid, CanBufferIdxType bufno, CanDataType *txdata)
+{
+	can_txbuffer_set_data(&can_tx_buffer_control.buf[cid][bufno], txdata);
+	return STD_E_OK;
+}
+Std_ReturnType can_txbuffer_get_txdata(CanChannelIdType cid, CanBufferIdxType bufno, CanDataType *txdata)
+{
+
+	can_txbuffer_ref_data(&can_tx_buffer_control.buf[cid][bufno], txdata);
+	can_tx_buffer_control.buf[cid][bufno].status.sending = TRUE;
+	return STD_E_OK;
+}
+Std_ReturnType can_txbuffer_peek_txdata(CanChannelIdType cid, CanBufferIdxType bufno, CanDataType *txdata)
+{
+	if (can_tx_buffer_control.buf[cid][bufno].ctrl.req_tx == TRUE) {
+		can_txbuffer_ref_data(&can_tx_buffer_control.buf[cid][bufno], txdata);
+		return STD_E_OK;
+	}
+	else {
+		return STD_E_NOENT;
+	}
+}
+Std_ReturnType can_txbuffer_notify_txdone(CanChannelIdType cid, CanBufferIdxType bufno)
+{
+	if (can_tx_buffer_control.buf[cid][bufno].ctrl.req_tx == TRUE) {
+		can_tx_buffer_control.buf[cid][bufno].status.result = CAN_TX_BUFFER_RESULT_OK;
+		can_tx_buffer_control.buf[cid][bufno].status.sending = FALSE;
+		can_tx_buffer_control.buf[cid][bufno].ctrl.req_tx = FALSE;
+	}
+
+	return STD_E_OK;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/can_buffer.h
@@ -0,0 +1,179 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _CAN_BUFFER_H_
+#define _CAN_BUFFER_H_
+
+#include "can_types.h"
+#include "can_data.h"
+#include <string.h>
+
+/************************************************************
+ * RX BUFFER
+ ************************************************************/
+
+typedef struct {
+	struct {
+		bool	ide;	// RMIDE, RFIDE, CFIDE
+		bool	rtr;	// RMRTR, RFRTR, CFRTR
+		uint32	id;		// RMID [28:0], RFID [28:0], CFID [28:0]
+	} id;				// RSCANnRMIDq, RSCANnRFIDx, RSCANnCFIDk
+	struct {
+		uint8	dlc;	// RMDLC [3:0], RFDLC [3:0], CFDLC [3:0]
+		uint16	label;	// RMPTR [11:0], RFPTR [11:0], CFPTR [11:0]
+						/* not supported RMTS [15:0], RFTS [15:0], CFTS [15:0] */
+	} header;			// RSCANnRMPTRq, RSCANnRFPTRx, RSCANnCFPTRk
+	struct {
+		uint8	buffer[CAN_RX_BUFFER_DATA_SIZE];
+	} body;				// RSCANnRMDF0q, RSCANnRMDF1q, RSCANnRFDF0x, RSCANnRFDF1x, RSCANnCFDF0k, RSCANnCFDF1k
+} CanRxBufferType;
+
+typedef struct {
+	uint8				rx_buffer_num;							// RSCANnRMNB.NRXMB[7:0]
+	uint32				rx_msgin_flag[CAN_RX_MSGIN_FLAG_NUM];	// RSCANnRMNDy
+	CanRxBufferType		buf[CAN_RX_BUFFER_NUM];
+} CanRxBufferControlType;
+
+#define CAN_RX_BUFFER_FLAG_ID(buffer_id)	((buffer_id) / CAN_RX_BUFFER_FLAG_BIT_NUM)
+#define CAN_RX_BUFFER_FLAG_IDX(buffer_id)	((buffer_id) % CAN_RX_BUFFER_FLAG_BIT_NUM)
+
+
+static inline void can_rxbuffer_set_data(CanRxBufferType *bufferp, CanDataType *rxdata)
+{
+	bufferp->id.id = rxdata->id;
+	bufferp->id.ide = rxdata->ide;
+	bufferp->id.rtr = rxdata->rtr;
+	bufferp->header.label = rxdata->label;
+	bufferp->header.dlc = rxdata->dlc;
+	memcpy(&bufferp->body.buffer[0], &rxdata->data[0], CAN_RX_BUFFER_DATA_SIZE);
+	return;
+}
+static inline void can_rxbuffer_ref_data(CanRxBufferType *bufferp, CanDataType *rxdata)
+{
+	rxdata->id = bufferp->id.id;
+	rxdata->ide = bufferp->id.ide;
+	rxdata->rtr = bufferp->id.rtr;
+	rxdata->label = bufferp->header.label;
+	rxdata->dlc = bufferp->header.dlc;
+	memcpy(&rxdata->data[0], &bufferp->body.buffer[0], CAN_RX_BUFFER_DATA_SIZE);
+	return;
+}
+
+/************************************************************
+ * TX BUFFER
+ ************************************************************/
+
+#define CAN_TX_BUFFER_RESULT_NONE		0x00
+#define CAN_TX_BUFFER_RESULT_SENDING	0x00
+#define CAN_TX_BUFFER_RESULT_ABORT		0x01
+#define CAN_TX_BUFFER_RESULT_OK			0x02
+
+typedef struct {
+	struct {
+						/* not supported TMOM */
+						/* not supported TMTAR */
+		bool 	req_tx;	// TMTR
+	} ctrl; 			// RSCANnTMCp
+	struct {
+						/* not supported TMTARM */
+		bool 	req_tx;	// TMTRM
+		uint8	result;	// TMTRF[1:0]
+		bool	sending; // TMTSTS
+	} status;			// RSCANnTMSTSp
+	struct {
+		bool	ide;	// TMIDE, CFIDE
+		bool	rtr;	// TMRTR, CFRTR
+						/* not supported THLEN */
+		uint32	id;		// TMID [28:0], CFID [28:0]
+	} id;				// RSCANnTMIDp, RSCANnCFIDk
+	struct {
+		uint8	dlc;	// TMDLC [3:0], CFDLC [3:0]
+		uint16	label;	// TMPTR [7:0], CFPTR [11:0]
+	} header;			// RSCANnTMPTRp, RSCANnCFPTRk
+	struct {
+		uint8	buffer[CAN_TX_BUFFER_DATA_SIZE];
+	} body;				// RSCANnTMDF0p, RSCANnTMDF1p, RSCANnCFDF0k, RSCANnCFDF1k
+} CanTxBufferType;
+
+static inline void can_txbuffer_set_data(CanTxBufferType *bufferp, CanDataType *txdata)
+{
+	bufferp->id.id = txdata->id;
+	bufferp->id.ide = txdata->ide;
+	bufferp->id.rtr = txdata->rtr;
+	bufferp->header.dlc = txdata->dlc;
+	bufferp->header.label = txdata->label;
+	memcpy(&bufferp->body.buffer[0], &txdata->data[0], CAN_TX_BUFFER_DATA_SIZE);
+	return;
+}
+static inline void can_txbuffer_ref_data(CanTxBufferType *bufferp, CanDataType *txdata)
+{
+	txdata->id = bufferp->id.id;
+	txdata->ide = bufferp->id.ide;
+	txdata->rtr = bufferp->id.rtr;
+	txdata->dlc = bufferp->header.dlc;
+	txdata->label = bufferp->header.label;
+	memcpy(&txdata->data[0], &bufferp->body.buffer[0], CAN_TX_BUFFER_DATA_SIZE);
+	return;
+}
+
+typedef struct {
+	uint32					intr_enable[CAN_TX_BUFFER_FLAG_NUM];		// RSCANnTMIECy
+	CanTxBufferType			buf[CAN_CHANNEL_NUM][CAN_TX_CHANNEL_BUFFER_NUM];
+} CanTxBufferControlType;
+#define CAN_TX_BUFFER_ID(cid, bufno)		( ( (cid) * CAN_TX_CHANNEL_BUFFER_NUM ) + (bufno) )
+#define CAN_TX_BUFFER_IDX(buffer_id)		( (buffer_id) % CAN_TX_CHANNEL_BUFFER_NUM)
+#define CAN_TX_BUFFER_FLAG_ID(buffer_id)	((buffer_id) / CAN_TX_BUFFER_FLAG_BIT_NUM)
+#define CAN_TX_BUFFER_FLAG_IDX(buffer_id)	((buffer_id) % CAN_TX_BUFFER_FLAG_BIT_NUM)
+
+extern void can_rxbuffer_init(void);
+extern Std_ReturnType can_rxbuffer_put_rxdata(CanChannelIdType cid, CanBufferIdType rxbuffer_id, CanDataType *rxdata);
+extern Std_ReturnType can_rxbuffer_get_rxdata(CanChannelIdType cid, CanBufferIdType rxbuffer_id, CanDataType *rxdata);
+
+extern Std_ReturnType can_txbuffer_put_txdata(CanChannelIdType cid, CanBufferIdxType bufno, CanDataType *txdata);
+extern Std_ReturnType can_txbuffer_get_txdata(CanChannelIdType cid, CanBufferIdxType bufno, CanDataType *txdata);
+extern Std_ReturnType can_txbuffer_peek_txdata(CanChannelIdType cid, CanBufferIdxType bufno, CanDataType *txdata);
+extern Std_ReturnType can_txbuffer_notify_txdone(CanChannelIdType cid, CanBufferIdxType bufno);
+
+
+extern CanRxBufferControlType can_rx_buffer_control;
+extern CanTxBufferControlType can_tx_buffer_control;
+
+#endif /* _CAN_BUFFER_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/can_config.h
@@ -0,0 +1,80 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _CAN_CONFIG_H_
+#define _CAN_CONFIG_H_
+
+#define CAN_CHANNEL_NUM				6U
+
+
+#define CAN_RX_UNIT_RULE_MAX		( 64U * CAN_CHANNEL_NUM )
+#define CAN_RX_CHANNEL_RULE_MAX		128U
+
+#define CAN_RX_PAGE_RULE_NUM		16U
+#define CAN_RX_RULE_TABLE_PAGE_NUM	24U
+
+
+#define CAN_RX_BUFFER_NUM			96U
+#define CAN_RX_BUFFER_FLAG_BIT_NUM  32U
+
+#define CAN_RX_MSGIN_FLAG_NUM		3U
+
+#define CAN_RX_BUFFER_DATA_SIZE		8U
+#define CAN_TX_BUFFER_DATA_SIZE		8U
+
+
+#define CAN_RX_FIFO_QUEUE_MAX		128U
+#define CAN_RX_FIFO_NUM				8U
+
+#define CAN_TX_BUFFER_FLAG_NUM		3U
+#define CAN_TX_BUFFER_FLAG_BIT_NUM	32U
+#define CAN_TX_CHANNEL_BUFFER_NUM	16U
+#define CAN_TX_FIFO_QUEUE_MAX		128U
+#define CAN_TX_BUFFER_NUM			96U
+
+#define CAN_TXRX_CHANNEL_FIFO_NUM	3U
+#define CAN_FIFO_FLAG_NUM			3U
+
+
+#define CAN_TX_HISTORY_BUFFER_NUM	16U
+#define CAN_TX_HISTORY_INTR_BUFNUM	12U
+
+#endif /* _CAN_CONFIG_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/can_data.h
@@ -0,0 +1,56 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _CAN_DATA_H_
+#define _CAN_DATA_H_
+
+#include "can_types.h"
+
+typedef struct {
+	bool 	ide;	//false:standard, true:extend
+	bool 	rtr;	//false:data frame, true:remote frame
+	uint8	dlc;
+	uint16	label;
+	uint32	id;
+	uint8	data[CAN_RX_BUFFER_DATA_SIZE];
+} CanDataType;
+
+#endif /* _CAN_DATA_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/can_fifo.c
@@ -0,0 +1,384 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "can_fifo.h"
+
+
+#define CAN_RXFIFO_QUEUE_ID_NUM		8U
+static const uint32 can_fifo_quelen[CAN_RXFIFO_QUEUE_ID_NUM] = {
+	0,
+	4,
+	8,
+	16,
+	32,
+	48,
+	64,
+	CAN_RX_FIFO_QUEUE_MAX,
+};
+
+CanRxFifoControlType can_rx_fifo_control;
+CanTxRxFifoControlType can_txrx_fifo_control;
+
+#define INTR_TIMING_CNT_MAX		7U
+typedef struct {
+	bool enable_intr;
+	bool enable_intr_everytime;
+	uint32 intr_timing_cnt;
+	uint32 quelen_max;
+} CanFifoRxInterruptParamType;
+static bool can_fifo_rx_interrupt_occured(CanFifoControlType *fifo, CanFifoRxInterruptParamType *param)
+{
+	uint32 intr_count;
+	if (param->enable_intr == FALSE) {
+		return FALSE;
+	}
+	if (param->enable_intr_everytime == TRUE) {
+		return TRUE;
+	}
+	if (param->intr_timing_cnt == INTR_TIMING_CNT_MAX) {
+		intr_count = param->quelen_max;
+	}
+	else {
+		intr_count = ( param->quelen_max * (param->intr_timing_cnt + 1U) ) / 8U;
+	}
+	if (fifo->count >= intr_count) {
+		return TRUE;
+	}
+	else {
+		return FALSE;
+	}
+}
+
+Std_ReturnType can_rxfifo_put_rxdata(CanChannelIdType cid, CanBufferIdType rxfifo_id, CanDataType *rxdata)
+{
+	CanRxFifoBufferType *fifo = &can_rx_fifo_control.fifo[rxfifo_id];
+	CanFifoRxInterruptParamType param;
+
+	if (fifo->config.enable_fifo == FALSE) {
+		return STD_E_PERM;
+	}
+
+	if (fifo->fifo_control.count >= can_fifo_quelen[fifo->config.quelen]) {
+		fifo->status.rx_lost = TRUE;
+		return STD_E_LIMIT;
+	}
+	can_rxbuffer_set_data(&fifo->buffer[fifo->fifo_control.woff], rxdata);
+
+	fifo->fifo_control.count++;
+	fifo->fifo_control.woff++;
+	if (fifo->fifo_control.woff >= can_fifo_quelen[fifo->config.quelen]) {
+		fifo->fifo_control.woff = 0U;
+	}
+
+	/*
+	 * status
+	 */
+	if (fifo->fifo_control.count >= can_fifo_quelen[fifo->config.quelen]) {
+		fifo->status.rx_full = TRUE;
+	}
+	fifo->status.rx_empty = FALSE;
+
+	param.enable_intr = fifo->config.enable_fifo;
+	param.enable_intr_everytime = fifo->config.enable_intr_everytime;
+	param.intr_timing_cnt = fifo->config.intr_timing_cnt;
+	param.quelen_max = can_fifo_quelen[fifo->config.quelen];
+	if (can_fifo_rx_interrupt_occured(&fifo->fifo_control, &param) == TRUE) {
+		fifo->status.rx_intr = TRUE;
+	}
+
+
+	return STD_E_OK;
+}
+Std_ReturnType can_rxfifo_next_rxdata(CanBufferIdType rxfifo_id)
+{
+	CanRxFifoBufferType *fifo = &can_rx_fifo_control.fifo[rxfifo_id];
+
+	if (fifo->config.enable_fifo == FALSE) {
+		return STD_E_PERM;
+	}
+	if (fifo->fifo_control.count == 0) {
+		return STD_E_NOENT;
+	}
+
+	fifo->fifo_control.count--;
+	fifo->fifo_control.roff++;
+	if (fifo->fifo_control.roff >= can_fifo_quelen[fifo->config.quelen]) {
+		fifo->fifo_control.roff = 0U;
+	}
+	/*
+	 * status
+	 */
+	if (fifo->fifo_control.count < can_fifo_quelen[fifo->config.quelen]) {
+		fifo->status.rx_full = FALSE;
+	}
+	if (fifo->fifo_control.count <= 0) {
+		fifo->status.rx_empty = TRUE;
+	}
+
+	return STD_E_OK;
+}
+
+Std_ReturnType can_rxfifo_peek_rxdata(CanBufferIdType rxfifo_id, CanDataType *rxdata)
+{
+	CanRxFifoBufferType *fifo = &can_rx_fifo_control.fifo[rxfifo_id];
+
+	if (fifo->config.enable_fifo == FALSE) {
+		return STD_E_PERM;
+	}
+	if (fifo->fifo_control.count == 0) {
+		return STD_E_NOENT;
+	}
+
+	can_rxbuffer_ref_data(&fifo->buffer[fifo->fifo_control.roff], rxdata);
+	return STD_E_OK;
+}
+
+
+Std_ReturnType can_rxfifo_clear(CanBufferIdxType rxfifo_id)
+{
+	CanRxFifoBufferType *fifo = &can_rx_fifo_control.fifo[rxfifo_id];
+	CAN_FIFO_CLEAR(&fifo->fifo_control);
+	return STD_E_OK;
+}
+
+Std_ReturnType can_txrxfifo_put_rxdata(CanChannelIdType cid, CanBufferIdxType txrxfifo_id, CanDataType *rxdata)
+{
+	CanTxRxFifoBufferType *fifo = &can_txrx_fifo_control.buf[cid][txrxfifo_id];
+	CanFifoRxInterruptParamType param;
+
+	if (fifo->config.mode == CAN_TXRX_FIFO_MODE_TX) {
+		printf("ERROR: can_txrxfifo_put_rxdata():invalid fifo_mode TX\n");
+		return STD_E_PERM;
+	}
+	if (fifo->config.enable_fifo == FALSE) {
+		printf("ERROR: can_txrxfifo_put_rxdata():fifo is not enabled\n");
+		return STD_E_PERM;
+	}
+
+	if (fifo->fifo_control.count >= can_fifo_quelen[fifo->config.quelen]) {
+		fifo->status.txrx_lost = TRUE;
+		return STD_E_LIMIT;
+	}
+	can_rxbuffer_set_data(&fifo->buffer.rx[fifo->fifo_control.woff], rxdata);
+
+	fifo->fifo_control.count++;
+	fifo->fifo_control.woff++;
+	if (fifo->fifo_control.woff >= can_fifo_quelen[fifo->config.quelen]) {
+		fifo->fifo_control.woff = 0U;
+	}
+
+	/*
+	 * status
+	 */
+	if (fifo->fifo_control.count >= can_fifo_quelen[fifo->config.quelen]) {
+		fifo->status.txrx_full = TRUE;
+	}
+	fifo->status.txrx_empty = FALSE;
+
+	param.enable_intr = fifo->config.enable_fifo;
+	param.enable_intr_everytime = fifo->config.enable_intr_everytime;
+	param.intr_timing_cnt = fifo->config.intr_timing_cnt;
+	param.quelen_max = can_fifo_quelen[fifo->config.quelen];
+	if (can_fifo_rx_interrupt_occured(&fifo->fifo_control, &param) == TRUE) {
+		fifo->status.rx_intr = TRUE;
+	}
+	return STD_E_OK;
+}
+
+Std_ReturnType can_txrxfifo_peek_rxdata(CanChannelIdType cid, CanBufferIdxType txrxfifo_id, CanDataType *rxdata)
+{
+	CanTxRxFifoBufferType *fifo = &can_txrx_fifo_control.buf[cid][txrxfifo_id];
+
+	if (fifo->config.mode == CAN_TXRX_FIFO_MODE_TX) {
+		return STD_E_PERM;
+	}
+	if (fifo->config.enable_fifo == FALSE) {
+		return STD_E_PERM;
+	}
+	if (fifo->fifo_control.count == 0) {
+		return STD_E_NOENT;
+	}
+
+	can_rxbuffer_ref_data(&fifo->buffer.rx[fifo->fifo_control.roff], rxdata);
+	return STD_E_OK;
+}
+Std_ReturnType can_txrxfifo_next_rxdata(CanChannelIdType cid, CanBufferIdxType txrxfifo_id)
+{
+	CanTxRxFifoBufferType *fifo = &can_txrx_fifo_control.buf[cid][txrxfifo_id];
+
+	if (fifo->config.mode == CAN_TXRX_FIFO_MODE_TX) {
+		return STD_E_PERM;
+	}
+	if (fifo->config.enable_fifo == FALSE) {
+		return STD_E_PERM;
+	}
+	if (fifo->fifo_control.count == 0) {
+		return STD_E_NOENT;
+	}
+
+	fifo->fifo_control.count--;
+	fifo->fifo_control.roff++;
+	if (fifo->fifo_control.roff >= can_fifo_quelen[fifo->config.quelen]) {
+		fifo->fifo_control.roff = 0U;
+	}
+	/*
+	 * status
+	 */
+	if (fifo->fifo_control.count < can_fifo_quelen[fifo->config.quelen]) {
+		fifo->status.txrx_full = FALSE;
+	}
+	if (fifo->fifo_control.count <= 0) {
+		fifo->status.txrx_empty = TRUE;
+	}
+	return STD_E_OK;
+}
+
+Std_ReturnType can_txrxfifo_put_txdata(CanChannelIdType cid, CanBufferIdxType txrxfifo_id, CanDataType *txdata)
+{
+	CanTxRxFifoBufferType *fifo = &can_txrx_fifo_control.buf[cid][txrxfifo_id];
+
+	if (fifo->config.mode != CAN_TXRX_FIFO_MODE_TX) {
+		return STD_E_PERM;
+	}
+	if (fifo->config.enable_fifo == FALSE) {
+		return STD_E_PERM;
+	}
+
+	if (fifo->fifo_control.count >= can_fifo_quelen[fifo->config.quelen]) {
+		fifo->status.txrx_lost = TRUE;
+		return STD_E_LIMIT;
+	}
+	can_txbuffer_set_data(&fifo->buffer.tx[fifo->fifo_control.woff], txdata);
+
+	fifo->fifo_control.count++;
+	fifo->fifo_control.woff++;
+	if (fifo->fifo_control.woff >= can_fifo_quelen[fifo->config.quelen]) {
+		fifo->fifo_control.woff = 0U;
+	}
+
+	/*
+	 * status
+	 */
+	if (fifo->fifo_control.count >= can_fifo_quelen[fifo->config.quelen]) {
+		fifo->status.txrx_full = TRUE;
+	}
+	fifo->status.txrx_empty = FALSE;
+
+	return STD_E_OK;
+}
+
+Std_ReturnType can_txrxfifo_get_txdata(CanChannelIdType cid, CanBufferIdxType txrxfifo_id, CanDataType *txdata)
+{
+	CanTxRxFifoBufferType *fifo = &can_txrx_fifo_control.buf[cid][txrxfifo_id];
+
+	if (fifo->config.mode != CAN_TXRX_FIFO_MODE_TX) {
+		return STD_E_PERM;
+	}
+	if (fifo->config.enable_fifo == FALSE) {
+		return STD_E_PERM;
+	}
+	if (fifo->fifo_control.count == 0) {
+		return STD_E_NOENT;
+	}
+
+	can_txbuffer_ref_data(&fifo->buffer.tx[fifo->fifo_control.roff], txdata);
+	fifo->fifo_control.count--;
+	fifo->fifo_control.roff++;
+	if (fifo->fifo_control.roff >= can_fifo_quelen[fifo->config.quelen]) {
+		fifo->fifo_control.roff = 0U;
+	}
+	/*
+	 * status
+	 */
+	if (fifo->fifo_control.count < can_fifo_quelen[fifo->config.quelen]) {
+		fifo->status.txrx_full = FALSE;
+	}
+	return STD_E_OK;
+}
+
+Std_ReturnType can_txrxfifo_peek_txdata(CanChannelIdType cid, CanBufferIdxType txrxfifo_id, CanDataType *txdata)
+{
+	CanTxRxFifoBufferType *fifo = &can_txrx_fifo_control.buf[cid][txrxfifo_id];
+
+	if (fifo->config.mode != CAN_TXRX_FIFO_MODE_TX) {
+		return STD_E_PERM;
+	}
+	if (fifo->config.enable_fifo == FALSE) {
+		return STD_E_PERM;
+	}
+	if (fifo->fifo_control.count == 0) {
+		return STD_E_NOENT;
+	}
+
+	can_txbuffer_ref_data(&fifo->buffer.tx[fifo->fifo_control.roff], txdata);
+	return STD_E_OK;
+}
+Std_ReturnType can_txrxfifo_notify_txdone(CanChannelIdType cid, CanBufferIdxType txrxfifo_id)
+{
+	CanTxRxFifoBufferType *fifo = &can_txrx_fifo_control.buf[cid][txrxfifo_id];
+
+	//CFTXIF フラグ
+	if (fifo->config.enable_intr_everytime == TRUE) {
+		fifo->status.tx_intr = TRUE;
+	}
+	else if (fifo->fifo_control.count <= 0) {
+		fifo->status.tx_intr = TRUE;
+	}
+	//CFEが0
+	if (fifo->config.enable_fifo == FALSE) {
+		CAN_FIFO_CLEAR(&fifo->fifo_control);
+	}
+
+	//CFEMP フラグ
+	//すべてのメッセージを送信したとき
+	if (fifo->fifo_control.count <= 0) {
+		fifo->status.txrx_empty = TRUE;
+	}
+
+	return STD_E_OK;
+}
+
+Std_ReturnType can_txrxfifo_clear(CanChannelIdType cid, CanBufferIdxType txrxfifo_id)
+{
+	CanTxRxFifoBufferType *fifo = &can_txrx_fifo_control.buf[cid][txrxfifo_id];
+	CAN_FIFO_CLEAR(&fifo->fifo_control);
+	return STD_E_OK;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/can_fifo.h
@@ -0,0 +1,140 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _CAN_FIFO_H_
+#define _CAN_FIFO_H_
+
+#include "can_buffer.h"
+#include "can_data.h"
+
+typedef struct {
+	uint32		count; 	// RSCANnRFSTSx.RFMC[7:0], RSCANnRFPCTRx.RFPC[7:0], RSCANnCFSTSk.CFMC [7:0]
+	uint32		roff;	// RSCANnRFPCTRx.RFPC[7:0]
+	uint32		woff;
+} CanFifoControlType;
+#define CAN_FIFO_CLEAR(fifo)	\
+do { \
+	(fifo)->count = 0U;	\
+	(fifo)->roff = 0U;	\
+	(fifo)->woff = 0U;	\
+} while (0)
+
+typedef struct {
+	struct {
+		uint8	intr_timing_cnt;		// RFIGCV [2:0]
+		bool	enable_intr_everytime;	// RFIM
+		uint8	quelen;					// RFDC [2:0]
+		bool	enable_intr;			// RFIE
+		bool	enable_fifo;			// RFE
+	} config;							// RSCANnRFCCx
+	struct {
+		bool	rx_intr;				// RFIF
+		bool	rx_lost;				// RFMLT
+		bool	rx_full;				// RFFLL
+		bool	rx_empty;				// RFEMP
+	} status;							// RSCANnRFSTSx
+	CanFifoControlType	fifo_control;
+	CanRxBufferType	buffer[CAN_RX_FIFO_QUEUE_MAX];	// RSCANnRFIDx, RSCANnRFPTRx, RSCANnRFDF0x, RSCANnRFDF1x
+} CanRxFifoBufferType;
+
+typedef struct {
+	CanRxFifoBufferType		fifo[CAN_RX_FIFO_NUM];
+} CanRxFifoControlType;
+
+
+#define CAN_TXRX_FIFO_MODE_RX			0x00
+#define CAN_TXRX_FIFO_MODE_TX			0x01
+#define CAN_TXRX_FIFO_MODE_GW			0x02
+
+typedef struct {
+	struct {
+		// not supported CFITT[7:0]
+		CanBufferIdxType	tx_bufno;				// CFTML[3:0]
+		// not supported CFITR
+		// not supported CFITSS
+		uint8			mode;					// CFM[1:0]
+		uint8			intr_timing_cnt;		// CFIGCV [2:0]
+		bool			enable_intr_everytime;	// CFIM
+		uint16			quelen;					// CFDC [2:0]
+		bool			enable_tx_intr;			// CFTXIE
+		bool			enable_rx_intr;			// CFRXIE
+		bool			enable_fifo;			// CFE
+	} config;							// RSCANnCFCCk
+	struct {
+		uint8	msg_num;				// CFMC [7:0]
+		bool	tx_intr;				// CFTXIF
+		bool	rx_intr;				// CFRXIF
+		bool	txrx_lost;				// CFMLT
+		bool	txrx_full;				// CFFLL
+		bool	txrx_empty;				// CFEMP
+	} status;							// RSCANnCFSTSk
+	uint8 fifo_ptr;						// RSCANnCFPCTRk.CFPC [7:0]
+	CanFifoControlType	fifo_control;
+	union {
+		CanRxBufferType	rx[CAN_RX_FIFO_QUEUE_MAX];
+		CanTxBufferType	tx[CAN_TX_FIFO_QUEUE_MAX];
+	} buffer; // RSCANnCFIDk, RSCANnCFIDk, RSCANnCFPTRk, RSCANnCFDF0k, RSCANnCFDF1k
+} CanTxRxFifoBufferType;
+
+typedef struct {
+	CanTxRxFifoBufferType	buf[CAN_CHANNEL_NUM][CAN_TXRX_CHANNEL_FIFO_NUM];
+} CanTxRxFifoControlType;
+
+
+extern Std_ReturnType can_rxfifo_put_rxdata(CanChannelIdType cid, CanBufferIdType rxfifo_id, CanDataType *rxdata);
+extern Std_ReturnType can_rxfifo_next_rxdata(CanBufferIdType rxfifo_id);
+extern Std_ReturnType can_rxfifo_peek_rxdata(CanBufferIdType rxfifo_id, CanDataType *rxdata);
+extern Std_ReturnType can_rxfifo_clear(CanBufferIdxType rxfifo_id);
+
+extern Std_ReturnType can_txrxfifo_put_rxdata(CanChannelIdType cid, CanBufferIdxType txrxfifo_id, CanDataType *rxdata);
+extern Std_ReturnType can_txrxfifo_next_rxdata(CanChannelIdType cid, CanBufferIdxType txrxfifo_id);
+extern Std_ReturnType can_txrxfifo_peek_rxdata(CanChannelIdType cid, CanBufferIdxType txrxfifo_id, CanDataType *rxdata);
+
+extern Std_ReturnType can_txrxfifo_put_txdata(CanChannelIdType cid, CanBufferIdxType txrxfifo_id, CanDataType *txdata);
+extern Std_ReturnType can_txrxfifo_get_txdata(CanChannelIdType cid, CanBufferIdxType txrxfifo_id, CanDataType *txdata);
+extern Std_ReturnType can_txrxfifo_peek_txdata(CanChannelIdType cid, CanBufferIdxType txrxfifo_id, CanDataType *txdata);
+extern Std_ReturnType can_txrxfifo_clear(CanChannelIdType cid, CanBufferIdxType txrxfifo_id);
+extern Std_ReturnType can_txrxfifo_notify_txdone(CanChannelIdType cid, CanBufferIdxType txrxfifo_id);
+
+extern CanRxFifoControlType can_rx_fifo_control;
+extern CanTxRxFifoControlType can_txrx_fifo_control;
+
+#endif /* _CAN_FIFO_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/can_interrupt.c
@@ -0,0 +1,243 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "can_interrupt.h"
+#include "device.h"
+#include "can_config.h"
+#include "can_mode_global.h"
+#include "can_fifo.h"
+#include "can_buffer.h"
+#include "can_tx_queue.h"
+#include "can_tx_history.h"
+
+/*
+ * Interrupt Number
+ *
+ * 	グローバル割り込み
+ *		・ 受信FIFO
+ * 		・グローバルエラー(DEF, MES)
+ * 	チャネル割り込み
+ * 		・CANm送信
+ * 			・送信完了
+ * 			・送受信FIFO送信完了
+ * 		・CANm送受信FIFO受信完了
+ */
+//22 ICRCANGERR0 FFFE EA2CH INTRCANGERR0 CAN グローバルエラー割り込み RSCAN0 レベル 1016H ○ ○ ○ +058H
+#define CAN_GLOBAL_ERROR_INTNO		22U
+//23 ICRCANGRECC0 FFFE EA2EH INTRCANGRECC0 CAN 受信 FIFO 割り込み RSCAN0 レベル 1017H ○ ○ ○ +05CH
+#define CAN_GLOBAL_RXFIFO_INTNO		23U
+
+
+typedef struct {
+	uint32	txrxfifo_rxdone_intno;
+	uint32	txdone_intno;
+} CanChannelIntnoType;
+
+static const CanChannelIntnoType can_channel_intno[CAN_CHANNEL_NUM] = {
+		//25 ICRCAN0REC FFFE EA32H INTRCAN0REC CAN0 送受信 FIFO 受信完了割り込み RSCAN0 レベル 1019H ○ ○ ○ +064H
+		//26 ICRCAN0TRX FFFE EA34H INTRCAN0TRX CAN0 送信割り込み RSCAN0 レベル 101AH ○ ○ ○ +068H
+		{ .txrxfifo_rxdone_intno = 25U, .txdone_intno = 26U },		/* CH0 */
+		//114 ICRCAN1REC FFFF B0E4H INTRCAN1REC CAN1 送受信 FIFO 受信完了割り込み RSCAN0 レベル 1072H ○ ○ ○ +1C8H
+		//115 ICRCAN1TRX FFFF B0E6H INTRCAN1TRX CAN1 送信割り込み RSCAN0 レベル 1073H ○ ○ ○ +1CCH
+		{ .txrxfifo_rxdone_intno = 114U, .txdone_intno = 115U },		/* CH1 */
+		//218 ICRCAN2REC FFFF B1B4H INTRCAN2REC CAN2 送受信 FIFO 受信完了割り込み RSCAN0 レベル 10DAH ○ ○ ○ +368H
+		//219 ICRCAN2TRX FFFF B1B6H INTRCAN2TRX CAN2 送信割り込み RSCAN0 レベル 10DBH ○ ○ ○ +36CH
+		{ .txrxfifo_rxdone_intno = 218U, .txdone_intno = 219U },		/* CH2 */
+		//221 ICRCAN3REC FFFF B1BAH INTRCAN3REC CAN3 送受信 FIFO 受信完了割り込み RSCAN0 レベル 10DDH ○ ○ ○ +374H
+		//222 ICRCAN3TRX FFFF B1BCH INTRCAN3TRX CAN3 送信割り込み RSCAN0 レベル 10DEH ○ ○ ○ +378H
+		{ .txrxfifo_rxdone_intno = 221U, .txdone_intno = 222U },		/* CH3 */
+		//273 ICRCAN4REC FFFF B222H INTRCAN4REC CAN4 送受信 FIFO 受信完了割り込み RSCAN0 レベル 1111H ○ ○ ○ +444H
+		//274 ICRCAN4TRX FFFF B224H INTRCAN4TRX CAN4 送信割り込み RSCAN0 レベル 1112H ○ ○ ○ +448H
+		{ .txrxfifo_rxdone_intno = 273U, .txdone_intno = 274U },		/* CH4 */
+		//288 ICRCAN5REC FFFF B240H INTRCAN5REC CAN5 送受信 FIFO 受信完了割り込み RSCAN0 レベル 1120H ○ ○ ○ +480H
+		//289 ICRCAN5TRX FFFF B242H INTRCAN5TRX CAN5 送信割り込み RSCAN0 レベル 1121H ○ ○ ○ +484H
+		{ .txrxfifo_rxdone_intno = 288U, .txdone_intno = 289U },		/* CH5 */
+};
+
+static void can_intr_txrxfifo_run(CanChannelIdType cid);
+static void can_intr_tx_run(CanChannelIdType cid);
+static void can_intr_global_run(void);
+
+void can_intr_run(void)
+{
+	CanChannelIdType cid;
+	can_intr_global_run();
+
+	for (cid = 0; cid < CAN_CHANNEL_NUM; cid++) {
+		can_intr_txrxfifo_run(cid);
+		can_intr_tx_run(cid);
+	}
+	return;
+}
+
+
+static bool can_intr_rxfifo_check(void);
+static bool can_intr_glerror_check(void);
+static void can_intr_global_run(void)
+{
+	if (can_intr_glerror_check() == TRUE) {
+		device_raise_int(CAN_GLOBAL_ERROR_INTNO);
+	}
+	if (can_intr_rxfifo_check() == TRUE) {
+		device_raise_int(CAN_GLOBAL_RXFIFO_INTNO);
+	}
+	return;
+}
+
+static void can_intr_txrxfifo_run(CanChannelIdType cid)
+{
+	uint32 k;
+	for (k = 0; k < CAN_TXRX_CHANNEL_FIFO_NUM; k++) {
+		if (can_txrx_fifo_control.buf[cid][k].config.enable_rx_intr == FALSE) {
+			continue;
+		}
+		if (can_txrx_fifo_control.buf[cid][k].status.rx_intr == FALSE) {
+			continue;
+		}
+		device_raise_int(can_channel_intno[cid].txrxfifo_rxdone_intno);
+		return;
+	}
+	return;
+}
+
+static bool can_intr_tx_buffer_check(CanChannelIdType cid)
+{
+	uint32 bufno;
+
+	for (bufno = 0; bufno < CAN_TX_CHANNEL_BUFFER_NUM; bufno++) {
+		uint32 flag_id = CAN_TX_BUFFER_FLAG_ID(CAN_TX_BUFFER_ID(cid, bufno));
+		uint32 flag_idx = CAN_TX_BUFFER_FLAG_IDX(CAN_TX_BUFFER_ID(cid, bufno));
+		if ((can_tx_buffer_control.intr_enable[flag_id] & (1U << flag_idx)) == 0U) {
+			continue;
+		}
+		if ((can_tx_buffer_control.buf[cid][bufno].status.result & 0x2) == 0) {
+			continue;
+		}
+		return TRUE;
+	}
+	if ((can_tx_queue[cid].config.enable_intr == TRUE) && (can_tx_queue[cid].status.intr_req == TRUE)) {
+		return TRUE;
+	}
+	return FALSE;
+}
+
+static bool can_intr_tx_fifo_check(CanChannelIdType cid)
+{
+	uint32 k;
+	for (k = 0; k < CAN_TXRX_CHANNEL_FIFO_NUM; k++) {
+		if (can_txrx_fifo_control.buf[cid][k].config.enable_tx_intr == FALSE) {
+			continue;
+		}
+		if (can_txrx_fifo_control.buf[cid][k].status.tx_intr == FALSE) {
+			continue;
+		}
+		return TRUE;
+	}
+	return FALSE;
+}
+
+static void can_intr_tx_run(CanChannelIdType cid)
+{
+	if (can_intr_tx_buffer_check(cid) == TRUE) {
+		device_raise_int(can_channel_intno[cid].txdone_intno);
+		return;
+	}
+	if (can_intr_tx_fifo_check(cid) == TRUE) {
+		device_raise_int(can_channel_intno[cid].txdone_intno);
+		return;
+	}
+	//送信履歴バッファ
+	if ((can_tx_history[cid].config.enable_intr == TRUE) && (can_tx_history[cid].status.thl_intr == TRUE)) {
+		device_raise_int(can_channel_intno[cid].txdone_intno);
+		return;
+	}
+	return;
+}
+
+static bool can_intr_rxfifo_check(void)
+{
+	uint32 x;
+	for (x = 0; x < CAN_RX_FIFO_NUM; x++) {
+		if (can_rx_fifo_control.fifo[x].config.enable_intr == FALSE) {
+			continue;
+		}
+		if (can_rx_fifo_control.fifo[x].status.rx_intr == FALSE) {
+			continue;
+		}
+		return TRUE;
+	}
+	return FALSE;
+}
+
+
+static bool can_intr_global_dlcerr_check(void);
+static bool can_intr_global_msglost_check(void);
+static bool can_intr_glerror_check(void)
+{
+	if (can_intr_global_dlcerr_check() == TRUE) {
+		return TRUE;
+	}
+	else if (can_intr_global_msglost_check() == TRUE) {
+		return TRUE;
+	}
+	return FALSE;
+}
+
+static bool can_intr_global_dlcerr_check(void)
+{
+	if (can_mode_global.ctrl.enable_dlc_error == FALSE) {
+		return FALSE;
+	}
+	if (can_mode_global.status.dlc_error == FALSE) {
+		return FALSE;
+	}
+	return TRUE;
+}
+static bool can_intr_global_msglost_check(void)
+{
+	if (can_mode_global.ctrl.enable_fifo_msglost == FALSE) {
+		return FALSE;
+	}
+	if (can_mode_global_is_msglost() == FALSE) {
+		return FALSE;
+	}
+	return TRUE;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/can_interrupt.h
@@ -0,0 +1,47 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _CAN_INTERRUPT_H_
+#define _CAN_INTERRUPT_H_
+
+extern void can_intr_run(void);
+
+#endif /* _CAN_INTERRUPT_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/can_mode_channel.c
@@ -0,0 +1,344 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "can_mode_global.h"
+#include "mapping/can_register_mapping_reset.h"
+
+static void can_mode_global_channel_event_set_run(CanModeGlobalType *gmode);
+static void can_mode_global_channel_event_set_test(CanModeGlobalType *gmode);
+static void can_mode_global_channel_event_set_stop(CanModeGlobalType *gmode);
+static void can_mode_global_channel_event_set_reset(CanModeGlobalType *gmode);
+
+static void can_mode_channel_reset(CanChannelIdType cid)
+{
+	can_register_reset_channel(CanRegisterResetType_CHANNEL_RESET, cid);
+	can_register_reset_tx_buffer_channel(cid);
+	can_register_reset_txrx_fifo_channel(cid);
+}
+
+
+void can_mode_global_channel_event(CanModeGlobalType *gmode, CanModeGlobalEventType event)
+{
+	switch (event) {
+	case CanModeGlobalEvent_CLR_STOP:
+		break;
+	case CanModeGlobalEvent_SET_STOP:
+		can_mode_global_channel_event_set_stop(gmode);
+		break;
+	case CanModeGlobalEvent_SET_RUN:
+		can_mode_global_channel_event_set_run(gmode);
+		break;
+	case CanModeGlobalEvent_SET_RESET:
+		can_mode_global_channel_event_set_reset(gmode);
+		break;
+	case CanModeGlobalEvent_SET_TEST:
+		can_mode_global_channel_event_set_test(gmode);
+		break;
+	default:
+		break;
+	}
+	return;
+}
+static void can_mode_global_channel_event_set_run(CanModeGlobalType *gmode)
+{
+	//nothing to do
+	return;
+}
+
+static void can_mode_global_channel_event_set_reset(CanModeGlobalType *gmode)
+{
+	CanChannelIdType cid;
+	for (cid = 0; cid < CAN_CHANNEL_NUM; cid++) {
+		can_mode_channel_event(&gmode->channel[cid], CanModeChannelEvent_SET_RESET);
+	}
+	return;
+}
+static void can_mode_global_channel_event_set_stop(CanModeGlobalType *gmode)
+{
+	CanChannelIdType cid;
+	for (cid = 0; cid < CAN_CHANNEL_NUM; cid++) {
+		can_mode_channel_event(&gmode->channel[cid], CanModeChannelEvent_SET_STOP);
+	}
+	return;
+}
+static void can_mode_global_channel_event_set_test(CanModeGlobalType *gmode)
+{
+	CanChannelIdType cid;
+	for (cid = 0; cid < CAN_CHANNEL_NUM; cid++) {
+		can_mode_channel_event(&gmode->channel[cid], CanModeChannelEvent_SET_WAIT);
+	}
+	return;
+}
+
+static void can_mode_channel_event_clr_stop(CanModeChannelType *cmode);
+static void can_mode_channel_event_set_stop(CanModeChannelType *cmode);
+static void can_mode_channel_event_set_comm(CanModeChannelType *cmode);
+static void can_mode_channel_event_set_wait(CanModeChannelType *cmode);
+static void can_mode_channel_event_set_reset(CanModeChannelType *cmode);
+static void can_mode_channel_event_comm_tx_start(CanModeChannelType *cmode);
+static void can_mode_channel_event_comm_tx_done(CanModeChannelType *cmode);
+static void can_mode_channel_event_comm_rx_start(CanModeChannelType *cmode);
+static void can_mode_channel_event_comm_rx_done(CanModeChannelType *cmode);
+
+void can_mode_channel_event(CanModeChannelType *cmode, CanModeChannelEventType event)
+{
+	switch (event) {
+	case CanModeChannelEvent_CLR_STOP:
+		can_mode_channel_event_clr_stop(cmode);
+		break;
+	case CanModeChannelEvent_SET_STOP:
+		can_mode_channel_event_set_stop(cmode);
+		break;
+	case CanModeChannelEvent_SET_COMM:
+		can_mode_channel_event_set_comm(cmode);
+		break;
+	case CanModeChannelEvent_SET_RESET:
+		can_mode_channel_event_set_reset(cmode);
+		break;
+	case CanModeChannelEvent_SET_WAIT:
+		can_mode_channel_event_set_wait(cmode);
+		break;
+	case CanModeChannelEvent_COMM_TX_START:
+		can_mode_channel_event_comm_tx_start(cmode);
+		break;
+	case CanModeChannelEvent_COMM_TX_DONE:
+		can_mode_channel_event_comm_tx_done(cmode);
+		break;
+	case CanModeChannelEvent_COMM_RX_START:
+		can_mode_channel_event_comm_rx_start(cmode);
+		break;
+	case CanModeChannelEvent_COMM_RX_DONE:
+		can_mode_channel_event_comm_rx_done(cmode);
+		break;
+	default:
+		break;
+	}
+	return;
+}
+static void can_mode_channel_event_clr_stop(CanModeChannelType *cmode)
+{
+	switch (cmode->mode) {
+	case ChannelMode_STOP:
+		cmode->ctrl.stop = FALSE;
+		can_mode_channel_reset(cmode->cid);
+		cmode->status.can_comm = FALSE;
+		cmode->status.receiving = FALSE;
+		cmode->status.sending = FALSE;
+		cmode->status.mode_stop = FALSE;
+		cmode->status.mode_reset = TRUE;
+		cmode->status.mode_wait = FALSE;;
+		cmode->mode = ChannelMode_RESET;
+		break;
+	default:
+		break;
+	}
+	return;
+}
+static void can_mode_channel_event_set_stop(CanModeChannelType *cmode)
+{
+	switch (cmode->mode) {
+	case ChannelMode_RESET:
+		cmode->ctrl.stop = TRUE;
+		cmode->mode = ChannelMode_STOP;
+		cmode->status.can_comm = FALSE;
+		cmode->status.receiving = FALSE;
+		cmode->status.sending = FALSE;
+		cmode->status.mode_stop = TRUE;
+		cmode->status.mode_reset = TRUE;
+		cmode->status.mode_wait = FALSE;
+		break;
+	default:
+		break;
+	}
+	return;
+}
+static void can_mode_channel_event_set_comm(CanModeChannelType *cmode)
+{
+	switch (cmode->mode) {
+	case ChannelMode_RESET:
+	case ChannelMode_WAIT:
+		cmode->mode = ChannelMode_COMM;
+		cmode->ctrl.select_mode = CAN_MODE_CHANNEL_MODE_COMM;
+		/*
+		 * 遷移後、 11 ビットの連続するレセシブを検出すると、 RSCAN1CmSTS レジス
+		 * タ（ m = 6）の COMSTS フラグが “1”（通信可能な状態）になり、 CAN ネットワーク上でア
+		 * クティブノードとして、送受信が許可されます。
+		 */
+		CAN_MODE_CHANNEL_COMM_MODE_SET_IDLE(cmode);
+		break;
+	default:
+		break;
+	}
+	return;
+}
+static void can_mode_channel_event_set_wait(CanModeChannelType *cmode)
+{
+	switch (cmode->mode) {
+	case ChannelMode_RESET:
+	case ChannelMode_COMM:
+		cmode->ctrl.select_mode = CAN_MODE_CHANNEL_MODE_WAIT;
+		/*
+		 * チャネル待機モードでチャネルのテスト関連レジスタの設定を行います。チャネル待機モー
+		 * ドに遷移すると、チャネルの CAN 通信は停止します。
+		 * 表 21.291 に CAN 通信中に CHMDC[1:0] ビットを “10B”（チャネル待機モード）に設定した
+		 * ときの動作を示します。
+		 */
+		/* 表 21.291 :
+		 * 受信の終了を待ってチャネル待機モードに遷移
+		 * 送信の終了を待ってチャネル待機モードに遷移
+		 */
+		if (cmode->comm_mode == ChannelModeComm_IDLE) {
+			cmode->mode = ChannelMode_WAIT;
+			cmode->status.can_comm = FALSE;
+			cmode->status.receiving = FALSE;
+			cmode->status.sending = FALSE;
+			cmode->status.mode_stop = FALSE;
+			cmode->status.mode_reset = FALSE;
+			cmode->status.mode_wait = TRUE;
+		}
+		break;
+	default:
+		break;
+	}
+	return;
+}
+static void can_mode_channel_event_set_reset(CanModeChannelType *cmode)
+{
+	switch (cmode->mode) {
+	case ChannelMode_COMM:
+	case ChannelMode_WAIT:
+		cmode->ctrl.select_mode = CAN_MODE_CHANNEL_MODE_RESET;
+		/*
+		 * CAN 通信中に RSCAN1CmCTR レジスタの CHMDC[1:0] ビットを “01B”（チャネルリセット
+		 * モード）にすると、送受信の完了を待たずに通信が中断され、チャネルリセットモードへ遷
+		 * 移します。 表 21.291 に CAN 通信中に CHMDC[1:0] ビットを “01B”（チャネルリセットモー
+		 * ド）に設定したときの動作を示します。
+		 */
+		/* 表 21.291 :
+		 * 受信の終了を待たずにチャネルリセットモードに遷移
+		 * 送信の終了を待たずにチャネルリセットモードに遷移
+		 */
+		can_mode_channel_reset(cmode->cid);
+		cmode->mode = ChannelMode_RESET;
+		CAN_MODE_CHANNEL_COMM_MODE_SET_IDLE(cmode);
+		cmode->status.can_comm = FALSE;
+		cmode->status.receiving = FALSE;
+		cmode->status.sending = FALSE;
+		cmode->status.mode_stop = FALSE;
+		cmode->status.mode_reset = TRUE;
+		cmode->status.mode_wait = FALSE;;
+		break;
+	default:
+		break;
+	}
+	return;
+}
+
+static void can_mode_channel_event_comm_tx_start(CanModeChannelType *cmode)
+{
+	switch (cmode->mode) {
+	case ChannelMode_COMM:
+		if (cmode->comm_mode == ChannelModeComm_IDLE) {
+			CAN_MODE_CHANNEL_COMM_MODE_SET_TX(cmode);
+		}
+		break;
+	default:
+		break;
+	}
+	return;
+}
+static void can_mode_channel_event_comm_tx_done(CanModeChannelType *cmode)
+{
+	switch (cmode->mode) {
+	case ChannelMode_COMM:
+		if (cmode->comm_mode == ChannelModeComm_TX) {
+			CAN_MODE_CHANNEL_COMM_MODE_SET_IDLE(cmode);
+			if (cmode->ctrl.select_mode == CAN_MODE_CHANNEL_MODE_WAIT) {
+				cmode->mode = ChannelMode_WAIT;
+				cmode->status.can_comm = FALSE;
+				cmode->status.receiving = FALSE;
+				cmode->status.sending = FALSE;
+				cmode->status.mode_stop = FALSE;
+				cmode->status.mode_reset = FALSE;
+				cmode->status.mode_wait = TRUE;
+			}
+		}
+		break;
+	default:
+		break;
+	}
+	return;
+}
+static void can_mode_channel_event_comm_rx_start(CanModeChannelType *cmode)
+{
+	switch (cmode->mode) {
+	case ChannelMode_COMM:
+		if (cmode->comm_mode == ChannelModeComm_IDLE) {
+			CAN_MODE_CHANNEL_COMM_MODE_SET_RX(cmode);
+		}
+		break;
+	default:
+		break;
+	}
+	return;
+}
+static void can_mode_channel_event_comm_rx_done(CanModeChannelType *cmode)
+{
+	switch (cmode->mode) {
+	case ChannelMode_COMM:
+		if (cmode->comm_mode == ChannelModeComm_RX) {
+			CAN_MODE_CHANNEL_COMM_MODE_SET_IDLE(cmode);
+			if (cmode->ctrl.select_mode == CAN_MODE_CHANNEL_MODE_WAIT) {
+				cmode->status.can_comm = FALSE;
+				cmode->status.receiving = FALSE;
+				cmode->status.sending = FALSE;
+				cmode->status.mode_stop = FALSE;
+				cmode->status.mode_reset = FALSE;
+				cmode->status.mode_wait = TRUE;;
+				cmode->mode = ChannelMode_WAIT;
+			}
+		}
+		break;
+	default:
+		break;
+	}
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/can_mode_channel.h
@@ -0,0 +1,125 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _CAN_MODE_CHANNEL_H_
+#define _CAN_MODE_CHANNEL_H_
+
+typedef enum {
+	ChannelMode_STOP = 0,
+	ChannelMode_RESET,
+	ChannelMode_WAIT,
+	ChannelMode_COMM,
+} ChannelModeType;
+
+typedef enum {
+	ChannelModeComm_IDLE = 0,
+	ChannelModeComm_RX,
+	ChannelModeComm_TX,
+} ChannelModeCommType;
+
+
+#define CAN_MODE_CHANNEL_MODE_COMM		0x0
+#define CAN_MODE_CHANNEL_MODE_RESET		0x1
+#define CAN_MODE_CHANNEL_MODE_WAIT		0x2
+typedef struct {
+	CanChannelIdType	cid;
+	ChannelModeType 	mode;
+	ChannelModeCommType	comm_mode;
+	struct {
+		bool	stop;			// CSLPR
+		uint8	select_mode;	// CHMDC[1:0]
+	} ctrl;	// RSCANnCmCTR
+	struct {
+		bool 	can_comm;		// COMSTS
+		bool 	receiving;		// RECSTS
+		bool 	sending;		// TRMSTS
+		bool	mode_stop;		// CSLPSTS
+		bool	mode_wait;		// CHLTSTS
+		bool	mode_reset;		// CRSTSTS
+	} status; // RSCANnCmSTS
+} CanModeChannelType;
+
+#define CAN_MODE_CHANNEL_COMM_MODE_SET_IDLE(cmode)	\
+do { 	\
+	(cmode)->comm_mode = ChannelModeComm_IDLE;	\
+	(cmode)->status.can_comm = TRUE;	\
+	(cmode)->status.sending = FALSE;	\
+	(cmode)->status.receiving = FALSE;	\
+	(cmode)->status.mode_stop = FALSE;	\
+	(cmode)->status.mode_wait = FALSE;	\
+	(cmode)->status.mode_reset = FALSE;	\
+} while (0)
+#define CAN_MODE_CHANNEL_COMM_MODE_SET_RX(cmode)	\
+do { 	\
+	(cmode)->comm_mode = ChannelModeComm_RX;	\
+	(cmode)->status.can_comm = TRUE;	\
+	(cmode)->status.sending = FALSE;	\
+	(cmode)->status.receiving = TRUE;	\
+	(cmode)->status.mode_stop = FALSE;	\
+	(cmode)->status.mode_wait = FALSE;	\
+	(cmode)->status.mode_reset = FALSE;	\
+} while (0)
+#define CAN_MODE_CHANNEL_COMM_MODE_SET_TX(cmode)	\
+do { 	\
+	(cmode)->comm_mode = ChannelModeComm_TX;	\
+	(cmode)->status.can_comm = TRUE;	\
+	(cmode)->status.sending = TRUE;	\
+	(cmode)->status.receiving = FALSE;	\
+	(cmode)->status.mode_stop = FALSE;	\
+	(cmode)->status.mode_wait = FALSE;	\
+	(cmode)->status.mode_reset = FALSE;	\
+} while (0)
+
+typedef enum {
+	CanModeChannelEvent_CLR_STOP = 0,
+	CanModeChannelEvent_SET_STOP,
+	CanModeChannelEvent_SET_COMM,
+	CanModeChannelEvent_SET_RESET,
+	CanModeChannelEvent_SET_WAIT,
+	CanModeChannelEvent_COMM_TX_START,
+	CanModeChannelEvent_COMM_TX_DONE,
+	CanModeChannelEvent_COMM_RX_START,
+	CanModeChannelEvent_COMM_RX_DONE,
+} CanModeChannelEventType;
+extern void can_mode_channel_event(CanModeChannelType *cmode, CanModeChannelEventType event);
+
+
+#endif /* _CAN_MODE_CHANNEL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/can_mode_global.c
@@ -0,0 +1,197 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "can_mode_global.h"
+#include "mapping/can_register_mapping_reset.h"
+
+static void can_mode_global_event_clr_stop(CanModeGlobalType *gmode);
+static void can_mode_global_event_set_stop(CanModeGlobalType *gmode);
+static void can_mode_global_event_set_run(CanModeGlobalType *gmode);
+static void can_mode_global_event_set_reset(CanModeGlobalType *gmode);
+static void can_mode_global_event_set_test(CanModeGlobalType *gmode);
+
+CanModeGlobalType can_mode_global;
+
+static void can_mode_globa_reset(void)
+{
+	CanChannelIdType cid;
+
+	can_register_reset_global(CanRegisterResetType_GLOBAL_RESET);
+	for (cid = 0; cid < CAN_CHANNEL_NUM; cid++) {
+		can_register_reset_channel(CanRegisterResetType_GLOBAL_RESET, cid);
+	}
+	can_register_reset_fifo_status(CanRegisterResetType_GLOBAL_RESET);
+	can_register_reset_rx_rule(CanRegisterResetType_GLOBAL_RESET);
+	can_register_reset_rx_buffer(CanRegisterResetType_GLOBAL_RESET);
+	can_register_reset_rx_fifo(CanRegisterResetType_GLOBAL_RESET);
+	can_register_reset_tx_buffer(CanRegisterResetType_GLOBAL_RESET);
+	can_register_reset_tx_buffer_status(CanRegisterResetType_GLOBAL_RESET);
+	can_register_reset_txrx_fifo(CanRegisterResetType_GLOBAL_RESET);
+
+}
+
+void can_mode_global_event(CanModeGlobalType *gmode, CanModeGlobalEventType event)
+{
+	switch (event) {
+	case CanModeGlobalEvent_CLR_STOP:
+		can_mode_global_event_clr_stop(gmode);
+		break;
+	case CanModeGlobalEvent_SET_STOP:
+		can_mode_global_event_set_stop(gmode);
+		break;
+	case CanModeGlobalEvent_SET_RUN:
+		can_mode_global_event_set_run(gmode);
+		break;
+	case CanModeGlobalEvent_SET_RESET:
+		can_mode_global_event_set_reset(gmode);
+		break;
+	case CanModeGlobalEvent_SET_TEST:
+		can_mode_global_event_set_test(gmode);
+		break;
+	default:
+		break;
+	}
+	return;
+}
+static void can_mode_global_event_clr_stop(CanModeGlobalType *gmode)
+{
+	switch (gmode->mode) {
+	case GlobalMode_STOP:
+		gmode->ctrl.stop = FALSE;
+		can_mode_global_channel_event(gmode, CanModeGlobalEvent_CLR_STOP);
+		can_mode_globa_reset();
+		gmode->mode = GlobalMode_RESET;
+		gmode->status.GSLPSTS = FALSE;
+		gmode->status.GHLTSTS = FALSE;
+		gmode->status.GRSTSTS = TRUE;
+		break;
+	default:
+		break;
+	}
+	return;
+}
+static void can_mode_global_event_set_stop(CanModeGlobalType *gmode)
+{
+	switch (gmode->mode) {
+	case GlobalMode_RESET:
+		gmode->ctrl.stop = TRUE;
+		/*
+		 * 各 RSCAN1CmCTR レジスタの CSLPR ビットが “1”（チャネルストップモード）
+		 * になります。その後、すべてのチャネルが強制的にチャネルストップモードへ遷移すると、
+		 * グローバルストップモードになります。
+		 */
+		can_mode_global_channel_event(gmode, CanModeGlobalEvent_SET_STOP);
+		gmode->mode = GlobalMode_STOP;
+		gmode->status.GSLPSTS = TRUE;
+		gmode->status.GHLTSTS = FALSE;
+		gmode->status.GRSTSTS = TRUE;
+		break;
+	default:
+		break;
+	}
+	return;
+}
+static void can_mode_global_event_set_run(CanModeGlobalType *gmode)
+{
+	switch (gmode->mode) {
+	case GlobalMode_TEST:
+	case GlobalMode_RESET:
+		gmode->ctrl.select_mode = CAN_MODE_GLOBAL_MODE_RUN;
+		can_mode_global_channel_event(gmode, CanModeGlobalEvent_SET_RUN);
+		gmode->mode = GlobalMode_RUN;
+		gmode->status.GSLPSTS = FALSE;
+		gmode->status.GHLTSTS = FALSE;
+		gmode->status.GRSTSTS = FALSE;
+		break;
+	default:
+		break;
+	}
+	return;
+}
+static void can_mode_global_event_set_reset(CanModeGlobalType *gmode)
+{
+	switch (gmode->mode) {
+	case GlobalMode_RUN:
+	case GlobalMode_TEST:
+		gmode->ctrl.select_mode = CAN_MODE_GLOBAL_MODE_RESET;
+		/*
+		 * RSCAN1GCTR レジスタの GMDC[1:0] ビットを “01B” に設定すると、各 RSCAN1CmCTR レ
+		 * ジスタ（ m = 6）の CHMDC[1:0] ビットが “01B”（チャネルリセットモード）になります。す
+		 * べてのチャネルが強制的にチャネルリセットモードへ遷移すると、グローバルリセットモー
+		 * ドになります。すでにチャネルリセットモードまたはチャネルストップモードであるチャネ
+		 * ルはモード遷移しません（ CHMDC[1:0] ビットがすでに “01B” に設定されているため）。
+		 */
+		can_mode_global_channel_event(gmode, CanModeGlobalEvent_SET_RESET);
+		can_mode_globa_reset();
+		gmode->mode = GlobalMode_RESET;
+		gmode->status.GSLPSTS = FALSE;
+		gmode->status.GHLTSTS = FALSE;
+		gmode->status.GRSTSTS = TRUE;
+		break;
+	default:
+		break;
+	}
+	return;
+}
+static void can_mode_global_event_set_test(CanModeGlobalType *gmode)
+{
+	switch (gmode->mode) {
+	case GlobalMode_RESET:
+	case GlobalMode_RUN:
+		gmode->ctrl.select_mode = CAN_MODE_GLOBAL_MODE_WAIT;
+		/*
+		 * RSCAN1GCTR レジスタの GMDC[1:0] ビット を “10B” に設定すると、各 RSCAN1CmCTR レ
+		 * ジスタの CHMDC[1:0] ビットが “10B”（チャネル待機モード）になります。すべてのチャネ
+		 * ルが強制的にチャネル待機モードへ遷移すると、グローバルテストモードになります。チャ
+		 * ネルストップモード、チャネルリセットモード、またはチャネル待機モードであるチャネル
+		 * は、モード遷移しません。
+		 */
+		can_mode_global_channel_event(gmode, CanModeGlobalEvent_SET_TEST);
+		gmode->mode = GlobalMode_TEST;
+		gmode->status.GSLPSTS = FALSE;
+		gmode->status.GHLTSTS = TRUE;
+		gmode->status.GRSTSTS = FALSE;
+		break;
+	default:
+		break;
+	}
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/can_mode_global.h
@@ -0,0 +1,127 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _CAN_MODE_GLOBAL_H_
+#define _CAN_MODE_GLOBAL_H_
+
+#include "can_types.h"
+#include "can_mode_channel.h"
+
+typedef enum {
+	GlobalMode_STOP = 0,
+	GlobalMode_RESET,
+	GlobalMode_RUN,
+	GlobalMode_TEST,
+} GlobalModeType;
+
+#define CAN_MODE_GLOBAL_MODE_RUN		0x0
+#define CAN_MODE_GLOBAL_MODE_RESET		0x1
+#define CAN_MODE_GLOBAL_MODE_WAIT		0x2
+typedef struct {
+	GlobalModeType	mode;
+	struct {
+		/* not supported ITRCP [15:0] */
+		/* not supported TSBTCS[2:0] */
+		/* not supported TSSS */
+		/* not supported TSP[3:0] */
+		/* not supported TMTSCE */
+		/* not supported EEFE */
+		/* not supported DCS */
+		/* not supported MME */
+		/* not supported DRE */
+		bool enable_dlc_check;		// DCE
+		bool enable_tx_bufno_first; // TPRI
+	} config; // RSCANnGCFG
+	struct {
+		/* not supported TSRST */
+		bool	enable_tx_history;		// THLEIE
+		bool	enable_dlc_error;		// DEIE
+		bool	enable_fifo_msglost;	// MEIE
+		bool	stop;					// GSLPR
+		uint8	select_mode; 			// GMDC[1:0]
+	} ctrl; // RSCANnGCTR
+	struct {
+		// not supported GRAMINIT
+		bool	GSLPSTS;	// GSLPSTS
+		bool	GHLTSTS;	// GHLTSTS
+		bool	GRSTSTS;	// GRSTSTS
+		bool	dlc_error;				// RSCANnGERFL.DEF
+	} status; // RSCANnGSTS
+
+	CanModeChannelType channel[CAN_CHANNEL_NUM];
+} CanModeGlobalType;
+
+
+
+typedef enum {
+	CanModeGlobalEvent_CLR_STOP = 0,
+	CanModeGlobalEvent_SET_STOP,
+	CanModeGlobalEvent_SET_RUN,
+	CanModeGlobalEvent_SET_RESET,
+	CanModeGlobalEvent_SET_TEST,
+} CanModeGlobalEventType;
+extern void can_mode_global_event(CanModeGlobalType *gmode, CanModeGlobalEventType event);
+extern void can_mode_global_channel_event(CanModeGlobalType *gmode, CanModeGlobalEventType event);
+
+extern CanModeGlobalType can_mode_global;
+#include "can_fifo.h"
+static inline bool can_mode_global_is_msglost(void)
+{
+	CanChannelIdType cid;
+	uint32 bid;
+	uint32 x;
+
+	for (cid = 0; cid < CAN_CHANNEL_NUM; cid++) {
+		for (bid = 0; bid < CAN_TXRX_CHANNEL_FIFO_NUM; bid++) {
+			if (can_txrx_fifo_control.buf[cid][bid].status.txrx_lost == TRUE) {
+				return TRUE;
+			}
+		}
+	}
+	for (x = 0; x < CAN_RX_FIFO_NUM; x++) {
+		if (can_rx_fifo_control.fifo[x].status.rx_lost == TRUE) {
+			return TRUE;
+		}
+	}
+	return FALSE;
+}
+
+#endif /* _CAN_MODE_GLOBAL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/can_rule.h
@@ -0,0 +1,101 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _CAN_RULE_H_
+#define _CAN_RULE_H_
+
+#include "can_types.h"
+
+typedef struct {
+	struct {
+		bool 	ide; 		// GAFLIDE
+		bool 	rtr;		// GAFLRTR
+		uint32	canid;		// GAFLID[28:0]
+	} id;					// RSCANnGAFLIDj
+	struct {
+		bool	ide;		// GAFLIDEM
+		bool	rtr;		// GAFLRTRM
+		uint32	canid;		// GAFLIDM
+	} mask;					// RSCANnGAFLMj
+	struct {
+		uint8	dlc;				// GAFLDLC[3:0]
+		uint16	label;				// GAFLPTR[11:0]
+		bool	enable_rxbuffer;	// GAFLRMV
+		uint8	rxbuffer_number;	// GAFLRMDP[6:0]
+	} filter_buffer;				// RSCANnGAFLP0j
+	struct {
+		/*
+		 * k = 0 - (m * 3) + 2
+		 */
+		uint32	txrx_fifo;			// GAFLFDP[25:8]
+		uint8	rx_fifo;			// GAFLFDP [7:0]
+	} filter_fifo;					// RSCANnGAFLP1j
+} CanRxRuleType;
+
+#define CAN_TXRXFIFO_CHANNEL_ID(txrxfifo_id)	( (txrxfifo_id) / CAN_TXRX_CHANNEL_FIFO_NUM )
+#define CAN_TXRXFIFO_BUFFER_ID(txrxfifo_id)		( (txrxfifo_id) % CAN_TXRX_CHANNEL_FIFO_NUM )
+#define CAN_TXRXFIFO_BITMASK(cid, bid)			( 1U << ( (CAN_TXRX_CHANNEL_FIFO_NUM * (cid)) + (bid) ) )
+
+typedef struct {
+	CanRxRuleType	rule[CAN_RX_PAGE_RULE_NUM];
+} CanRxPageType;
+
+typedef struct {
+	struct {
+		bool	enable_write;	// AFLDAE
+		uint8	page_number;	// AFLPN [4:0]
+	} ctrl; // RSCANnGAFLECTR
+	CanRxPageType	page[CAN_RX_RULE_TABLE_PAGE_NUM];
+} CanRxRuleTableType;
+
+#define CAN_RX_GET_PAGEID(rule_id)	( (rule_id) / CAN_RX_PAGE_RULE_NUM )
+#define CAN_RX_GET_PAGEIDX(rule_id)	( (rule_id) % CAN_RX_PAGE_RULE_NUM )
+
+typedef struct {
+	uint32			channel_rx_rule_num[CAN_CHANNEL_NUM];
+} CanRxRuleNumType;					// RSCANnGAFLCFG0, RSCANnGAFLCFG1
+
+extern CanRxRuleNumType 	can_rx_number;
+extern CanRxRuleTableType	can_rx_rule_table;
+
+extern void can_rx_update_rule_table(void);
+
+#endif /* _CAN_RULE_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/can_rx.c
@@ -0,0 +1,246 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "can_rx.h"
+#include "can_buffer.h"
+#include "can_fifo.h"
+
+
+CanRxRuleNumType 	can_rx_number;
+CanRxRuleTableType	can_rx_rule_table;
+
+typedef struct {
+	uint32			rule_num;
+	CanRxRuleType	*rule[CAN_RX_RULE_TABLE_PAGE_NUM * CAN_RX_PAGE_RULE_NUM];
+} CanRxChannelRuleType;
+
+typedef struct {
+	CanRxRuleTableType	*rule_table;
+	CanChannelIdType	cid;
+	CanRxRuleType 		*rule;
+	CanDataType 		*received_data;
+	bool				filter_result;
+	bool				filter_acceptance;
+	bool				filter_dlc;
+} CanRxProcDataType;
+
+static void can_rx_proc_one(CanRxProcDataType *proc_data);
+/*
+ * Filter Process
+ */
+static void can_rx_proc_filter(CanRxProcDataType *proc_data);
+static void can_rx_proc_filter_acceptance(CanRxProcDataType *proc_data);
+static void can_rx_proc_filter_dlc(CanRxProcDataType *proc_data);
+
+/*
+ * Routing Process
+ */
+static void can_rx_proc_routing(CanRxProcDataType *proc_data);
+
+static CanRxChannelRuleType can_rx_channel_rule[CAN_CHANNEL_NUM];
+static CanBusOperationType *canbus_rx_operation;
+static CanModeGlobalType *can_rx_mode_global;
+
+void can_rx_init(CanBusOperationType *canbus_op)
+{
+	can_rx_mode_global = &can_mode_global;
+	canbus_rx_operation = &can_bus_operation_impl_ros;
+
+	can_rx_update_rule_table();
+	return;
+}
+void can_rx_update_rule_table(void)
+{
+	uint32 rid;
+	uint32 cid;
+	uint32 count;
+	rid = 0;
+	for (cid = 0; cid < CAN_CHANNEL_NUM; cid++) {
+		can_rx_channel_rule[cid].rule_num = can_rx_number.channel_rx_rule_num[cid];
+		for (count = 0; count < can_rx_channel_rule[cid].rule_num; count++) {
+			uint32 pid = CAN_RX_GET_PAGEID(rid);
+			uint32 pidx = CAN_RX_GET_PAGEIDX(rid);
+			can_rx_channel_rule[cid].rule[count] = &can_rx_rule_table.page[pid].rule[pidx];
+			rid++;
+		}
+	}
+}
+
+void can_rx_proc(void)
+{
+	uint32 cid;
+	uint32 count;
+	CanRxProcDataType proc_data;
+	CanDataType data;
+
+	if (can_rx_mode_global->mode != GlobalMode_RUN) {
+		return;
+	}
+
+	proc_data.rule_table = &can_rx_rule_table;
+	for (cid = 0; cid < CAN_CHANNEL_NUM; cid++) {
+		if (canbus_rx_operation->rx.is_arrived(cid) == FALSE) {
+			continue;
+		}
+
+		if (can_rx_mode_global->channel[cid].mode != ChannelMode_COMM) {
+			continue;
+		}
+		can_mode_channel_event(&can_rx_mode_global->channel[cid], CanModeChannelEvent_COMM_RX_START);
+		if (can_rx_mode_global->channel[cid].comm_mode != ChannelModeComm_RX) {
+			continue;
+		}
+
+		(void)canbus_rx_operation->rx.receive(cid, &data);
+		proc_data.received_data = &data;
+		proc_data.cid = cid;
+		for (count = 0; count < can_rx_channel_rule[cid].rule_num; count++) {
+			proc_data.rule = can_rx_channel_rule[cid].rule[count];
+			can_rx_proc_one(&proc_data);
+		}
+		can_mode_channel_event(&can_rx_mode_global->channel[cid], CanModeChannelEvent_COMM_RX_DONE);
+	}
+	return;
+}
+
+/********************************************************
+ * Private methods
+ ********************************************************/
+static void can_rx_proc_one(CanRxProcDataType *proc_data)
+{
+	can_rx_proc_filter(proc_data);
+	if (proc_data->filter_result == FALSE) {
+		return;
+	}
+
+	can_rx_proc_routing(proc_data);
+	return;
+}
+
+static void can_rx_proc_filter(CanRxProcDataType *proc_data)
+{
+	proc_data->filter_result = FALSE;
+	proc_data->filter_acceptance = FALSE;
+	proc_data->filter_dlc = FALSE;
+
+	can_rx_proc_filter_acceptance(proc_data);
+	if (proc_data->filter_acceptance == FALSE) {
+		return;
+	}
+
+	(void)can_rx_proc_filter_dlc(proc_data);
+	if (proc_data->filter_dlc == FALSE) {
+		return;
+	}
+	proc_data->filter_result = TRUE;
+	return;
+}
+
+
+static void can_rx_proc_filter_acceptance(CanRxProcDataType *proc_data)
+{
+	if (proc_data->rule->mask.ide != FALSE) {
+		if (proc_data->rule->id.ide != proc_data->received_data->ide) {
+			return;
+		}
+	}
+	if (proc_data->rule->mask.rtr != FALSE) {
+		if (proc_data->rule->id.rtr != proc_data->received_data->rtr) {
+			return;
+		}
+	}
+	if (proc_data->rule->mask.canid != 0U) {
+		if ((proc_data->rule->id.canid &  proc_data->rule->mask.canid) != (proc_data->received_data->id & proc_data->rule->mask.canid)) {
+			return;
+		}
+	}
+	proc_data->filter_acceptance = TRUE;
+	return;
+}
+static void can_rx_proc_filter_dlc(CanRxProcDataType *proc_data)
+{
+	if (can_rx_mode_global->config.enable_dlc_check == FALSE) {
+		proc_data->filter_dlc = TRUE;
+	}
+	else if (proc_data->rule->filter_buffer.dlc != 0) {
+		if (proc_data->received_data->dlc < proc_data->rule->filter_buffer.dlc) {
+			can_rx_mode_global->status.dlc_error = TRUE;
+			proc_data->filter_dlc = FALSE;
+		}
+		else {
+			proc_data->filter_dlc = TRUE;
+		}
+	}
+	else { /* proc_data->rule->filter_buffer.dlc == 0 */
+		proc_data->filter_dlc = TRUE;
+	}
+	return;
+}
+
+static void can_rx_proc_routing(CanRxProcDataType *proc_data)
+{
+	CanBufferIdType rxfifo_id;
+	CanBufferIdxType txrxfifo_id;
+
+	/*
+	 * ラベル付加する
+	 */
+	proc_data->received_data->label = proc_data->rule->filter_buffer.label;
+	if (proc_data->rule->filter_buffer.enable_rxbuffer == TRUE) {
+		(void)can_rxbuffer_put_rxdata(proc_data->cid, proc_data->rule->filter_buffer.rxbuffer_number, proc_data->received_data);
+	}
+	if (proc_data->rule->filter_fifo.rx_fifo != 0) {
+		for (rxfifo_id = 0; rxfifo_id < CAN_RX_FIFO_NUM; rxfifo_id++) {
+			if ( ((1U << rxfifo_id) & proc_data->rule->filter_fifo.rx_fifo) != 0U) {
+				(void)can_rxfifo_put_rxdata(proc_data->cid, rxfifo_id, proc_data->received_data);
+			}
+		}
+	}
+	if (proc_data->rule->filter_fifo.txrx_fifo != 0) {
+		for (txrxfifo_id = 0; txrxfifo_id < CAN_TXRX_CHANNEL_FIFO_NUM; txrxfifo_id++) {
+			if ( (CAN_TXRXFIFO_BITMASK(proc_data->cid, txrxfifo_id) & proc_data->rule->filter_fifo.txrx_fifo) != 0U) {
+				(void)can_txrxfifo_put_rxdata(proc_data->cid, txrxfifo_id, proc_data->received_data);
+			}
+		}
+	}
+
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/can_rx.h
@@ -0,0 +1,54 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _CAN_RX_H_
+#define _CAN_RX_H_
+
+#include "can_rule.h"
+#include "can_data.h"
+#include "canbus/can_bus.h"
+#include "can_mode_global.h"
+
+extern void can_rx_init(CanBusOperationType *canbus_op);
+extern void can_rx_proc(void);
+
+
+#endif /* _CAN_RX_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/can_tx.c
@@ -0,0 +1,333 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "can_tx.h"
+
+typedef struct {
+	CanModeGlobalType 			*can_mode_global;
+	CanTxRxFifoControlType		*can_tx_fifo;
+	CanTxBufferControlType		*can_tx_buffer;
+	struct {
+		CanBufferIdxType bufidx;
+		CanDataType txdata;
+		CanTxHistoryDataType	history;
+		Std_ReturnType (*get_txdata) (CanChannelIdType cid, CanBufferIdxType txbufno, CanDataType *txdata);
+		Std_ReturnType (*notify_txdone) (CanChannelIdType cid, CanBufferIdxType txbufno);
+	} txreq[CAN_CHANNEL_NUM];
+} CanTxControlType;
+
+static CanTxControlType can_tx_control;
+
+static Std_ReturnType can_tx_select_buffer_prio_bufno(CanChannelIdType cid);
+static Std_ReturnType can_tx_select_buffer_prio_standard(CanChannelIdType cid);
+static Std_ReturnType can_tx_select_buffer(CanChannelIdType cid);
+static Std_ReturnType can_tx_send(CanChannelIdType cid);
+
+static CanBusOperationType *canbus_tx_operation;
+static CanModeGlobalType *can_tx_mode_global;
+void can_tx_init(CanBusOperationType *canbus_op)
+{
+	can_tx_mode_global = &can_mode_global;
+	canbus_tx_operation = canbus_op;
+	can_tx_control.can_mode_global = &can_mode_global;
+	can_tx_control.can_tx_fifo = &can_txrx_fifo_control;
+	can_tx_control.can_tx_buffer = &can_tx_buffer_control;
+	return;
+}
+
+void can_tx_proc(void)
+{
+	Std_ReturnType err;
+	CanChannelIdType cid;
+
+	if (can_tx_mode_global->mode != GlobalMode_RUN) {
+		return;
+	}
+
+	for (cid = 0; cid < CAN_CHANNEL_NUM; cid++) {
+		if (can_tx_mode_global->channel[cid].mode != ChannelMode_COMM) {
+			continue;
+		}
+		if (can_tx_mode_global->channel[cid].comm_mode != ChannelModeComm_IDLE) {
+			continue;
+		}
+		err = can_tx_select_buffer(cid);
+		if (err != STD_E_OK) {
+			continue;
+		}
+		can_mode_channel_event(&can_tx_mode_global->channel[cid], CanModeChannelEvent_COMM_TX_START);
+		if (can_tx_mode_global->channel[cid].comm_mode != ChannelModeComm_TX) {
+			continue;
+		}
+		(void)can_tx_send(cid);
+	}
+	return;
+}
+
+void can_tx_done(void)
+{
+	Std_ReturnType err;
+	CanChannelIdType cid;
+
+	if (can_tx_mode_global->mode != GlobalMode_RUN) {
+		return;
+	}
+
+	for (cid = 0; cid < CAN_CHANNEL_NUM; cid++) {
+		if (can_tx_mode_global->channel[cid].mode != ChannelMode_COMM) {
+			continue;
+		}
+		if (can_tx_mode_global->channel[cid].comm_mode != ChannelModeComm_TX) {
+			continue;
+		}
+		if (canbus_tx_operation->tx.is_done(cid) == FALSE) {
+			continue;
+		}
+		err = can_tx_control.txreq[cid].notify_txdone(cid, can_tx_control.txreq[cid].bufidx);
+		if (err == STD_E_OK) {
+			can_tx_control.txreq[cid].get_txdata = NULL;
+			can_tx_control.txreq[cid].notify_txdone = NULL;
+			can_mode_channel_event(&can_tx_mode_global->channel[cid], CanModeChannelEvent_COMM_TX_DONE);
+		}
+	}
+	return;
+}
+
+
+static Std_ReturnType can_tx_select_buffer(CanChannelIdType cid)
+{
+	can_tx_control.txreq[cid].get_txdata = NULL;
+	can_tx_control.txreq[cid].notify_txdone = NULL;
+	if (can_tx_control.can_mode_global->config.enable_tx_bufno_first == TRUE) {
+		return can_tx_select_buffer_prio_bufno(cid);
+	}
+	else {
+		return can_tx_select_buffer_prio_standard(cid);
+	}
+}
+/*
+  * 送信要求があるバッファの中で、最も小さいバッファ番号
+ * の送信バッファのメッセージが最初に送信されます。送受信 FIFO バッファが送信バッファ
+ * にリンクしている場合は、リンク先の送信バッファ番号で判定されます。
+ */
+static Std_ReturnType can_tx_select_buffer_prio_bufno(CanChannelIdType cid)
+{
+	CanBufferIdType min_tx_bufno = CAN_TX_BUFFER_ID(CAN_CHANNEL_NUM, CAN_TX_CHANNEL_BUFFER_NUM);
+	CanBufferIdxType bufno;
+	bool is_tx_buffer = TRUE;
+
+	/*
+	 * 送信バッファ
+	 */
+	for (bufno = 0; bufno < CAN_TX_CHANNEL_BUFFER_NUM; bufno++) {
+		if (can_tx_control.can_tx_buffer->buf[cid][bufno].ctrl.req_tx == TRUE) {
+			min_tx_bufno = CAN_TX_BUFFER_ID(cid, bufno);
+			break;
+		}
+	}
+	/*
+	 * 送受信FIFOバッファ
+	 */
+	for (bufno = 0; bufno < CAN_TXRX_CHANNEL_FIFO_NUM; bufno++) {
+		if (can_tx_control.can_tx_fifo->buf[cid][bufno].config.mode != CAN_TXRX_FIFO_MODE_TX) {
+			continue;
+		}
+		if (can_tx_control.can_tx_fifo->buf[cid][bufno].fifo_control.count <= 0) {
+			continue;
+		}
+		if (CAN_TX_BUFFER_ID(cid, can_tx_control.can_tx_fifo->buf[cid][bufno].config.tx_bufno) < min_tx_bufno) {
+			min_tx_bufno = can_tx_control.can_tx_fifo->buf[cid][bufno].config.tx_bufno;
+			is_tx_buffer = FALSE;
+		}
+	}
+	if (min_tx_bufno == CAN_TX_BUFFER_ID(CAN_CHANNEL_NUM, CAN_TX_CHANNEL_BUFFER_NUM)) {
+		return STD_E_NOENT;
+	}
+
+	can_tx_control.txreq[cid].bufidx = CAN_TX_BUFFER_IDX(min_tx_bufno);
+	if (is_tx_buffer == TRUE) {
+		can_tx_control.txreq[cid].history.buftype = CAN_TX_HISTORY_BUFTYPE_BUFFER;
+		can_tx_control.txreq[cid].history.bufno = min_tx_bufno;
+		can_tx_control.txreq[cid].get_txdata = can_txbuffer_get_txdata;
+		can_tx_control.txreq[cid].notify_txdone = can_txbuffer_notify_txdone;
+	}
+	else {
+		can_tx_control.txreq[cid].history.buftype = CAN_TX_HISTORY_BUFTYPE_FIFO;
+		can_tx_control.txreq[cid].history.bufno = ( (cid * CAN_TXRX_CHANNEL_FIFO_NUM) + bufno );
+		can_tx_control.txreq[cid].get_txdata = can_txrxfifo_get_txdata;
+		can_tx_control.txreq[cid].notify_txdone = can_txrxfifo_notify_txdone;
+	}
+	can_tx_control.txreq[cid].history.label = can_tx_control.txreq[cid].txdata.label;
+	return STD_E_OK;
+}
+/*
+ * アービトレーション仕様
+ *
+ * (1) IDの優先順位
+ *     IDの値が小さい方が優先度が高い
+ *
+ * (2) data frame and remote frame 優先順位
+ *     データフレームの方が優先度が高い
+ *
+ * (3) standard format と extended format の優先順位
+ *     標準フォーマットの方が優先度が高い
+ *
+ */
+
+static uint32 can_get_check_id(CanDataType *data)
+{
+	uint32 checkid;
+	uint32 stdid = (data->id & 0x7FF);/* 0:10 */
+	uint32 extid = (data->id & 0x1FFFF800); /* 13:30 */
+
+	checkid = stdid;
+	if (data->ide == TRUE) {
+		checkid |= (1U << 11U); /* SRR */
+		checkid |= (1U << 12U); /* IDE */
+		checkid |= (extid << 13U); /* extid */
+		if (data->rtr == TRUE) {
+			checkid |= (1U << 31U); /* RTR */
+		}
+	}
+	else {
+		if (data->rtr == TRUE) {
+			checkid |= (1U << 11U); /* RTR */
+		}
+	}
+	return checkid;
+}
+
+static Std_ReturnType can_tx_select_buffer_prio_standard(CanChannelIdType cid)
+{
+	CanBufferIdxType candidate_bufno = -1;
+	CanBufferIdxType bufno;
+	uint32 min_id = -1;
+	uint32 checkid;
+	CanDataType data;
+	uint8 buftype = -1;
+	/*
+	 * 送信バッファ
+	 */
+	for (bufno = 0; bufno < CAN_TX_CHANNEL_BUFFER_NUM; bufno++) {
+		if (can_tx_control.can_tx_buffer->buf[cid][bufno].ctrl.req_tx == TRUE) {
+			if (can_txbuffer_peek_txdata(cid, bufno, &data) != STD_E_OK) {
+				continue;
+			}
+			checkid = can_get_check_id(&data);
+			if (checkid < min_id) {
+				min_id = checkid;
+				candidate_bufno = bufno;
+				buftype = CAN_TX_HISTORY_BUFTYPE_BUFFER;
+			}
+		}
+	}
+	/*
+	 * 送受信FIFOバッファ
+	 */
+	for (bufno = 0; bufno < CAN_TXRX_CHANNEL_FIFO_NUM; bufno++) {
+		if (can_txrxfifo_peek_txdata(cid, bufno, &data) != STD_E_OK) {
+			continue;
+		}
+		checkid = can_get_check_id(&data);
+		if (checkid < min_id) {
+			min_id = checkid;
+			candidate_bufno = bufno;
+			buftype = CAN_TX_HISTORY_BUFTYPE_FIFO;
+		}
+	}
+	if (can_tx_queue[cid].config.enable_queue == TRUE) {
+		// 送信キュー
+		for (bufno = 0; bufno < CAN_TX_CHANNEL_BUFFER_NUM; bufno++) {
+			if (can_txque_peek_txdata(cid, bufno, &data) != STD_E_OK) {
+				continue;
+			}
+			checkid = can_get_check_id(&data);
+			if (checkid < min_id) {
+				min_id = checkid;
+				candidate_bufno = bufno;
+				buftype = CAN_TX_HISTORY_BUFTYPE_QUEUE;
+			}
+		}
+	}
+
+	if (min_id == -1) {
+		return STD_E_NOENT;
+	}
+	can_tx_control.txreq[cid].bufidx = candidate_bufno;
+	if (buftype == CAN_TX_HISTORY_BUFTYPE_BUFFER) {
+		can_tx_control.txreq[cid].history.buftype = CAN_TX_HISTORY_BUFTYPE_BUFFER;
+		can_tx_control.txreq[cid].history.bufno = CAN_TX_BUFFER_ID(cid, candidate_bufno);
+		can_tx_control.txreq[cid].get_txdata = can_txbuffer_get_txdata;
+		can_tx_control.txreq[cid].notify_txdone = can_txbuffer_notify_txdone;
+	}
+	else if (buftype == CAN_TX_HISTORY_BUFTYPE_FIFO) {
+		can_tx_control.txreq[cid].history.buftype = CAN_TX_HISTORY_BUFTYPE_FIFO;
+		can_tx_control.txreq[cid].history.bufno = ( (cid * CAN_TXRX_CHANNEL_FIFO_NUM) + candidate_bufno );
+		can_tx_control.txreq[cid].get_txdata = can_txrxfifo_get_txdata;
+		can_tx_control.txreq[cid].notify_txdone = can_txrxfifo_notify_txdone;
+	}
+	else {
+		can_tx_control.txreq[cid].history.buftype = CAN_TX_HISTORY_BUFTYPE_QUEUE;
+		can_tx_control.txreq[cid].history.bufno = CAN_TX_BUFFER_ID(cid, candidate_bufno);
+		can_tx_control.txreq[cid].get_txdata = can_txque_get_txdata;
+		can_tx_control.txreq[cid].notify_txdone = can_txque_notify_txdone;
+	}
+	can_tx_control.txreq[cid].history.label = can_tx_control.txreq[cid].txdata.label;
+	return STD_E_OK;
+}
+
+static Std_ReturnType can_tx_send(CanChannelIdType cid)
+{
+	Std_ReturnType err;
+
+	err = can_tx_control.txreq[cid].get_txdata(cid, can_tx_control.txreq[cid].bufidx, &can_tx_control.txreq[cid].txdata);
+	if (err != STD_E_OK) {
+		printf("ERROR: can_tx_send()/get_txdata(): cid=%u bufidx=%u err=%d\n", cid, can_tx_control.txreq[cid].bufidx, err);
+		return err;
+	}
+	err = canbus_tx_operation->tx.start_send(cid, &can_tx_control.txreq[cid].txdata);
+	if (err != STD_E_OK) {
+		printf("ERROR: can_tx_send()/start_send(): cid=%u bufidx=%u err=%d\n", cid, can_tx_control.txreq[cid].bufidx, err);
+		return err;
+	}
+	can_txhl_put_thldata(cid, &can_tx_control.txreq[cid].history);
+	return STD_E_OK;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/can_tx.h
@@ -0,0 +1,56 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _CAN_TX_H_
+#define _CAN_TX_H_
+
+#include "can_buffer.h"
+#include "can_fifo.h"
+#include "can_tx_queue.h"
+#include "can_mode_global.h"
+#include "canbus/can_bus.h"
+#include "can_tx_history.h"
+
+extern void can_tx_init(CanBusOperationType *canbus_op);
+extern void can_tx_proc(void);
+extern void can_tx_done(void);
+
+#endif /* _CAN_TX_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/can_tx_history.c
@@ -0,0 +1,107 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "can_tx_history.h"
+
+CanTxHistoryType can_tx_history[CAN_CHANNEL_NUM];
+
+Std_ReturnType can_txhl_put_thldata(CanChannelIdType cid, CanTxHistoryDataType *thldata)
+{
+	if (can_tx_history[cid].config.enable_history == FALSE) {
+		return STD_E_INVALID;
+	}
+	if (can_tx_history[cid].fifo_control.count >= CAN_TX_HISTORY_BUFFER_NUM) {
+		can_tx_history[cid].status.thl_ovr = TRUE;
+		return STD_E_LIMIT;
+	}
+	can_tx_history[cid].buffer[can_tx_history[cid].fifo_control.woff] = *thldata;
+	can_tx_history[cid].fifo_control.count++;
+	can_tx_history[cid].fifo_control.woff++;
+	if (can_tx_history[cid].fifo_control.woff >= CAN_TX_HISTORY_BUFFER_NUM) {
+		can_tx_history[cid].fifo_control.woff = 0U;
+	}
+
+	if (can_tx_history[cid].config.select_intr_factor == TRUE) {
+		can_tx_history[cid].status.thl_intr = TRUE;
+	}
+	else if (can_tx_history[cid].fifo_control.count == CAN_TX_HISTORY_INTR_BUFNUM) {
+		can_tx_history[cid].status.thl_intr = TRUE;
+	}
+
+	if (can_tx_history[cid].fifo_control.count >= CAN_TX_HISTORY_BUFFER_NUM) {
+		can_tx_history[cid].status.thl_full = TRUE;
+	}
+	can_tx_history[cid].status.thl_empty = FALSE;
+	return STD_E_OK;
+}
+
+Std_ReturnType can_txhl_next_thldata(CanChannelIdType cid)
+{
+	if (can_tx_history[cid].config.enable_history == FALSE) {
+		return STD_E_INVALID;
+	}
+	if (can_tx_history[cid].fifo_control.count <= 0) {
+		return STD_E_NOENT;
+	}
+	can_tx_history[cid].fifo_control.count--;
+	can_tx_history[cid].fifo_control.roff++;
+	if (can_tx_history[cid].fifo_control.roff >= CAN_TX_HISTORY_BUFFER_NUM) {
+		can_tx_history[cid].fifo_control.roff = 0U;
+	}
+
+	if (can_tx_history[cid].fifo_control.count <= 0) {
+		can_tx_history[cid].status.thl_empty = TRUE;
+	}
+	can_tx_history[cid].status.thl_full = FALSE;
+	return STD_E_OK;
+}
+
+Std_ReturnType can_txhl_peek_thldata(CanChannelIdType cid, CanTxHistoryDataType *thldata)
+{
+	if (can_tx_history[cid].config.enable_history == FALSE) {
+		return STD_E_INVALID;
+	}
+	if (can_tx_history[cid].fifo_control.count <= 0) {
+		return STD_E_NOENT;
+	}
+	*thldata = can_tx_history[cid].buffer[can_tx_history[cid].fifo_control.roff];
+	return STD_E_OK;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/can_tx_history.h
@@ -0,0 +1,84 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+
+#ifndef _CAN_TX_HISTORY_H_
+#define _CAN_TX_HISTORY_H_
+
+#include "can_fifo.h"
+#include "can_data.h"
+
+#define CAN_TX_HISTORY_BUFTYPE_BUFFER	0x1
+#define CAN_TX_HISTORY_BUFTYPE_FIFO		0x2
+#define CAN_TX_HISTORY_BUFTYPE_QUEUE	0x4
+
+typedef struct {
+	uint8	label;		// 15 ～ 8 TID[7:0]
+	uint8	bufno;		// 6 ～ 3 BN[3:0]
+	uint8	buftype;	// 2 ～ 0 BT[2:0]
+} CanTxHistoryDataType;
+
+typedef struct {
+	struct {
+		bool	select_tx_buffer; 		// 10 THLDTE
+		bool	select_intr_factor;		// 9 THLIM
+		bool	enable_intr;			// 8 THLIE
+		bool	enable_history;			// 0 THLE
+	} config;	// RSCANnTHLCCm
+	struct {
+		bool	thl_intr;				// 3 THLIF
+		bool	thl_ovr;				// 2 THLELT
+		bool	thl_full;				// 1 THLFLL
+		bool	thl_empty;				// 0 THLEMP
+	} status;	// RSCANnTHLSTSm
+	CanFifoControlType	fifo_control;
+	CanTxHistoryDataType buffer[CAN_TX_HISTORY_BUFFER_NUM];	// RSCANnTHLACCm
+} CanTxHistoryType;
+
+
+extern CanTxHistoryType can_tx_history[CAN_CHANNEL_NUM];
+
+extern Std_ReturnType can_txhl_put_thldata(CanChannelIdType cid, CanTxHistoryDataType *thldata);
+extern Std_ReturnType can_txhl_next_thldata(CanChannelIdType cid);
+extern Std_ReturnType can_txhl_peek_thldata(CanChannelIdType cid, CanTxHistoryDataType *thldata);
+
+
+#endif /* _CAN_TX_HISTORY_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/can_tx_queue.c
@@ -0,0 +1,123 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+
+#include "can_tx_queue.h"
+
+CanTxQueueType can_tx_queue[CAN_CHANNEL_NUM];
+
+Std_ReturnType can_txque_peek_txdata(CanChannelIdType cid, CanBufferIdxType txbufno, CanDataType *txdata)
+{
+	if (can_tx_queue[cid].config.enable_queue == FALSE) {
+		return STD_E_INVALID;
+	}
+	if (can_tx_queue[cid].config.quelen == 0) {
+		return STD_E_INVALID;
+	}
+	if (can_tx_queue[cid].control.tx_data[txbufno].tx_req == FALSE) {
+		return STD_E_NOENT;
+	}
+	*txdata = can_tx_queue[cid].control.tx_data[txbufno].data;
+	return STD_E_OK;
+}
+
+void can_txque_put_txdata(CanChannelIdType cid)
+{
+	uint8 maxquelen;
+	uint32 bufno;
+	uint32 count;
+
+	if (can_tx_queue[cid].config.enable_queue == FALSE) {
+		return;
+	}
+	if (can_tx_queue[cid].config.quelen == 0) {
+		return;
+	}
+	maxquelen = can_tx_queue[cid].config.quelen + 1U;
+	if (can_tx_queue[cid].control.reqbufnum >= maxquelen) {
+		return;
+	}
+	can_tx_queue[cid].control.reqbufnum++;
+	count = maxquelen;
+	bufno = (CAN_TX_CHANNEL_BUFFER_NUM - 1U);
+	while (count > 0) {
+		if (can_tx_queue[cid].control.tx_data[bufno].tx_req == FALSE) {
+			break;
+		}
+		count--;
+		bufno--;
+	}
+	if (count == 0) {
+		return;
+	}
+	can_tx_queue[cid].control.tx_data[bufno].tx_req = TRUE;
+	can_txbuffer_ref_data(&can_tx_buffer_control.buf[cid][CAN_TX_CHANNEL_BUFFER_NUM - 1U], &can_tx_queue[cid].control.tx_data[bufno].data);
+
+	if (can_tx_queue[cid].control.reqbufnum >= maxquelen) {
+		can_tx_queue[cid].status.is_full = TRUE;
+	}
+	can_tx_queue[cid].status.is_empty = FALSE;
+	return;
+}
+
+Std_ReturnType can_txque_get_txdata(CanChannelIdType cid, CanBufferIdxType txbufno, CanDataType *txdata)
+{
+	return can_txque_peek_txdata(cid, txbufno, txdata);
+}
+
+Std_ReturnType can_txque_notify_txdone(CanChannelIdType cid, CanBufferIdxType txbufno)
+{
+	if (can_tx_queue[cid].control.tx_data[txbufno].tx_req == TRUE) {
+		can_tx_queue[cid].control.reqbufnum--;
+		can_tx_queue[cid].control.tx_data[txbufno].tx_req = FALSE;
+		can_tx_queue[cid].status.is_full = FALSE;
+		if (can_tx_queue[cid].control.reqbufnum <= 0) {
+			can_tx_queue[cid].status.is_empty = TRUE;
+		}
+		if (can_tx_queue[cid].config.intr_factor == TRUE) {
+			can_tx_queue[cid].status.intr_req = TRUE;
+		}
+		else if (can_tx_queue[cid].status.is_empty == TRUE) {
+			can_tx_queue[cid].status.intr_req = TRUE;
+		}
+	}
+	return STD_E_OK;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/can_tx_queue.h
@@ -0,0 +1,81 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+
+#ifndef _CAN_TX_QUEUE_H_
+#define _CAN_TX_QUEUE_H_
+
+#include "can_buffer.h"
+#include "can_data.h"
+
+typedef struct {
+	bool	tx_req;
+	CanDataType	data;
+} CanTxQueueDataType;;
+
+typedef struct {
+	uint8	reqbufnum;
+	CanTxQueueDataType	tx_data[CAN_TX_CHANNEL_BUFFER_NUM];
+} CanTxQueueControlType;
+
+typedef struct {
+	struct {
+		bool	intr_factor;	// 13 TXQIM
+		bool	enable_intr;	// 12 TXQIE
+		uint8	quelen;			// 11 ～ 8 TXQDC [3:0]
+		bool	enable_queue; 	// 0 TXQE
+	} config; // RSCANnTXQCCm
+	struct {
+		bool	intr_req;		// 2 TXQIF
+		bool	is_full;		// 1 TXQFLL
+		bool	is_empty;		// 0 TXQEMP
+	} status; // RSCANnTXQSTSm
+	CanTxQueueControlType	control;
+} CanTxQueueType;
+
+extern CanTxQueueType can_tx_queue[CAN_CHANNEL_NUM];
+
+extern Std_ReturnType can_txque_peek_txdata(CanChannelIdType cid, CanBufferIdxType txbufno, CanDataType *txdata);
+extern void can_txque_put_txdata(CanChannelIdType cid);
+extern Std_ReturnType can_txque_get_txdata(CanChannelIdType cid, CanBufferIdxType txbufno, CanDataType *txdata);
+extern Std_ReturnType can_txque_notify_txdone(CanChannelIdType cid, CanBufferIdxType txbufno);
+
+#endif /* _CAN_TX_QUEUE_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/can_types.h
@@ -0,0 +1,61 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _CAN_TYPES_H_
+#define _CAN_TYPES_H_
+
+#include "std_types.h"
+#include "std_errno.h"
+#include "can_config.h"
+#include "assert.h"
+
+typedef uint32 CanChannelIdType;
+
+/*
+ * グローバルなID
+ */
+typedef uint32 CanBufferIdType;
+/*
+ * チャネル内の相対インデックス
+ */
+typedef uint32 CanBufferIdxType;
+
+#endif /* _CAN_TYPES_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/canbus/can_bus.h
@@ -0,0 +1,62 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _CAN_BUS_H_
+#define _CAN_BUS_H_
+
+#include "can_types.h"
+#include "can_data.h"
+
+typedef struct {
+	void (*init) (void);
+	struct {
+		bool (*is_arrived) (CanChannelIdType cid);
+		bool (*receive) (CanChannelIdType cid, CanDataType *data);
+	} rx;
+	struct {
+		Std_ReturnType (*start_send) (CanChannelIdType cid, CanDataType *data);
+		bool (*is_done) (CanChannelIdType cid);
+	} tx;
+} CanBusOperationType;
+
+extern CanBusOperationType can_bus_operation_impl_ros;
+
+#endif /* _CAN_BUS_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/canbus/can_bus_impl_ros.c
@@ -0,0 +1,327 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "can_types.h"
+#include "can_config.h"
+#include "canbus/can_bus.h"
+#include "athrill_mros_device.h"
+#include "cpuemu_ops.h"
+#include "mpu_ops.h"
+
+static void can_bus_operation_impl_ros_init(void);
+static bool can_bus_operation_impl_ros_rx_is_arrived(CanChannelIdType cid);
+static bool can_bus_operation_impl_ros_rx_receive(CanChannelIdType cid, CanDataType *data);
+static Std_ReturnType can_bus_operation_impl_ros_tx_start_send(CanChannelIdType cid, CanDataType *data);
+static bool can_bus_operation_impl_ros_tx_is_done(CanChannelIdType cid);
+
+CanBusOperationType can_bus_operation_impl_ros = {
+	.init = can_bus_operation_impl_ros_init,
+	.rx.is_arrived = can_bus_operation_impl_ros_rx_is_arrived,
+	.rx.receive = can_bus_operation_impl_ros_rx_receive,
+	.tx.start_send = can_bus_operation_impl_ros_tx_start_send,
+	.tx.is_done = can_bus_operation_impl_ros_tx_is_done,
+};
+static 	uint32 rx_queue_max = 256U;
+
+typedef struct {
+	uint32 count;
+	uint32 roff;
+	uint32 woff;
+	CanDataType  *bufferp;
+} CanBusRosRxBufferType;
+
+static CanBusRosRxBufferType can_bus_ros_rx_buffer[CAN_CHANNEL_NUM];
+static void can_bus_ros_rx_buffer_init(void)
+{
+	CanChannelIdType cid;
+
+	for (cid = 0; cid < CAN_CHANNEL_NUM; cid++) {
+		can_bus_ros_rx_buffer[cid].count = 0;
+		can_bus_ros_rx_buffer[cid].roff = 0;
+		can_bus_ros_rx_buffer[cid].woff = 0;
+		can_bus_ros_rx_buffer[cid].bufferp = malloc(sizeof(CanDataType) * rx_queue_max);
+		ASSERT(can_bus_ros_rx_buffer[cid].bufferp != NULL);
+	}
+}
+static bool can_bus_ros_rx_is_arrived(CanChannelIdType cid)
+{
+	if (can_bus_ros_rx_buffer[cid].count > 0) {
+		return TRUE;
+	}
+	return FALSE;
+}
+
+static bool can_bus_ros_rx_buffer_put(CanChannelIdType cid, CanDataType *data)
+{
+	if (can_bus_ros_rx_buffer[cid].count >= rx_queue_max) {
+		return FALSE;
+	}
+	can_bus_ros_rx_buffer[cid].bufferp[can_bus_ros_rx_buffer[cid].woff] = *data;
+	can_bus_ros_rx_buffer[cid].count++;
+	can_bus_ros_rx_buffer[cid].woff++;
+	if (can_bus_ros_rx_buffer[cid].woff >= rx_queue_max) {
+		can_bus_ros_rx_buffer[cid].woff = 0;
+	}
+	return TRUE;
+}
+static bool can_bus_ros_rx_buffer_get(CanChannelIdType cid, CanDataType *data)
+{
+	ros_topic_callback_lock();
+	if (can_bus_ros_rx_buffer[cid].count <= 0) {
+		ros_topic_callback_unlock();
+		return FALSE;
+	}
+	*data = can_bus_ros_rx_buffer[cid].bufferp[can_bus_ros_rx_buffer[cid].roff];
+	can_bus_ros_rx_buffer[cid].count--;
+	can_bus_ros_rx_buffer[cid].roff++;
+	if (can_bus_ros_rx_buffer[cid].roff >= rx_queue_max) {
+		can_bus_ros_rx_buffer[cid].roff = 0;
+	}
+	ros_topic_callback_unlock();
+	return TRUE;
+}
+
+
+typedef enum {
+	mRosTopicType_PUB = 0,
+	mRosTopicType_SUB
+} mRosTopicType;
+
+static uint32 mros_pub_req_num = 0;
+static AthrillMrosDevPubReqType *pub_req_table;
+
+static void topic_callback(const char *data, int datalen);
+static uint32 mros_sub_req_num = 0;
+static AthrillMrosDevSubReqType *sub_req_table;
+
+typedef struct {
+	CanChannelIdType 	cid;
+	uint32				ide;
+	uint32				rtr;
+	uint32				dlc;
+	uint32				canid;
+} CanBusRosTopicType;
+
+static CanBusRosTopicType *can_bus_ros_pub_topic;
+static CanBusRosTopicType *can_bus_ros_sub_topic;
+
+static void device_parse_can_config(mRosTopicType type, const char* fmt_num, const char* fmt_topic)
+{
+	uint32 i;
+	uint32 param_num;
+	Std_ReturnType err;
+	static char parameter[4096];
+	char *param_value;
+
+	err = cpuemu_get_devcfg_value(fmt_num, &param_num);
+	if (err != STD_E_OK) {
+		return;
+	}
+	if (type == mRosTopicType_PUB) {
+		mros_pub_req_num = param_num;
+		pub_req_table = malloc(sizeof(AthrillMrosDevPubReqType) * param_num);
+		ASSERT(pub_req_table != NULL);
+		can_bus_ros_pub_topic = malloc(sizeof(CanBusRosTopicType) * mros_pub_req_num);
+		ASSERT(can_bus_ros_pub_topic != NULL);
+	}
+	else {
+		mros_sub_req_num = param_num;
+		sub_req_table = malloc(sizeof(AthrillMrosDevSubReqType) * param_num);
+		ASSERT(sub_req_table != NULL);
+		can_bus_ros_sub_topic = malloc(sizeof(CanBusRosTopicType) * mros_sub_req_num);
+		ASSERT(can_bus_ros_sub_topic != NULL);
+	}
+	for (i = 0; i < param_num; i++) {
+		snprintf(parameter, sizeof(parameter), fmt_topic, i);
+		err = cpuemu_get_devcfg_string(parameter, &param_value);
+		if (err != STD_E_OK) {
+			printf("not found param=%s\n", parameter);
+			return;
+		}
+		/*
+		 * topic_name:channel<ch>/CAN_IDE<ide>_RTR<rtr>_DLC<dlc>_<canid>
+		 * topic_data: <0><1><2><3><4><5><6><7>
+		 */
+		if (type == mRosTopicType_PUB) {
+			pub_req_table[i].topic_name = param_value;
+			pub_req_table[i].pub = NULL;
+			int n = sscanf(param_value, "channel%u/CAN_IDE%u_RTR%u_DLC%u_0x%x",
+					&can_bus_ros_pub_topic[i].cid,
+					&can_bus_ros_pub_topic[i].ide,
+					&can_bus_ros_pub_topic[i].rtr,
+					&can_bus_ros_pub_topic[i].dlc,
+					&can_bus_ros_pub_topic[i].canid);
+			if (n != 5U) {
+				printf("ERROR: can not parse param(%s). format:channel<ch>/CAN_IDE<ide>_RTR<rtr>_DLC<dlc>_<canid>\n", param_value);
+			}
+		}
+		else {
+			sub_req_table[i].topic_name = param_value;
+			sub_req_table[i].callback = topic_callback;
+			sub_req_table[i].sub = NULL;
+			int n = sscanf(param_value, "channel%u/CAN_IDE%u_RTR%u_DLC%u_0x%x",
+					&can_bus_ros_sub_topic[i].cid,
+					&can_bus_ros_sub_topic[i].ide,
+					&can_bus_ros_sub_topic[i].rtr,
+					&can_bus_ros_sub_topic[i].dlc,
+					&can_bus_ros_sub_topic[i].canid);
+			if (n != 5U) {
+				printf("ERROR: can not parse param(%s). format:channel<ch>/CAN_IDE<ide>_RTR<rtr>_DLC<dlc>_<canid>\n", param_value);
+			}
+		}
+	}
+}
+
+static void can_bus_operation_impl_ros_init(void)
+{
+	int err;
+
+	set_athrill_task();
+
+	(void)cpuemu_get_devcfg_value("DEBUG_FUNC_CAN_RX_QUEUE_SIZE ", &rx_queue_max);
+	can_bus_ros_rx_buffer_init();
+
+	device_parse_can_config(mRosTopicType_PUB, "DEBUG_FUNC_MROS_TOPIC_PUB_NUM", "DEBUG_FUNC_MROS_TOPIC_PUB_%d");
+	device_parse_can_config(mRosTopicType_SUB, "DEBUG_FUNC_MROS_TOPIC_SUB_NUM", "DEBUG_FUNC_MROS_TOPIC_SUB_%d");
+
+	err = athrill_mros_device_pub_register(pub_req_table, mros_pub_req_num);
+	if (err < 0) {
+		printf("error: athrill_mros_device_pub_register()\n");
+		return;
+	}
+	err = athrill_mros_device_sub_register(sub_req_table, mros_sub_req_num);
+	if (err < 0) {
+		printf("error: athrill_mros_device_sub_register()\n");
+		return;
+	}
+	err = athrill_mros_device_start();
+	if (err < 0) {
+		printf("error: athrill_mros_device_start()\n");
+		return;
+	}
+	return;
+}
+
+
+
+static void topic_callback(const char *data, int datalen)
+{
+	mRosCallbackTopicIdType topic_id = ros_topic_callback_topic_id();
+	int i;
+	int copylen;
+	CanDataType can_data;
+	CanChannelIdType cid;
+
+	for (i = 0; i < mros_sub_req_num; i++) {
+		if (sub_req_table[i].sub == NULL) {
+			continue;
+		}
+		if (topic_id == sub_req_table[i].sub->topic_id) {
+			break;
+		}
+	}
+	if (i == mros_sub_req_num) {
+		return;
+	}
+	cid = can_bus_ros_sub_topic[i].cid;
+	can_data.ide = can_bus_ros_sub_topic[i].ide;
+	can_data.rtr = can_bus_ros_sub_topic[i].rtr;
+	can_data.dlc = can_bus_ros_sub_topic[i].dlc;
+	can_data.id = can_bus_ros_sub_topic[i].canid;
+
+	copylen = datalen;
+	if (datalen != CAN_RX_BUFFER_DATA_SIZE) {
+		printf("ERROR: can rx data size invalid(topic=%s len=%u)\n", sub_req_table[i].topic_name, datalen);
+		if (datalen > CAN_RX_BUFFER_DATA_SIZE) {
+			copylen = CAN_RX_BUFFER_DATA_SIZE;
+		}
+	}
+	memcpy(can_data.data, data, copylen);
+	can_bus_ros_rx_buffer_put(cid, &can_data);
+	return;
+}
+
+
+static bool can_bus_operation_impl_ros_rx_is_arrived(CanChannelIdType cid)
+{
+	return can_bus_ros_rx_is_arrived(cid);
+}
+
+static bool can_bus_operation_impl_ros_rx_receive(CanChannelIdType cid, CanDataType *data)
+{
+	return can_bus_ros_rx_buffer_get(cid, data);
+}
+static Std_ReturnType can_bus_operation_impl_ros_tx_start_send(CanChannelIdType cid, CanDataType *data)
+{
+	uint32 i;
+	for (i = 0; i < mros_pub_req_num; i++) {
+		if (can_bus_ros_pub_topic[i].cid != cid) {
+			continue;
+		}
+		if (can_bus_ros_pub_topic[i].ide != data->ide) {
+			continue;
+		}
+		if (can_bus_ros_pub_topic[i].rtr != data->rtr) {
+			continue;
+		}
+		if (can_bus_ros_pub_topic[i].dlc != data->dlc) {
+			continue;
+		}
+		if (can_bus_ros_pub_topic[i].canid != data->id) {
+			continue;
+		}
+		break;
+	}
+	if (i == mros_pub_req_num) {
+		printf("ERROR: ROS Unknown can data send(ide=%u rtr=%u dlc=%u id=0x%x\n", data->ide, data->rtr, data->dlc, data->id);
+		return STD_E_NOENT;
+	}
+	(void)ros_topic_publish(pub_req_table[i].pub, data->data, data->dlc);
+	return STD_E_OK;
+}
+
+static bool can_bus_operation_impl_ros_tx_is_done(CanChannelIdType cid)
+{
+	return TRUE;
+}
+
+
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/mapping/can_register.h
@@ -0,0 +1,142 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _CAN_REGISTER_H_
+#define _CAN_REGISTER_H_
+
+#define RSCANn_base							0xFFD00000
+
+#define CAN_REG_RSCANnCmCFG(index)			( (RSCANn_base + 0x0000) +  (0x10 * (index) ) )
+#define CAN_REG_RSCANnCmCTR(index)			( (RSCANn_base + 0x0004) +  (0x10 * (index) ) )
+#define CAN_REG_RSCANnCmSTS(index)			( (RSCANn_base + 0x0008) +  (0x10 * (index) ) )
+#define CAN_REG_RSCANnCmERFL(index)			( (RSCANn_base + 0x000C) +  (0x10 * (index) ) )
+#define CAN_REG_RSCANnGCFG					( (RSCANn_base + 0x0084) )
+#define CAN_REG_RSCANnGCTR					( (RSCANn_base + 0x0088) )
+#define CAN_REG_RSCANnGSTS					( (RSCANn_base + 0x008C) )
+#define CAN_REG_RSCANnGERFL					( (RSCANn_base + 0x0090) )
+#define CAN_REG_RSCANnGTSC					( (RSCANn_base + 0x0094) )
+#define CAN_REG_RSCANnGTINTSTS0				( (RSCANn_base + 0x0460) )
+#define CAN_REG_RSCANnGTINTSTS1				( (RSCANn_base + 0x0464) )
+#define CAN_REG_RSCANnGFDCFG				( (RSCANn_base + 0x0474) )
+#define CAN_REG_RSCANnGAFLECTR				( (RSCANn_base + 0x0098) )
+#define CAN_REG_RSCANnGAFLCFG0				( (RSCANn_base + 0x009C) )
+#define CAN_REG_RSCANnGAFLCFG1				( (RSCANn_base + 0x00A0) )
+#define CAN_REG_RSCANnGAFLIDj(index)		( (RSCANn_base + 0x0500) +  (0x10 * (index) ) )
+#define CAN_REG_RSCANnGAFLMj(index)			( (RSCANn_base + 0x0504) +  (0x10 * (index) ) )
+#define CAN_REG_RSCANnGAFLP0j(index)		( (RSCANn_base + 0x0508) +  (0x10 * (index) ) )
+#define CAN_REG_RSCANnGAFLP1j(index)		( (RSCANn_base + 0x050C) +  (0x10 * (index) ) )
+#define CAN_REG_RSCANnRMNB					( (RSCANn_base + 0x00A4) )
+#define CAN_REG_RSCANnRMNDy(index)			( (RSCANn_base + 0x00A8) +  (0x04 * (index) ) )
+#define CAN_REG_RSCANnRMIDq(index)			( (RSCANn_base + 0x0600) +  (0x10 * (index) ) )
+#define CAN_REG_RSCANnRMPTRq(index)			( (RSCANn_base + 0x0604) +  (0x10 * (index) ) )
+#define CAN_REG_RSCANnRMDF0q(index)			( (RSCANn_base + 0x0608) +  (0x10 * (index) ) )
+#define CAN_REG_RSCANnRMDF1q(index)			( (RSCANn_base + 0x060C) +  (0x10 * (index) ) )
+#define CAN_REG_RSCANnRFCCx(index)			( (RSCANn_base + 0x00B8) +  (0x04 * (index) ) )
+#define CAN_REG_RSCANnRFSTSx(index)			( (RSCANn_base + 0x00D8) +  (0x04 * (index) ) )
+#define CAN_REG_RSCANnRFPCTRx(index)		( (RSCANn_base + 0x00F8) +  (0x04 * (index) ) )
+#define CAN_REG_RSCANnRFIDx(index)			( (RSCANn_base + 0x0E00) +  (0x10 * (index) ) )
+#define CAN_REG_RSCANnRFPTRx(index)			( (RSCANn_base + 0x0E04) +  (0x10 * (index) ) )
+#define CAN_REG_RSCANnRFDF0x(index)			( (RSCANn_base + 0x0E08) +  (0x10 * (index) ) )
+#define CAN_REG_RSCANnRFDF1x(index)			( (RSCANn_base + 0x0E0C) +  (0x10 * (index) ) )
+#define CAN_REG_RSCANnCFCCk(index)			( (RSCANn_base + 0x0118) +  (0x04 * (index) ) )
+#define CAN_REG_RSCANnCFSTSk(index)			( (RSCANn_base + 0x0178) +  (0x04 * (index) ) )
+#define CAN_REG_RSCANnCFPCTRk(index)		( (RSCANn_base + 0x01D8) +  (0x04 * (index) ) )
+#define CAN_REG_RSCANnCFIDk(index)			( (RSCANn_base + 0x0E80) +  (0x10 * (index) ) )
+#define CAN_REG_RSCANnCFPTRk(index)			( (RSCANn_base + 0x0E84) +  (0x10 * (index) ) )
+#define CAN_REG_RSCANnCFDF0k(index)			( (RSCANn_base + 0x0E88) +  (0x10 * (index) ) )
+#define CAN_REG_RSCANnCFDF1k(index)			( (RSCANn_base + 0x0E8C) +  (0x10 * (index) ) )
+#define CAN_REG_RSCANnFESTS					( (RSCANn_base + 0x0238) )
+#define CAN_REG_RSCANnFFSTS					( (RSCANn_base + 0x023C) )
+#define CAN_REG_RSCANnFMSTS					( (RSCANn_base + 0x0240) )
+#define CAN_REG_RSCANnRFISTS				( (RSCANn_base + 0x0244) )
+#define CAN_REG_RSCANnCFRISTS				( (RSCANn_base + 0x0248) )
+#define CAN_REG_RSCANnCFTISTS			    ( (RSCANn_base + 0x024C) )
+#define CAN_REG_RSCANnTMCp(index)			( (RSCANn_base + 0x0250) +  (0x01 * (index) ) )
+#define CAN_REG_RSCANnTMSTSp(index)			( (RSCANn_base + 0x02D0) +  (0x01 * (index) ) )
+#define CAN_REG_RSCANnTMIDp(index)			( (RSCANn_base + 0x1000) +  (0x10 * (index) ) )
+#define CAN_REG_RSCANnTMPTRp(index)			( (RSCANn_base + 0x1004) +  (0x10 * (index) ) )
+#define CAN_REG_RSCANnTMDF0p(index)			( (RSCANn_base + 0x1008) +  (0x10 * (index) ) )
+#define CAN_REG_RSCANnTMDF1p(index)			( (RSCANn_base + 0x100C) +  (0x10 * (index) ) )
+#define CAN_REG_RSCANnTMIECy(index)			( (RSCANn_base + 0x0390) +  (0x04 * (index) ) )
+#define CAN_REG_RSCANnTMTRSTSy(index)		( (RSCANn_base + 0x0350) +  (0x04 * (index) ) )
+#define CAN_REG_RSCANnTMTARSTSy(index)		( (RSCANn_base + 0x0360) +  (0x04 * (index) ) )
+#define CAN_REG_RSCANnTMTCSTSy(index)		( (RSCANn_base + 0x0370) +  (0x04 * (index) ) )
+#define CAN_REG_RSCANnTMTASTSy(index)		( (RSCANn_base + 0x0380) +  (0x04 * (index) ) )
+
+#define CAN_REG_RSCANnTXQCCm(index)			( (RSCANn_base + 0x03A0) +  (0x04 * (index) ) )
+#define CAN_REG_RSCANnTXQSTSm(index)		( (RSCANn_base + 0x03C0) +  (0x04 * (index) ) )
+#define CAN_REG_RSCANnTXQPCTRm(index)		( (RSCANn_base + 0x03E0) +  (0x04 * (index) ) )
+
+
+#define CAN_REG_RSCANnTHLCCm(index)			( (RSCANn_base + 0x0400) +  (0x04 * (index) ) )
+#define CAN_REG_RSCANnTHLSTSm(index)		( (RSCANn_base + 0x0420) +  (0x04 * (index) ) )
+#define CAN_REG_RSCANnTHLPCTRm(index)		( (RSCANn_base + 0x0440) +  (0x04 * (index) ) )
+#define CAN_REG_RSCANnTHLACCm(index)		( (RSCANn_base + 0x1800) +  (0x04 * (index) ) )
+
+#define CAN_REG_UPDATE_REG_BIT(model_flag, bits, reg_data)	\
+do {	\
+	if ((model_flag) == TRUE) {	\
+		(reg_data)	|=	(1U << (bits));	\
+	}	\
+	else {	\
+		(reg_data)	&=	~(1U << (bits));	\
+	}	\
+} while (0)
+#define CAN_REG_GET_MASK_DATA(reg_data, mask)	((reg_data) & (mask))
+
+#define CAN_REG_UPDATE_MODEL_FLAG(reg_data, bits, model_flag)	\
+do {	\
+	if ( ((reg_data) & (1U << (bits))) != 0U) {	\
+		(model_flag) = TRUE;	\
+	}	\
+	else {	\
+		(model_flag) = FALSE;	\
+	}	\
+} while (0)
+
+#define CAN_DATA_IS_BITSET(data, bits)							( ((data) << (bits)) != 0U )
+
+#define CAN_REG_GET_ALIGNED_ADDR(reg_data)						((reg_data) & 0xFFFFFFFCU)
+
+#define CAN_REG_GROUP_INDEX(addr, start_addr, group_size)		( ( CAN_REG_GET_ALIGNED_ADDR(addr) - (start_addr) ) / ((group_size)) )
+
+#define CAN_REG_INDEX(addr, start_addr, group_size)				( ( (addr) - (start_addr) ) / ((group_size)) )
+#endif /* _CAN_REGISTER_H_  */
\ No newline at end of file
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/mapping/can_register_mapping.c
@@ -0,0 +1,122 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "can_register_mapping.h"
+#include "can_register_mapping_io_table.h"
+#include "can_register.h"
+#include <stdio.h>
+
+#if 0 /* for test */
+void debug_map_print(void)
+{
+	CanRegisterMappingType *map;
+	int i;
+	uint32 end_addr;
+
+
+	printf("start, end,\n");
+	for (i = 0; i < CAN_REGISTER_MAPPING_TABLE_NUM; i++) {
+		map = &can_reigster_mapping_table[i];
+		if (map->register_group_size != 0) {
+			end_addr = map->start_address + map->register_group_size;
+		}
+		else {
+			end_addr = map->start_address + map->register_unit_size;
+		}
+		printf("0x%x, 0x%x,\n", map->start_address - RSCANn_base, end_addr - RSCANn_base);
+	}
+}
+#endif
+
+static CanRegisterMappingType *search_map(uint32 address, uint32 size)
+{
+	CanRegisterMappingType *map;
+	int i;
+	uint32 end_addr;
+
+
+	for (i = 0; i < CAN_REGISTER_MAPPING_TABLE_NUM; i++) {
+		map = &can_reigster_mapping_table[i];
+		if (map->register_group_size != 0) {
+			end_addr = map->start_address + map->register_group_size;
+		}
+		else {
+			end_addr = map->start_address + map->register_unit_size;
+		}
+		if (address < map->start_address) {
+			continue;
+		}
+		if (address >= end_addr) {
+			continue;
+		}
+		return map;
+	}
+
+	return NULL;
+}
+
+void can_register_mapping_write_data(uint32 address, uint32 size)
+{
+	CanRegisterIoArgType arg;
+	CanRegisterMappingType *map = search_map(address, size);
+	if (map == NULL) {
+		printf("ERROR: can not WRITE HIT CAN address:0x%x %u\n", address, size);
+		return;
+	}
+	arg.address = address;
+	arg.size = size;
+	map->io(CanRegisterIo_Write, &arg);
+	return;
+}
+
+void can_register_mapping_read_data(uint32 address, uint32 size)
+{
+	CanRegisterIoArgType arg;
+	CanRegisterMappingType *map = search_map(address, size);
+	if (map == NULL) {
+		printf("ERROR: can not READ HIT CAN address:0x%x %u\n", address, size);
+		return;
+	}
+	arg.address = address;
+	arg.size = size;
+	map->io(CanRegisterIo_Read, &arg);
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/mapping/can_register_mapping.h
@@ -0,0 +1,85 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _CAN_REGISTER_MAPPING_H_
+#define _CAN_REGISTER_MAPPING_H_
+
+#include "std_types.h"
+
+typedef enum {
+	CanRegisterIo_Read = 0,
+	CanRegisterIo_Write,
+} CanRegisterIoType;
+
+typedef struct {
+	/*
+	 * アクセスされた先頭アドレス
+	 */
+	uint32 address;
+	/*
+	 * アクセスサイズ ?? 不要か ???
+	 */
+	uint32 size;
+} CanRegisterIoArgType;
+
+typedef struct {
+	uint32	start_address;			//byte
+	uint32	register_unit_size;		//byte
+	uint32	register_group_size;	//byte
+	void (*io) (CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+} CanRegisterMappingType;
+
+extern void can_register_mapping_write_data(uint32 address, uint32 size);
+extern void can_register_mapping_read_data(uint32 address, uint32 size);
+
+extern void can_register_read_data32(uint32 address, uint32 *data);
+extern void can_register_read_data16(uint32 address, uint16 *data);
+extern void can_register_read_data8(uint32 address, uint8 *data);
+
+extern void can_register_write_data32(uint32 address, uint32 data);
+extern void can_register_write_data16(uint32 address, uint16 data);
+extern void can_register_write_data8(uint32 address, uint8 data);
+
+extern void can_register_mcu_reset(void);
+extern void can_register_global_reset(void);
+extern void can_register_channel_reset(void);
+
+#endif /* _CAN_REGISTER_MAPPING_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io.h
@@ -0,0 +1,163 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "can_register_mapping.h"
+
+
+/*
+ * チャネル関連レジスタ
+ */
+extern void can_register_mapping_io_CHANNEL(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+
+extern void can_register_mapping_io_RSCANnCmCFG(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnCmCTR(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnCmSTS(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnCmERFL(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+
+/*
+ * グローバル関連レジスタ
+ */
+extern void can_register_mapping_io_RSCANnGCFG(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnGCTR(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnGSTS(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnGERFL(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnGTINTSTS0(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnGTINTSTS1(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+
+/*
+ * 受信ルール関連レジスタ
+ */
+extern void can_register_mapping_io_RSCANnGAFLECTR(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnGAFLCFG0(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnGAFLCFG1(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+
+extern void can_register_mapping_io_RX_RULE(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnGAFLIDj(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnGAFLMj(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnGAFLP0j(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnGAFLP1j(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+
+/*
+ * 受信バッファ関連レジスタ
+ */
+extern void can_register_mapping_io_RSCANnRMNB(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnRMNDy(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+
+extern void can_register_mapping_io_RX_BUFFER(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+
+extern void can_register_mapping_io_RSCANnRMIDq(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnRMPTRq(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnRMDF0q(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnRMDF1q(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+
+/*
+ * 受信 FIFO バッファ関連レジスタ
+ */
+extern void can_register_mapping_io_RSCANnRFCCx(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnRFSTSx(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnRFPCTRx(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+
+extern void can_register_mapping_io_RX_FIFO(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+
+extern void can_register_mapping_io_RSCANnRFIDx(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnRFPTRx(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnRFDF0x(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnRFDF1x(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+
+/*
+ * 送受信 FIFO バッファ関連レジスタ
+ */
+extern void can_register_mapping_io_RSCANnCFCCk(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnCFSTSk(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnCFPCTRk(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+
+extern void can_register_mapping_io_TXRX_FIFO(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnCFIDk(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnCFPTRk(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnCFDF0k(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnCFDF1k(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+
+/*
+ * FIFO ステータス関連レジスタ
+ */
+extern void can_register_mapping_io_RSCANnFESTS(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnFFSTS(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnFMSTS(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnRFISTS(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnCFRISTS(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnCFTISTS(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+
+/*
+ * 送信バッファ関連レジスタ
+ */
+extern void can_register_mapping_io_RSCANnTMCp(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnTMSTSp(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+
+extern void can_register_mapping_io_TX_BUFFER(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+
+extern void can_register_mapping_io_RSCANnTMIDp(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnTMPTRp(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnTMDF0p(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnTMDF1p(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnTMIECy(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+
+/*
+ * 送信バッファステータス関連レジスタ
+ */
+extern void can_register_mapping_io_RSCANnTMTRSTSy(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnTMTCSTSy(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+
+
+/*
+ * 送信キュー関連レジスタ
+ */
+extern void can_register_mapping_io_RSCANnTXQCCm(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnTXQSTSm(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnTXQPCTRm(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+
+/*
+ * 送信履歴関連レジスタ
+ */
+extern void can_register_mapping_io_RSCANnTHLCCm(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnTHLSTSm(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnTHLPCTRm(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+extern void can_register_mapping_io_RSCANnTHLACCm(CanRegisterIoType io_type, CanRegisterIoArgType *arg);
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io_channel.c
@@ -0,0 +1,178 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "can_register_mapping_io.h"
+#include "can_register.h"
+#include "can_mode_global.h"
+#include "can_register_mapping_reset.h"
+
+void can_register_reset_channel(CanRegisterResetType type, CanChannelIdType cid)
+{
+	if (type == CanRegisterResetType_MCU_RESET) {
+		can_mode_global.channel[cid].cid = cid;
+		can_mode_global.channel[cid].ctrl.stop = TRUE;
+		can_mode_global.channel[cid].ctrl.select_mode = CAN_MODE_CHANNEL_MODE_RESET;
+		can_mode_global.channel[cid].mode = ChannelMode_STOP;
+		can_mode_global.channel[cid].comm_mode = ChannelModeComm_IDLE;
+		can_mode_global.channel[cid].status.can_comm = FALSE;
+		can_mode_global.channel[cid].status.receiving = FALSE;
+		can_mode_global.channel[cid].status.sending = FALSE;
+		can_mode_global.channel[cid].status.mode_stop = TRUE;
+		can_mode_global.channel[cid].status.mode_wait = FALSE;
+		can_mode_global.channel[cid].status.mode_reset = TRUE;
+	}
+	else if (type == CanRegisterResetType_GLOBAL_RESET) {
+		// nothing
+	}
+	else if (type == CanRegisterResetType_CHANNEL_RESET) {
+		can_mode_global.channel[cid].mode = ChannelMode_STOP;
+		can_mode_global.channel[cid].ctrl.select_mode = CAN_MODE_CHANNEL_MODE_RESET;
+		can_mode_global.channel[cid].status.can_comm = FALSE;
+		can_mode_global.channel[cid].status.receiving = FALSE;
+		can_mode_global.channel[cid].status.sending = FALSE;
+		can_mode_global.channel[cid].status.mode_wait = FALSE;
+	}
+
+}
+
+void can_register_mapping_io_CHANNEL(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 addr = CAN_REG_GET_ALIGNED_ADDR(arg->address);
+
+	switch (addr & 0x0000000F) {
+	case 0x0:
+		can_register_mapping_io_RSCANnCmCFG(io_type, arg);
+		break;
+	case 0x04:
+		can_register_mapping_io_RSCANnCmCTR(io_type, arg);
+		break;
+	case 0x8:
+		can_register_mapping_io_RSCANnCmSTS(io_type, arg);
+		break;
+	case 0xC:
+		can_register_mapping_io_RSCANnCmERFL(io_type, arg);
+		break;
+	default:
+		break;
+	}
+	return;
+}
+void can_register_mapping_io_RSCANnCmCFG(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	//not supported
+	return;
+}
+void can_register_mapping_io_RSCANnCmCTR(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 current_cslpr;
+	uint32 current_chmdc;
+	static uint32 old_cslpr = 0x01; // reset value
+	static uint32 old_chmdc = 0x01; // reset value
+	uint32 data;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnCmCTR(0), 16U);
+
+	can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+	current_cslpr = CAN_REG_GET_MASK_DATA(data >> 2U, 0x1);
+	current_chmdc = CAN_REG_GET_MASK_DATA(data, 0x3);
+
+	if (io_type == CanRegisterIo_Write) {
+		// 2 CSLPR
+		if (current_cslpr != old_cslpr) {
+			if (current_cslpr != 0U) {
+				can_mode_channel_event(&can_mode_global.channel[index], CanModeChannelEvent_SET_STOP);
+			}
+			else {
+				can_mode_channel_event(&can_mode_global.channel[index], CanModeChannelEvent_CLR_STOP);
+			}
+		}
+		// 1、 0 CHMDC[1:0]
+		if (current_chmdc != old_chmdc) {
+			if (current_chmdc == CAN_MODE_CHANNEL_MODE_COMM) {
+				can_mode_channel_event(&can_mode_global.channel[index], CanModeChannelEvent_SET_COMM);
+			}
+			else if (current_chmdc == CAN_MODE_CHANNEL_MODE_RESET) {
+				can_mode_channel_event(&can_mode_global.channel[index], CanModeChannelEvent_SET_RESET);
+			}
+			else if (current_chmdc == CAN_MODE_CHANNEL_MODE_WAIT) {
+				can_mode_channel_event(&can_mode_global.channel[index], CanModeChannelEvent_SET_WAIT);
+			}
+		}
+		old_chmdc = current_chmdc;
+		old_cslpr = current_cslpr;
+	}
+	// 2 CSLPR
+	CAN_REG_UPDATE_REG_BIT(can_mode_global.channel[index].ctrl.stop, 2U, data);
+	// 1、 0 CHMDC[1:0]
+	data &= ~0x3;
+	data |= can_mode_global.channel[index].ctrl.select_mode;
+	can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), data);
+	return;
+}
+void can_register_mapping_io_RSCANnCmSTS(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data = 0x0;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnCmSTS(0), 16U);
+
+	if (io_type == CanRegisterIo_Read) {
+		// 7 COMSTS
+		CAN_REG_UPDATE_REG_BIT(can_mode_global.channel[index].status.can_comm, 7U, data);
+		// 6 RECSTS
+		CAN_REG_UPDATE_REG_BIT(can_mode_global.channel[index].status.receiving, 6U, data);
+		// 5 TRMSTS
+		CAN_REG_UPDATE_REG_BIT(can_mode_global.channel[index].status.sending, 5U, data);
+		// 2 CSLPSTS
+		CAN_REG_UPDATE_REG_BIT(can_mode_global.channel[index].status.mode_stop, 2U, data);
+		// 1 CHLTSTS
+		CAN_REG_UPDATE_REG_BIT(can_mode_global.channel[index].status.mode_wait, 1U, data);
+		// 0 CRSTSTS
+		CAN_REG_UPDATE_REG_BIT(can_mode_global.channel[index].status.mode_reset, 0U, data);
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), data);
+	}
+	else {
+		// nothing to do read only.
+	}
+	return;
+}
+void can_register_mapping_io_RSCANnCmERFL(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	//not supported
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io_fifo_status.c
@@ -0,0 +1,203 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "can_register_mapping_io.h"
+#include "can_register.h"
+#include "can_fifo.h"
+#include "can_register_mapping_reset.h"
+
+void can_register_reset_fifo_status(CanRegisterResetType type)
+{
+	if (type == CanRegisterResetType_MCU_RESET) {
+		//nothing
+	}
+	else if (type == CanRegisterResetType_GLOBAL_RESET) {
+		//nothing
+	}
+	else if (type == CanRegisterResetType_CHANNEL_RESET) {
+		//nothing
+	}
+
+}
+
+void can_register_mapping_io_RSCANnFESTS(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 txrxdata = 0x0;
+	uint32 rxdata = 0x0;
+	uint32 k = 0;
+	uint32 x;
+	CanChannelIdType cid;
+	CanBufferIdxType bid;
+
+	if (io_type == CanRegisterIo_Read) {
+		for (cid = 0; cid < CAN_CHANNEL_NUM; cid++) {
+			for (bid = 0; bid < CAN_TXRX_CHANNEL_FIFO_NUM; bid++) {
+				CAN_REG_UPDATE_REG_BIT(can_txrx_fifo_control.buf[cid][bid].status.txrx_empty, k, txrxdata);
+				k++;
+			}
+		}
+		for (x = 0; x < CAN_RX_FIFO_NUM; x++) {
+			CAN_REG_UPDATE_REG_BIT(can_rx_fifo_control.fifo[x].status.rx_empty, x, rxdata);
+		}
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), ( (txrxdata << 8U) | rxdata ) );
+	}
+	else { /* CanRegisterIo_Write */
+		// nothing to do
+		// ユーザ側は参照のみ
+	}
+	return;
+}
+void can_register_mapping_io_RSCANnFFSTS(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 txrxdata = 0x0;
+	uint32 rxdata = 0x0;
+	uint32 k = 0;
+	uint32 x;
+	CanChannelIdType cid;
+	CanBufferIdxType bid;
+
+	if (io_type == CanRegisterIo_Read) {
+		for (cid = 0; cid < CAN_CHANNEL_NUM; cid++) {
+			for (bid = 0; bid < CAN_TXRX_CHANNEL_FIFO_NUM; bid++) {
+				CAN_REG_UPDATE_REG_BIT(can_txrx_fifo_control.buf[cid][bid].status.txrx_full, k, txrxdata);
+				k++;
+			}
+		}
+		for (x = 0; x < CAN_RX_FIFO_NUM; x++) {
+			CAN_REG_UPDATE_REG_BIT(can_rx_fifo_control.fifo[x].status.rx_full, x, rxdata);
+		}
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), ( (txrxdata << 8U) | rxdata ) );
+	}
+	else { /* CanRegisterIo_Write */
+		// nothing to do
+		// ユーザ側は参照のみ
+	}
+	return;
+}
+void can_register_mapping_io_RSCANnFMSTS(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 txrxdata = 0x0;
+	uint32 rxdata = 0x0;
+	uint32 k = 0;
+	uint32 x;
+	CanChannelIdType cid;
+	CanBufferIdxType bid;
+
+	if (io_type == CanRegisterIo_Read) {
+		for (cid = 0; cid < CAN_CHANNEL_NUM; cid++) {
+			for (bid = 0; bid < CAN_TXRX_CHANNEL_FIFO_NUM; bid++) {
+				CAN_REG_UPDATE_REG_BIT(can_txrx_fifo_control.buf[cid][bid].status.txrx_lost, k, txrxdata);
+				k++;
+			}
+		}
+		for (x = 0; x < CAN_RX_FIFO_NUM; x++) {
+			CAN_REG_UPDATE_REG_BIT(can_rx_fifo_control.fifo[x].status.rx_lost, x, rxdata);
+		}
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), ( (txrxdata << 8U) | rxdata ) );
+	}
+	else { /* CanRegisterIo_Write */
+		// nothing to do
+		// ユーザ側は参照のみ
+	}
+	return;
+}
+void can_register_mapping_io_RSCANnRFISTS(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 rxdata = 0x0;
+	uint32 x;
+
+	if (io_type == CanRegisterIo_Read) {
+		for (x = 0; x < CAN_RX_FIFO_NUM; x++) {
+			CAN_REG_UPDATE_REG_BIT(can_rx_fifo_control.fifo[x].status.rx_intr, x, rxdata);
+		}
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), ( rxdata ) );
+	}
+	else { /* CanRegisterIo_Write */
+		// nothing to do
+		// ユーザ側は参照のみ
+	}
+
+	return;
+}
+void can_register_mapping_io_RSCANnCFRISTS(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 txrxdata = 0x0;
+	uint32 k = 0;
+	CanChannelIdType cid;
+	CanBufferIdxType bid;
+
+	if (io_type == CanRegisterIo_Read) {
+		for (cid = 0; cid < CAN_CHANNEL_NUM; cid++) {
+			for (bid = 0; bid < CAN_TXRX_CHANNEL_FIFO_NUM; bid++) {
+				CAN_REG_UPDATE_REG_BIT(can_txrx_fifo_control.buf[cid][bid].status.rx_intr, k, txrxdata);
+				k++;
+			}
+		}
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), ( txrxdata ) );
+	}
+	else { /* CanRegisterIo_Write */
+		// nothing to do
+		// ユーザ側は参照のみ
+	}
+	return;
+}
+void can_register_mapping_io_RSCANnCFTISTS(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 txrxdata = 0x0;
+	uint32 k = 0;
+	CanChannelIdType cid;
+	CanBufferIdxType bid;
+
+	if (io_type == CanRegisterIo_Read) {
+		for (cid = 0; cid < CAN_CHANNEL_NUM; cid++) {
+			for (bid = 0; bid < CAN_TXRX_CHANNEL_FIFO_NUM; bid++) {
+				CAN_REG_UPDATE_REG_BIT(can_txrx_fifo_control.buf[cid][bid].status.tx_intr, k, txrxdata);
+				k++;
+			}
+		}
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), ( txrxdata ) );
+	}
+	else { /* CanRegisterIo_Write */
+		// nothing to do
+		// ユーザ側は参照のみ
+	}
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io_global.c
@@ -0,0 +1,337 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "can_register_mapping_io.h"
+#include "can_register.h"
+#include "can_fifo.h"
+#include "can_buffer.h"
+#include "can_tx_queue.h"
+#include "can_tx_history.h"
+#include "can_mode_global.h"
+#include "can_register_mapping_reset.h"
+
+void can_register_reset_global(CanRegisterResetType type)
+{
+	if (type == CanRegisterResetType_MCU_RESET) {
+		can_mode_global.config.enable_dlc_check = FALSE;
+		can_mode_global.config.enable_tx_bufno_first = FALSE;
+		can_mode_global.ctrl.enable_fifo_msglost = FALSE;
+		can_mode_global.ctrl.enable_dlc_error = FALSE;
+		can_mode_global.ctrl.stop = TRUE;
+		can_mode_global.ctrl.select_mode = CAN_MODE_GLOBAL_MODE_RESET;
+		can_mode_global.mode = GlobalMode_STOP;
+		can_mode_global.status.GSLPSTS = TRUE;
+		can_mode_global.status.GHLTSTS = FALSE;
+		can_mode_global.status.GRSTSTS = TRUE;
+	}
+	else if (type == CanRegisterResetType_GLOBAL_RESET) {
+		can_mode_global.status.dlc_error = FALSE;
+		can_mode_global.status.GHLTSTS = FALSE;
+	}
+	else if (type == CanRegisterResetType_CHANNEL_RESET) {
+		/* nothing */
+	}
+
+	return;
+}
+
+
+void can_register_mapping_io_RSCANnGCFG(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data;
+
+	if (io_type == CanRegisterIo_Read) {
+		// nothing to do
+		// モデル側は参照のみで自発的な更新はしないためモデル情報を取得する必要はない
+	}
+	else { /* CanRegisterIo_Write */
+		//モデルへの同期処理
+		can_register_read_data32(CAN_REG_RSCANnGCFG, &data);
+
+		//1 DCE
+		CAN_REG_UPDATE_MODEL_FLAG(data, 1U, can_mode_global.config.enable_dlc_check);
+		//0 TPRI
+		CAN_REG_UPDATE_MODEL_FLAG(data, 0U, can_mode_global.config.enable_tx_bufno_first);
+	}
+	return;
+}
+void can_register_mapping_io_RSCANnGCTR(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data;
+	uint32 current_gslpr;
+	uint32 current_gmdc;
+	static uint32 old_gslpr = 0x01; // reset value
+	static uint32 old_gmdc = 0x01; // reset value
+
+	can_register_read_data32(CAN_REG_RSCANnGCTR, &data);
+	current_gslpr = CAN_REG_GET_MASK_DATA(data >> 2U, 0x1);
+	current_gmdc = CAN_REG_GET_MASK_DATA(data, 0x3);
+	if (io_type == CanRegisterIo_Write) {
+		//10 THLEIE
+		CAN_REG_UPDATE_MODEL_FLAG(data, 10U, can_mode_global.ctrl.enable_tx_history);
+		//9 MEIE
+		CAN_REG_UPDATE_MODEL_FLAG(data, 9U, can_mode_global.ctrl.enable_fifo_msglost);
+		//8 DEIE
+		CAN_REG_UPDATE_MODEL_FLAG(data, 8U, can_mode_global.ctrl.enable_dlc_error);
+
+		// 2 GSLPR
+		if (current_gslpr != old_gslpr) {
+			if (current_gslpr != 0U) {
+				can_mode_global_event(&can_mode_global, CanModeGlobalEvent_SET_STOP);
+			}
+			else {
+				can_mode_global_event(&can_mode_global, CanModeGlobalEvent_CLR_STOP);
+			}
+		}
+		// 1、 0 GMDC[1:0]
+		if (current_gmdc != old_gmdc) {
+			if (current_gmdc == CAN_MODE_GLOBAL_MODE_RUN) {
+				can_mode_global_event(&can_mode_global, CanModeGlobalEvent_SET_RUN);
+			}
+			else if (current_gmdc == CAN_MODE_GLOBAL_MODE_RESET) {
+				can_mode_global_event(&can_mode_global, CanModeGlobalEvent_SET_RESET);
+			}
+			else if (current_gmdc == CAN_MODE_GLOBAL_MODE_WAIT) {
+				can_mode_global_event(&can_mode_global, CanModeGlobalEvent_SET_TEST);
+			}
+		}
+		old_gmdc = current_gmdc;
+		old_gslpr = current_gslpr;
+	}
+	// 2 GSLPR
+	CAN_REG_UPDATE_REG_BIT(can_mode_global.ctrl.stop, 2U, data);
+	// 1、 0 GMDC[1:0]
+	data &= ~0x3;
+	data |= can_mode_global.ctrl.select_mode;
+	can_register_write_data32(CAN_REG_RSCANnGCTR, data);
+
+	return;
+}
+void can_register_mapping_io_RSCANnGSTS(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data = 0x0;
+	if (io_type == CanRegisterIo_Read) {
+		// 0 GRSTSTS
+		CAN_REG_UPDATE_REG_BIT(can_mode_global.status.GRSTSTS, 0U, data);
+		// 1 GHLTSTS
+		CAN_REG_UPDATE_REG_BIT(can_mode_global.status.GHLTSTS, 1U, data);
+		// 2 GSLPSTS
+		CAN_REG_UPDATE_REG_BIT(can_mode_global.status.GSLPSTS, 2U, data);
+		// 3 GRAMINIT　固定値(0)とする
+		can_register_write_data32(CAN_REG_RSCANnGSTS, data);
+	}
+	else {
+		// nothing to do
+	}
+	return;
+}
+void can_register_mapping_io_RSCANnGERFL(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 i;
+	uint32 data;
+
+	can_register_read_data32(CAN_REG_RSCANnGERFL, &data);
+	if (io_type == CanRegisterIo_Read) {
+		//0 DEF
+		CAN_REG_UPDATE_REG_BIT(can_mode_global.status.dlc_error, 0U, data);
+
+		//1 MES
+		CAN_REG_UPDATE_REG_BIT(can_mode_global_is_msglost(), 1U, data);
+
+		for (i = 0; i < CAN_CHANNEL_NUM; i++) {
+			if (can_tx_history[i].status.thl_ovr == TRUE) {
+				//2 THLES
+				data |= (1U << 2U);
+				break;
+			}
+		}
+
+		can_register_write_data32(CAN_REG_RSCANnGERFL, data);
+	}
+	else { /* CanRegisterIo_Write */
+		//モデルへの同期処理
+
+		//0 DEF
+		if ((data & 0x1) == 0x0) {
+			can_mode_global.status.dlc_error = FALSE;
+		}
+	}
+	return;
+}
+
+bool can_register_mapping_io_RSCANnGTINTSTS_is_tx_intr(CanChannelIdType cid)
+{
+	CanBufferIdxType bid;
+
+	for (bid = 0; bid < CAN_TX_CHANNEL_BUFFER_NUM; bid++) {
+		uint32 flag_id = CAN_TX_BUFFER_FLAG_ID(CAN_TX_BUFFER_ID(cid, bid));
+		uint32 flag_idx = CAN_TX_BUFFER_FLAG_IDX(CAN_TX_BUFFER_ID(cid, bid));
+		if (CAN_DATA_IS_BITSET(can_tx_buffer_control.intr_enable[flag_id], flag_idx)) {
+			if ((can_tx_buffer_control.buf[cid][bid].status.result & 0x10) != 0U) {
+				return TRUE;
+			}
+		}
+	}
+	return FALSE;
+}
+
+bool can_register_mappin_io_RSCANnGTINTSTS_is_CFTIFm(CanChannelIdType cid)
+{
+	CanBufferIdxType bid;
+
+	for (bid = 0; bid < CAN_TXRX_CHANNEL_FIFO_NUM; bid++) {
+		if (can_txrx_fifo_control.buf[cid][bid].config.enable_tx_intr == FALSE) {
+			continue;
+		}
+		if (can_txrx_fifo_control.buf[cid][bid].status.tx_intr == TRUE) {
+			return TRUE;
+		}
+	}
+	return FALSE;
+}
+bool can_register_mappin_io_RSCANnGTINTSTS_is_TQIFm(CanChannelIdType cid)
+{
+	CanBufferIdxType bid;
+
+	for (bid = 0; bid < CAN_TXRX_CHANNEL_FIFO_NUM; bid++) {
+		if (can_tx_queue[cid].config.enable_intr == FALSE) {
+			continue;
+		}
+		if (can_tx_queue[cid].status.intr_req == TRUE) {
+			return TRUE;
+		}
+	}
+	return FALSE;
+}
+bool can_register_mappin_io_RSCANnGTINTSTS_is_THIFm(CanChannelIdType cid)
+{
+	if (can_tx_history[cid].config.enable_intr == FALSE) {
+		return FALSE;
+	}
+	if (can_tx_history[cid].status.thl_intr == TRUE) {
+		return FALSE;
+	}
+	return FALSE;
+}
+void can_register_mapping_io_RSCANnGTINTSTS0(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data;
+
+	can_register_read_data32(CAN_REG_RSCANnGTINTSTS0, &data);
+	if (io_type == CanRegisterIo_Read) {
+		//0 TSIF0
+		CAN_REG_UPDATE_REG_BIT(can_register_mapping_io_RSCANnGTINTSTS_is_tx_intr(0), 0U, data);
+		//8 TSIF1
+		CAN_REG_UPDATE_REG_BIT(can_register_mapping_io_RSCANnGTINTSTS_is_tx_intr(1), 8U, data);
+		//16 TSIF2
+		CAN_REG_UPDATE_REG_BIT(can_register_mapping_io_RSCANnGTINTSTS_is_tx_intr(2), 16U, data);
+		//24 TSIF3
+		CAN_REG_UPDATE_REG_BIT(can_register_mapping_io_RSCANnGTINTSTS_is_tx_intr(3), 24U, data);
+
+		//3 CFTIF0
+		CAN_REG_UPDATE_REG_BIT(can_register_mappin_io_RSCANnGTINTSTS_is_CFTIFm(0), 3U, data);
+		//11 CFTIF1
+		CAN_REG_UPDATE_REG_BIT(can_register_mappin_io_RSCANnGTINTSTS_is_CFTIFm(1), 11U, data);
+		//19 CFTIF2
+		CAN_REG_UPDATE_REG_BIT(can_register_mappin_io_RSCANnGTINTSTS_is_CFTIFm(2), 19U, data);
+		//27 CFTIF3
+		CAN_REG_UPDATE_REG_BIT(can_register_mappin_io_RSCANnGTINTSTS_is_CFTIFm(3), 27U, data);
+
+		//2 TQIF0
+		CAN_REG_UPDATE_REG_BIT(can_register_mappin_io_RSCANnGTINTSTS_is_TQIFm(0), 2U, data);
+		//10 TQIF1
+		CAN_REG_UPDATE_REG_BIT(can_register_mappin_io_RSCANnGTINTSTS_is_TQIFm(1), 10U, data);
+		//18 TQIF2
+		CAN_REG_UPDATE_REG_BIT(can_register_mappin_io_RSCANnGTINTSTS_is_TQIFm(2), 18U, data);
+		//26 TQIF3
+		CAN_REG_UPDATE_REG_BIT(can_register_mappin_io_RSCANnGTINTSTS_is_TQIFm(3), 26U, data);
+
+
+		//4 THIF0
+		CAN_REG_UPDATE_REG_BIT(can_register_mappin_io_RSCANnGTINTSTS_is_THIFm(0), 4U, data);
+		//12 THIF1
+		CAN_REG_UPDATE_REG_BIT(can_register_mappin_io_RSCANnGTINTSTS_is_THIFm(1), 12U, data);
+		//20 THIF2
+		CAN_REG_UPDATE_REG_BIT(can_register_mappin_io_RSCANnGTINTSTS_is_THIFm(2), 20U, data);
+		//28 THIF3
+		CAN_REG_UPDATE_REG_BIT(can_register_mappin_io_RSCANnGTINTSTS_is_THIFm(3), 28U, data);
+
+		can_register_write_data32(CAN_REG_RSCANnGTINTSTS0, data);
+	}
+	else {
+		//nothing to do
+	}
+
+	return;
+}
+void can_register_mapping_io_RSCANnGTINTSTS1(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data;
+
+	can_register_read_data32(CAN_REG_RSCANnGTINTSTS1, &data);
+	if (io_type == CanRegisterIo_Read) {
+		//0 TSIF4
+		CAN_REG_UPDATE_REG_BIT(can_register_mapping_io_RSCANnGTINTSTS_is_tx_intr(4), 0U, data);
+		//8 TSIF5
+		CAN_REG_UPDATE_REG_BIT(can_register_mapping_io_RSCANnGTINTSTS_is_tx_intr(5), 8U, data);
+
+		//3 CFTIF4
+		CAN_REG_UPDATE_REG_BIT(can_register_mappin_io_RSCANnGTINTSTS_is_CFTIFm(4), 3U, data);
+		//11 CFTIF5
+		CAN_REG_UPDATE_REG_BIT(can_register_mappin_io_RSCANnGTINTSTS_is_CFTIFm(5), 11U, data);
+
+		//2 TQIF4
+		CAN_REG_UPDATE_REG_BIT(can_register_mappin_io_RSCANnGTINTSTS_is_TQIFm(4), 2U, data);
+		//10 TQIF5
+		CAN_REG_UPDATE_REG_BIT(can_register_mappin_io_RSCANnGTINTSTS_is_TQIFm(5), 10U, data);
+
+		//4 THIF4
+		CAN_REG_UPDATE_REG_BIT(can_register_mappin_io_RSCANnGTINTSTS_is_THIFm(4), 4U, data);
+		//12 THIF5
+		CAN_REG_UPDATE_REG_BIT(can_register_mappin_io_RSCANnGTINTSTS_is_THIFm(5), 12U, data);
+		can_register_write_data32(CAN_REG_RSCANnGTINTSTS1, data);
+	}
+	else {
+		//nothing to do
+	}
+
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io_rx_buffer.c
@@ -0,0 +1,218 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "can_register_mapping_io.h"
+#include "can_register.h"
+#include "can_buffer.h"
+#include "can_register_mapping_reset.h"
+#include <string.h>
+
+void can_register_reset_rx_buffer(CanRegisterResetType type)
+{
+	uint32 i;
+
+	if (type == CanRegisterResetType_MCU_RESET) {
+		can_rx_buffer_control.rx_buffer_num = 0U;
+
+		for (i = 0; i < CAN_RX_MSGIN_FLAG_NUM; i++) {
+			can_rx_buffer_control.rx_msgin_flag[i] = 0U;
+		}
+
+		for (i = 0; i < CAN_RX_BUFFER_NUM; i++) {
+			can_rx_buffer_control.buf[i].id.ide = 0U;
+			can_rx_buffer_control.buf[i].id.rtr = 0U;
+			can_rx_buffer_control.buf[i].id.id = 0U;
+			can_rx_buffer_control.buf[i].header.dlc = 0U;
+			can_rx_buffer_control.buf[i].header.label = 0U;
+			memset(can_rx_buffer_control.buf[i].body.buffer, 0, CAN_RX_BUFFER_DATA_SIZE);
+		}
+	}
+	else if (type == CanRegisterResetType_GLOBAL_RESET) {
+		for (i = 0; i < CAN_RX_MSGIN_FLAG_NUM; i++) {
+			can_rx_buffer_control.rx_msgin_flag[i] = 0U;
+		}
+	}
+	else if (type == CanRegisterResetType_CHANNEL_RESET) {
+		// nothing
+	}
+
+}
+
+void can_register_mapping_io_RSCANnRMNB(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data;
+
+	if (io_type == CanRegisterIo_Read) {
+		// nothing to do
+		// モデル側は参照のみで自発的な更新はしないためモデル情報を取得する必要はない
+	}
+	else { /* CanRegisterIo_Write */
+		//モデルへの同期処理
+		can_register_read_data32(CAN_REG_RSCANnRMNB, &data);
+
+		//7 ～ 0 NRXMB [7:0]
+		can_rx_buffer_control.rx_buffer_num = CAN_REG_GET_MASK_DATA(data, 0xFFU);
+	}
+	return;
+}
+void can_register_mapping_io_RSCANnRMNDy(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnRMNDy(0), 4U);
+
+	if (io_type == CanRegisterIo_Read) {
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), can_rx_buffer_control.rx_msgin_flag[index]);
+	}
+	else { /* CanRegisterIo_Write */
+		can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+		can_rx_buffer_control.rx_msgin_flag[index] = data;
+	}
+	return;
+}
+
+void can_register_mapping_io_RX_BUFFER(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 addr = CAN_REG_GET_ALIGNED_ADDR(arg->address);
+
+	switch (addr & 0x0000000F) {
+	case 0x0:
+		can_register_mapping_io_RSCANnRMIDq(io_type, arg);
+		break;
+	case 0x04:
+		can_register_mapping_io_RSCANnRMPTRq(io_type, arg);
+		break;
+	case 0x8:
+		can_register_mapping_io_RSCANnRMDF0q(io_type, arg);
+		break;
+	case 0xC:
+		can_register_mapping_io_RSCANnRMDF1q(io_type, arg);
+		break;
+	default:
+		break;
+	}
+	return;
+}
+
+void can_register_mapping_io_RSCANnRMIDq(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data = 0x0;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnRMIDq(0), 16U);
+
+	if (io_type == CanRegisterIo_Read) {
+		// 31 RMIDE
+		CAN_REG_UPDATE_REG_BIT(can_rx_buffer_control.buf[index].id.ide, 31U, data);
+		// 30 RMRTR
+		CAN_REG_UPDATE_REG_BIT(can_rx_buffer_control.buf[index].id.rtr, 30U, data);
+		// 28 ～ 0 RMID [28:0]
+		data |= can_rx_buffer_control.buf[index].id.id;
+
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), data);
+	}
+	else { /* CanRegisterIo_Write */
+		// nothing to do
+		// ユーザ側は参照のみ
+	}
+	return;
+}
+void can_register_mapping_io_RSCANnRMPTRq(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data = 0x0;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnRMPTRq(0), 16U);
+
+	if (io_type == CanRegisterIo_Read) {
+		// 31 ～ 28 RMDLC [3:0]
+		data  |= (can_rx_buffer_control.buf[index].header.dlc << 28U);
+		// 27 ～ 16 RMPTR [11:0]
+		data  |= (can_rx_buffer_control.buf[index].header.label << 16U);
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), data);
+	}
+	else { /* CanRegisterIo_Write */
+		// nothing to do
+		// ユーザ側は参照のみ
+	}
+	return;
+}
+void can_register_mapping_io_RSCANnRMDF0q(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data;
+	uint8 *array = (uint8*)&data;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnRMDF0q(0), 16U);
+
+	if (io_type == CanRegisterIo_Read) {
+		// 7 ～ 0 RMDB0 [7:0]
+		array[0] = can_rx_buffer_control.buf[index].body.buffer[0];
+		// 15 ～ 8 RMDB1 [7:0]
+		array[1] = can_rx_buffer_control.buf[index].body.buffer[1];
+		// 23 ～ 16 RMDB2 [7:0]
+		array[2] = can_rx_buffer_control.buf[index].body.buffer[2];
+		// 31 ～ 24 RMDB3 [7:0]
+		array[3] = can_rx_buffer_control.buf[index].body.buffer[3];
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), data);
+	}
+	else { /* CanRegisterIo_Write */
+		// nothing to do
+		// ユーザ側は参照のみ
+	}
+	return;
+}
+void can_register_mapping_io_RSCANnRMDF1q(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data;
+	uint8 *array = (uint8*)&data;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnRMDF1q(0), 16U);
+
+	if (io_type == CanRegisterIo_Read) {
+		// 7 ～ 0 RMDB4 [7:0]
+		array[0] = can_rx_buffer_control.buf[index].body.buffer[4];
+		// 15 ～ 8 RMDB5 [7:0]
+		array[1] = can_rx_buffer_control.buf[index].body.buffer[5];
+		// 23 ～ 16 RMDB6 [7:0]
+		array[2] = can_rx_buffer_control.buf[index].body.buffer[6];
+		// 31 ～ 24 RMDB7 [7:0]
+		array[3] = can_rx_buffer_control.buf[index].body.buffer[7];
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), data);
+	}
+	else { /* CanRegisterIo_Write */
+		// nothing to do
+		// ユーザ側は参照のみ
+	}
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io_rx_fifo.c
@@ -0,0 +1,292 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "can_register_mapping_io.h"
+#include "can_register.h"
+#include "can_fifo.h"
+#include "can_register_mapping_reset.h"
+
+void can_register_reset_rx_fifo(CanRegisterResetType type)
+{
+	uint32 i;
+
+	if (type == CanRegisterResetType_MCU_RESET) {
+		for (i = 0; i < CAN_RX_FIFO_NUM; i++) {
+			can_rx_fifo_control.fifo[i].config.intr_timing_cnt = 0U;
+			can_rx_fifo_control.fifo[i].config.enable_intr_everytime = FALSE;
+			can_rx_fifo_control.fifo[i].config.quelen = 0U;
+			can_rx_fifo_control.fifo[i].config.enable_intr = FALSE;
+			can_rx_fifo_control.fifo[i].config.enable_fifo = FALSE;
+			(void)can_rxfifo_clear(i);
+			can_rx_fifo_control.fifo[i].status.rx_intr = FALSE;
+			can_rx_fifo_control.fifo[i].status.rx_lost = FALSE;
+			can_rx_fifo_control.fifo[i].status.rx_full = FALSE;
+			can_rx_fifo_control.fifo[i].status.rx_empty = TRUE;
+			memset(&can_rx_fifo_control.fifo[i].buffer[0], 0, sizeof(CanRxBufferType) * CAN_RX_FIFO_QUEUE_MAX);
+		}
+
+	}
+	else if (type == CanRegisterResetType_GLOBAL_RESET) {
+		for (i = 0; i < CAN_RX_FIFO_NUM; i++) {
+			can_rx_fifo_control.fifo[i].config.enable_fifo = FALSE;
+			(void)can_rxfifo_clear(i);
+			can_rx_fifo_control.fifo[i].status.rx_intr = FALSE;
+			can_rx_fifo_control.fifo[i].status.rx_lost = FALSE;
+			can_rx_fifo_control.fifo[i].status.rx_full = FALSE;
+			can_rx_fifo_control.fifo[i].status.rx_empty = TRUE;
+		}
+	}
+	else if (type == CanRegisterResetType_CHANNEL_RESET) {
+		// nothing
+	}
+
+}
+void can_register_mapping_io_RSCANnRFCCx(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnRFCCx(0), 4U);
+
+	if (io_type == CanRegisterIo_Read) {
+		// 15 ～ 13 RFIGCV [2:0]: モデル側は参照のみで自発的な更新はしないためモデル情報を取得する必要はない
+		// 12 RFIM: モデル側は参照のみで自発的な更新はしないためモデル情報を取得する必要はない
+		// 10 ～ 8 RFDC [2:0]: モデル側は参照のみで自発的な更新はしないためモデル情報を取得する必要はない
+		// 1 RFIE: モデル側は参照のみで自発的な更新はしないためモデル情報を取得する必要はない
+		// 0 RFE モデル側は参照のみで自発的な更新はしないためモデル情報を取得する必要はない
+	}
+	else { /* CanRegisterIo_Write */
+		can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+		//モデルへの同期処理
+		// 15 ～ 13 RFIGCV [2:0]
+		can_rx_fifo_control.fifo[index].config.intr_timing_cnt = CAN_REG_GET_MASK_DATA(data >> 13U, 0x3);
+		// 12 RFIM
+		CAN_REG_UPDATE_MODEL_FLAG(data, 12U, can_rx_fifo_control.fifo[index].config.enable_intr_everytime);
+		// 10 ～ 8 RFDC [2:0]
+		can_rx_fifo_control.fifo[index].config.quelen = CAN_REG_GET_MASK_DATA(data >> 8U, 0x7);
+		// 1 RFIE
+		CAN_REG_UPDATE_MODEL_FLAG(data, 1U, can_rx_fifo_control.fifo[index].config.enable_intr);
+		// 0 RFE
+		CAN_REG_UPDATE_MODEL_FLAG(data, 0U, can_rx_fifo_control.fifo[index].config.enable_fifo);
+		if (can_rx_fifo_control.fifo[index].config.enable_fifo == FALSE) {
+			(void)can_rxfifo_clear(index);
+			can_rx_fifo_control.fifo[index].status.rx_empty = TRUE;
+			can_rx_fifo_control.fifo[index].status.rx_full = FALSE;
+		}
+	}
+	return;
+}
+void can_register_mapping_io_RSCANnRFSTSx(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data = 0x0;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnRFSTSx(0), 4U);
+
+	if (io_type == CanRegisterIo_Read) {
+		//15 ～ 8 RFMC[7:0]
+		data |= (can_rx_fifo_control.fifo[index].fifo_control.count << 8U);
+		//3 RFIF
+		CAN_REG_UPDATE_REG_BIT(can_rx_fifo_control.fifo[index].status.rx_intr, 3U, data);
+		//2 RFMLT
+		CAN_REG_UPDATE_REG_BIT(can_rx_fifo_control.fifo[index].status.rx_lost, 2U, data);
+		//1 RFFLL
+		CAN_REG_UPDATE_REG_BIT(can_rx_fifo_control.fifo[index].status.rx_full, 1U, data);
+		//0 RFEMPL
+		CAN_REG_UPDATE_REG_BIT(can_rx_fifo_control.fifo[index].status.rx_empty, 0U, data);
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), data);
+	}
+	else { /* CanRegisterIo_Write */
+		can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+		//モデルへの同期処理
+		//3 RFIF
+		if ((data & (1U << 3U)) == 0x00) {
+			can_rx_fifo_control.fifo[index].status.rx_intr = FALSE;
+		}
+		//2 RFMLT
+		if ((data & (1U << 2U)) == 0x00) {
+			can_rx_fifo_control.fifo[index].status.rx_lost = FALSE;
+		}
+	}
+	return;
+}
+void can_register_mapping_io_RSCANnRFPCTRx(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data = 0x0;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnRFPCTRx(0), 4U);
+
+	if (io_type == CanRegisterIo_Read) {
+		// write only
+	}
+	else { /* CanRegisterIo_Write */
+		can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+		//モデルへの同期処理
+		if (CAN_REG_GET_MASK_DATA(data, 0xFF) == 0xFF) {
+			(void)can_rxfifo_next_rxdata(index);
+		}
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), 0x0);
+	}
+	return;
+}
+void can_register_mapping_io_RX_FIFO(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 addr = CAN_REG_GET_ALIGNED_ADDR(arg->address);
+
+	switch (addr & 0x0000000F) {
+	case 0x0:
+		can_register_mapping_io_RSCANnRFIDx(io_type, arg);
+		break;
+	case 0x04:
+		can_register_mapping_io_RSCANnRFPTRx(io_type, arg);
+		break;
+	case 0x8:
+		can_register_mapping_io_RSCANnRFDF0x(io_type, arg);
+		break;
+	case 0xC:
+		can_register_mapping_io_RSCANnRFDF1x(io_type, arg);
+		break;
+	default:
+		break;
+	}
+	return;
+}
+
+void can_register_mapping_io_RSCANnRFIDx(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	Std_ReturnType err;
+	CanDataType rxdata;
+	uint32 data = 0x0;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnRFIDx(0), 16U);
+
+	if (io_type == CanRegisterIo_Read) {
+		err = can_rxfifo_peek_rxdata(index, &rxdata);
+		if (err == STD_E_OK) {
+			// 31 RFIDE
+			CAN_REG_UPDATE_REG_BIT(rxdata.ide, 31U, data);
+			// 30 RFRTR
+			CAN_REG_UPDATE_REG_BIT(rxdata.rtr, 30U, data);
+			// 28 ～ 0 RFID [28:0]
+			data |= rxdata.id;
+		}
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), data);
+	}
+	else { /* CanRegisterIo_Write */
+		// nothing to do
+		// ユーザ側は参照のみ
+	}
+	return;
+}
+
+void can_register_mapping_io_RSCANnRFPTRx(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	Std_ReturnType err;
+	CanDataType rxdata;
+	uint32 data = 0x0;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnRFPTRx(0), 16U);
+
+	if (io_type == CanRegisterIo_Read) {
+		err = can_rxfifo_peek_rxdata(index, &rxdata);
+		if (err == STD_E_OK) {
+			// 31 ～ 28 RFDLC [3:0]
+			data  |= (rxdata.dlc << 28U);
+			// 27 ～ 16 RFPTR [11:0]
+			data  |= (rxdata.label << 16U);
+		}
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), data);
+	}
+	else { /* CanRegisterIo_Write */
+		// nothing to do
+		// ユーザ側は参照のみ
+	}
+	return;
+}
+void can_register_mapping_io_RSCANnRFDF0x(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	Std_ReturnType err;
+	uint32 data = 0x0;
+	uint8 *array = (uint8*)&data;
+	CanDataType rxdata;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnRFDF0x(0), 16U);
+
+	if (io_type == CanRegisterIo_Read) {
+		err = can_rxfifo_peek_rxdata(index, &rxdata);
+		if (err == STD_E_OK) {
+			// 7 ～ 0 RFDB0 [7:0]
+			array[0] = rxdata.data[0];
+			// 15 ～ 8 RFDB1 [7:0]
+			array[1] = rxdata.data[1];
+			// 23 ～ 16 RFDB2 [7:0]
+			array[2] = rxdata.data[2];
+			// 31 ～ 24 RFDB3 [7:0]
+			array[3] = rxdata.data[3];
+		}
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), data);
+	}
+	else { /* CanRegisterIo_Write */
+		// nothing to do
+		// ユーザ側は参照のみ
+	}
+	return;
+}
+void can_register_mapping_io_RSCANnRFDF1x(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	Std_ReturnType err;
+	uint32 data;
+	uint8 *array = (uint8*)&data;
+	CanDataType rxdata;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnRFDF1x(0), 16U);
+
+	if (io_type == CanRegisterIo_Read) {
+		err = can_rxfifo_peek_rxdata(index, &rxdata);
+		if (err == STD_E_OK) {
+			// 7 ～ 0 RFDB4 [7:0]
+			array[0] = rxdata.data[4];
+			// 15 ～ 8 RFDB5 [7:0]
+			array[1] = rxdata.data[5];
+			// 23 ～ 16 RFDB6 [7:0]
+			array[2] = rxdata.data[6];
+			// 31 ～ 24 RFDB7 [7:0]
+			array[3] = rxdata.data[7];
+		}
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), data);
+	}
+	else { /* CanRegisterIo_Write */
+		// nothing to do
+		// ユーザ側は参照のみ
+	}
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io_rx_rule.c
@@ -0,0 +1,243 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "can_register_mapping_io.h"
+#include "can_register.h"
+#include "can_register_mapping_reset.h"
+#include "can_rule.h"
+
+void can_register_reset_rx_rule(CanRegisterResetType type)
+{
+	CanChannelIdType cid;
+	uint32 pid;
+	uint32 rid;
+
+	if (type == CanRegisterResetType_MCU_RESET) {
+		can_rx_rule_table.ctrl.enable_write = FALSE;
+		can_rx_rule_table.ctrl.page_number = 0U;
+		for (cid = 0; cid < CAN_CHANNEL_NUM; cid++) {
+			can_rx_number.channel_rx_rule_num[cid]  = 0U;
+		}
+
+		for (pid = 0; pid < CAN_RX_RULE_TABLE_PAGE_NUM; pid++) {
+			for (rid = 0; rid < CAN_RX_PAGE_RULE_NUM; rid++) {
+				can_rx_rule_table.page[pid].rule[rid].id.ide = 0U;
+				can_rx_rule_table.page[pid].rule[rid].id.rtr = 0U;
+				can_rx_rule_table.page[pid].rule[rid].id.canid = 0U;
+				can_rx_rule_table.page[pid].rule[rid].mask.ide = 0U;
+				can_rx_rule_table.page[pid].rule[rid].mask.rtr = 0U;
+				can_rx_rule_table.page[pid].rule[rid].mask.canid = 0U;
+				can_rx_rule_table.page[pid].rule[rid].filter_buffer.dlc = 0U;
+				can_rx_rule_table.page[pid].rule[rid].filter_buffer.label = 0U;
+				can_rx_rule_table.page[pid].rule[rid].filter_buffer.enable_rxbuffer = 0U;
+				can_rx_rule_table.page[pid].rule[rid].filter_buffer.rxbuffer_number = 0U;
+				can_rx_rule_table.page[pid].rule[rid].filter_fifo.txrx_fifo = 0U;
+				can_rx_rule_table.page[pid].rule[rid].filter_fifo.rx_fifo = 0U;
+			}
+		}
+	}
+	else if (type == CanRegisterResetType_GLOBAL_RESET) {
+		// nothing
+	}
+	else if (type == CanRegisterResetType_CHANNEL_RESET) {
+		// nothing
+	}
+
+}
+
+void can_register_mapping_io_RSCANnGAFLECTR(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data;
+
+	if (io_type == CanRegisterIo_Read) {
+		// nothing to do
+		// モデル側は参照のみで自発的な更新はしないためモデル情報を取得する必要はない
+	}
+	else { /* CanRegisterIo_Write */
+		//モデルへの同期処理
+		can_register_read_data32(CAN_REG_RSCANnGAFLECTR, &data);
+		//AFLDAE
+		CAN_REG_UPDATE_MODEL_FLAG(data, 8U, can_rx_rule_table.ctrl.enable_write);
+		//AFLPN [4:0]
+		can_rx_rule_table.ctrl.page_number = CAN_REG_GET_MASK_DATA(data, 0x01FU);
+	}
+}
+void can_register_mapping_io_RSCANnGAFLCFG0(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data;
+	uint8 *array = (uint8*)&data;
+
+	if (io_type == CanRegisterIo_Read) {
+		// nothing to do
+		// モデル側は参照のみで自発的な更新はしないためモデル情報を取得する必要はない
+	}
+	else { /* CanRegisterIo_Write */
+		//モデルへの同期処理
+		can_register_read_data32(CAN_REG_RSCANnGAFLCFG0, &data);
+		can_rx_number.channel_rx_rule_num[0] = array[3];
+		can_rx_number.channel_rx_rule_num[1] = array[2];
+		can_rx_number.channel_rx_rule_num[2] = array[1];
+		can_rx_number.channel_rx_rule_num[3] = array[0];
+		can_rx_update_rule_table();
+	}
+}
+void can_register_mapping_io_RSCANnGAFLCFG1(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data;
+	uint8 *array = (uint8*)&data;
+
+	if (io_type == CanRegisterIo_Read) {
+		// nothing to do
+		// モデル側は参照のみで自発的な更新はしないためモデル情報を取得する必要はない
+	}
+	else { /* CanRegisterIo_Write */
+		//モデルへの同期処理
+		can_register_read_data32(CAN_REG_RSCANnGAFLCFG1, &data);
+		can_rx_number.channel_rx_rule_num[4] = array[3];
+		can_rx_number.channel_rx_rule_num[5] = array[2];
+		can_rx_update_rule_table();
+	}
+}
+
+void can_register_mapping_io_RSCANnGAFLIDj(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnGAFLIDj(0), 16U);
+
+	if (io_type == CanRegisterIo_Read) {
+		// nothing to do
+		// モデル側は参照のみで自発的な更新はしないためモデル情報を取得する必要はない
+	}
+	else { /* CanRegisterIo_Write */
+		//モデルへの同期処理
+		can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+		// 31 GAFLIDE
+		CAN_REG_UPDATE_MODEL_FLAG(data, 31, can_rx_rule_table.page[can_rx_rule_table.ctrl.page_number].rule[index].id.ide);
+		// 30 GAFLRTR
+		CAN_REG_UPDATE_MODEL_FLAG(data, 30, can_rx_rule_table.page[can_rx_rule_table.ctrl.page_number].rule[index].id.rtr);
+		// 28 ～ 0 GAFLID[28:0]
+		can_rx_rule_table.page[can_rx_rule_table.ctrl.page_number].rule[index].id.canid = CAN_REG_GET_MASK_DATA(data, 0x1FFFFFFF);
+	}
+}
+void can_register_mapping_io_RSCANnGAFLMj(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnGAFLMj(0), 16U);
+
+	if (io_type == CanRegisterIo_Read) {
+		// nothing to do
+		// モデル側は参照のみで自発的な更新はしないためモデル情報を取得する必要はない
+	}
+	else { /* CanRegisterIo_Write */
+		//モデルへの同期処理
+		can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+		// 31 GAFLIDEM
+		CAN_REG_UPDATE_MODEL_FLAG(data, 31, can_rx_rule_table.page[can_rx_rule_table.ctrl.page_number].rule[index].mask.ide);
+		// 30 GAFLRTRM
+		CAN_REG_UPDATE_MODEL_FLAG(data, 30, can_rx_rule_table.page[can_rx_rule_table.ctrl.page_number].rule[index].mask.rtr);
+		// 28 ～ 0 GAFLIDM[28:0]
+		can_rx_rule_table.page[can_rx_rule_table.ctrl.page_number].rule[index].mask.canid = CAN_REG_GET_MASK_DATA(data, 0x1FFFFFFF);
+	}
+}
+void can_register_mapping_io_RSCANnGAFLP0j(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnGAFLP0j(0), 16U);
+
+	if (io_type == CanRegisterIo_Read) {
+		// nothing to do
+		// モデル側は参照のみで自発的な更新はしないためモデル情報を取得する必要はない
+	}
+	else { /* CanRegisterIo_Write */
+		//モデルへの同期処理
+		can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+		// 31 ～ 28 GAFLDLC [3:0]
+		can_rx_rule_table.page[can_rx_rule_table.ctrl.page_number].rule[index].filter_buffer.dlc = (data >> 28U);
+		// 27 ～ 16 GAFLPTR[11:0]
+		can_rx_rule_table.page[can_rx_rule_table.ctrl.page_number].rule[index].filter_buffer.label = ((data >> 16U) & 0xFFF);
+		// 15 GAFLRMV
+		CAN_REG_UPDATE_MODEL_FLAG(data, 15, can_rx_rule_table.page[can_rx_rule_table.ctrl.page_number].rule[index].filter_buffer.enable_rxbuffer);
+		// 14 ～ 8 GAFLRMDP[6:0]
+		can_rx_rule_table.page[can_rx_rule_table.ctrl.page_number].rule[index].filter_buffer.rxbuffer_number = CAN_REG_GET_MASK_DATA((data >> 8U), 0x0000007F);
+	}
+}
+
+void can_register_mapping_io_RSCANnGAFLP1j(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnGAFLP1j(0), 16U);
+
+	if (io_type == CanRegisterIo_Read) {
+		// nothing to do
+		// モデル側は参照のみで自発的な更新はしないためモデル情報を取得する必要はない
+	}
+	else { /* CanRegisterIo_Write */
+		//モデルへの同期処理
+		can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+		// 25 ～ 8 GAFLFDP[25:8]
+		can_rx_rule_table.page[can_rx_rule_table.ctrl.page_number].rule[index].filter_fifo.txrx_fifo = CAN_REG_GET_MASK_DATA((data >> 8U), 0x0003FFFF);/* 18bits */
+		// 7 ～ 0 GAFLFDP [7:0]
+		can_rx_rule_table.page[can_rx_rule_table.ctrl.page_number].rule[index].filter_fifo.rx_fifo = CAN_REG_GET_MASK_DATA((data >> 0U), 0x000000FF);
+	}
+}
+void can_register_mapping_io_RX_RULE(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 addr = CAN_REG_GET_ALIGNED_ADDR(arg->address);
+
+	switch (addr & 0x0000000F) {
+	case 0x0:
+		can_register_mapping_io_RSCANnGAFLIDj(io_type, arg);
+		break;
+	case 0x04:
+		can_register_mapping_io_RSCANnGAFLMj(io_type, arg);
+		break;
+	case 0x8:
+		can_register_mapping_io_RSCANnGAFLP0j(io_type, arg);
+		break;
+	case 0xC:
+		can_register_mapping_io_RSCANnGAFLP1j(io_type, arg);
+		break;
+	default:
+		break;
+	}
+	return;
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io_table.c
@@ -0,0 +1,130 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "can_register.h"
+#include "can_config.h"
+#include "can_register_mapping_io_table.h"
+
+CanRegisterMappingType can_reigster_mapping_table[CAN_REGISTER_MAPPING_TABLE_NUM] = {
+		/*
+		 * チャネル関連レジスタ
+		 */
+		{ (RSCANn_base + 0x0000), 4U, (16U * CAN_CHANNEL_NUM), can_register_mapping_io_CHANNEL },
+		/*
+		 * グローバル関連レジスタ
+		 */
+		{ (RSCANn_base + 0x0084), 4U, 0U, can_register_mapping_io_RSCANnGCFG },
+		{ (RSCANn_base + 0x0088), 4U, 0U, can_register_mapping_io_RSCANnGCTR },
+		{ (RSCANn_base + 0x008C), 4U, 0U, can_register_mapping_io_RSCANnGSTS },
+		{ (RSCANn_base + 0x0090), 4U, 0U, can_register_mapping_io_RSCANnGERFL },
+		{ (RSCANn_base + 0x0460), 4U, 0U, can_register_mapping_io_RSCANnGTINTSTS0 },
+		{ (RSCANn_base + 0x0464), 4U, 0U, can_register_mapping_io_RSCANnGTINTSTS1 },
+
+		/*
+		 * 受信ルール関連レジスタ
+		 */
+		{ (RSCANn_base + 0x0098), 4U, 0U, can_register_mapping_io_RSCANnGAFLECTR },
+		{ (RSCANn_base + 0x009C), 4U, 0U, can_register_mapping_io_RSCANnGAFLCFG0 },
+		{ (RSCANn_base + 0x00A0), 4U, 0U, can_register_mapping_io_RSCANnGAFLCFG1 },
+		{ (RSCANn_base + 0x0500), 4U, (16U * CAN_RX_PAGE_RULE_NUM), can_register_mapping_io_RX_RULE },
+
+		/*
+		 * 受信バッファ関連レジスタ
+		 */
+		{ (RSCANn_base + 0x00A4), 4U, 0U, can_register_mapping_io_RSCANnRMNB },
+		{ (RSCANn_base + 0x00A8), 4U, (4U * CAN_RX_MSGIN_FLAG_NUM), can_register_mapping_io_RSCANnRMNDy },
+		{ (RSCANn_base + 0x0600), 4U, (16U * CAN_RX_BUFFER_NUM), can_register_mapping_io_RX_BUFFER },
+
+		/*
+		 * 受信 FIFO バッファ関連レジスタ
+		 */
+		{ (RSCANn_base + 0x00B8), 4U, (4U * CAN_RX_FIFO_NUM), can_register_mapping_io_RSCANnRFCCx },
+		{ (RSCANn_base + 0x00D8), 4U, (4U * CAN_RX_FIFO_NUM), can_register_mapping_io_RSCANnRFSTSx },
+		{ (RSCANn_base + 0x00F8), 4U, (4U * CAN_RX_FIFO_NUM), can_register_mapping_io_RSCANnRFPCTRx },
+		{ (RSCANn_base + 0x0E00), 4U, (16U * CAN_RX_FIFO_NUM), can_register_mapping_io_RX_FIFO },
+
+		/*
+		 * 送受信 FIFO バッファ関連レジスタ
+		 */
+		{ (RSCANn_base + 0x0118), 4U, (4U * (CAN_CHANNEL_NUM * CAN_TXRX_CHANNEL_FIFO_NUM)), can_register_mapping_io_RSCANnCFCCk },
+		{ (RSCANn_base + 0x0178), 4U, (4U * (CAN_CHANNEL_NUM * CAN_TXRX_CHANNEL_FIFO_NUM)), can_register_mapping_io_RSCANnCFSTSk },
+		{ (RSCANn_base + 0x01D8), 4U, (4U * (CAN_CHANNEL_NUM * CAN_TXRX_CHANNEL_FIFO_NUM)), can_register_mapping_io_RSCANnCFPCTRk },
+		{ (RSCANn_base + 0x0E80), 4U, (16U * (CAN_CHANNEL_NUM * CAN_TXRX_CHANNEL_FIFO_NUM)), can_register_mapping_io_TXRX_FIFO },
+
+		/*
+		 * FIFO ステータス関連レジスタ
+		 */
+		{ (RSCANn_base + 0x0238), 4U, 0U, can_register_mapping_io_RSCANnFESTS },
+		{ (RSCANn_base + 0x023C), 4U, 0U, can_register_mapping_io_RSCANnFFSTS },
+		{ (RSCANn_base + 0x0240), 4U, 0U, can_register_mapping_io_RSCANnFMSTS },
+		{ (RSCANn_base + 0x0244), 4U, 0U, can_register_mapping_io_RSCANnRFISTS },
+		{ (RSCANn_base + 0x0248), 4U, 0U, can_register_mapping_io_RSCANnCFRISTS },
+		{ (RSCANn_base + 0x024C), 4U, 0U, can_register_mapping_io_RSCANnCFTISTS },
+
+		/*
+		 * 送信バッファ関連レジスタ
+		 */
+		{ (RSCANn_base + 0x0250), 1U, (1U * (CAN_TX_BUFFER_NUM)), can_register_mapping_io_RSCANnTMCp },
+		{ (RSCANn_base + 0x02D0), 1U, (1U * (CAN_TX_BUFFER_NUM)), can_register_mapping_io_RSCANnTMSTSp },
+		{ (RSCANn_base + 0x1000), 4U, (16U * CAN_TX_BUFFER_NUM), can_register_mapping_io_TX_BUFFER },
+		{ (RSCANn_base + 0x0390), 4U, (4U * CAN_TX_BUFFER_FLAG_NUM), can_register_mapping_io_RSCANnTMIECy },
+
+		/*
+		 * 送信バッファステータス関連レジスタ
+		 */
+		{ (RSCANn_base + 0x0350), 4U, (4U * CAN_TX_BUFFER_FLAG_NUM), can_register_mapping_io_RSCANnTMTRSTSy },
+		{ (RSCANn_base + 0x0370), 4U, (4U * CAN_TX_BUFFER_FLAG_NUM), can_register_mapping_io_RSCANnTMTCSTSy },
+
+		/*
+		 * 送信キュー関連レジスタ
+		 */
+		{ (RSCANn_base + 0x03A0), 4U, (4U * CAN_CHANNEL_NUM), can_register_mapping_io_RSCANnTXQCCm },
+		{ (RSCANn_base + 0x03C0), 4U, (4U * CAN_CHANNEL_NUM), can_register_mapping_io_RSCANnTXQSTSm },
+		{ (RSCANn_base + 0x03E0), 4U, (4U * CAN_CHANNEL_NUM), can_register_mapping_io_RSCANnTXQPCTRm },
+
+		/*
+		 * 送信履歴関連レジスタ
+		 */
+		{ (RSCANn_base + 0x0400), 4U, (4U * CAN_CHANNEL_NUM), can_register_mapping_io_RSCANnTHLCCm },
+		{ (RSCANn_base + 0x0420), 4U, (4U * CAN_CHANNEL_NUM), can_register_mapping_io_RSCANnTHLSTSm },
+		{ (RSCANn_base + 0x0440), 4U, (4U * CAN_CHANNEL_NUM), can_register_mapping_io_RSCANnTHLPCTRm },
+		{ (RSCANn_base + 0x1800), 4U, (4U * CAN_CHANNEL_NUM), can_register_mapping_io_RSCANnTHLACCm },
+};
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io_table.h
@@ -0,0 +1,51 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _CAN_REGISTER_MAPPING_IO_TABLE_H_
+#define _CAN_REGISTER_MAPPING_IO_TABLE_H_
+
+#include "can_register_mapping_io.h"
+
+#define CAN_REGISTER_MAPPING_TABLE_NUM	41U
+extern CanRegisterMappingType can_reigster_mapping_table[CAN_REGISTER_MAPPING_TABLE_NUM];
+
+
+#endif /* _CAN_REGISTER_MAPPING_IO_TABLE_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io_tx_buffer.c
@@ -0,0 +1,292 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "can_register_mapping_io.h"
+#include "can_register.h"
+#include "can_buffer.h"
+#include "can_register_mapping_reset.h"
+
+void can_register_reset_tx_buffer(CanRegisterResetType type)
+{
+	CanChannelIdType cid;
+	uint32 bid;
+	uint32 i;
+
+	if (type == CanRegisterResetType_MCU_RESET) {
+		for (cid = 0U; cid < CAN_CHANNEL_NUM; cid++) {
+			for (bid = 0U; bid < CAN_TX_CHANNEL_BUFFER_NUM; bid++) {
+				can_tx_buffer_control.buf[cid][bid].ctrl.req_tx = FALSE;
+				can_tx_buffer_control.buf[cid][bid].status.result = 0U;
+				can_tx_buffer_control.buf[cid][bid].status.sending = FALSE;
+				can_tx_buffer_control.buf[cid][bid].id.ide = FALSE;
+				can_tx_buffer_control.buf[cid][bid].id.rtr = FALSE;
+				can_tx_buffer_control.buf[cid][bid].id.id = 0U;
+				can_tx_buffer_control.buf[cid][bid].header.dlc = 0U;
+				memset(&can_tx_buffer_control.buf[cid][bid].body.buffer, 0, CAN_TX_BUFFER_DATA_SIZE);
+			}
+			for (i = 0; i < CAN_TX_BUFFER_FLAG_NUM; i++) {
+				can_tx_buffer_control.intr_enable[i] = 0U;
+			}
+		}
+	}
+	else if (type == CanRegisterResetType_GLOBAL_RESET) {
+		// nothing
+	}
+	else if (type == CanRegisterResetType_CHANNEL_RESET) {
+		for (cid = 0U; cid < CAN_CHANNEL_NUM; cid++) {
+			for (bid = 0U; bid < CAN_TX_CHANNEL_BUFFER_NUM; bid++) {
+				can_tx_buffer_control.buf[cid][bid].ctrl.req_tx = FALSE;
+				can_tx_buffer_control.buf[cid][bid].status.result = 0U;
+				can_tx_buffer_control.buf[cid][bid].status.sending = FALSE;
+			}
+		}
+	}
+
+}
+void can_register_reset_tx_buffer_channel(CanChannelIdType cid)
+{
+	uint32 bid;
+
+	for (bid = 0U; bid < CAN_TX_CHANNEL_BUFFER_NUM; bid++) {
+		can_tx_buffer_control.buf[cid][bid].ctrl.req_tx = FALSE;
+		can_tx_buffer_control.buf[cid][bid].status.result = 0U;
+		can_tx_buffer_control.buf[cid][bid].status.sending = FALSE;
+	}
+}
+void can_register_mapping_io_RSCANnTMCp(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint8 data = 0x0;
+	uint32 index = CAN_REG_INDEX(arg->address, CAN_REG_RSCANnTMCp(0), 1U);
+	CanChannelIdType cid = index / CAN_TX_CHANNEL_BUFFER_NUM;
+	CanBufferIdxType bid = index % CAN_TX_CHANNEL_BUFFER_NUM;
+
+	if (io_type == CanRegisterIo_Read) {
+		//0 TMTR
+		CAN_REG_UPDATE_REG_BIT(can_tx_buffer_control.buf[cid][bid].ctrl.req_tx, 0U, data);
+		can_register_write_data8(arg->address, data);
+	}
+	else { /* CanRegisterIo_Write */
+		can_register_read_data8(arg->address, &data);
+		CAN_REG_UPDATE_MODEL_FLAG(data, 0U, can_tx_buffer_control.buf[cid][bid].ctrl.req_tx);
+	}
+	return;
+}
+void can_register_mapping_io_RSCANnTMSTSp(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint8 data = 0x0;
+	uint32 index = CAN_REG_INDEX(arg->address, CAN_REG_RSCANnTMSTSp(0), 1U);
+	CanChannelIdType cid = index / CAN_TX_CHANNEL_BUFFER_NUM;
+	CanBufferIdxType bid = index % CAN_TX_CHANNEL_BUFFER_NUM;
+	if (io_type == CanRegisterIo_Read) {
+		//3 TMTRM
+		CAN_REG_UPDATE_REG_BIT(can_tx_buffer_control.buf[cid][bid].ctrl.req_tx, 3U, data);
+		//2、 1 TMTRF[1:0]
+		data |= (can_tx_buffer_control.buf[cid][bid].status.result << 1U);
+		//0 TMTSTS
+		CAN_REG_UPDATE_REG_BIT(can_tx_buffer_control.buf[cid][bid].status.sending, 0U, data);
+
+		can_register_write_data8(arg->address, data);
+	}
+	else { /* CanRegisterIo_Write */
+		can_register_read_data8(arg->address, &data);
+		//2、 1 TMTRF[1:0]
+		can_tx_buffer_control.buf[cid][bid].status.result = CAN_REG_GET_MASK_DATA(data >> 1U, 0x3);
+	}
+	return;
+}
+
+void can_register_mapping_io_TX_BUFFER(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 addr = CAN_REG_GET_ALIGNED_ADDR(arg->address);
+
+	switch (addr & 0x0000000F) {
+	case 0x0:
+		can_register_mapping_io_RSCANnTMIDp(io_type, arg);
+		break;
+	case 0x04:
+		can_register_mapping_io_RSCANnTMPTRp(io_type, arg);
+		break;
+	case 0x8:
+		can_register_mapping_io_RSCANnTMDF0p(io_type, arg);
+		break;
+	case 0xC:
+		can_register_mapping_io_RSCANnTMDF1p(io_type, arg);
+		break;
+	default:
+		break;
+	}
+	return;
+}
+
+void can_register_mapping_io_RSCANnTMIDp(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data = 0x0;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnTMIDp(0), 16U);
+	CanChannelIdType cid = index / CAN_TX_CHANNEL_BUFFER_NUM;
+	CanBufferIdxType bid = index % CAN_TX_CHANNEL_BUFFER_NUM;
+
+	if (io_type == CanRegisterIo_Read) {
+		// 31 TMIDE
+		CAN_REG_UPDATE_REG_BIT(can_tx_buffer_control.buf[cid][bid].id.ide, 31U, data);
+		// 30 TMRTR
+		CAN_REG_UPDATE_REG_BIT(can_tx_buffer_control.buf[cid][bid].id.rtr, 30U, data);
+		// 28 ～ 0 TMID [28:0]
+		data |= can_tx_buffer_control.buf[cid][bid].id.id;
+
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), data);
+	}
+	else { /* CanRegisterIo_Write */
+		can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+		// 31 TMIDE
+		CAN_REG_UPDATE_MODEL_FLAG(data, 31U, can_tx_buffer_control.buf[cid][bid].id.ide);
+		// 30 TMRTR
+		CAN_REG_UPDATE_MODEL_FLAG(data, 30U, can_tx_buffer_control.buf[cid][bid].id.rtr);
+		// 28 ～ 0 TMID [28:0]
+		can_tx_buffer_control.buf[cid][bid].id.id = CAN_REG_GET_MASK_DATA(data, 0x1FFFFFFF);
+	}
+
+	return;
+}
+void can_register_mapping_io_RSCANnTMPTRp(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data = 0x0;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnTMPTRp(0), 16U);
+	CanChannelIdType cid = index / CAN_TX_CHANNEL_BUFFER_NUM;
+	CanBufferIdxType bid = index % CAN_TX_CHANNEL_BUFFER_NUM;
+
+	if (io_type == CanRegisterIo_Read) {
+		// 31 ～ 28 TMDLC [3:0]
+		data |= (can_tx_buffer_control.buf[cid][bid].header.dlc << 28U);
+		// 23 ～ 16 TMPTR [7:0]
+		data |= (can_tx_buffer_control.buf[cid][bid].header.label << 16U);
+
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), data);
+	}
+	else { /* CanRegisterIo_Write */
+		can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+
+		can_tx_buffer_control.buf[cid][bid].header.dlc = CAN_REG_GET_MASK_DATA(data >> 28U, 0x0F);
+		can_tx_buffer_control.buf[cid][bid].header.label = CAN_REG_GET_MASK_DATA(data >> 16U, 0xFF);
+	}
+	return;
+}
+
+void can_register_mapping_io_RSCANnTMDF0p(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data = 0x0;
+	uint8 *array = (uint8*)&data;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnTMDF0p(0), 16U);
+	CanChannelIdType cid = index / CAN_TX_CHANNEL_BUFFER_NUM;
+	CanBufferIdxType bid = index % CAN_TX_CHANNEL_BUFFER_NUM;
+
+	if (io_type == CanRegisterIo_Read) {
+		// 7 ～ 0 TMDB0 [7:0]
+		array[0] = can_tx_buffer_control.buf[cid][bid].body.buffer[0];
+		// 15 ～ 8 TMDB1 [7:0]
+		array[1] = can_tx_buffer_control.buf[cid][bid].body.buffer[1];
+		// 23 ～ 16 TMDB2 [7:0]
+		array[2] = can_tx_buffer_control.buf[cid][bid].body.buffer[2];
+		// 31 ～ 24 TMDB3 [7:0]
+		array[3] = can_tx_buffer_control.buf[cid][bid].body.buffer[3];
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), data);
+	}
+	else { /* CanRegisterIo_Write */
+		can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+		// 7 ～ 0 TMDB0 [7:0]
+		can_tx_buffer_control.buf[cid][bid].body.buffer[0] = array[0];
+		// 15 ～ 8 TMDB1 [7:0]
+		can_tx_buffer_control.buf[cid][bid].body.buffer[1] = array[1];
+		// 23 ～ 16 TMDB2 [7:0]
+		can_tx_buffer_control.buf[cid][bid].body.buffer[2] = array[2];
+		// 31 ～ 24 TMDB3 [7:0]
+		can_tx_buffer_control.buf[cid][bid].body.buffer[3] = array[3];
+	}
+
+	return;
+}
+void can_register_mapping_io_RSCANnTMDF1p(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data = 0x0;
+	uint8 *array = (uint8*)&data;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnTMDF1p(0), 16U);
+	CanChannelIdType cid = index / CAN_TX_CHANNEL_BUFFER_NUM;
+	CanBufferIdxType bid = index % CAN_TX_CHANNEL_BUFFER_NUM;
+
+	if (io_type == CanRegisterIo_Read) {
+		// 7 ～ 0 TMDB4 [7:0]
+		array[0] = can_tx_buffer_control.buf[cid][bid].body.buffer[4];
+		// 15 ～ 8 TMDB5 [7:0]
+		array[1] = can_tx_buffer_control.buf[cid][bid].body.buffer[5];
+		// 23 ～ 16 TMDB6 [7:0]
+		array[2] = can_tx_buffer_control.buf[cid][bid].body.buffer[6];
+		// 31 ～ 24 TMDB7 [7:0]
+		array[3] = can_tx_buffer_control.buf[cid][bid].body.buffer[7];
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), data);
+	}
+	else { /* CanRegisterIo_Write */
+		can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+		// 7 ～ 0 TMDB4 [7:0]
+		can_tx_buffer_control.buf[cid][bid].body.buffer[4] = array[0];
+		// 15 ～ 8 TMDB5 [7:0]
+		can_tx_buffer_control.buf[cid][bid].body.buffer[5] = array[1];
+		// 23 ～ 16 TMDB6 [7:0]
+		can_tx_buffer_control.buf[cid][bid].body.buffer[6] = array[2];
+		// 31 ～ 24 TMDB7 [7:0]
+		can_tx_buffer_control.buf[cid][bid].body.buffer[7] = array[3];
+	}
+	return;
+}
+
+void can_register_mapping_io_RSCANnTMIECy(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data = 0x0;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnTMIECy(0), 4U);
+
+	if (io_type == CanRegisterIo_Read) {
+		data = can_tx_buffer_control.intr_enable[index];
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), data);
+	}
+	else { /* CanRegisterIo_Write */
+		can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+		can_tx_buffer_control.intr_enable[index] = data;
+	}
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io_tx_buffer_status.c
@@ -0,0 +1,113 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "can_register_mapping_io.h"
+#include "can_register.h"
+#include "can_buffer.h"
+#include "can_register_mapping_reset.h"
+
+void can_register_reset_tx_buffer_status(CanRegisterResetType type)
+{
+	if (type == CanRegisterResetType_MCU_RESET) {
+		// nothing
+	}
+	else if (type == CanRegisterResetType_GLOBAL_RESET) {
+		// nothing
+	}
+	else if (type == CanRegisterResetType_CHANNEL_RESET) {
+		// nothing
+	}
+
+}
+void can_register_mapping_io_RSCANnTMTRSTSy(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data = 0x0;
+	uint32 p = 0;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnTMTRSTSy(0), 4U);
+	CanChannelIdType cid;
+	CanBufferIdxType bid;
+
+	if (io_type == CanRegisterIo_Read) {
+		for (cid = (index * 2U); cid < ((index * 2U) + 2U); cid++) {
+			for (bid = 0; bid < CAN_TX_CHANNEL_BUFFER_NUM; bid++) {
+				CAN_REG_UPDATE_REG_BIT(can_tx_buffer_control.buf[cid][bid].ctrl.req_tx, p, data);
+				p++;
+			}
+		}
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), data);
+	}
+	else { /* CanRegisterIo_Write */
+		// nothing to do
+		// ユーザ側は参照のみ
+	}
+
+	return;
+}
+
+void can_register_mapping_io_RSCANnTMTCSTSy(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data = 0x0;
+	uint32 p = 0;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnTMTCSTSy(0), 4U);
+	CanChannelIdType cid;
+	CanBufferIdxType bid;
+
+	if (io_type == CanRegisterIo_Read) {
+		for (cid = (index * 2U); cid < ((index * 2U) + 2U); cid++) {
+			for (bid = 0; bid < CAN_TX_CHANNEL_BUFFER_NUM; bid++) {
+				if ((can_tx_buffer_control.buf[cid][bid].status.result & CAN_TX_BUFFER_RESULT_OK) != 0U) {
+					data |= (1U << (p));
+				}
+				else {
+					data &= ~(1U << (p));
+				}
+				p++;
+			}
+		}
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), data);
+	}
+	else { /* CanRegisterIo_Write */
+		// nothing to do
+		// ユーザ側は参照のみ
+	}
+
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io_tx_history.c
@@ -0,0 +1,144 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "can_register_mapping_io.h"
+#include "can_register.h"
+#include "can_buffer.h"
+#include "can_tx_history.h"
+#include "can_register_mapping_reset.h"
+
+void can_register_reset_tx_history(CanRegisterResetType type)
+{
+	CanChannelIdType cid;
+
+	if (type == CanRegisterResetType_MCU_RESET) {
+		for (cid = 0U; cid < CAN_CHANNEL_NUM; cid++) {
+			can_tx_history[cid].status.thl_empty = TRUE;
+		}
+	}
+	else {
+		// not supported
+	}
+	return;
+}
+
+void can_register_mapping_io_RSCANnTHLCCm(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnTHLCCm(0), 4U);
+
+	if (io_type == CanRegisterIo_Read) {
+		// none
+	}
+	else { /* CanRegisterIo_Write */
+		can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+		CAN_REG_UPDATE_MODEL_FLAG(data, 10U, can_tx_history[index].config.select_tx_buffer);
+		CAN_REG_UPDATE_MODEL_FLAG(data, 9U, can_tx_history[index].config.select_intr_factor);
+		CAN_REG_UPDATE_MODEL_FLAG(data, 8U, can_tx_history[index].config.enable_intr);
+		CAN_REG_UPDATE_MODEL_FLAG(data, 0U, can_tx_history[index].config.enable_history);
+	}
+	return;
+}
+
+void can_register_mapping_io_RSCANnTHLSTSm(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data = 0x0;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnTHLSTSm(0), 4U);
+
+	if (io_type == CanRegisterIo_Read) {
+		//12 ～ 8 THLMC [4:0]
+		data |= (can_tx_history[index].fifo_control.count << 8U);
+		CAN_REG_UPDATE_REG_BIT(can_tx_history[index].status.thl_intr, 3U, data);
+		CAN_REG_UPDATE_REG_BIT(can_tx_history[index].status.thl_ovr, 2U, data);
+		CAN_REG_UPDATE_REG_BIT(can_tx_history[index].status.thl_full, 1U, data);
+		CAN_REG_UPDATE_REG_BIT(can_tx_history[index].status.thl_empty, 0U, data);
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), data);
+	}
+	else { /* CanRegisterIo_Write */
+		can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+		if ( (data & (1U << 3U)) == 0x0) {
+			can_tx_history[index].status.thl_intr = FALSE;
+		}
+		if ( (data & (1U << 2U)) == 0x0) {
+			can_tx_history[index].status.thl_ovr = FALSE;
+		}
+	}
+	return;
+}
+void can_register_mapping_io_RSCANnTHLPCTRm(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data = 0x0;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnTHLPCTRm(0), 4U);
+
+	if (io_type == CanRegisterIo_Read) {
+		/* write only */
+	}
+	else { /* CanRegisterIo_Write */
+		can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+		//モデルへの同期処理
+		if (CAN_REG_GET_MASK_DATA(data, 0xFF) == 0xFF) {
+			(void)can_txhl_next_thldata(index);
+		}
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), 0x0);
+	}
+	return;
+}
+void can_register_mapping_io_RSCANnTHLACCm(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data = 0x0;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnTHLACCm(0), 4U);
+	CanTxHistoryDataType thldata;
+
+	if (io_type == CanRegisterIo_Read) {
+		can_txhl_peek_thldata(index, &thldata);
+		//15 ～ 8 TID[7:0]
+		data |= (thldata.label << 8U);
+		//6 ～ 3 BN[3:0]
+		data |= (thldata.bufno << 3U);
+		//2 ～ 0 BT[2:0]
+		data |= (thldata.buftype << 0U);
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), data);
+	}
+	else { /* CanRegisterIo_Write */
+		/* read only */
+	}
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io_tx_queue.c
@@ -0,0 +1,118 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "can_register_mapping_io.h"
+#include "can_register.h"
+#include "can_buffer.h"
+#include "can_tx_queue.h"
+#include "can_register_mapping_reset.h"
+
+void can_register_reset_tx_queue(CanRegisterResetType type)
+{
+	CanChannelIdType cid;
+
+	if (type == CanRegisterResetType_MCU_RESET) {
+		for (cid = 0U; cid < CAN_CHANNEL_NUM; cid++) {
+			can_tx_queue[cid].status.is_empty = TRUE;
+		}
+	}
+	else {
+		// not supported
+	}
+	return;
+}
+
+void can_register_mapping_io_RSCANnTXQCCm(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnTXQCCm(0), 4U);
+
+	if (io_type == CanRegisterIo_Read) {
+		// none
+	}
+	else { /* CanRegisterIo_Write */
+		can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+		CAN_REG_UPDATE_MODEL_FLAG(data, 13U, can_tx_queue[index].config.intr_factor);
+		CAN_REG_UPDATE_MODEL_FLAG(data, 12U, can_tx_queue[index].config.enable_intr);
+		CAN_REG_UPDATE_MODEL_FLAG(data, 0U, can_tx_queue[index].config.enable_queue);
+		//11 ～ 8 TXQDC [3:0]
+		can_tx_queue[index].config.quelen = CAN_REG_GET_MASK_DATA(data >> 8U, 0xF);
+	}
+	return;
+}
+
+void can_register_mapping_io_RSCANnTXQSTSm(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data = 0x0;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnTXQSTSm(0), 4U);
+
+	if (io_type == CanRegisterIo_Read) {
+		CAN_REG_UPDATE_REG_BIT(can_tx_queue[index].status.intr_req, 2U, data);
+		CAN_REG_UPDATE_REG_BIT(can_tx_queue[index].status.is_full, 1U, data);
+		CAN_REG_UPDATE_REG_BIT(can_tx_queue[index].status.is_empty, 0U, data);
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), data);
+	}
+	else { /* CanRegisterIo_Write */
+		can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+		if ( (data & (1U << 2U)) == 0x0) {
+			can_tx_queue[index].status.intr_req = FALSE;
+		}
+	}
+	return;
+}
+void can_register_mapping_io_RSCANnTXQPCTRm(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data = 0x0;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnTXQPCTRm(0), 4U);
+
+	if (io_type == CanRegisterIo_Read) {
+		/* write only */
+	}
+	else { /* CanRegisterIo_Write */
+		can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+		//モデルへの同期処理
+		if (CAN_REG_GET_MASK_DATA(data, 0xFF) == 0xFF) {
+			(void)can_txque_put_txdata(index);
+		}
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), 0x0);
+	}
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_io_txrx_fifo.c
@@ -0,0 +1,393 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "can_register_mapping_io.h"
+#include "can_register.h"
+#include "can_fifo.h"
+#include "can_register_mapping_reset.h"
+
+static 	CanDataType txrx_tx_fifodata;
+
+
+void can_register_reset_txrx_fifo(CanRegisterResetType type)
+{
+	CanChannelIdType cid;
+	uint32 fifo_id;
+	memset(&txrx_tx_fifodata, 0, sizeof(CanDataType));
+	if (type == CanRegisterResetType_MCU_RESET) {
+		for (cid = 0U; cid < CAN_CHANNEL_NUM; cid++) {
+			for (fifo_id = 0U; fifo_id < CAN_FIFO_FLAG_NUM; fifo_id++) {
+				can_txrx_fifo_control.buf[cid][fifo_id].config.tx_bufno = 0U;
+				can_txrx_fifo_control.buf[cid][fifo_id].config.mode = 0U;
+				can_txrx_fifo_control.buf[cid][fifo_id].config.intr_timing_cnt = 0U;
+				can_txrx_fifo_control.buf[cid][fifo_id].config.enable_intr_everytime = FALSE;
+				can_txrx_fifo_control.buf[cid][fifo_id].config.quelen = 0U;
+				can_txrx_fifo_control.buf[cid][fifo_id].config.enable_tx_intr = FALSE;
+				can_txrx_fifo_control.buf[cid][fifo_id].config.enable_rx_intr = FALSE;
+				can_txrx_fifo_control.buf[cid][fifo_id].config.enable_fifo = FALSE;
+				can_txrxfifo_clear(cid, fifo_id);
+				can_txrx_fifo_control.buf[cid][fifo_id].status.tx_intr = FALSE;
+				can_txrx_fifo_control.buf[cid][fifo_id].status.rx_intr = FALSE;
+				can_txrx_fifo_control.buf[cid][fifo_id].status.txrx_lost = FALSE;
+				can_txrx_fifo_control.buf[cid][fifo_id].status.txrx_full = FALSE;
+				can_txrx_fifo_control.buf[cid][fifo_id].status.txrx_empty = TRUE;
+				memset(&can_txrx_fifo_control.buf[cid][fifo_id].buffer.tx[0], 0, sizeof(CanTxBufferType) * CAN_TX_FIFO_QUEUE_MAX);
+			}
+		}
+	}
+	else {
+		for (cid = 0U; cid < CAN_CHANNEL_NUM; cid++) {
+			for (fifo_id = 0U; fifo_id < CAN_FIFO_FLAG_NUM; fifo_id++) {
+				can_txrx_fifo_control.buf[cid][fifo_id].config.enable_fifo = FALSE;
+				can_txrxfifo_clear(cid, fifo_id);
+				can_txrx_fifo_control.buf[cid][fifo_id].status.tx_intr = FALSE;
+				can_txrx_fifo_control.buf[cid][fifo_id].status.rx_intr = FALSE;
+				can_txrx_fifo_control.buf[cid][fifo_id].status.txrx_lost = FALSE;
+				can_txrx_fifo_control.buf[cid][fifo_id].status.txrx_full = FALSE;
+				can_txrx_fifo_control.buf[cid][fifo_id].status.txrx_empty = TRUE;
+			}
+		}
+	}
+
+}
+void can_register_reset_txrx_fifo_channel(CanChannelIdType cid)
+{
+	uint32 fifo_id;
+	for (fifo_id = 0U; fifo_id < CAN_FIFO_FLAG_NUM; fifo_id++) {
+		can_txrx_fifo_control.buf[cid][fifo_id].config.enable_fifo = FALSE;
+		can_txrxfifo_clear(cid, fifo_id);
+		can_txrx_fifo_control.buf[cid][fifo_id].status.tx_intr = FALSE;
+		can_txrx_fifo_control.buf[cid][fifo_id].status.rx_intr = FALSE;
+		can_txrx_fifo_control.buf[cid][fifo_id].status.txrx_lost = FALSE;
+		can_txrx_fifo_control.buf[cid][fifo_id].status.txrx_full = FALSE;
+		can_txrx_fifo_control.buf[cid][fifo_id].status.txrx_empty = TRUE;
+	}
+
+}
+
+void can_register_mapping_io_RSCANnCFCCk(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnCFCCk(0), 4U);
+	CanChannelIdType cid = index / CAN_TXRX_CHANNEL_FIFO_NUM;
+	CanBufferIdxType bid = index % CAN_TXRX_CHANNEL_FIFO_NUM;
+
+	if (io_type == CanRegisterIo_Read) {
+		// 31 ～ 24 CFITT[7:0]: 未サポート
+		// 23 ～ 20 CFTML[3:0]:モデル側は参照のみで自発的な更新はしないためモデル情報を取得する必要はない
+		// 19 CFITR: 未サポート
+		// 18 CFITSS: 未サポート
+		// 17 ～ 16 CFM[1:0]: モデル側は参照のみで自発的な更新はしないためモデル情報を取得する必要はない
+		// 15 ～ 13 CFIGCV [2:0]: モデル側は参照のみで自発的な更新はしないためモデル情報を取得する必要はない
+		// 12 CFIM: モデル側は参照のみで自発的な更新はしないためモデル情報を取得する必要はない
+		// 10 ～ 8 CFDC [2:0]: モデル側は参照のみで自発的な更新はしないためモデル情報を取得する必要はない
+		// 2 CFTXIE: モデル側は参照のみで自発的な更新はしないためモデル情報を取得する必要はない
+		// 1 CFRXIE: モデル側は参照のみで自発的な更新はしないためモデル情報を取得する必要はない
+		// 0 CFE: モデル側は参照のみで自発的な更新はしないためモデル情報を取得する必要はない
+	}
+	else { /* CanRegisterIo_Write */
+		can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+		//モデルへの同期処理
+		// 23 ～ 20 CFTML[3:0]
+		can_txrx_fifo_control.buf[cid][bid].config.tx_bufno = CAN_REG_GET_MASK_DATA(data >> 20U, 0xF);
+		{
+			/*
+			 * RSCANnTMCp レジスタが次の条件を満たす場合は、 “00H” にしてください。
+			 *  RSCANnCFCCk レジスタの CFTML[3:0] ビットで選択した送信バッファ番号に対応する
+			 *  RSCANnTMCp レジスタ（ p = m × 16 + CFTML[3:0] ビットの値）
+			 */
+			can_tx_buffer_control.buf[cid][can_txrx_fifo_control.buf[cid][bid].config.tx_bufno].ctrl.req_tx = FALSE;
+		}
+		// 17 ～ 16 CFM[1:0]
+		can_txrx_fifo_control.buf[cid][bid].config.mode = CAN_REG_GET_MASK_DATA(data >> 16U, 0x3);
+		// 15 ～ 13 CFIGCV [2:0]
+		can_txrx_fifo_control.buf[cid][bid].config.intr_timing_cnt = CAN_REG_GET_MASK_DATA(data >> 13U, 0x7);
+		// 12 CFIM
+		CAN_REG_UPDATE_MODEL_FLAG(data, 12U, can_txrx_fifo_control.buf[cid][bid].config.enable_intr_everytime);
+		// 10 ～ 8 CFDC [2:0]
+		can_txrx_fifo_control.buf[cid][bid].config.quelen = CAN_REG_GET_MASK_DATA(data >> 8U, 0x7);
+		// 2 CFTXIE
+		CAN_REG_UPDATE_MODEL_FLAG(data, 2U, can_txrx_fifo_control.buf[cid][bid].config.enable_tx_intr);
+		// 1 CFRXIE
+		CAN_REG_UPDATE_MODEL_FLAG(data, 1U, can_txrx_fifo_control.buf[cid][bid].config.enable_rx_intr);
+		// 0 CFE
+		CAN_REG_UPDATE_MODEL_FLAG(data, 0U, can_txrx_fifo_control.buf[cid][bid].config.enable_fifo);
+		if (can_txrx_fifo_control.buf[cid][bid].config.enable_fifo == FALSE) {
+			(void)can_txrxfifo_clear(cid, bid);
+			can_txrx_fifo_control.buf[cid][bid].status.txrx_empty = TRUE;
+			can_txrx_fifo_control.buf[cid][bid].status.txrx_full = FALSE;
+		}
+	}
+	return;
+}
+void can_register_mapping_io_RSCANnCFSTSk(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data = 0x0;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnCFSTSk(0), 4U);
+	CanChannelIdType cid = index / CAN_TXRX_CHANNEL_FIFO_NUM;
+	CanBufferIdxType bid = index % CAN_TXRX_CHANNEL_FIFO_NUM;
+
+	if (io_type == CanRegisterIo_Read) {
+		//15 ～ 8 CFMC [7:0
+		data |= (can_txrx_fifo_control.buf[cid][bid].fifo_control.count << 8U);
+		//4 CFTXIF
+		CAN_REG_UPDATE_REG_BIT(can_txrx_fifo_control.buf[cid][bid].status.tx_intr, 4U, data);
+		//3 CFRXIF
+		CAN_REG_UPDATE_REG_BIT(can_txrx_fifo_control.buf[cid][bid].status.rx_intr, 3U, data);
+		//2 CFMLT
+		CAN_REG_UPDATE_REG_BIT(can_txrx_fifo_control.buf[cid][bid].status.txrx_lost, 2U, data);
+		//1 CFFLL
+		CAN_REG_UPDATE_REG_BIT(can_txrx_fifo_control.buf[cid][bid].status.txrx_full, 1U, data);
+		//0 CFEMP
+		CAN_REG_UPDATE_REG_BIT(can_txrx_fifo_control.buf[cid][bid].status.txrx_empty, 0U, data);
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), data);
+	}
+	else {
+		can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+		//モデルへの同期処理
+		//4 CFTXIF
+		CAN_REG_UPDATE_MODEL_FLAG(data, 4U, can_txrx_fifo_control.buf[cid][bid].status.tx_intr);
+		//3 CFRXIF
+		CAN_REG_UPDATE_MODEL_FLAG(data, 3U, can_txrx_fifo_control.buf[cid][bid].status.rx_intr);
+		//2 CFMLT
+		CAN_REG_UPDATE_MODEL_FLAG(data, 2U, can_txrx_fifo_control.buf[cid][bid].status.txrx_lost);
+	}
+	return;
+}
+void can_register_mapping_io_RSCANnCFPCTRk(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 data = 0x0;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnCFPCTRk(0), 4U);
+	CanChannelIdType cid = index / CAN_TXRX_CHANNEL_FIFO_NUM;
+	CanBufferIdxType bid = index % CAN_TXRX_CHANNEL_FIFO_NUM;
+
+	if (io_type == CanRegisterIo_Read) {
+		// write only
+	}
+	else { /* CanRegisterIo_Write */
+		can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+		//モデルへの同期処理
+		if (CAN_REG_GET_MASK_DATA(data, 0xFF) == 0xFF) {
+			if (can_txrx_fifo_control.buf[cid][bid].config.mode == CAN_TXRX_FIFO_MODE_TX) {
+				(void)can_txrxfifo_put_txdata(cid, bid, &txrx_tx_fifodata);
+				memset(&txrx_tx_fifodata, 0, sizeof(CanDataType));
+			}
+			else {
+				(void)can_txrxfifo_next_rxdata(cid, bid);
+			}
+		}
+		can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), 0x0);
+	}
+	return;
+}
+
+void can_register_mapping_io_TXRX_FIFO(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	uint32 addr = CAN_REG_GET_ALIGNED_ADDR(arg->address);
+
+	switch (addr & 0x0000000F) {
+	case 0x0:
+		can_register_mapping_io_RSCANnCFIDk(io_type, arg);
+		break;
+	case 0x04:
+		can_register_mapping_io_RSCANnCFPTRk(io_type, arg);
+		break;
+	case 0x8:
+		can_register_mapping_io_RSCANnCFDF0k(io_type, arg);
+		break;
+	case 0xC:
+		can_register_mapping_io_RSCANnCFDF1k(io_type, arg);
+		break;
+	default:
+		break;
+	}
+	return;
+}
+void can_register_mapping_io_RSCANnCFIDk(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	Std_ReturnType err;
+	CanDataType txrxdata;
+	uint32 data = 0x0;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnCFIDk(0), 16U);
+	CanChannelIdType cid = index / CAN_TXRX_CHANNEL_FIFO_NUM;
+	CanBufferIdxType bid = index % CAN_TXRX_CHANNEL_FIFO_NUM;
+
+	if (io_type == CanRegisterIo_Read) {
+		if (can_txrx_fifo_control.buf[cid][bid].config.mode == CAN_TXRX_FIFO_MODE_RX) {
+			err = can_txrxfifo_peek_rxdata(cid, bid, &txrxdata);
+			if (err == STD_E_OK) {
+				// 31 CFIDE
+				CAN_REG_UPDATE_REG_BIT(txrxdata.ide, 31U, data);
+				// 30 CFRTR
+				CAN_REG_UPDATE_REG_BIT(txrxdata.rtr, 30U, data);
+				// 28 ～ 0 CFID [28:0]
+				data |= txrxdata.id;
+			}
+			can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), data);
+		}
+	}
+	else { /* CanRegisterIo_Write */
+		if (can_txrx_fifo_control.buf[cid][bid].config.mode == CAN_TXRX_FIFO_MODE_TX) {
+			can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+			// 31 CFIDE
+			CAN_REG_UPDATE_MODEL_FLAG(data, 31U, txrxdata.ide);
+			// 30 CFRTR
+			CAN_REG_UPDATE_MODEL_FLAG(data, 30U, txrxdata.rtr);
+			// 28 ～ 0 CFID [28:0]
+			txrx_tx_fifodata.id = CAN_REG_GET_MASK_DATA(data, 0x1FFFFFFF);
+		}
+	}
+	return;
+}
+void can_register_mapping_io_RSCANnCFPTRk(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	Std_ReturnType err;
+	CanDataType txrxdata;
+	uint32 data = 0x0;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnCFPTRk(0), 16U);
+	CanChannelIdType cid = index / CAN_TXRX_CHANNEL_FIFO_NUM;
+	CanBufferIdxType bid = index % CAN_TXRX_CHANNEL_FIFO_NUM;
+
+	if (io_type == CanRegisterIo_Read) {
+		if (can_txrx_fifo_control.buf[cid][bid].config.mode == CAN_TXRX_FIFO_MODE_RX) {
+			err = can_txrxfifo_peek_rxdata(cid, bid, &txrxdata);
+			if (err == STD_E_OK) {
+				// 31 ～ 28 CFDLC [3:0]
+				data  |= (txrxdata.dlc << 28U);
+				// 27 ～ 16 CFPTR [11:0]
+				data  |= (txrxdata.label << 16U);
+			}
+			can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), data);
+		}
+	}
+	else { /* CanRegisterIo_Write */
+		if (can_txrx_fifo_control.buf[cid][bid].config.mode == CAN_TXRX_FIFO_MODE_TX) {
+			can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+			// 31 ～ 28 CFDLC [3:0]
+			txrx_tx_fifodata.dlc = CAN_REG_GET_MASK_DATA(data >> 28U, 0xF);
+			// 27 ～ 16 CFPTR [11:0]
+			txrx_tx_fifodata.label = CAN_REG_GET_MASK_DATA(data >> 16U, 0xFFF);
+		}
+	}
+	return;
+}
+void can_register_mapping_io_RSCANnCFDF0k(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	Std_ReturnType err;
+	uint32 data = 0x0;
+	uint8 *array = (uint8*)&data;
+	CanDataType txrxdata;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnCFDF0k(0), 16U);
+	CanChannelIdType cid = index / CAN_TXRX_CHANNEL_FIFO_NUM;
+	CanBufferIdxType bid = index % CAN_TXRX_CHANNEL_FIFO_NUM;
+
+	if (io_type == CanRegisterIo_Read) {
+		if (can_txrx_fifo_control.buf[cid][bid].config.mode == CAN_TXRX_FIFO_MODE_RX) {
+			err = can_txrxfifo_peek_rxdata(cid, bid, &txrxdata);
+			if (err == STD_E_OK) {
+				// 7 ～ 0 CFDB0 [7:0]
+				array[0] = txrxdata.data[0];
+				// 15 ～ 8 CFDB1 [7:0]
+				array[1] = txrxdata.data[1];
+				// 23 ～ 16 CFDB2 [7:0]
+				array[2] = txrxdata.data[2];
+				// 31 ～ 24 CFDB3 [7:0]
+				array[3] = txrxdata.data[3];
+			}
+			can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), data);
+		}
+	}
+	else { /* CanRegisterIo_Write */
+		if (can_txrx_fifo_control.buf[cid][bid].config.mode == CAN_TXRX_FIFO_MODE_TX) {
+			can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+			// 7 ～ 0 CFDB0 [7:0]
+			txrx_tx_fifodata.data[0] = array[0];
+			// 15 ～ 8 CFDB1 [7:0]
+			txrx_tx_fifodata.data[1] = array[1];
+			// 23 ～ 16 CFDB2 [7:0]
+			txrx_tx_fifodata.data[2] = array[2];
+			// 31 ～ 24 CFDB3 [7:0]
+			txrx_tx_fifodata.data[3] = array[3];
+		}
+	}
+	return;
+}
+void can_register_mapping_io_RSCANnCFDF1k(CanRegisterIoType io_type, CanRegisterIoArgType *arg)
+{
+	Std_ReturnType err;
+	uint32 data = 0x0;
+	uint8 *array = (uint8*)&data;
+	CanDataType txrxdata;
+	uint32 index = CAN_REG_GROUP_INDEX(arg->address, CAN_REG_RSCANnCFDF1k(0), 16U);
+	CanChannelIdType cid = index / CAN_TXRX_CHANNEL_FIFO_NUM;
+	CanBufferIdxType bid = index % CAN_TXRX_CHANNEL_FIFO_NUM;
+
+	if (io_type == CanRegisterIo_Read) {
+		if (can_txrx_fifo_control.buf[cid][bid].config.mode == CAN_TXRX_FIFO_MODE_RX) {
+			err = can_txrxfifo_peek_rxdata(cid, bid, &txrxdata);
+			if (err == STD_E_OK) {
+				// 7 ～ 0 CFDB4 [7:0]
+				array[0] = txrxdata.data[4];
+				// 15 ～ 8 CFDB5 [7:0]
+				array[1] = txrxdata.data[5];
+				// 23 ～ 16 CFDB6 [7:0]
+				array[2] = txrxdata.data[6];
+				// 31 ～ 24 CFDB7 [7:0]
+				array[3] = txrxdata.data[7];
+			}
+			can_register_write_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), data);
+		}
+	}
+	else { /* CanRegisterIo_Write */
+		if (can_txrx_fifo_control.buf[cid][bid].config.mode == CAN_TXRX_FIFO_MODE_TX) {
+			can_register_read_data32(CAN_REG_GET_ALIGNED_ADDR(arg->address), &data);
+			// 7 ～ 0 CFDB4 [7:0]
+			txrx_tx_fifodata.data[4] = array[0];
+			// 15 ～ 8 CFDB5 [7:0]
+			txrx_tx_fifodata.data[5] = array[1];
+			// 23 ～ 16 CFDB6 [7:0]
+			txrx_tx_fifodata.data[6] = array[2];
+			// 31 ～ 24 CFDB7 [7:0]
+			txrx_tx_fifodata.data[7] = array[3];
+		}
+	}
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/mapping/can_register_mapping_reset.h
@@ -0,0 +1,69 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _CAN_REGISTER_MAPPING_RESET_H_
+#define _CAN_REGISTER_MAPPING_RESET_H_
+
+#include "can_types.h"
+
+typedef enum {
+	CanRegisterResetType_MCU_RESET = 0,
+	CanRegisterResetType_GLOBAL_RESET,
+	CanRegisterResetType_CHANNEL_RESET,
+} CanRegisterResetType;
+
+extern void can_register_reset_global(CanRegisterResetType type);
+extern void can_register_reset_channel(CanRegisterResetType type, CanChannelIdType cid);
+extern void can_register_reset_fifo_status(CanRegisterResetType type);
+extern void can_register_reset_rx_rule(CanRegisterResetType type);
+extern void can_register_reset_rx_buffer(CanRegisterResetType type);
+extern void can_register_reset_rx_fifo(CanRegisterResetType type);
+extern void can_register_reset_tx_buffer(CanRegisterResetType type);
+extern void can_register_reset_tx_buffer_channel(CanChannelIdType cid);
+extern void can_register_reset_tx_buffer_status(CanRegisterResetType type);
+extern void can_register_reset_txrx_fifo(CanRegisterResetType type);
+extern void can_register_reset_txrx_fifo_channel(CanChannelIdType cid);
+
+extern void can_register_reset_tx_queue(CanRegisterResetType type);
+extern void can_register_reset_tx_history(CanRegisterResetType type);
+
+
+#endif /* _CAN_REGISTER_MAPPING_RESET_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/can/mapping/can_register_memory.c
@@ -0,0 +1,102 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "can_register_mapping.h"
+#include "can_register.h"
+#include "mpu_config.h"
+
+uint8 memory_data_CAN[MPU_ADDRESS_REGION_SIZE_INX_CAN];
+
+void can_register_read_data32(uint32 address, uint32 *data)
+{
+	uint32 off = address - RSCANn_base;
+	uint32 *tmp;
+
+	tmp = (uint32*)&memory_data_CAN[off];
+	*data = *tmp;
+	return;
+}
+void can_register_read_data16(uint32 address, uint16 *data)
+{
+	uint32 off = address - RSCANn_base;
+	uint16 *tmp;
+
+	tmp = (uint16*)&memory_data_CAN[off];
+	*data = *tmp;
+	return;
+}
+void can_register_read_data8(uint32 address, uint8 *data)
+{
+	uint32 off = address - RSCANn_base;
+	uint8 *tmp;
+
+	tmp = (uint8*)&memory_data_CAN[off];
+	*data = *tmp;
+	return;
+}
+
+void can_register_write_data32(uint32 address, uint32 data)
+{
+	uint32 off = address - RSCANn_base;
+	uint32 *tmp;
+
+	tmp = (uint32*)&memory_data_CAN[off];
+	*tmp = data;
+	return;
+}
+void can_register_write_data16(uint32 address, uint16 data)
+{
+	uint32 off = address - RSCANn_base;
+	uint16 *tmp;
+
+	tmp = (uint16*)&memory_data_CAN[off];
+	*tmp = data;
+	return;
+}
+void can_register_write_data8(uint32 address, uint8 data)
+{
+	uint32 off = address - RSCANn_base;
+	uint8 *tmp;
+
+	tmp = (uint8*)&memory_data_CAN[off];
+	*tmp = data;
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/clock/clock.c
@@ -0,0 +1,171 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "inc/clock.h"
+#include "device.h"
+#include "std_errno.h"
+#include "mpu_types.h"
+#include "cpuemu_ops.h"
+#include <stdio.h>
+
+static Std_ReturnType clock_get_data8(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 *data);
+static Std_ReturnType clock_get_data16(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint16 *data);
+static Std_ReturnType clock_get_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 *data);
+static Std_ReturnType clock_put_data8(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 data);
+static Std_ReturnType clock_put_data16(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint16 data);
+static Std_ReturnType clock_put_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 data);
+static Std_ReturnType clock_get_pointer(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 **data);
+
+MpuAddressRegionOperationType	clock_memory_operation = {
+		.get_data8 		= 	clock_get_data8,
+		.get_data16		=	clock_get_data16,
+		.get_data32		=	clock_get_data32,
+
+		.put_data8 		= 	clock_put_data8,
+		.put_data16		=	clock_put_data16,
+		.put_data32		=	clock_put_data32,
+
+		.get_pointer	= clock_get_pointer,
+};
+
+static MpuAddressRegionType *clock_region;
+
+void device_init_clock(MpuAddressRegionType *region)
+{
+	clock_region = region;
+	return;
+}
+
+static void clock_hook_update_mosce(MpuAddressRegionType *region, CoreIdType core_id, uint32 data)
+{
+	uint8* moscs_datap;
+
+	(void)clock_get_pointer(region, core_id, MOSCS, (uint8**)&moscs_datap);
+	if (MOSCE_ISSTOP(data)) {
+		MOSCS_CLR_ACT((uint32*)moscs_datap);
+	}
+
+	if (MOSCE_ISSTART(data)) {
+		MOSCS_SET_ACT((uint32*)moscs_datap);
+	}
+
+	return;
+}
+
+static Std_ReturnType clock_get_data8(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 *data)
+{
+	uint32 off = (addr - region->start);
+	*data = *((uint8*)(&region->data[off]));
+	return STD_E_OK;
+}
+static Std_ReturnType clock_get_data16(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint16 *data)
+{
+	uint32 off = (addr - region->start);
+	*data = *((uint16*)(&region->data[off]));
+	return STD_E_OK;
+}
+static Std_ReturnType clock_get_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 *data)
+{
+	uint32 off = (addr - region->start);
+	*data = *((uint32*)(&region->data[off]));
+	return STD_E_OK;
+}
+static Std_ReturnType clock_put_data8(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 data)
+{
+	uint32 off = (addr - region->start);
+	*((uint8*)(&region->data[off])) = data;
+	return STD_E_OK;
+}
+static Std_ReturnType clock_put_data16(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint16 data)
+{
+	uint32 off = (addr - region->start);
+	*((uint16*)(&region->data[off])) = data;
+	return STD_E_OK;
+}
+static Std_ReturnType clock_put_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 data)
+{
+	uint8* datap;
+	uint32 off = (addr - region->start);
+	*((uint32*)(&region->data[off])) = data;
+
+	if (addr ==  MOSCE) {
+		clock_hook_update_mosce(region, core_id, data);
+	}
+	else if (addr == CKSC_PPLLCLKS_CTL) {
+		(void)clock_get_pointer(region, core_id, CKSC_PPLLCLKS_ACT, (uint8**)&datap);
+		*datap = data;
+	}
+	else if (addr == CKSC_CPUCLKS_CTL) {
+		(void)clock_get_pointer(region, core_id, CKSC_CPUCLKS_ACT, (uint8**)&datap);
+		*datap = data;
+	}
+	else if (addr == CKSC_CPUCLKD_CTL) {
+		(void)clock_get_pointer(region, core_id, CKSC_CPUCLKD_ACT, (uint8**)&datap);
+		*datap = data;
+	}
+	else if (addr == CKSC_ATAUJS_CTL) {
+		(void)clock_get_pointer(region, core_id, CKSC_ATAUJS_ACT, (uint8**)&datap);
+		*datap = data;
+	}
+	else if (addr == CKSC_ATAUJD_CTL) {
+		(void)clock_get_pointer(region, core_id, CKSC_ATAUJD_ACT, (uint8**)&datap);
+		*datap = data;
+	}
+	else if (addr == CKSC_ILINS_CTL) {
+		(void)clock_get_pointer(region, core_id, CKSC_ILINS_ACT, (uint8**)&datap);
+		*datap = data;
+	}
+	else if (addr == CKSC_ILIND_CTL) {
+		(void)clock_get_pointer(region, core_id, CKSC_ILIND_ACT, (uint8**)&datap);
+		*datap = data;
+	}
+	else {
+		/* nop */
+	}
+
+	return STD_E_OK;
+}
+static Std_ReturnType clock_get_pointer(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 **data)
+{
+	uint32 off = (addr - region->start);
+	*data = &region->data[off];
+	return STD_E_OK;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/digital/digital.c
@@ -0,0 +1,86 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "inc/digital.h"
+#include "device.h"
+#include "std_errno.h"
+#include "mpu_types.h"
+#include "mpu_ops.h"
+#include <stdio.h>
+
+static uint8 prev_digital_value;
+
+void device_init_digital(MpuAddressRegionType *region)
+{
+	prev_digital_value = 0xffU;
+	(void)mpu_put_data8(0U, DIGITAL_REGADD_DSW + 0, 0xff);
+	(void)mpu_put_data8(0U, DIGITAL_REGADD_DSW + 1, 0xff);
+	(void)mpu_put_data8(0U, DIGITAL_REGADD_DSW + 2, 0xff);
+	(void)mpu_put_data8(0U, DIGITAL_REGADD_DSW + 2, 0xff);
+	(void)mpu_put_data8(0U, DIGITAL_REGADD_PSW, 0x3);
+	return;
+}
+
+void device_supply_clock_digital(DeviceClockType *dev_clock)
+{
+	Std_ReturnType err;
+	uint8 *datap;
+	uint8 data;
+
+	err = mpu_get_pointer(0U, DIGITAL_REGADD_PSW, &datap);
+	if (err != STD_E_OK) {
+		printf("ERROR: device_supply_clock_digital() can not read DIGITAL_REGADD_PSW\n");
+		return;
+	}
+	data = *datap;
+	if ((!DIGITAL_IS_BITSET(prev_digital_value, DIGITAL_BITPOS_PSW1))
+			& (DIGITAL_IS_BITSET(data, DIGITAL_BITPOS_PSW1))) {
+		device_raise_int(DIGITAL_PSW1_INTNO);
+	}
+	else if ((!DIGITAL_IS_BITSET(prev_digital_value, DIGITAL_BITPOS_PSW2))
+			& (DIGITAL_IS_BITSET(data, DIGITAL_BITPOS_PSW2))) {
+		device_raise_int(DIGITAL_PSW2_INTNO);
+	}
+	prev_digital_value = data;
+	return;
+}
+
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/inc/clock.h
@@ -0,0 +1,93 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _CLOCK_H_
+#define _CLOCK_H_
+
+#include "device.h"
+
+/* MainOSC */
+#define MOSCE	0xFFF81100
+#define MOSCS	0xFFF81104
+
+#define MOSCE_ISSTOP(data32)		(((data32) & 0x02) == 0x02)
+#define MOSCE_ISSTART(data32)		(((data32) & 0x01) == 0x01)
+
+#define MOSCS_SET_ACT(data32p)	\
+do {	\
+	*(data32p) |= (1U << 2);	\
+} while (0)
+#define MOSCS_CLR_ACT(data32p)	\
+do {	\
+	*(data32p) &= ~(1U << 2);	\
+} while (0)
+
+
+/* CKSC_PPLLCLKS */
+#define CKSC_PPLLCLKS_CTL	0xFFF8A010
+#define CKSC_PPLLCLKS_ACT	0xFFF8A018
+
+/* CKSC_CPUCLKS */
+#define CKSC_CPUCLKS_CTL	0xFFF8A000
+#define CKSC_CPUCLKS_ACT	0xFFF8A008
+
+/* CKSC_CPUCLKD */
+#define CKSC_CPUCLKD_CTL	0xFFF8A100
+#define CKSC_CPUCLKD_ACT	0xFFF8A108
+
+/* CKSC_ATAUJS */
+#define CKSC_ATAUJS_CTL		0xFFF82100
+#define CKSC_ATAUJS_ACT		0xFFF82108
+
+/* CKSC_ATAUJD */
+#define CKSC_ATAUJD_CTL		0xFFF82200
+#define CKSC_ATAUJD_ACT		0xFFF82208
+
+/* CKSC_ILINS */
+#define CKSC_ILINS_CTL		0xFFF8A400
+#define CKSC_ILINS_ACT		0xFFF8A408
+
+/* CKSC_ILIND */
+#define CKSC_ILIND_CTL		0xFFF8A800
+#define CKSC_ILIND_ACT		0xFFF8A808
+
+
+#endif /* _CLOCK_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/inc/digital.h
@@ -0,0 +1,54 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _DIGITAL_H_
+#define _DIGITAL_H_
+
+#define DIGITAL_REGADD_DSW		0xFFC10200
+#define DIGITAL_REGADD_PSW		0xFFC10220
+#define DIGITAL_BITPOS_PSW1		0U
+#define DIGITAL_BITPOS_PSW2		1U
+#define DIGITAL_PSW1_INTNO		35U
+#define DIGITAL_PSW2_INTNO		36U
+
+#define DIGITAL_IS_BITSET(data, bitoff) ((data & (1U << bitoff)) != 0U)
+
+#endif /* _DIGITAL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/inc/serial.h
@@ -0,0 +1,253 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _SERIAL_H_
+#define _SERIAL_H_
+
+#include "device.h"
+
+/*
+ *  RLIN3
+ */
+#define RLIN30_BASE 	0xffce2000
+#define RLIN31_BASE 	0xffce2040
+#define RLIN32_BASE 	0xffce2080
+#define RLIN33_BASE 	0xffce20c0
+#define RLIN34_BASE 	0xffce2100
+#define RLIN35_BASE 	0xffce2140
+
+#define RLIN3x_BASE        RLIN30_BASE
+
+#define RLIN3xLWBR_B		0x00000001
+#define RLIN3xLBRP01_H		0x00000002
+#define RLIN3xLBRP0_B		0x00000002
+#define RLIN3xLBRP1_B		0x00000003
+#define RLIN3xLSTC_B		0x00000004
+#define RLIN3xLMD_B			0x00000008
+#define RLIN3xLBFC_B		0x00000009
+#define RLIN3xLSC_B			0x0000000a
+#define RLIN3xLWUP_B		0x0000000b
+//#define RLIN3xLIE_B			0x0000000c
+#define RLIN3xLEDE_B		0x0000000d
+#define RLIN3xLCUC_B		0x0000000e
+#define RLIN3xLTRC_B		0x00000010
+#define RLIN3xLMST_B		0x00000011
+//#define RLIN3xLST_B			0x00000012
+#define RLIN3xLEST_B		0x00000013
+#define RLIN3xLDFC_B		0x00000014
+#define RLIN3xLIDB_B		0x00000015
+#define RLIN3xLCBR_B		0x00000016
+#define RLIN3xLUDB0_B		0x00000017
+#define RLIN3xLDBR1_B		0x00000018
+#define RLIN3xLDBR2_B		0x00000019
+#define RLIN3xLDBR3_B		0x0000001a
+#define RLIN3xLDBR4_B		0x0000001b
+#define RLIN3xLDBR5_B		0x0000001c
+#define RLIN3xLDBR6_B		0x0000001d
+#define RLIN3xLDBR7_B		0x0000001e
+#define RLIN3xLDBR8_B		0x0000001f
+//#define RLIN3xLUOER_B		0x00000020
+#define RLIN3xLUOR1_B		0x00000021
+#define RLIN3xLUTDR_H		0x00000024
+//#define RLIN3xLUTDRL_B		0x00000024
+#define RLIN3xLUTDRH_B		0x00000025
+#define RLIN3xLURDR_H		0x00000026
+//#define RLIN3xLURDRL_B		0x00000026
+#define RLIN3xLURDRH_B		0x00000027
+#define RLIN3xLUWTDR_H		0x00000028
+#define RLIN3xLUWTDRL_B		0x00000028
+#define RLIN3xLUWTDRH_B		0x00000029
+
+
+#define UDnCH0	0
+#define UDnCH1	1
+#define UDnCH2	2
+#define UDnCH3	3
+#define UDnCH4	4
+#define UDnCH5	5
+
+#define UDnChannelNum	4
+
+#define UDxCH_OFFSET	0x40
+#define RLIN_GET_CHANNEL(addr)		(((addr) - RLIN3x_BASE) / UDxCH_OFFSET)
+
+/*
+ * 出力
+ * １バイト送信
+ */
+#define RLIN3xLUTDRL_B		0x00000024
+
+#define RLIN3xLUTDRL(ch)	(RLIN3x_BASE + (UDxCH_OFFSET * (ch)) + RLIN3xLUTDRL_B)
+
+/*
+ * 送信許可
+ * 0x10
+ */
+#define RLIN3xLST_B			0x00000012
+
+#define RLIN3xLST(ch)		(RLIN3x_BASE + (UDxCH_OFFSET * (ch)) + RLIN3xLST_B)
+
+#define RLIN3x_LST_URS_BIT		(5)
+#define RLIN3x_LST_UTS_BIT		(4)
+
+#define RLIN3x_LST_GET_URS(is_receiving)		(is_receiving)? (1) : (0)
+#define RLIN3x_LST_GET_UTS(is_sending)			(is_sending)? (1) : (0)
+
+
+/*
+ * 動作許可
+ * 0x03
+ */
+#define RLIN3xLUOER_B		0x00000020
+#define RLIN3xLUOER(ch)		(RLIN3x_BASE + (UDxCH_OFFSET * (ch)) + RLIN3xLUOER_B)
+
+#define RLIN3x_LUOER_ISSET_UTOE(data8)		 ( ((data8) & (1U << 0)) != 0 )
+#define RLIN3x_LUOER_ISSET_UROE(data8)		 ( ((data8) & (1U << 1)) != 0 )
+
+
+/*
+ * オプション1制御
+ */
+#define RLIN3x_LUOR1_B		0x00000021
+#define RLIN3x_LUOR1(ch)	(RLIN3x_BASE + (UDxCH_OFFSET * (ch)) + RLIN3x_LUOR1_B)
+
+#define RLIN3x_LUOR1_ISSET_SEND_START_INTR(data8)		( ((data8) & (1U << 0)) == 0 )
+
+/*
+ * 入力
+ * １バイト受信
+ */
+#define RLIN3xLURDRL_B		0x00000026
+#define RLIN3xLURDRL(ch)	(RLIN3x_BASE + (UDxCH_OFFSET * (ch)) + RLIN3xLURDRL_B)
+
+/*
+ * 受信割り込み許可
+ * 0x02
+ */
+#define RLIN3xLIE_B			0x0000000c
+#define RLIN3xLIE(ch)		(RLIN3x_BASE + (UDxCH_OFFSET * (ch)) + RLIN3xLIE_B)
+
+
+/*
+ * UARTモードステータス管理
+ */
+#define RLIN3xLMST_B		0x00000011
+#define RLIN3xLMST(ch)		(RLIN3x_BASE + (UDxCH_OFFSET * (ch)) + RLIN3xLMST_B)
+
+#define RLIN3xLCUC_B		0x0000000e
+#define RLIN3xLCUC(ch)		(RLIN3x_BASE + (UDxCH_OFFSET * (ch)) + RLIN3xLCUC_B)
+
+
+#define RLIN_ISMODE_RESET(data8)	( (data8) == 0 )
+
+
+/*
+ *  INTNO
+ */
+#define RLIN30_TX_INTNO		UINT_C(34)
+#define RLIN30_RX_INTNO		UINT_C(35)
+#define RLIN30_ER_INTNO		UINT_C(36)
+#define RLIN31_TX_INTNO		UINT_C(121)
+#define RLIN31_RX_INTNO		UINT_C(122)
+#define RLIN31_ER_INTNO		UINT_C(123)
+#define RLIN32_TX_INTNO		UINT_C(165)
+#define RLIN32_RX_INTNO		UINT_C(166)
+#define RLIN32_ER_INTNO		UINT_C(167)
+#define RLIN33_TX_INTNO		UINT_C(229)
+#define RLIN33_RX_INTNO		UINT_C(230)
+#define RLIN33_ER_INTNO		UINT_C(231)
+#define RLIN34_TX_INTNO		UINT_C(225)
+#define RLIN34_RX_INTNO		UINT_C(226)
+#define RLIN34_ER_INTNO		UINT_C(227)
+#define RLIN35_TX_INTNO		UINT_C(229)
+#define RLIN35_RX_INTNO		UINT_C(230)
+#define RLIN35_ER_INTNO		UINT_C(231)
+
+static inline uint16 serial_rlin3x_get_rx_intno(uint8 ch)
+{
+	uint16 intno;
+	switch (ch){
+		case UDnCH0:
+			intno = RLIN30_RX_INTNO;
+			break;
+		case UDnCH1:
+			intno = RLIN31_RX_INTNO;
+			break;
+		case UDnCH2:
+			intno = RLIN32_RX_INTNO;
+			break;
+		case UDnCH3:
+			intno = RLIN33_RX_INTNO;
+			break;
+		case UDnCH4:
+			intno = RLIN34_RX_INTNO;
+			break;
+		default:
+			break;
+	}
+	return intno;
+}
+
+static inline uint16 serial_rlin3x_get_tx_intno(uint8 ch)
+{
+	uint16 intno;
+	switch (ch){
+		case UDnCH0:
+			intno = RLIN30_TX_INTNO;
+			break;
+		case UDnCH1:
+			intno = RLIN31_TX_INTNO;
+			break;
+		case UDnCH2:
+			intno = RLIN32_TX_INTNO;
+			break;
+		case UDnCH3:
+			intno = RLIN33_TX_INTNO;
+			break;
+		case UDnCH4:
+			intno = RLIN34_TX_INTNO;
+			break;
+		default:
+			break;
+	}
+	return intno;
+}
+#endif /* _SERIAL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/inc/timer.h
@@ -0,0 +1,124 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#ifndef _TIMER_H_
+#define _TIMER_H_
+
+#include "device.h"
+
+#define TAUJ_UNIT_NUM	2
+#define TAUJ_CH_NUM		2
+
+#define TAUFJ0I0_INTNO		(80)
+#define TAUFJ0I1_INTNO		(81)
+#define TAUFJ0I2_INTNO		(82)
+#define TAUFJ0I3_INTNO		(83)
+#define TAUFJ1I0_INTNO		(168)
+#define TAUFJ1I1_INTNO		(169)
+#define TAUFJ1I2_INTNO		(170)
+#define TAUFJ1I3_INTNO		(171)
+
+#define TAUJ_INTNO(n, ch)	(n == 0)? ((uint32) ((TAUFJ0I0_INTNO + ch))) : ((uint32) (TAUFJ1I0_INTNO + ch))
+
+/*
+ *  TAUJ関連レジスタ
+ *
+ *  Units：2
+ */
+#define TAUJ_BASE(n)	((uint32) (0xffe50000U + (n * 0x1000U)))
+
+/*
+ * プリスケーラ：未使用
+ */
+#define TAUJTPS(n)		(TAUJ_BASE(n) + 0x90U)
+
+/*
+ * タイマカウント周期設定
+ * 32bitレジスタ
+ */
+#define TAUJCDR(n, ch)	(TAUJ_BASE(n) + (ch * 0x04U))
+
+/*
+ * 現在ティック値
+ * 32bitレジスタ
+ */
+#define TAUJCNT(n, ch)	(TAUJ_BASE(n) + 0x10U + (ch * 0x04U))
+
+/*
+ * インターバルタイマ設定用：未使用
+ */
+#define TAUJCMOR(n, ch)	(TAUJ_BASE(n) + 0x80U + (ch * 0x04U))
+
+/*
+ * インターバルタイマ設定用：未使用
+ */
+#define TAUJCMUR(n, ch)	(TAUJ_BASE(n) + 0x20U + (ch * 0x04U))
+/*
+ *　 タイマ開始処理
+ */
+// 16bitレジスタ(ch)
+//
+// |F|E|D|C|B|A|9|8|7|6|5|4|3|2|1|0|
+// |-------|-------|-------|-------|
+//
+// 1:start
+// 0:not start
+#define TAUJTS(n)		(TAUJ_BASE(n) + 0x54U)
+/*
+ *　タイマ停止処理
+ */
+// 16bitレジスタ(ch)
+//
+// |F|E|D|C|B|A|9|8|7|6|5|4|3|2|1|0|
+// |-------|-------|-------|-------|
+//
+// 1:stop
+// 0:not stop
+#define TAUJTT(n)		(TAUJ_BASE(n) + 0x58U)
+
+#define MCU_TAUJ_MASK_CK0				((uint16) 0xfff0)
+#define MCU_TAUJ_CK0_0					((uint16) 0x0000)
+#define MCU_TAUJ00_CMOR					((uint16) 0x0000)
+#define MCU_TAUJ00_CMUR					((uint8) 0x01)
+
+
+
+#endif /* _TIMER_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/serial/serial.c
@@ -0,0 +1,346 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "inc/serial.h"
+#include "device.h"
+#include "std_errno.h"
+#include "mpu_types.h"
+#include "device_ex_serial_ops.h"
+#include "cpuemu_ops.h"
+#include <stdio.h>
+
+typedef struct {
+	uint32 					received_counter;
+	uint16 					id;
+	uint16 					rx_intno;
+	uint16					tx_intno;
+	uint32					send_counter;
+	bool   					is_send_data;
+	uint8 					send_data;
+	DeviceExSerialOpType 	*ops;
+	DeviceClockType 		*dev_clock;
+	uint64					start_clock;
+	bool					is_send_enable;
+	bool					is_read_enable;
+	bool					is_reset_mode;
+	bool					is_send_start_intr;
+	bool					is_sending;
+	bool					is_receiving;
+} SerialDeviceType;
+
+static SerialDeviceType SerialDevice[UDnChannelNum];
+
+static Std_ReturnType serial_get_data8(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 *data);
+static Std_ReturnType serial_get_data16(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint16 *data);
+static Std_ReturnType serial_get_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 *data);
+static Std_ReturnType serial_put_data8(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 data);
+static Std_ReturnType serial_put_data16(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint16 data);
+static Std_ReturnType serial_put_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 data);
+static Std_ReturnType serial_get_pointer(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 **data);
+
+MpuAddressRegionOperationType	serial_memory_operation = {
+		.get_data8 		= 	serial_get_data8,
+		.get_data16		=	serial_get_data16,
+		.get_data32		=	serial_get_data32,
+
+		.put_data8 		= 	serial_put_data8,
+		.put_data16		=	serial_put_data16,
+		.put_data32		=	serial_put_data32,
+
+		.get_pointer	= serial_get_pointer,
+};
+
+#define SERIAL_SEND_TIME_DEFAULT		100U
+#define SERIAL_RECEIVE_TIME_DEFAULT		1000U
+
+static uint32 serial_send_time = SERIAL_SEND_TIME_DEFAULT;
+static uint32 serial_receiv_time = SERIAL_SEND_TIME_DEFAULT;
+
+static MpuAddressRegionType *serial_region;
+
+
+void device_init_serial(MpuAddressRegionType *region)
+{
+	uint8 ch;
+
+	(void)cpuemu_get_devcfg_value("DEVICE_CONFIG_SERIAL_SEND_TIME", &serial_send_time);
+	(void)cpuemu_get_devcfg_value("DEVICE_CONFIG_SERIAL_RECIVE_TIME", &serial_receiv_time);
+
+	for (ch = 0; ch < UDnChannelNum; ch++) {
+		SerialDevice[ch].id = ch;
+		SerialDevice[ch].rx_intno = serial_rlin3x_get_rx_intno(ch);
+		SerialDevice[ch].tx_intno = serial_rlin3x_get_tx_intno(ch);
+		SerialDevice[ch].is_send_data = FALSE;
+		SerialDevice[ch].start_clock = 0U;
+		SerialDevice[ch].ops = NULL;
+		SerialDevice[ch].send_counter = 0U;
+		SerialDevice[ch].received_counter = 0U;
+		SerialDevice[ch].is_send_enable = FALSE;
+		SerialDevice[ch].is_read_enable = FALSE;
+		SerialDevice[ch].is_reset_mode = TRUE;
+		SerialDevice[ch].is_send_start_intr = TRUE;
+		SerialDevice[ch].is_sending = FALSE;
+		SerialDevice[ch].is_receiving = FALSE;
+	}
+
+	serial_region = region;
+
+	return;
+}
+
+static void serial_receive(SerialDeviceType *serial)
+{
+	uint8 data;
+	bool ret;
+
+	if (serial->ops == NULL) {
+		return;
+	}
+
+	//受信の有効・無効確認
+	if (!(serial->is_read_enable)) {
+		return;
+	}
+
+	if (serial->is_receiving == FALSE) {
+		/*
+		 * ユーザがレディ状態
+		 */
+		ret = serial->ops->getchar(serial->id, &data);
+		if (ret == TRUE) {
+			serial->is_receiving = TRUE;
+			//受信データをセットする．
+			(void)serial_put_data8(serial_region, CPU_CONFIG_CORE_ID_0, (RLIN3xLURDRL(serial->id) & serial_region->mask), data);
+			serial->received_counter = serial_receiv_time;
+		}
+	}
+	else {
+		if (serial->received_counter > 0U) {
+			serial->received_counter--;
+		}
+		else {
+			device_raise_int(serial->rx_intno);
+			serial->is_receiving = FALSE;
+		}
+	}
+
+	return;
+}
+
+static void serial_send(SerialDeviceType *serial)
+{
+	//送信の有効・無効確認
+	if (!(serial->is_send_enable)) {
+		return;
+	}
+
+	if (serial->is_send_data == TRUE) {
+		serial->is_sending = TRUE;
+	}
+
+	//送信中処理
+	if (serial->is_sending == TRUE) {
+		if (serial->send_counter == 0U) {
+			//送信開始
+			//(void)serial->ops->putchar(serial->id, serial->send_data);
+			if (serial->ops->flush != NULL) {
+				serial->ops->flush(serial->id);
+			}
+			serial->is_send_data = FALSE;
+
+			if (serial->is_send_start_intr) {
+				device_raise_int(serial->tx_intno);
+			}
+			serial->send_counter++;
+		}
+		else if (serial->send_counter >= serial_send_time) {
+			//送信完了
+			if (!(serial->is_send_start_intr)) {
+				device_raise_int(serial->tx_intno);
+				serial->is_sending = FALSE;
+			}
+			else {
+				if (!(serial->is_send_data)) {
+					serial->is_sending = FALSE;
+				}
+			}
+			serial->send_counter = 0U;
+		}
+		else {
+			//送信中
+			serial->send_counter++;
+		}
+	}
+
+	return;
+}
+
+void device_do_serial(SerialDeviceType *serial)
+{
+	serial_receive(serial);
+	serial_send(serial);
+	return;
+}
+
+void device_supply_clock_serial(DeviceClockType *dev_clock)
+{
+
+	SerialDevice[UDnCH1].dev_clock = dev_clock;
+	device_do_serial(&SerialDevice[UDnCH1]);
+
+	return;
+}
+
+void device_ex_serial_register_ops(uint8 channel, DeviceExSerialOpType *ops)
+{
+	SerialDevice[channel].ops = ops;
+	return;
+}
+
+static void serial_change_mode_reset(MpuAddressRegionType *region, uint8 ch)
+{
+	uint32 off;
+
+	/* RLN3nLTRC (not supported) */
+	/* RLN3nLEST (not supported) */
+	/* RLN3nLST */
+	off = ((RLIN3xLST(ch)) - region->start);
+	*((uint8*)(&region->data[off])) = 0x00;
+	SerialDevice[ch].is_sending = FALSE;
+	SerialDevice[ch].is_receiving = FALSE;
+
+	/* RLN3nLUOER */
+	off = (RLIN3xLUOER(ch) - region->start);
+	*((uint8*)(&region->data[off])) = 0x00;
+	SerialDevice[ch].is_read_enable = FALSE;
+	SerialDevice[ch].is_send_enable = FALSE;
+
+	SerialDevice[ch].received_counter = 0U;
+	SerialDevice[ch].send_counter = 0U;
+
+	return;
+}
+
+static Std_ReturnType serial_get_data8(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 *data)
+{
+	uint32 off = (addr - region->start);
+	uint8 ch = RLIN_GET_CHANNEL(addr);
+
+	if (addr == RLIN3xLST(ch)) {
+		*data = ((RLIN3x_LST_GET_URS(SerialDevice[ch].is_receiving) << RLIN3x_LST_URS_BIT) |
+				(RLIN3x_LST_GET_UTS(SerialDevice[ch].is_sending) << RLIN3x_LST_UTS_BIT));
+	}
+	else {
+		*data = *((uint8*)(&region->data[off]));
+	}
+
+	return STD_E_OK;
+}
+static Std_ReturnType serial_get_data16(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint16 *data)
+{
+	uint32 off = (addr - region->start);
+	*data = *((uint16*)(&region->data[off]));
+	return STD_E_OK;
+}
+static Std_ReturnType serial_get_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 *data)
+{
+	uint32 off = (addr - region->start);
+	*data = *((uint32*)(&region->data[off]));
+	return STD_E_OK;
+}
+static Std_ReturnType serial_put_data8(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 data)
+{
+	uint32 off = (addr - region->start);
+	*((uint8*)(&region->data[off])) = data;
+	uint8 ch = RLIN_GET_CHANNEL(addr);
+
+	if (addr == RLIN3xLUTDRL(ch)) {
+		SerialDevice[ch].send_data = data;;
+		SerialDevice[ch].is_send_data = TRUE;
+		(void)SerialDevice[ch].ops->putchar(SerialDevice[ch].id, SerialDevice[ch].send_data);
+	}
+	else if (addr == RLIN3xLCUC(ch)) {
+		off = (RLIN3xLMST(ch) - region->start);
+		*((uint8*)(&region->data[off])) = data;
+		SerialDevice[ch].is_reset_mode = RLIN_ISMODE_RESET(data);
+		if (SerialDevice[ch].is_reset_mode) {
+			serial_change_mode_reset(region, ch);
+		}
+	}
+	else if (addr == RLIN3xLUOER(ch)) {
+		if (!(SerialDevice[ch].is_reset_mode)) {
+			SerialDevice[ch].is_read_enable = RLIN3x_LUOER_ISSET_UROE(data);
+			SerialDevice[ch].is_send_enable = RLIN3x_LUOER_ISSET_UTOE(data);
+		}
+	}
+	else if (addr == (RLIN3x_LUOR1(ch))) {
+		SerialDevice[ch].is_send_start_intr = RLIN3x_LUOR1_ISSET_SEND_START_INTR(data);
+	}
+
+
+	return STD_E_OK;
+}
+static Std_ReturnType serial_put_data16(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint16 data)
+{
+	uint32 off = (addr - region->start);
+	*((uint16*)(&region->data[off])) = data;
+	uint8 ch = RLIN_GET_CHANNEL(addr);
+
+	if (addr == RLIN3xLUTDRL(ch)) {
+		SerialDevice[ch].send_data = (uint8)data;
+		SerialDevice[ch].is_send_data = TRUE;
+	}
+
+	return STD_E_OK;
+}
+static Std_ReturnType serial_put_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 data)
+{
+	uint32 off = (addr - region->start);
+	*((uint32*)(&region->data[off])) = data;
+	return STD_E_OK;
+}
+static Std_ReturnType serial_get_pointer(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 **data)
+{
+	uint32 off = (addr - region->start);
+	*data = &region->data[off];
+	return STD_E_OK;
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill-target-rh850f1x/src/device/peripheral/rh850f1k/timer/timer.c
@@ -0,0 +1,316 @@
+/*
+ *  TOPPERS athrill
+ *     Athrill is a CPU emulator. Athrill was developed to easily
+ *     execute and debug embedded programs on virtual microcomputer.
+ *
+ *  Copyright (C) 2019 by Center for Embedded Computing Systems
+ *                          Graduate School of Informatics, Nagoya Univ., JAPAN
+ *  Copyright (C) 2019 by ESM, Inc.
+ *
+ *
+ *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ *      スコード中に含まれていること．
+ *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ *      の無保証規定を掲載すること．
+ *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ *      と．
+ *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ *        報告すること．
+ *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ *      免責すること．
+ *
+ *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ *  の責任を負わない．
+ *
+ *  $Id$
+ */
+#include "inc/timer.h"
+#include "cpuemu_ops.h"
+#include <stdio.h>
+#include <limits.h>
+
+typedef enum {
+	TIMER_STATE_STOP,
+	TIMER_STATE_READY,
+	TIMER_STATE_RUNNING
+} TimerStateType;
+
+typedef enum {
+	TIMER_MODE_FREERUN,
+	TIMER_MODE_INTERVAL
+} TimerModeType;
+
+typedef struct {
+	uint32 				cnt;
+	uint32				reg_cnt;
+	TimerStateType 		state;
+	TimerModeType 		mode;
+	uint32 				compare0;
+	uint32 				compare0_intno;
+	uint64 				start_clock;
+	uint32 				fd;
+} TimerDeviceType;
+
+static Std_ReturnType timer_get_data8(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 *data);
+static Std_ReturnType timer_get_data16(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint16 *data);
+static Std_ReturnType timer_get_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 *data);
+static Std_ReturnType timer_put_data8(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 data);
+static Std_ReturnType timer_put_data16(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint16 data);
+static Std_ReturnType timer_put_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 data);
+static Std_ReturnType timer_get_pointer(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 **data);
+
+MpuAddressRegionOperationType	timer_memory_operation = {
+		.get_data8 		= 	timer_get_data8,
+		.get_data16		=	timer_get_data16,
+		.get_data32		=	timer_get_data32,
+
+		.put_data8 		= 	timer_put_data8,
+		.put_data16		=	timer_put_data16,
+		.put_data32		=	timer_put_data32,
+
+		.get_pointer	= timer_get_pointer,
+};
+static TimerDeviceType TimerDevice[TAUJ_UNIT_NUM][TAUJ_CH_NUM];
+static MpuAddressRegionType *timer_region;
+
+void device_init_timer(MpuAddressRegionType *region)
+{
+	int i;
+	int j;
+	uint32 value = 50000;
+
+	(void)cpuemu_get_devcfg_value("DEVICE_CONFIG_TIMER_FD", &value);
+	//printf("timer value=%d\n", value);
+
+	timer_region = region;
+
+	for (i = 0; i < TAUJ_UNIT_NUM; i++) {
+		for (j = 0; j < TAUJ_CH_NUM; j++) {
+			TimerDevice[i][j].cnt = 0;
+			TimerDevice[i][j].reg_cnt = 0xFFFFFFFF;
+			TimerDevice[i][j].state = TIMER_STATE_STOP;
+			TimerDevice[i][j].mode = TIMER_MODE_INTERVAL;
+			TimerDevice[i][j].compare0 = 0;
+			TimerDevice[i][j].fd = value;
+			TimerDevice[i][j].start_clock = 0;
+			TimerDevice[i][j].compare0_intno = TAUJ_INTNO(i, j);
+		}
+	}
+
+	return;
+}
+
+static void device_timer_do_update(DeviceClockType *device, int n, int ch)
+{
+	TimerDeviceType *timer = &(TimerDevice[n][ch]);
+
+	if (timer->state == TIMER_STATE_READY) {
+		timer->state = TIMER_STATE_RUNNING;
+		if ((timer->start_clock == 0U) || (timer->mode == TIMER_MODE_INTERVAL)) {
+			timer->start_clock = device->clock;
+		}
+		//printf("device_timer_do_update:n=%d ch=%d compare=%d\n", n, ch, timer->compare0);
+	}
+
+	timer->cnt = (uint32)((device->clock - timer->start_clock) / (uint64)timer->fd);
+	if (timer->state == TIMER_STATE_RUNNING) {
+		if (timer->mode == TIMER_MODE_INTERVAL) {
+			timer->reg_cnt = timer->compare0 - timer->cnt;
+			//static int interval = 0;
+			//if ((interval++) >= 0) { printf("cnt=%u\n", timer->cnt); interval = 0;}
+			if (timer->cnt >= timer->compare0) {
+				//printf("raise INT:n=%d ch=%d cnt=%d\n", n, ch, timer->cnt);
+				device_raise_int(timer->compare0_intno);
+				timer->state = TIMER_STATE_READY;
+			}
+		}
+	}
+	return;
+}
+
+
+static void device_timer_do_calc_min_interval(DeviceClockType *device, int n, int ch)
+{
+	TimerDeviceType *timer = &(TimerDevice[n][ch]);
+	uint64 interval;
+
+#ifndef CPUEMU_CLOCK_BUG_FIX
+	if (device->can_skip_clock == FALSE) {
+		return;
+	}
+	if (timer->cnt >= timer->compare0) {
+		return;
+	}
+
+	interval = (timer->compare0 - timer->cnt) * timer->fd;
+
+	if ((interval > 0) && (interval < device->min_intr_interval)) {
+		device->min_intr_interval = interval;
+		//printf("TIMER clock=%I64u min=%I64u\n", device->clock, device->min_intr_interval);
+	}
+#else
+	uint64 cnt_1 = (device->clock - timer->start_clock);
+	uint64 compare_value = (((uint64)timer->compare0) * ((uint64)timer->fd));
+	if (cnt_1 <= compare_value) {
+		interval = (compare_value - cnt_1);
+	}
+	else {
+		interval = 1;
+	}
+	//printf("TIMER compare_value=%llu clock=%llu start_clock=%llu cnt_1=%llu interval=%llu\n", compare_value, device->clock, timer->start_clock, cnt_1, interval);
+
+	if (interval < device->min_intr_interval) {
+		if (interval == 0) {
+			interval = 1;
+		}
+		device->min_intr_interval = interval;
+		//printf("TIMER clock=%llu min=%llu\n", device->clock, device->min_intr_interval);
+	}
+#endif
+	return;
+}
+
+#ifndef CPUEMU_CLOCK_BUG_FIX
+#define INLINE_device_supply_clock_timer(dev_clock, n, ch)	\
+do {	\
+	if ((dev_clock->clock % TimerDevice[n][ch].fd) == 0) {	\
+		device_timer_do_update(dev_clock, n, ch);	\
+		device_timer_do_calc_min_interval(dev_clock, n, ch);	\
+	}	\
+	else {	\
+		dev_clock->can_skip_clock = FALSE;	\
+	}	\
+} while(0)
+#else
+#define INLINE_device_supply_clock_timer(dev_clock, n, ch)	\
+do {	\
+	if ((dev_clock->clock % TimerDevice[n][ch].fd) == 0) {	\
+		device_timer_do_update(dev_clock, n, ch);	\
+	}	\
+	if (((dev_clock)->is_halt == TRUE) && (TimerDevice[n][ch].state != TIMER_STATE_STOP)) {	\
+		device_timer_do_calc_min_interval(dev_clock, n, ch);	\
+	}	\
+} while(0)
+#endif
+
+void device_supply_clock_timer(DeviceClockType *dev_clock)
+{
+	INLINE_device_supply_clock_timer(dev_clock, 0, 0);
+	INLINE_device_supply_clock_timer(dev_clock, 0, 1);
+	//INLINE_device_supply_clock_timer(dev_clock, 1, 0);
+	//INLINE_device_supply_clock_timer(dev_clock, 1, 1);
+	return;
+}
+
+
+static Std_ReturnType timer_get_data8(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 *data)
+{
+	uint32 off = (addr - region->start);
+	*data = *((uint8*)(&region->data[off]));
+	return STD_E_OK;
+}
+static Std_ReturnType timer_get_data16(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint16 *data)
+{
+	uint32 off = (addr - region->start);
+	*data = *((uint16*)(&region->data[off]));
+	return STD_E_OK;
+}
+
+static Std_ReturnType timer_get_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 *data)
+{
+	uint32 off = (addr - region->start);
+	uint8 n;
+	uint8 ch;
+	*data = *((uint32*)(&region->data[off]));
+
+	for (n = 0; n < TAUJ_UNIT_NUM; n++) {
+		for (ch = 0; ch < TAUJ_CH_NUM; ch++) {
+			if (addr == (TAUJCNT(n, ch) & region->mask)) {
+				*data = TimerDevice[n][ch].reg_cnt;
+				//printf("%s():n=%d ch=%d cnt=%u\n", __FUNCTION__, n, ch, *data);
+				return STD_E_OK;
+			}
+		}
+	}
+	return STD_E_OK;
+}
+static Std_ReturnType timer_put_data8(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 data)
+{
+	uint8 n;
+	uint8 ch;
+	uint32 off = (addr - region->start);
+	*((uint8*)(&region->data[off])) = data;
+
+		//printf("timer_put_data8 core=%d addr=0x%x data=0x%x\n", core_id, addr, data);
+	for (n = 0; n < TAUJ_UNIT_NUM; n++) {
+		if (addr == (TAUJTS(n) & region->mask)) {
+			for (ch = 0; ch < TAUJ_CH_NUM; ch++) {
+				if ((data & (1U << ch)) != 0) {
+					TimerDevice[n][ch].state = TIMER_STATE_READY;
+					//printf("timer[%d][%d] addr=0x%x ready\n", n, ch, addr);
+					return STD_E_OK;
+				}
+			}
+		}
+		else if (addr == (TAUJTT(n) & region->mask)) {
+			for (ch = 0; ch < TAUJ_CH_NUM; ch++) {
+				if ((data & (1U << ch)) != 0) {
+					TimerDevice[n][ch].state = TIMER_STATE_STOP;
+					//printf("timer[%d][%d] addr=0x%x stop\n", n, ch, addr);
+					return STD_E_OK;
+				}
+			}
+		}
+	}
+	return STD_E_OK;
+}
+static Std_ReturnType timer_put_data16(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint16 data)
+{
+	uint32 off = (addr - region->start);
+	*((uint16*)(&region->data[off])) = data;
+
+	return STD_E_OK;
+}
+static Std_ReturnType timer_put_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 data)
+{
+	uint8 n;
+	uint8 ch;
+	uint32 off = (addr - region->start);
+	*((uint32*)(&region->data[off])) = data;
+
+	for (n = 0; n < TAUJ_UNIT_NUM; n++) {
+		for (ch = 0; ch < TAUJ_CH_NUM; ch++) {
+			if (addr == (TAUJCDR(n, ch) & region->mask)) {
+				TimerDevice[n][ch].compare0 = data;
+				if (TimerDevice[n][ch].state == TIMER_STATE_RUNNING) {
+					TimerDevice[n][ch].state = TIMER_STATE_READY;
+				}
+				//printf("%s() n=%d ch=%d compare0=%u\n", __FUNCTION__, n, ch, data);
+				return STD_E_OK;
+			}
+		}
+	}
+
+	return STD_E_OK;
+}
+static Std_ReturnType timer_get_pointer(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 **data)
+{
+	uint32 off = (addr - region->start);
+	*data = &region->data[off];
+	return STD_E_OK;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/MANIFEST
@@ -0,0 +1,244 @@
+PACKAGE athrill
+VERSION 1.1.1
+
+MANIFEST
+README.ja.md
+README.md
+
+apl/include/athrill_syscall.h
+apl/src/athrill-syscall.c
+
+bin/linux/athrill_extfunc.sh
+bin/linux/athrill-run
+bin/linux/athrill-run-remote
+bin/linux/athrill_terminal
+bin/linux/geany.sh
+bin/linux/variable_conflict_check.groovy
+bin/linux/variable_conflict_check.sh
+bin/windows/athrill_scenario_cmd.sh
+bin/windows/sakura.sh
+build/core/linux/Makefile.bus
+build/core/linux/Makefile.cpu
+build/core/linux/Makefile.cui
+build/core/linux/Makefile.device
+build/core/linux/Makefile.loader
+build/core/linux/Makefile.main
+build/core/linux/Makefile.mpu
+build/core/linux/Makefile.mros
+build/core/linux/Makefile.std
+command/remote/remote_cui_client/cpuemu_config.h
+command/remote/remote_cui_client/main.c
+command/remote/remote_cui_client/Makefile
+
+src/bus/bus.c
+src/bus/bus.h
+src/cpu/cpu.h
+src/debugger/executor/concrete_executor/dbg_std_executor.c
+src/debugger/executor/concrete_executor/dbg_std_executor.h
+src/debugger/executor/concrete_executor/target/dbg_target_cpu.h
+src/debugger/executor/concrete_executor/target/dbg_target_serial.h
+src/debugger/executor/concrete_executor/util/dbg_print_data_type.c
+src/debugger/executor/concrete_executor/util/dbg_print_data_type.h
+src/debugger/executor/cpu_control/dbg_cpu_callback.c
+src/debugger/executor/cpu_control/dbg_cpu_callback.h
+src/debugger/executor/cpu_control/dbg_cpu_control.c
+src/debugger/executor/cpu_control/dbg_cpu_control.h
+src/debugger/executor/cpu_control/dbg_cpu_thread_control.c
+src/debugger/executor/cpu_control/dbg_cpu_thread_control.h
+src/debugger/executor/dbg_executor.h
+src/debugger/interaction/front/parser/concrete_parser/dbg_std_parser.c
+src/debugger/interaction/front/parser/concrete_parser/dbg_std_parser.h
+src/debugger/interaction/front/parser/dbg_parser.c
+src/debugger/interaction/front/parser/dbg_parser_config.c
+src/debugger/interaction/front/parser/dbg_parser_config.h
+src/debugger/interaction/front/parser/dbg_parser.h
+src/debugger/interaction/inc/dbg_interaction_std_ids.h
+src/debugger/interaction/inc/target/rh850/dbg_interaction_target_ids.h
+src/debugger/interaction/inc/target/v850e2m/dbg_interaction_target_ids.h
+src/debugger/interaction/inc/target/v850esfk3/dbg_interaction_target_ids.h
+src/device/mpu/loader/loader.c
+src/device/mpu/loader/loader.h
+src/device/mpu/mpu.c
+src/device/mpu/mpu.h
+src/device/mpu/mpu_malloc.c
+src/device/mpu/mpu_malloc.h
+src/device/mpu/mpu_ops.h
+src/device/mpu/mpu_types.h
+src/device/peripheral/athrill_device.c
+src/device/peripheral/athrill_mpthread.c
+src/device/peripheral/athrill_syscall_device.c
+src/device/peripheral/mros-dev/mros-athrill/api/ros_cimpl.c
+src/device/peripheral/mros-dev/mros-athrill/api/ros_cimpl.h
+src/device/peripheral/mros-dev/mros-athrill/config/mros_sys_config.c
+src/device/peripheral/mros-dev/mros-athrill/config/mros_sys_config.h
+src/device/peripheral/mros-dev/mros-athrill/config/mros_usr_config.c
+src/device/peripheral/mros-dev/mros-athrill/config/mros_usr_config.h
+src/device/peripheral/mros-dev/mros-athrill/config/os/target/os_asp/mros_os_config.c
+src/device/peripheral/mros-dev/mros-athrill/config/os/target/os_asp/mros_os_config.h
+src/device/peripheral/mros-dev/mros-athrill/device/athrill_mros_device.c
+src/device/peripheral/mros-dev/mros-athrill/device/athrill_mros_device.h
+src/device/peripheral/mros-dev/mros-athrill/target/lwip/init.h
+src/device/peripheral/mros-dev/mros-athrill/target/lwip/lwip_linux.c
+src/device/peripheral/mros-dev/mros-athrill/target/lwip/netdb.h
+src/device/peripheral/mros-dev/mros-athrill/target/lwip/sockets.h
+src/device/peripheral/mros-dev/mros-athrill/target/os/kernel_cfg.h
+src/device/peripheral/mros-dev/mros-athrill/target/os/kernel.h
+src/device/peripheral/mros-dev/mros-athrill/target/os/mros_exclusive_ops_linux.c
+src/device/peripheral/mros-dev/mros-athrill/target/os/os_asp.c
+src/device/peripheral/mros-dev/mros-athrill/target/os/t_syslog.h
+src/device/peripheral/mros-dev/mros-src/api/mros_topic_callback.h
+src/device/peripheral/mros-dev/mros-src/comm/cimpl/mros_comm_cimpl.h
+src/device/peripheral/mros-dev/mros-src/comm/cimpl/mros_comm_socket_cimpl.c
+src/device/peripheral/mros-dev/mros-src/comm/cimpl/mros_comm_socket_cimpl.h
+src/device/peripheral/mros-dev/mros-src/comm/cimpl/mros_comm_tcp_client_cimpl.c
+src/device/peripheral/mros-dev/mros-src/comm/cimpl/mros_comm_tcp_client_cimpl.h
+src/device/peripheral/mros-dev/mros-src/comm/cimpl/mros_comm_tcp_client_factory_cimpl.c
+src/device/peripheral/mros-dev/mros-src/comm/cimpl/mros_comm_tcp_client_factory_cimpl.h
+src/device/peripheral/mros-dev/mros-src/comm/cimpl/mros_comm_tcp_server_cimpl.c
+src/device/peripheral/mros-dev/mros-src/comm/cimpl/mros_comm_tcp_server_cimpl.h
+src/device/peripheral/mros-dev/mros-src/comm/cimpl/target/lwip/mros_comm_cimpl.c
+src/device/peripheral/mros-dev/mros-src/comm/cimpl/target/lwip/mros_comm_target.h
+src/device/peripheral/mros-dev/mros-src/inc/mros_array_container.h
+src/device/peripheral/mros-dev/mros-src/inc/mros_exclusive_area.h
+src/device/peripheral/mros-dev/mros-src/inc/mros_exclusive_ops.h
+src/device/peripheral/mros-dev/mros-src/inc/mros_list.h
+src/device/peripheral/mros-dev/mros-src/inc/mros_memory.h
+src/device/peripheral/mros-dev/mros-src/inc/mros_name.h
+src/device/peripheral/mros-dev/mros-src/inc/mros_os.h
+src/device/peripheral/mros-dev/mros-src/inc/mros_types.h
+src/device/peripheral/mros-dev/mros-src/inc/mros_wait_queue.h
+src/device/peripheral/mros-dev/mros-src/lib/mros_memory.c
+src/device/peripheral/mros-dev/mros-src/lib/mros_name.c
+src/device/peripheral/mros-dev/mros-src/lib/mros_wait_queue.c
+src/device/peripheral/mros-dev/mros-src/node/cimpl/mros_node_cimpl.c
+src/device/peripheral/mros-dev/mros-src/node/cimpl/mros_node_cimpl.h
+src/device/peripheral/mros-dev/mros-src/os/mros_exclusive_area.c
+src/device/peripheral/mros-dev/mros-src/os/mros_exclusive_ops.c
+src/device/peripheral/mros-dev/mros-src/os/target/os_asp/mros_log.h
+src/device/peripheral/mros-dev/mros-src/os/target/os_asp/mros_os.c
+src/device/peripheral/mros-dev/mros-src/os/target/os_asp/mros_os_target.h
+src/device/peripheral/mros-dev/mros-src/os/target/os_asp/mros_test.c
+src/device/peripheral/mros-dev/mros-src/os/target/os_asp/mros_test.h
+src/device/peripheral/mros-dev/mros-src/packet/cimpl/mros_packet_cimpl.h
+src/device/peripheral/mros-dev/mros-src/packet/cimpl/mros_packet_decoder_cimpl.h
+src/device/peripheral/mros-dev/mros-src/packet/cimpl/mros_packet_encoder_cimpl.h
+src/device/peripheral/mros-dev/mros-src/packet/cimpl/version/kinetic/mros_packet_config.h
+src/device/peripheral/mros-dev/mros-src/packet/cimpl/version/kinetic/mros_packet_decoder_cimpl.c
+src/device/peripheral/mros-dev/mros-src/packet/cimpl/version/kinetic/mros_packet_encoder_cimpl.c
+src/device/peripheral/mros-dev/mros-src/packet/template/version/kinetic/mros_packet_fmt_http.h
+src/device/peripheral/mros-dev/mros-src/packet/template/version/kinetic/mros_packet_fmt_tcpros.h
+src/device/peripheral/mros-dev/mros-src/packet/template/version/kinetic/mros_packet_fmt_xml.h
+src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_client_rpc_cimpl.c
+src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_client_rpc_cimpl.h
+src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_master_cimpl.c
+src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_master_cimpl.h
+src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_operation_cimpl.c
+src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_operation_cimpl.h
+src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_publish_cimpl.c
+src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_publish_cimpl.h
+src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_server_proc_cimpl.c
+src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_server_proc_cimpl.h
+src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_slave_cimpl.c
+src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_slave_cimpl.h
+src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_subscribe_cimpl.c
+src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_subscribe_cimpl.h
+src/device/peripheral/mros-dev/mros-src/topic/cimpl/mros_topic_cimpl.c
+src/device/peripheral/mros-dev/mros-src/topic/cimpl/mros_topic_cimpl.h
+src/device/peripheral/mros-dev/mros-src/topic/cimpl/mros_topic_connector_cimpl.c
+src/device/peripheral/mros-dev/mros-src/topic/cimpl/mros_topic_connector_cimpl.h
+src/device/peripheral/mros-dev/mros-src/topic/cimpl/mros_topic_connector_factory_cimpl.c
+src/device/peripheral/mros-dev/mros-src/topic/cimpl/mros_topic_connector_factory_cimpl.h
+src/device/peripheral/mros-dev/mros-src/topic/cimpl/mros_topic_runner_cimpl.h
+src/device/peripheral/mros-dev/mros-src/transfer/cimpl/mros_topic_data_publisher_cimpl.c
+src/device/peripheral/mros-dev/mros-src/transfer/cimpl/mros_topic_data_publisher_cimpl.h
+src/device/peripheral/mros-dev/mros-src/transfer/cimpl/mros_topic_data_subscriber_cimpl.c
+src/device/peripheral/mros-dev/mros-src/transfer/cimpl/mros_topic_data_subscriber_cimpl.h
+src/device/peripheral/serial/fifo/serial_fifo.c
+src/device/peripheral/serial/fifo/serial_fifo.h
+src/device/peripheral/target/device_ex_serial_ops.h
+src/inc/athrill_device.h
+src/inc/athrill_mpthread.h
+src/inc/cpu_config_ops.h
+src/inc/cpuemu_ops.h
+src/inc/std_cpu_ops.h
+src/inc/std_device_ops.h
+src/inc/std_errno.h
+src/inc/std_types.h
+src/lib/assert.h
+src/lib/athrill_memory.h
+src/lib/comm_buffer.c
+src/lib/comm_buffer.h
+src/lib/cui/cui_ops.c
+src/lib/cui/cui_ops.h
+src/lib/cui/stdio/cui_ops_stdio.c
+src/lib/cui/stdio/cui_ops_stdio.h
+src/lib/cui/tcp/cui_ops_tcp.c
+src/lib/cui/tcp/cui_ops_tcp.h
+src/lib/cui/udp/cui_ops_udp.c
+src/lib/cui/udp/cui_ops_udp.h
+src/lib/dbg_log.c
+src/lib/dbg_log.h
+src/lib/dwarf/data_type/elf_dwarf_array_type.c
+src/lib/dwarf/data_type/elf_dwarf_array_type.h
+src/lib/dwarf/data_type/elf_dwarf_base_type.c
+src/lib/dwarf/data_type/elf_dwarf_base_type.h
+src/lib/dwarf/data_type/elf_dwarf_data_type.c
+src/lib/dwarf/data_type/elf_dwarf_data_type.h
+src/lib/dwarf/data_type/elf_dwarf_enum_type.c
+src/lib/dwarf/data_type/elf_dwarf_enum_type.h
+src/lib/dwarf/data_type/elf_dwarf_pointer_type.c
+src/lib/dwarf/data_type/elf_dwarf_pointer_type.h
+src/lib/dwarf/data_type/elf_dwarf_struct_type.c
+src/lib/dwarf/data_type/elf_dwarf_struct_type.h
+src/lib/dwarf/data_type/elf_dwarf_subprogram_type.c
+src/lib/dwarf/data_type/elf_dwarf_subprogram_type.h
+src/lib/dwarf/data_type/elf_dwarf_typedef_type.c
+src/lib/dwarf/data_type/elf_dwarf_typedef_type.h
+src/lib/dwarf/data_type/elf_dwarf_variable_type.c
+src/lib/dwarf/data_type/elf_dwarf_variable_type.h
+src/lib/dwarf/elf_dwarf_abbrev.c
+src/lib/dwarf/elf_dwarf_abbrev.h
+src/lib/dwarf/elf_dwarf_info.c
+src/lib/dwarf/elf_dwarf_info.h
+src/lib/dwarf/elf_dwarf_info_ops.c
+src/lib/dwarf/elf_dwarf_info_ops.h
+src/lib/dwarf/elf_dwarf_line.c
+src/lib/dwarf/elf_dwarf_line.h
+src/lib/dwarf/elf_dwarf_loc.c
+src/lib/dwarf/elf_dwarf_loc.h
+src/lib/dwarf/elf_dwarf_util.c
+src/lib/dwarf/elf_dwarf_util.h
+src/lib/dwarf/elf_section.c
+src/lib/dwarf/elf_section.h
+src/lib/dwarf/file_address_mapping.c
+src/lib/dwarf/file_address_mapping.h
+src/lib/file.c
+src/lib/file.h
+src/lib/hash.c
+src/lib/hash.h
+src/lib/list.h
+src/lib/loader/elf_common.h
+src/lib/loader/elf.h
+src/lib/object_container.h
+src/lib/symbol_ops.c
+src/lib/symbol_ops.h
+src/lib/target/target_os_api.h
+src/lib/tcp/tcp_client.c
+src/lib/tcp/tcp_client.h
+src/lib/tcp/tcp_connection.c
+src/lib/tcp/tcp_connection.h
+src/lib/tcp/tcp_server.c
+src/lib/tcp/tcp_server.h
+src/lib/tcp/tcp_socket.c
+src/lib/tcp/tcp_socket.h
+src/lib/token.c
+src/lib/token.h
+src/lib/udp/udp_comm.c
+src/lib/udp/udp_comm.h
+src/lib/udp/udp_common.h
+src/lib/winsock_wrapper/winsock_wrapper.c
+src/lib/winsock_wrapper/winsock_wrapper.h
+src/main/cpuemu.c
+src/main/main.c
+src/main/option/option.c
+src/main/option/option.h
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/README.ja.md
@@ -0,0 +1,52 @@
+athrill
+=======
+
+Athrill は CPU エミュレータです. 
+Athrill を使用すると，仮想マイコン上で組込みプログラムを簡単に実行/デバッグすることができます．
+ベアメタルプログラムやリアルタイムOS上で動作する組込み制御プログラムを評価できます．
+現時点の Athrill は V850 のCPU命令をサポートしています．
+
+# Table of Contents
+-----------------
+  * [Requirements](#requirements)
+  * [Install](#install)
+  * [License](#license)
+
+# Requirements
+------------
+Athrill は， 以下の環境で動作します：
+
+  * OS
+    * [Linux]
+      * Ubuntu(32bit)
+    * [Windows]
+      * MinGW32_NT-6.2(Windows10, Windows7)
+
+Athrill は， ソースデバッグ用に以下のエディタを使用します:
+
+  * エディタ
+    * [Linux]
+      * geany
+    * [Windows]
+      * Sakura Editor
+
+# Install
+-----
+Athrill プロジェクトをダウンロード後,  環境変数(PATH)にathrillの実行バイナリフォルダのパスを追加しててください．
+
+```
+export PATH=[athrill root folder]/src/bin:$PATH 
+```
+任意のフォルダ上でathrillを空打ちし， usageが表示されればインストール完了です：
+
+	Usage:athrill -m<memory config file> [OPTION]... <load_file>
+	-i                             : execute on the interaction mode. if -i is not set, execute on the background mode.
+	-r                             : execute on the remote mode. this option is valid on the interaction mode.
+	-t<timeout>                    : set program end time using <timeout> clocks. this option is valid on the background mode.
+	-m<memory config file>         : set athrill memory configuration. rom, ram region is configured on your system.
+	-d<device config file>         : set device parameter.
+
+
+# License
+-------
+Athrill is licensed under the TOPPERS License Agreement (http://www.toppers.jp/en/license.html).
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/README.md
@@ -0,0 +1,51 @@
+athrill
+=======
+
+Athrill is a CPU emulator. 
+Athrill was developed to easily execute and debug embedded programs on virtual microcomputer. 
+You can evaluate bare metal programs or embedded control programs running on real-time OS. 
+Athrill at the moment supports V850 CPU instructions.
+
+# Table of Contents
+-----------------
+  * [Requirements](#requirements)
+  * [Install](#install)
+  * [License](#license)
+
+# Requirements
+------------
+Athrill requires the following to run:
+
+  * OS
+    * [Linux]
+      * Ubuntu(32bit)
+    * [Windows]
+      * MinGW32_NT-6.2(Windows10, Windows7)
+
+Athrill uses the following editors for source debugging:
+
+  * Editor
+    * [Linux]
+      * geany
+    * [Windows]
+      * Sakura Editor
+
+# Install
+-----
+After downloading Athrill project, add the following athrill executable binary folder path on the environment-variable (PATH).
+
+```
+export PATH=[athrill root folder]/src/bin:$PATH 
+```
+Then make sure you can display usage of athrill on an arbitrary folder:
+
+	Usage:athrill -m<memory config file> [OPTION]... <load_file>
+	-i                             : execute on the interaction mode. if -i is not set, execute on the background mode.
+	-r                             : execute on the remote mode. this option is valid on the interaction mode.
+	-t<timeout>                    : set program end time using <timeout> clocks. this option is valid on the background mode.
+	-m<memory config file>         : set athrill memory configuration. rom, ram region is configured on your system.
+
+
+# License
+-------
+Athrill is licensed under the TOPPERS License Agreement (http://www.toppers.jp/en/license.html).
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/apl/include/athrill_syscall.h
@@ -0,0 +1,787 @@
+#ifndef _ATHRILL_SYSCALL_H_
+#define _ATHRILL_SYSCALL_H_
+
+typedef unsigned int sys_uint32;
+typedef unsigned short sys_uint16;
+typedef unsigned char sys_uint8;
+typedef signed int sys_int32;
+typedef signed short sys_int16;
+typedef signed char sys_int8;
+typedef unsigned int sys_addr;
+#ifndef ATHRILL_FD_SETSIZE
+#define ATHRILL_FD_SETSIZE      64
+#endif /* ATHRILL_FD_SETSIZE */
+typedef struct {
+    unsigned char fd_bits [(ATHRILL_FD_SETSIZE+7)/8];
+} sys_fd_set;
+#define SYS_FD_SET_SIZE     sizeof(sys_fd_set)
+
+typedef enum {
+    sys_false = 0,
+    sys_true,
+} SysBoolType;
+typedef sys_int32 sys_bool; 
+
+struct sys_sockaddr_in {
+    sys_uint8  sin_family;
+    sys_uint16 sin_port;
+    sys_uint32 sin_addr;
+    sys_int8   sin_zero[8];
+};
+struct api_arg_socket {
+    sys_int32 domain;
+    sys_int32 type;
+    sys_int32 protocol;
+};
+
+struct api_arg_sense {
+    sys_int32   sockfd;
+    sys_int32   api_id;
+};
+
+struct api_arg_connect {
+    sys_int32 sockfd;
+    sys_addr sockaddr;
+    sys_uint32 addrlen;
+};
+struct api_arg_select {
+    sys_int32    nfds;
+    sys_addr     readfds;
+    sys_addr     writefds;
+    sys_addr     exceptfds;
+};
+
+struct api_arg_bind {
+    sys_int32 sockfd;
+    sys_addr sockaddr;
+    sys_uint32 addrlen;
+};
+
+struct api_arg_listen {
+    sys_int32 sockfd;
+    sys_int32 backlog;
+};
+
+struct api_arg_accept {
+    sys_int32 sockfd;
+    sys_addr sockaddr;
+    sys_addr addrlen;
+};
+
+struct api_arg_send {
+    sys_int32 sockfd;
+    sys_addr buf;
+    sys_uint32 len;
+    sys_int32 flags;
+};
+struct api_arg_recv {
+    sys_int32 sockfd;
+    sys_addr buf;
+    sys_uint32 len;
+    sys_int32 flags;
+};
+struct api_arg_shutdown {
+    sys_int32 sockfd;
+    sys_int32 how;
+};
+struct api_arg_system {
+    sys_uint32 id;
+};
+struct api_arg_malloc {
+    sys_uint32 size;
+    sys_addr    rptr;
+};
+struct api_arg_calloc {
+    sys_uint32 nmemb;
+    sys_uint32 size;
+    sys_addr    rptr;
+};
+struct api_arg_realloc {
+    sys_addr ptr;
+    sys_uint32 size;
+    sys_addr    rptr;
+};
+struct api_arg_free {
+    sys_addr ptr;
+};
+
+struct api_arg_open_r {
+    sys_addr file_name;
+    sys_int32 flags;
+    sys_int32 mode;
+};
+
+struct api_arg_read_r {
+    sys_int32 fd;
+    sys_addr buf;
+    sys_uint32 size;
+};
+
+struct api_arg_write_r {
+    sys_int32 fd;
+    sys_addr buf;
+    sys_uint32 size;
+};
+
+struct api_arg_close_r {
+    sys_int32 fd;
+};
+
+struct api_arg_lseek_r {
+    sys_int32 fd;
+    sys_uint32 offset;
+    sys_int32 whence;
+};
+
+
+struct api_arg_set_virtfs_top {
+    sys_addr top_dir;
+};
+
+struct api_arg_fflush {
+    sys_addr fp;
+};
+
+struct api_arg_ev3_opendir {
+    sys_addr path;
+    // output
+    sys_int32 dirid; // 8byte area to keep DIR pointer. caller must prepare the memory
+};
+
+// This function is different from original read dir. So, this api named ev3_readdir.
+struct api_arg_ev3_readdir {
+    sys_int32 dirid;
+    // output
+    sys_uint32 size;
+    sys_uint16 date;
+    sys_uint16 time;
+    sys_uint8  attrib;
+    sys_addr  name;
+};
+
+struct api_arg_ev3_closedir {
+    sys_int32 dirid;
+};
+
+enum {
+    SYS_SERIAL_DEFAULT = 0,
+    SYS_SERIAL_UART = 1,
+    SYS_SERIAL_BT = 2
+};
+
+struct api_arg_ev3_serial_open {
+    sys_int32 port;
+};
+
+struct api_arg_exit {
+	sys_int32 status;
+};
+
+// for v850 optimize
+struct api_arg_v850_set_intpri {
+    sys_addr imr_table;
+    sys_addr disint_table;
+};
+
+// for performance measuring
+struct api_arg_reset_time {
+
+};
+struct api_arg_show_time {
+
+
+};
+
+
+typedef enum {
+    SYS_API_ID_NONE = 0,
+    SYS_API_ID_SOCKET,
+    SYS_API_ID_SENSE,
+    SYS_API_ID_BIND,
+    SYS_API_ID_LISTEN,
+    SYS_API_ID_ACCEPT,
+    SYS_API_ID_CONNECT,
+    SYS_API_ID_SELECT,
+    SYS_API_ID_SEND,
+    SYS_API_ID_RECV,
+    SYS_API_ID_SHUTDOWN,
+    SYS_API_ID_SYSTEM,
+    SYS_API_ID_MALLOC,
+    SYS_API_ID_CALLOC,
+    SYS_API_ID_REALLOC,
+    SYS_API_ID_FREE,
+    // Add for ETRbocon
+    SYS_API_ID_OPEN_R,
+    SYS_API_ID_READ_R,
+    SYS_API_ID_WRITE_R,
+    SYS_API_ID_CLOSE_R,
+    SYS_API_ID_LSEEK_R,
+    SYS_API_ID_SET_VIRTFS_TOP,
+    SYS_API_ID_EV3_OPENDIR,
+    SYS_API_ID_EV3_READDIR,
+    SYS_API_ID_EV3_CLOSEDIR,
+    SYS_API_ID_EV3_SERIAL_OPEN,
+	SYS_API_ID_EXIT,
+    SYS_API_ID_V850_SET_INTPRI,
+    SYS_API_ID_RESET_TIME,
+    SYS_API_ID_SHOW_TIME,
+    SYS_API_ID_NUM,
+} AthrillSyscallApiIdType;
+
+#define SYS_API_ERR_OK       0
+#define SYS_API_ERR_PERM     -1
+#define SYS_API_ERR_NOENT    -2
+#define SYS_API_ERR_IO       -5
+#define SYS_API_ERR_AGAIN   -11
+#define SYS_API_ERR_NOMEM   -12
+#define SYS_API_ERR_ACCESS  -13
+#define SYS_API_ERR_FAULT   -14
+#define SYS_API_ERR_EXSIT   -17
+#define SYS_API_ERR_INVAL   -22
+#define SYS_API_ERR_BADFD   -77
+#define SYS_API_ERR_CONNREFUSED   -111
+#define SYS_API_ERR_INPROGRESS    -115
+
+typedef struct {
+    sys_uint32 api_id;
+    sys_int32 ret_value;
+    sys_int32 ret_errno;
+    union {
+        struct api_arg_socket api_socket;
+        struct api_arg_sense api_sense;
+        struct api_arg_bind api_bind;
+        struct api_arg_listen api_listen;
+        struct api_arg_accept api_accept;
+        struct api_arg_connect api_connect;
+        struct api_arg_select api_select;
+        struct api_arg_send api_send;
+        struct api_arg_recv api_recv;
+        struct api_arg_shutdown api_shutdown;
+        struct api_arg_system api_system;
+        struct api_arg_malloc api_malloc;
+        struct api_arg_calloc api_calloc;
+        struct api_arg_realloc api_realloc;
+        struct api_arg_free api_free;
+        struct api_arg_open_r api_open_r;
+        struct api_arg_read_r api_read_r;
+        struct api_arg_write_r api_write_r;
+        struct api_arg_close_r api_close_r;
+        struct api_arg_lseek_r api_lseek_r;
+        struct api_arg_set_virtfs_top api_set_virtfs_top;
+        struct api_arg_ev3_opendir api_ev3_opendir;
+        struct api_arg_ev3_readdir api_ev3_readdir;
+        struct api_arg_ev3_closedir api_ev3_closedir;
+        struct api_arg_ev3_serial_open api_ev3_serial_open;
+        struct api_arg_exit api_exit;
+        struct api_arg_v850_set_intpri api_v850_set_intpri;
+    } body;
+} AthrillSyscallArgType;
+
+#include <fcntl.h>
+
+#define ATHRILL_OPEN_FLAGS_O_APPEND		0x0001
+#define ATHRILL_OPEN_FLAGS_O_CREAT		0x0002
+#define ATHRILL_OPEN_FLAGS_O_EXCL		0x0004
+#define ATHRILL_OPEN_FLAGS_O_NOCTTY		0x0008
+#define ATHRILL_OPEN_FLAGS_O_NONBLOCK	0x0010
+#define ATHRILL_OPEN_FLAGS_O_SYNC		0x0020
+#define ATHRILL_OPEN_FLAGS_O_TRUNC		0x0040
+#define ATHRILL_OPEN_FLAGS_O_RDONLY		0x0080
+#define ATHRILL_OPEN_FLAGS_O_WRONLY		0x0100
+#define ATHRILL_OPEN_FLAGS_O_RDWR		0x0200
+
+#define ATHRILL_OPEN_R_FLAG_TARGET2INF(flag, org_flags, target_flag)   \
+do {    \
+		if ((org_flags) & (target_flag)) {	\
+			(flag) |= ATHRILL_OPEN_FLAGS_##target_flag;   \
+		}	\
+} while (0)
+
+#define ATHRILL_OPEN_R_FLAG_INF2TARGET(flag, inf_flags, target_flag)   \
+do {    \
+		if ((inf_flags) & ATHRILL_OPEN_FLAGS_##target_flag) {	\
+			(flag) |= (target_flag);   \
+		}	\
+} while (0)
+
+static inline int athrill_newlib_open_r_flag(int org_flags)
+{
+	int flags = 0x0;
+	ATHRILL_OPEN_R_FLAG_TARGET2INF(flags, org_flags, O_APPEND);
+	ATHRILL_OPEN_R_FLAG_TARGET2INF(flags, org_flags, O_CREAT);
+	ATHRILL_OPEN_R_FLAG_TARGET2INF(flags, org_flags, O_EXCL);
+	ATHRILL_OPEN_R_FLAG_TARGET2INF(flags, org_flags, O_NOCTTY);
+	ATHRILL_OPEN_R_FLAG_TARGET2INF(flags, org_flags, O_NONBLOCK);
+	ATHRILL_OPEN_R_FLAG_TARGET2INF(flags, org_flags, O_SYNC);
+	ATHRILL_OPEN_R_FLAG_TARGET2INF(flags, org_flags, O_TRUNC);
+	ATHRILL_OPEN_R_FLAG_TARGET2INF(flags, org_flags, O_RDONLY);
+	ATHRILL_OPEN_R_FLAG_TARGET2INF(flags, org_flags, O_WRONLY);
+	ATHRILL_OPEN_R_FLAG_TARGET2INF(flags, org_flags, O_RDWR);
+	return flags;
+}
+
+static inline int athrill_syscall_open_r_flag(int inf_flags)
+{
+	int flags = 0x0;
+	ATHRILL_OPEN_R_FLAG_INF2TARGET(flags, inf_flags, O_APPEND);
+	ATHRILL_OPEN_R_FLAG_INF2TARGET(flags, inf_flags, O_CREAT);
+	ATHRILL_OPEN_R_FLAG_INF2TARGET(flags, inf_flags, O_EXCL);
+	ATHRILL_OPEN_R_FLAG_INF2TARGET(flags, inf_flags, O_NOCTTY);
+	ATHRILL_OPEN_R_FLAG_INF2TARGET(flags, inf_flags, O_NONBLOCK);
+	ATHRILL_OPEN_R_FLAG_INF2TARGET(flags, inf_flags, O_SYNC);
+	ATHRILL_OPEN_R_FLAG_INF2TARGET(flags, inf_flags, O_TRUNC);
+	ATHRILL_OPEN_R_FLAG_INF2TARGET(flags, inf_flags, O_RDONLY);
+	ATHRILL_OPEN_R_FLAG_INF2TARGET(flags, inf_flags, O_WRONLY);
+	ATHRILL_OPEN_R_FLAG_INF2TARGET(flags, inf_flags, O_RDWR);
+	return flags;
+}
+
+#ifndef ATHRILL_SYSCALL_DEVICE
+
+#ifdef DISABLE_EV3RT_API
+#else
+#include "ev3api.h"
+#include "string.h"
+#include "driver_interface_filesys.h"
+#endif /* DISABLE_EV3RT_API */
+#include <errno.h>
+extern sys_addr athrill_device_func_call __attribute__ ((section(".athrill_device_section")));
+
+
+#if 0
+/* compiler optimization changes the order of putting the values in valiables.
+   it caused parameter is not set when athrill_device_func_call is set.
+   to avoid this, change sysacall from macro to function in another file */
+#define ATHRILL_SYSCALL(api_argp)   \
+do {    \
+    athrill_device_func_call = (sys_addr)(api_argp);    \
+} while (0) 
+
+#else
+
+extern void athrill_syscall(AthrillSyscallArgType *param);
+#define ATHRILL_SYSCALL(api_argp) athrill_syscall(api_argp);
+// to supress warning 
+#define volatile
+#endif
+
+#define ATHRILL_SYSCALL_SOCKET_DOMAIN_AF_INET   0
+#define ATHRILL_SYSCALL_SOCKET_TYPE_STREAM   0
+#define ATHRILL_SYSCALL_SOCKET_PROTOCOL_ZERO   0
+static inline sys_int32 athrill_posix_socket(sys_int32 domain, sys_int32 type, sys_int32 protocol)
+{
+    volatile AthrillSyscallArgType args;
+
+    args.api_id = SYS_API_ID_SOCKET;
+    args.ret_value = SYS_API_ERR_INVAL;
+    args.body.api_socket.domain = domain;
+    args.body.api_socket.type = type;
+    args.body.api_socket.protocol = protocol;
+
+    ATHRILL_SYSCALL(&args);
+    
+    return args.ret_value;
+}
+
+static inline sys_int32 athrill_posix_sense(sys_int32 sockfd, AthrillSyscallApiIdType api_id)
+{
+    volatile AthrillSyscallArgType args;
+
+    args.api_id = SYS_API_ID_SENSE;
+    args.ret_value = SYS_API_ERR_INVAL;
+    args.body.api_sense.sockfd = sockfd;
+    args.body.api_sense.api_id = api_id;
+
+    ATHRILL_SYSCALL(&args);
+
+    return args.ret_value;
+}
+
+#define ATHRILL_SYSCALL_SOCKADDR_FAMILIY_PF_INET 0
+#define ATHRILL_SYSCALL_IPADDR(arg3, arg2, arg1, arg0)  \
+    ( \
+        ((arg3) << 24) | \
+        ((arg2) << 16) | \
+        ((arg1) << 8) | \
+        ((arg0) << 0) \
+    )
+
+static inline sys_int32 athrill_posix_bind(sys_int32 sockfd, const struct sys_sockaddr_in *addr, sys_uint32 addrlen)
+{
+    volatile AthrillSyscallArgType args;
+
+    args.api_id = SYS_API_ID_BIND;
+    args.ret_value = SYS_API_ERR_INVAL;
+    args.body.api_bind.sockfd = sockfd;
+    args.body.api_bind.sockaddr = (sys_addr)addr;
+    args.body.api_bind.addrlen = addrlen;
+
+    ATHRILL_SYSCALL(&args);
+
+    return args.ret_value;
+}
+
+static inline sys_int32 athrill_posix_listen(sys_int32 sockfd, sys_int32 backlog)
+{
+    volatile AthrillSyscallArgType args;
+
+    args.api_id = SYS_API_ID_LISTEN;
+    args.ret_value = SYS_API_ERR_INVAL;
+    args.body.api_listen.sockfd = sockfd;
+    args.body.api_listen.backlog = backlog;
+
+    ATHRILL_SYSCALL(&args);
+
+    return args.ret_value;
+}
+
+static inline sys_int32 athrill_posix_accept(sys_int32 sockfd, struct sys_sockaddr_in *addr, sys_uint32 *addrlen)
+{
+    volatile AthrillSyscallArgType args;
+
+    args.api_id = SYS_API_ID_ACCEPT;
+    args.ret_value = SYS_API_ERR_INVAL;
+    args.body.api_accept.sockfd = sockfd;
+    args.body.api_accept.sockaddr = (sys_addr)addr;
+    args.body.api_accept.addrlen = (sys_addr)addrlen;
+
+    ATHRILL_SYSCALL(&args);
+
+    return args.ret_value;
+}
+
+static inline sys_int32 athrill_posix_connect(sys_int32 sockfd, const struct sys_sockaddr_in *addr, sys_uint32 addrlen)
+{
+    volatile AthrillSyscallArgType args;
+
+    args.api_id = SYS_API_ID_CONNECT;
+    args.ret_value = SYS_API_ERR_INVAL;
+    args.body.api_connect.sockfd = sockfd;
+    args.body.api_connect.sockaddr = (sys_addr)addr;
+    args.body.api_connect.addrlen = addrlen;
+
+    ATHRILL_SYSCALL(&args);
+
+    return args.ret_value;
+}
+
+static inline sys_int32 athrill_posix_select(sys_int32 nfds, sys_fd_set *readfds, sys_fd_set *writefds, sys_fd_set *exceptfds)
+{
+    volatile AthrillSyscallArgType args;
+
+    args.api_id = SYS_API_ID_SELECT;
+    args.ret_value = SYS_API_ERR_INVAL;
+    args.body.api_select.nfds = nfds;
+    args.body.api_select.readfds = (sys_addr)readfds;
+    args.body.api_select.writefds = (sys_addr)writefds;
+    args.body.api_select.exceptfds = (sys_addr)exceptfds;
+
+    ATHRILL_SYSCALL(&args);
+
+    return args.ret_value;
+}
+
+#define ATHRILL_POSIX_MSG_DONTWAIT 0
+static inline sys_uint32 athrill_posix_send(sys_int32 sockfd, const sys_addr buf, sys_uint32 len, sys_int32 flags)
+{
+    volatile AthrillSyscallArgType args;
+
+    args.api_id = SYS_API_ID_SEND;
+    args.ret_value = SYS_API_ERR_INVAL;
+    args.body.api_send.sockfd = sockfd;
+    args.body.api_send.buf = buf;
+    args.body.api_send.len = len;
+    args.body.api_send.flags = flags;
+
+    ATHRILL_SYSCALL(&args);
+
+    return args.ret_value;
+}
+static inline sys_uint32 athrill_posix_recv(sys_int32 sockfd, sys_addr buf, sys_uint32 len, sys_int32 flags)
+{
+    volatile AthrillSyscallArgType args;
+
+    args.api_id = SYS_API_ID_RECV;
+    args.ret_value = SYS_API_ERR_INVAL;
+    args.body.api_recv.sockfd = sockfd;
+    args.body.api_recv.buf = buf;
+    args.body.api_recv.len = len;
+    args.body.api_recv.flags = flags;
+
+    ATHRILL_SYSCALL(&args);
+
+    return args.ret_value;
+}
+
+#define ATHRILL_POSIX_SHUT_RDWR 0
+static inline sys_int32 athrill_posix_shutdown(sys_int32 sockfd, sys_int32 how)
+{
+    volatile AthrillSyscallArgType args;
+
+    args.api_id = SYS_API_ID_SHUTDOWN;
+    args.ret_value = SYS_API_ERR_INVAL;
+    args.body.api_shutdown.sockfd = sockfd;
+    args.body.api_shutdown.how = how;
+
+    ATHRILL_SYSCALL(&args);
+
+    return args.ret_value;
+}
+
+static inline sys_int32 athrill_posix_system(sys_uint32 id)
+{
+    volatile AthrillSyscallArgType args;
+    args.api_id = SYS_API_ID_SYSTEM;
+    args.ret_value = SYS_API_ERR_INVAL;
+    args.body.api_system.id = id;
+
+    ATHRILL_SYSCALL(&args);
+
+    return args.ret_value;
+}
+
+static inline sys_addr athrill_posix_malloc(sys_uint32 size)
+{
+    volatile AthrillSyscallArgType args;
+    args.api_id = SYS_API_ID_MALLOC;
+    args.ret_value = SYS_API_ERR_INVAL;
+    args.body.api_malloc.size = size;
+
+    ATHRILL_SYSCALL(&args);
+
+    return args.body.api_malloc.rptr;
+}
+static inline sys_addr athrill_posix_calloc(sys_uint32 nmemb, sys_uint32 size)
+{
+    volatile AthrillSyscallArgType args;
+    args.api_id = SYS_API_ID_CALLOC;
+    args.ret_value = SYS_API_ERR_INVAL;
+    args.body.api_calloc.nmemb = nmemb;
+    args.body.api_calloc.size = size;
+
+    ATHRILL_SYSCALL(&args);
+
+    return args.body.api_calloc.rptr;
+}
+static inline sys_addr athrill_posix_realloc(sys_addr ptr, sys_uint32 size)
+{
+    volatile AthrillSyscallArgType args;
+    args.api_id = SYS_API_ID_REALLOC;
+    args.ret_value = SYS_API_ERR_INVAL;
+    args.body.api_realloc.ptr = ptr;
+    args.body.api_realloc.size = size;
+
+    ATHRILL_SYSCALL(&args);
+
+    return args.body.api_realloc.rptr;
+}
+static inline void athrill_posix_free(sys_addr ptr)
+{
+    volatile AthrillSyscallArgType args;
+    args.api_id = SYS_API_ID_FREE;
+    args.ret_value = SYS_API_ERR_INVAL;
+    args.body.api_free.ptr = ptr;
+
+    ATHRILL_SYSCALL(&args);
+
+    return;
+}
+
+static inline int athrill_newlib_open_r(const char *file, int flags, int mode)
+{
+    volatile AthrillSyscallArgType args;
+    args.api_id = SYS_API_ID_OPEN_R;
+    args.ret_value = -1;
+    args.body.api_open_r.file_name = (sys_addr)file;
+    args.body.api_open_r.flags = athrill_newlib_open_r_flag(flags);
+    args.body.api_open_r.mode = mode;
+
+    ATHRILL_SYSCALL(&args);
+
+    return args.ret_value;
+
+}
+
+static inline int athrill_newlib_read_r(int fd, char *buf, sys_uint32 cnt)
+{
+    volatile AthrillSyscallArgType args;
+    args.api_id = SYS_API_ID_READ_R;
+    args.ret_value = -1;
+    args.body.api_read_r.fd = fd;
+    args.body.api_read_r.buf = (sys_addr)buf;
+    args.body.api_read_r.size = (sys_uint32)cnt;
+
+    ATHRILL_SYSCALL(&args);
+    errno = args.ret_errno;
+    return args.ret_value;
+
+}
+
+static inline int athrill_newlib_write_r(int fd, const char *buf, sys_uint32 cnt)
+{
+    volatile AthrillSyscallArgType args;
+    args.api_id = SYS_API_ID_WRITE_R;
+    args.ret_value = -1;
+    args.body.api_write_r.fd = fd;
+    args.body.api_write_r.buf = (sys_addr)buf;
+    args.body.api_write_r.size = (sys_uint32)cnt;
+
+    ATHRILL_SYSCALL(&args);
+
+    return args.ret_value;
+
+}
+
+static inline int athrill_newlib_close_r(int fd)
+{
+    volatile AthrillSyscallArgType args;
+    args.api_id = SYS_API_ID_CLOSE_R;
+    args.ret_value = -1;
+    args.body.api_close_r.fd = fd;
+
+    ATHRILL_SYSCALL(&args);
+
+    return args.ret_value;
+
+}
+
+static inline int athrill_newlib_lseek_r(int fd, sys_int32 offset, int whence)
+{
+    volatile AthrillSyscallArgType args;
+    args.api_id = SYS_API_ID_LSEEK_R;
+    args.ret_value = -1;
+    args.body.api_lseek_r.fd = fd;
+    args.body.api_lseek_r.offset = offset;
+    args.body.api_lseek_r.whence = whence;
+
+    ATHRILL_SYSCALL(&args);
+
+    return args.ret_value;
+
+}
+
+
+static inline sys_int32 athrill_set_virtfs_top(sys_addr top_dir)
+{
+    volatile AthrillSyscallArgType args;
+    
+    args.api_id = SYS_API_ID_SET_VIRTFS_TOP;
+    args.ret_value = 0;
+    args.body.api_set_virtfs_top.top_dir = top_dir;
+
+    ATHRILL_SYSCALL(&args);
+
+    return args.ret_value;
+}
+
+
+static inline sys_int32 athrill_ev3_opendir(sys_addr path)
+{
+    volatile AthrillSyscallArgType args;
+
+    // allocate 64bit memory for store DIR * pointer
+    args.api_id = SYS_API_ID_EV3_OPENDIR;
+    args.ret_value = 0;
+    args.body.api_ev3_opendir.path = path;
+
+    ATHRILL_SYSCALL(&args);
+
+    return args.body.api_ev3_opendir.dirid;
+
+}
+
+#ifdef DISABLE_EV3RT_API
+#else
+static inline sys_int32 athrill_ev3_readdir(sys_int32 dirid, fatfs_filinfo_t *fileinfo)
+{
+    volatile AthrillSyscallArgType args;
+
+    // allocate 64bit memory for store DIR * pointer
+    args.api_id = SYS_API_ID_EV3_READDIR;
+    args.ret_value = 0;
+    args.body.api_ev3_readdir.dirid = dirid;
+    args.body.api_ev3_readdir.name = (sys_addr)fileinfo->fname;
+
+    ATHRILL_SYSCALL(&args);
+
+    if ( args.ret_value != E_OK ) return args.ret_value;
+
+    fileinfo->fsize = args.body.api_ev3_readdir.size;
+    fileinfo->fdate = args.body.api_ev3_readdir.date;
+    fileinfo->ftime = args.body.api_ev3_readdir.time;
+    fileinfo->fattrib = args.body.api_ev3_readdir.attrib;
+
+    return E_OK;
+
+}
+#endif
+
+static inline sys_int32 athrill_ev3_closedir(sys_int32 dirid)
+{
+    volatile AthrillSyscallArgType args;
+
+    // allocate 64bit memory for store DIR * pointer
+    args.api_id = SYS_API_ID_EV3_CLOSEDIR;
+    args.ret_value = 0;
+    args.body.api_ev3_closedir.dirid = dirid;
+
+    ATHRILL_SYSCALL(&args);
+
+    return args.ret_value;
+
+}
+
+static inline sys_int32 athrill_ev3_serial_open(sys_int32 port)
+{
+    volatile AthrillSyscallArgType args;
+
+    args.api_id = SYS_API_ID_EV3_SERIAL_OPEN;
+    args.ret_value = 0;
+    args.body.api_ev3_serial_open.port = (sys_addr)port;
+
+    ATHRILL_SYSCALL(&args);
+
+    return args.ret_value;
+
+}
+static inline sys_int32 athrill_posix_exit(sys_int32 status)
+{
+    volatile AthrillSyscallArgType args;
+    args.api_id = SYS_API_ID_EXIT;
+    args.ret_value = SYS_API_ERR_INVAL;
+    args.body.api_exit.status = status;
+
+    ATHRILL_SYSCALL(&args);
+
+    return args.ret_value;
+}
+
+static inline void athrill_v850_set_intpri(sys_addr imr_table,sys_addr disint_table)
+{
+    volatile AthrillSyscallArgType args;
+    args.api_id = SYS_API_ID_V850_SET_INTPRI;
+    args.body.api_v850_set_intpri.imr_table = imr_table;
+    args.body.api_v850_set_intpri.disint_table = disint_table;
+
+    ATHRILL_SYSCALL(&args);
+
+}
+
+static inline void athrill_reset_time()
+{
+    volatile AthrillSyscallArgType args;
+    args.api_id = SYS_API_ID_RESET_TIME;
+    ATHRILL_SYSCALL(&args);
+}
+
+static inline void athrill_show_time()
+{
+    volatile AthrillSyscallArgType args;
+    args.api_id = SYS_API_ID_SHOW_TIME;
+    ATHRILL_SYSCALL(&args);
+}
+
+
+#endif /* ATHRILL_SYSCALL_DEVICE */
+
+#endif /* _ATHRILL_SYSCALL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/apl/src/athrill-syscall.c
@@ -0,0 +1,6 @@
+#include "athrill_syscall.h"
+
+void athrill_syscall(AthrillSyscallArgType *param)
+{
+	athrill_device_func_call = (sys_addr)(param);
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/bin/linux/athrill-run
@@ -0,0 +1,37 @@
+#!/bin/bash
+
+CORE_NUM=1
+if [ $# -eq 1 ]
+then
+	CORE_NUM=2
+fi
+
+if [ -f device_config.txt ]
+then
+    echo "OK: found device_config.txt"
+else
+    echo "ERROR: not found device_config.txt"
+    exit 1
+fi
+
+if [ -f memory.txt ]
+then
+    echo "OK: found memory.txt"
+else
+    echo "ERROR: not found memory.txt"
+    exit 1
+fi
+
+ls  | grep -v "\.o" | grep -v "\.exe" | xargs file | grep ELF > /dev/null
+if [ $? -ne 0 ]
+then
+    echo "ERROR: not found elf file for execution"
+    exit 1
+fi
+
+ELF_FILE=`ls  | grep -v "\.o" | grep -v "\.exe" | xargs file | grep ELF | awk -F\: '{print $1}'`
+echo "OK: found ${ELF_FILE}"
+
+athrill2 -c${CORE_NUM} -i -m memory.txt -d device_config.txt ${ELF_FILE}
+
+exit 0
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/bin/linux/athrill-run-remote
@@ -0,0 +1,37 @@
+#!/bin/bash
+
+CORE_NUM=1
+if [ $# -eq 1 ]
+then
+	CORE_NUM=2
+fi
+
+if [ -f device_config.txt ]
+then
+    echo "OK: found device_config.txt"
+else
+    echo "ERROR: not found device_config.txt"
+    exit 1
+fi
+
+if [ -f memory.txt ]
+then
+    echo "OK: found memory.txt"
+else
+    echo "ERROR: not found memory.txt"
+    exit 1
+fi
+
+ls  | grep -v "\.o" | grep -v "\.exe" | xargs file | grep ELF > /dev/null
+if [ $? -ne 0 ]
+then
+    echo "ERROR: not found elf file for execution"
+    exit 1
+fi
+
+ELF_FILE=`ls  | grep -v "\.o" | grep -v "\.exe" | xargs file | grep ELF | awk -F\: '{print $1}'`
+echo "OK: found ${ELF_FILE}"
+
+athrill2 -c${CORE_NUM} -r -i -m memory.txt -d device_config.txt ${ELF_FILE}
+
+exit 0
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/bin/linux/athrill_extfunc.sh
@@ -0,0 +1,3 @@
+#!/bin/sh
+
+echo $*
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/bin/linux/athrill_terminal
@@ -0,0 +1,19 @@
+#!/bin/bash
+
+if [ $# -ne 1 ]
+then
+	echo "Usage: $0 <serial-channel>"
+	exit 1
+fi
+CHANNEL=${1}
+
+athrill_remote c > /dev/null
+while [ 1 ]
+do
+	#echo -n "$ "
+	read -rN1 str 
+	athrill_remote q > /dev/null
+	athrill_remote S ${CHANNEL}  $str > /dev/null
+	athrill_remote c > /dev/null
+done
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/bin/linux/geany.sh
@@ -0,0 +1,22 @@
+#!/bin/sh
+
+SAKURA_FILE="./arg_sakura.txt"
+
+which code > /dev/null
+if [ $? -eq 0 ]
+then
+    FILE=$(cat ./arg_sakura.txt | awk '{print $3}')
+    LINE=$(cat ./arg_sakura.txt | awk '{print $2}')
+    code -r  -g ${FILE}:${LINE}
+else
+    which geany > /dev/null
+    if [ $? -eq 0 ]
+    then
+        geany -r `cat ${SAKURA_FILE}` &
+    else
+        echo "ERROR not found editor: please install vscode or geany!"
+        exit 1
+    fi
+fi
+
+exit 0
\ No newline at end of file
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/bin/linux/variable_conflict_check.groovy
@@ -0,0 +1,101 @@
+@Grab('com.xlson.groovycsv:groovycsv:0.2')
+
+import com.xlson.groovycsv.CsvParser
+
+if (args.length != 2) {
+    println "Usage: variable_conflict_check.groovy <file> <interval>"
+    return 1;
+}
+
+csv_file = args[0];
+int interval = Integer.parseInt(args[1]);
+
+class DataAccessInfo {
+	public String variable;
+	public String clock;
+	public String type;
+	public String core;
+	public String stack;
+	public String func;
+
+	public DataAccessInfo(String var, String clock, String type, String core, String stack, String func) {
+		this.variable = var.trim();
+		this.clock = clock.trim();
+		this.type = type.trim();
+		this.core = core.trim();
+		this.stack = stack.trim();
+		this.func = func.trim();
+	}
+	
+}
+
+Map<String, List<DataAccessInfo>> map = new HashMap<>();
+
+def csv = new File(csv_file).text
+def data = new CsvParser().parse(csv, separator: ',', quoteChar: '"')
+data.each {
+	def info = new DataAccessInfo(it.variable, 
+					it.access_clock, 
+					it.type,
+					it.core,
+					it.stack,
+					it.access_func);
+	def var = map.get(it.variable);
+	if (var == null) {
+		var = new ArrayList<>();
+		map.put(it.variable, var);
+	}
+	var.add(info);
+}
+
+for (String key : map.keySet()) {
+	def var = map.get(key);
+	def readList = var.stream()
+		.filter {
+			it.type.equals("READ")
+		}.collect();
+	def writeList = var.stream()
+		.filter {
+			it.type.equals("WRITE")
+		}.collect();
+
+	for (def writeInfo : writeList) {
+		if (readList.isEmpty()) {
+			continue;
+		}
+		if (readList.stream()
+			.every{ writeInfo.stack.equals(it.stack) }) {
+			continue;
+		}
+		
+		DataAccessInfo readInfo = null;
+		int wclock = Integer.parseInt(writeInfo.clock);
+		int min = Integer.MAX_VALUE;
+		readList.stream()
+			.filter{ !writeInfo.stack.equals(it.stack) }
+			.each {
+				int tmp_clock = Integer.parseInt(it.clock);
+				if (min > Math.abs(tmp_clock - wclock)) {
+					min = Math.abs(tmp_clock - wclock);
+					readInfo = it;
+				}
+			}
+		
+		if ((interval > 0) && Math.abs(Integer.parseInt(writeInfo.clock) - Integer.parseInt(readInfo.clock)) > interval) {
+			continue;
+		}
+
+		println String.format("%d W:%s %s (%s) : %s(%s)", 
+					Integer.parseInt(writeInfo.clock) - Integer.parseInt(readInfo.clock),
+					key,
+					writeInfo.clock, 
+					writeInfo.core,
+					writeInfo.stack,
+					writeInfo.func);
+		println String.format("  + R:%s (%s) : %s(%s)>", 
+				readInfo.clock,
+				readInfo.core,
+				readInfo.stack, 
+				readInfo.func);
+	}
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/bin/linux/variable_conflict_check.sh
@@ -0,0 +1,4 @@
+#!/bin/sh
+
+GROOVY_PATH=$(dirname $(which $0))
+groovy ${GROOVY_PATH}/variable_conflict_check.groovy $*
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/bin/windows/athrill_scenario_cmd.sh
@@ -0,0 +1,44 @@
+#!/bin/sh
+
+function athrill_cont() {
+    athrill_remote c ${1}
+}
+
+CPU_ELAPS=""
+function athrill_elaps() {
+    RET=`athrill_remote e`
+    CPU_ELAPS=`echo ${RET} | awk '{print $1}'`
+}
+
+MEMORY_VALUE=""
+function athrill_print_memory() {
+    ADDR=${1}
+    SIZE=${2}
+
+    if [ ${SIZE} -gt 4 ]
+    then
+        echo "ERROR: can not print memory data size over 4bytes"
+    else 
+        RET=`athrill_remote p ${ADDR} ${SIZE}`
+        MEMORY_VALUE=`echo ${RET} | awk '{print $1}'`
+    fi
+}
+
+VARIABLE_VALUE=""
+function athrill_print_variable() {
+    RET=`athrill_remote p ${1}`
+    ADDR=`echo ${RET} | awk '{print $1}'`
+    SIZE=`echo ${RET} | awk '{print $2}'`
+    athrill_print_memory ${ADDR} ${SIZE}
+    VARIABLE_VALUE=${MEMORY_VALUE}
+}
+
+
+#SAMPLE USAGE
+#athrill_cont 10
+#athrill_elaps
+#echo ${CPU_ELAPS}
+#athrill_print_variable gl_variable1
+#echo ${VARIABLE_VALUE}
+#athrill_print_memory 0x6ff7408 2
+#echo ${VARIABLE_VALUE}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/bin/windows/sakura.sh
@@ -0,0 +1,5 @@
+#!/bin/sh
+
+SAKURA_FILE="./arg_sakura.txt"
+
+sakura -R `cat ${SAKURA_FILE}` &
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/build/core/linux/Makefile.bus
@@ -0,0 +1,23 @@
+include Makefile.env
+
+LIBTARGET	:= libbus.a
+
+
+IFLAGS		:= -I$(CORE_DIR)/inc
+IFLAGS		+= -I$(CORE_DIR)/device/mpu
+
+VPATH		:= $(CORE_DIR)/bus
+
+CFLAGS		:= $(WFLAGS)
+CFLAGS		+= $(IFLAGS)
+
+OBJS		:= bus.o
+
+all:	$(LIBTARGET)
+
+$(LIBTARGET):	$(OBJS)
+	$(AR) $(AFLAGS) $(LIBTARGET) $(OBJS)
+
+clean:
+	$(RM) -f $(OBJS) $(LIBTARGET)
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/build/core/linux/Makefile.cpu
@@ -0,0 +1,51 @@
+include Makefile.env
+
+LIBTARGET	:= libcpu.a
+
+IFLAGS	:= -I$(CORE_DIR)/inc
+IFLAGS	+= -I$(CORE_DIR)/cpu
+IFLAGS	+= -I$(CORE_DIR)/bus
+IFLAGS	+= -I$(CORE_DIR)/device/mpu
+IFLAGS	+= -I$(CORE_DIR)/lib
+IFLAGS	+= -I$(TARGET_DIR)/cpu
+IFLAGS	+= -I$(TARGET_DIR)/device
+IFLAGS	+= -I$(TARGET_DIR)/cpu/config
+
+VPATH	:=	$(TARGET_DIR)/cpu/cpu_common
+VPATH	+=	$(TARGET_DIR)/cpu/cpu_dec
+VPATH	+=	$(TARGET_DIR)/cpu/cpu_exec
+VPATH	+=	$(TARGET_DIR)/cpu/config
+VPATH	+=	$(CORE_DIR)/lib
+
+
+CFLAGS	:= $(WFLAGS)
+CFLAGS	+= $(IFLAGS)
+
+OBJS	:=	op_exec.o
+OBJS	+=	op_dec.o
+OBJS	+=	op_parse.o
+OBJS	+=	op_parse_private.o
+OBJS	+=	op_exec_bit.o
+OBJS	+=	op_exec_branch.o
+OBJS	+=	op_exec_dbg.o
+OBJS	+=	op_exec_div.o
+OBJS	+=	op_exec_logic.o
+OBJS	+=	op_exec_sat.o
+OBJS	+=	op_exec_arithm.o
+OBJS	+=	op_exec_store.o
+OBJS	+=	op_exec_load.o
+OBJS	+=	op_exec_spec.o
+OBJS	+=	cpu_config.o
+OBJS	+=	dbg_log.o
+
+
+all:	$(LIBTARGET)
+
+$(LIBTARGET):	$(OBJS)
+	$(AR) $(AFLAGS) $(LIBTARGET) $(OBJS)
+
+clean:
+	$(RM) -f $(OBJS) $(LIBTARGET)
+
+
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/build/core/linux/Makefile.cui
@@ -0,0 +1,47 @@
+include Makefile.env
+
+LIBTARGET	:= libcui.a
+
+IFLAGS	:= -I$(CORE_DIR)/inc
+IFLAGS	+= -I$(CORE_DIR)/lib
+IFLAGS	+= -I$(CORE_DIR)/lib/dwarf
+IFLAGS	+= -I$(CORE_DIR)/debugger/interaction
+IFLAGS	+= -I$(CORE_DIR)/debugger/executor
+IFLAGS	+= -I$(CORE_DIR)/debugger/interaction/inc
+IFLAGS	+= -I$(CORE_DIR)/debugger/executor/concrete_executor/target
+IFLAGS	+= -I$(CORE_DIR)/cpu
+IFLAGS	+= -I$(TARGET_DIR)/cpu
+IFLAGS	+= -I$(TARGET_DIR)/cpu/config
+IFLAGS	+= -I$(TARGET_DIR)/debugger/interaction/inc
+
+VPATH	:= $(CORE_DIR)/debugger/interaction/front/parser
+VPATH	+= $(CORE_DIR)/debugger/interaction/front/parser/concrete_parser
+VPATH	+= $(CORE_DIR)/debugger/executor/concrete_executor
+VPATH	+= $(CORE_DIR)/debugger/executor/concrete_executor/util
+VPATH	+= $(CORE_DIR)/lib/cui
+VPATH	+= $(CORE_DIR)/lib/cui/stdio
+VPATH	+= $(CORE_DIR)/lib/cui/udp
+
+
+CFLAGS	:= $(WFLAGS)
+CFLAGS	+= $(IFLAGS)
+
+OBJS	:= dbg_parser_config.o
+OBJS	+= dbg_std_parser.o
+OBJS	+= dbg_parser.o
+OBJS	+= dbg_std_executor.o
+OBJS	+= dbg_print_data_type.o
+OBJS	+= cui_ops.o
+OBJS	+= cui_ops_stdio.o
+OBJS	+= cui_ops_udp.o
+
+all:	$(LIBTARGET)
+
+$(LIBTARGET):	$(OBJS)
+	$(AR) $(AFLAGS) $(LIBTARGET) $(OBJS)
+
+clean:
+	$(RM) -f $(OBJS) $(LIBTARGET)
+
+
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/build/core/linux/Makefile.device
@@ -0,0 +1,49 @@
+include Makefile.env
+
+LIBTARGET	:= libdevice.a
+
+IFLAGS	:= -I$(CORE_DIR)/inc
+IFLAGS	+= -I$(CORE_DIR)/cpu
+IFLAGS	+= -I$(CORE_DIR)/device/mpu
+IFLAGS	+= -I$(CORE_DIR)/debugger/executor
+IFLAGS	+= -I$(CORE_DIR)/lib
+IFLAGS	+= -I$(CORE_DIR)/device/peripheral/target
+IFLAGS	+= -I$(APLDIR)/include
+IFLAGS	+= -I$(TARGET_DIR)/cpu
+IFLAGS	+= -I$(TARGET_DIR)/device
+IFLAGS	+= -I$(TARGET_DIR)/device/intc
+IFLAGS	+= -I$(TARGET_DIR)/device/peripheral
+IFLAGS	+= -I$(TARGET_DIR)/device/peripheral/inc
+IFLAGS	+= -I$(TARGET_DIR)/cpu/config
+
+VPATH	:=	$(CORE_DIR)/device/peripheral
+VPATH	+=	$(TARGET_DIR)/device
+VPATH	+=	$(TARGET_DIR)/device/intc
+VPATH	+=	$(TARGET_DIR)/device/peripheral
+VPATH	+=	$(TARGET_DIR)/device/peripheral/timer
+VPATH	+=	$(TARGET_DIR)/device/peripheral/serial
+VPATH	+=	$(TARGET_DIR)/debugger/executor/concrete_executor
+
+
+CFLAGS	:= $(WFLAGS)
+CFLAGS	+= $(IFLAGS)
+
+OBJS	:=	device.o
+OBJS	+=	timer.o
+OBJS	+=	serial.o
+OBJS	+=	dbg_target_serial.o
+OBJS	+=	dbg_target_cpu.o
+OBJS	+=	intc.o
+OBJS	+=	athrill_device.o
+OBJS	+=	athrill_syscall_device.o
+
+all:	$(LIBTARGET)
+
+$(LIBTARGET):	$(OBJS)
+	$(AR) $(AFLAGS) $(LIBTARGET) $(OBJS)
+
+clean:
+	$(RM) -f $(OBJS) $(LIBTARGET)
+
+
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/build/core/linux/Makefile.loader
@@ -0,0 +1,48 @@
+include Makefile.env
+
+LIBTARGET	:= libloader.a
+
+IFLAGS	:= -I$(CORE_DIR)/inc
+IFLAGS	+= -I$(CORE_DIR)/lib
+IFLAGS	+= -I$(CORE_DIR)/lib/dwarf
+IFLAGS	+= -I$(CORE_DIR)/cpu
+IFLAGS	+= -I$(TARGET_DIR)/cpu
+IFLAGS	+= -I$(TARGET_DIR)/cpu/config
+
+VPATH	:=	$(CORE_DIR)/lib
+VPATH	+=	$(CORE_DIR)/lib/dwarf
+VPATH	+=	$(CORE_DIR)/lib/dwarf/data_type
+
+
+CFLAGS	:= $(WFLAGS)
+CFLAGS	+= $(IFLAGS)
+
+OBJS	:= elf_section.o
+OBJS	+= elf_dwarf_line.o
+OBJS	+= elf_dwarf_loc.o
+OBJS	+= elf_dwarf_info.o
+OBJS	+= elf_dwarf_abbrev.o
+OBJS	+= elf_dwarf_util.o
+OBJS	+= elf_dwarf_data_type.o
+OBJS	+= elf_dwarf_base_type.o
+OBJS	+= elf_dwarf_typedef_type.o
+OBJS	+= elf_dwarf_pointer_type.o
+OBJS	+= elf_dwarf_struct_type.o
+OBJS	+= elf_dwarf_enum_type.o
+OBJS	+= elf_dwarf_array_type.o
+OBJS	+= elf_dwarf_variable_type.o
+OBJS	+= elf_dwarf_subprogram_type.o
+OBJS	+= elf_dwarf_info_ops.o
+OBJS	+= file_address_mapping.o
+OBJS	+= symbol_ops.o
+
+all:	$(LIBTARGET)
+
+$(LIBTARGET):	$(OBJS)
+	$(AR) $(AFLAGS) $(LIBTARGET) $(OBJS)
+
+clean:
+	$(RM) -f $(OBJS) $(LIBTARGET)
+
+
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/build/core/linux/Makefile.main
@@ -0,0 +1,46 @@
+include Makefile.env
+
+LIBTARGET	:= libmain.a
+
+IFLAGS	:= -I$(CORE_DIR)/inc
+IFLAGS	+= -I$(CORE_DIR)/lib
+IFLAGS	+= -I$(CORE_DIR)/lib/dwarf
+IFLAGS	+= -I$(CORE_DIR)/bus
+IFLAGS	+= -I$(CORE_DIR)/device/mpu
+IFLAGS	+= -I$(CORE_DIR)/debugger/interaction
+IFLAGS	+= -I$(CORE_DIR)/debugger/executor
+IFLAGS	+= -I$(CORE_DIR)/debugger/interaction/inc
+IFLAGS	+= -I$(CORE_DIR)/debugger/interaction/inc/target/$(ARCH)
+IFLAGS	+= -I$(CORE_DIR)/cpu
+IFLAGS	+= -I$(CORE_DIR)/main
+IFLAGS	+= -I$(TARGET_DIR)/cpu
+IFLAGS	+= -I$(TARGET_DIR)/cpu/config
+
+
+VPATH	:= $(CORE_DIR)/debugger/executor/cpu_control
+VPATH	+= $(CORE_DIR)/main
+VPATH	+= $(CORE_DIR)/main/option
+
+
+CFLAGS	:= $(WFLAGS)
+CFLAGS	+= $(IFLAGS)
+
+
+OBJS		:= main.o
+OBJS		+= cpuemu.o
+OBJS		+= dbg_cpu_control.o
+OBJS		+= dbg_cpu_thread_control.o
+OBJS		+= dbg_cpu_callback.o
+OBJS		+= option.o
+
+
+all:	$(LIBTARGET)
+
+$(LIBTARGET):	$(OBJS)
+	$(AR) $(AFLAGS) $(LIBTARGET) $(OBJS)
+
+clean:
+	$(RM) -f $(OBJS) $(LIBTARGET)
+
+
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/build/core/linux/Makefile.mpu
@@ -0,0 +1,37 @@
+include Makefile.env
+
+LIBTARGET	:= libmpu.a
+
+IFLAGS	:= -I$(CORE_DIR)/inc
+IFLAGS	+= -I$(CORE_DIR)/device/mpu
+IFLAGS  += -I$(CORE_DIR)/device/peripheral/serial/fifo
+IFLAGS	+= -I$(CORE_DIR)/lib
+IFLAGS	+= -I$(CORE_DIR)/lib/dwarf
+IFLAGS	+= -I$(CORE_DIR)/lib/dwarf/data_type
+IFLAGS	+= -I$(CORE_DIR)/cpu
+IFLAGS	+= -I$(TARGET_DIR)/cpu
+IFLAGS	+= -I$(TARGET_DIR)/cpu/config
+
+VPATH	:=	$(CORE_DIR)/device/mpu
+VPATH	+=	$(CORE_DIR)/device/mpu/loader
+VPATH	+=	$(TARGET_DIR)/cpu/config
+
+
+CFLAGS	:= $(WFLAGS)
+CFLAGS	+= $(IFLAGS)
+
+OBJS	:=	mpu.o
+OBJS	+=	mpu_config.o
+OBJS	+=	mpu_malloc.o
+OBJS	+=	loader.o
+
+all:	$(LIBTARGET)
+
+$(LIBTARGET):	$(OBJS)
+	$(AR) $(AFLAGS) $(LIBTARGET) $(OBJS)
+
+clean:
+	$(RM) -f $(OBJS) $(LIBTARGET)
+
+
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/build/core/linux/Makefile.mros
@@ -0,0 +1,103 @@
+include Makefile.env
+
+ROOTDIR		:= $(CORE_DIR)
+SRC_ROOT	:= $(ROOTDIR)/device/peripheral/mros-dev/mros-src
+DEV_ROOT	:= $(ROOTDIR)/device/peripheral/mros-dev/mros-athrill
+
+ROS_VERSION	:= kinetic
+
+LIBTARGET	:= libmros.a
+
+IFLAGS	:= -I.
+IFLAGS	+= -I$(ROOTDIR)/inc
+IFLAGS	+= -I$(ROOTDIR)/lib
+IFLAGS	+= -I$(TARGET_DIR)/cpu
+IFLAGS	+= -I$(TARGET_DIR)/cpu/config
+IFLAGS	+= -I$(SRC_ROOT)/api
+IFLAGS	+= -I$(DEV_ROOT)/api
+IFLAGS	+= -I$(DEV_ROOT)/config
+IFLAGS	+= -I$(DEV_ROOT)/config/os/target/os_asp
+IFLAGS	+= -I$(DEV_ROOT)/target
+IFLAGS	+= -I$(DEV_ROOT)/target/os
+IFLAGS	+= -I$(DEV_ROOT)/device
+IFLAGS	+= -I$(SRC_ROOT)/inc
+IFLAGS	+= -I$(SRC_ROOT)/os/target/os_asp
+IFLAGS	+= -I$(SRC_ROOT)/protocol/cimpl
+IFLAGS	+= -I$(SRC_ROOT)/node/cimpl
+IFLAGS	+= -I$(SRC_ROOT)/topic/cimpl
+IFLAGS	+= -I$(SRC_ROOT)/comm/cimpl/target/lwip
+IFLAGS	+= -I$(SRC_ROOT)/comm/cimpl
+IFLAGS	+= -I$(SRC_ROOT)/packet/cimpl
+IFLAGS	+= -I$(SRC_ROOT)/packet/template/version/$(ROS_VERSION)
+IFLAGS	+= -I$(SRC_ROOT)/packet/cimpl/version/$(ROS_VERSION)
+IFLAGS	+= -I$(SRC_ROOT)/protocol/cimpl
+IFLAGS	+= -I$(SRC_ROOT)/transfer/cimpl
+
+VPATH	:= $(SRC_ROOT)/comm/cimpl/target/lwip
+VPATH	+= $(SRC_ROOT)/comm/cimpl/target/lwip
+VPATH	+= $(SRC_ROOT)/comm/cimpl
+VPATH	+= $(SRC_ROOT)/node/cimpl
+VPATH	+= $(SRC_ROOT)/lib
+VPATH	+= $(SRC_ROOT)/os
+VPATH	+= $(SRC_ROOT)/os/target/os_asp
+VPATH	+= $(SRC_ROOT)/packet/cimpl/version/$(ROS_VERSION)
+VPATH	+= $(SRC_ROOT)/protocol/cimpl
+VPATH	+= $(SRC_ROOT)/topic/cimpl
+VPATH	+= $(SRC_ROOT)/transfer/cimpl
+VPATH	+= $(DEV_ROOT)/api
+VPATH	+= $(DEV_ROOT)
+VPATH	+= $(DEV_ROOT)/target/lwip
+VPATH	+= $(DEV_ROOT)/target/os
+VPATH	+= $(DEV_ROOT)/device
+VPATH	+= $(DEV_ROOT)/config
+VPATH	+= $(DEV_ROOT)/config/os/target/os_asp
+
+CFLAGS	:= $(WFLAGS)
+CFLAGS	+= $(IFLAGS)
+CFLAGS += -DTARGET_ATHRILL 
+CFLAGS += -DLWIP_TRANSPORT_ETHERNET
+
+
+OBJS += ros_cimpl.o
+OBJS += mros_comm_cimpl.o
+OBJS += mros_comm_socket_cimpl.o
+OBJS += mros_comm_tcp_client_cimpl.o
+OBJS += mros_comm_tcp_client_factory_cimpl.o
+OBJS += mros_comm_tcp_server_cimpl.o
+OBJS += mros_memory.o
+OBJS += mros_wait_queue.o
+OBJS += mros_node_cimpl.o
+OBJS += mros_exclusive_area.o
+OBJS += mros_exclusive_ops_linux.o
+OBJS += mros_os.o
+OBJS += mros_packet_decoder_cimpl.o
+OBJS += mros_packet_encoder_cimpl.o
+OBJS += mros_protocol_client_rpc_cimpl.o
+OBJS += mros_protocol_master_cimpl.o
+OBJS += mros_protocol_operation_cimpl.o
+OBJS += mros_protocol_publish_cimpl.o
+OBJS += mros_protocol_server_proc_cimpl.o
+OBJS += mros_protocol_slave_cimpl.o
+OBJS += mros_protocol_subscribe_cimpl.o
+OBJS += mros_topic_data_publisher_cimpl.o
+OBJS += mros_topic_data_subscriber_cimpl.o
+OBJS += mros_topic_cimpl.o
+OBJS += mros_topic_connector_cimpl.o
+OBJS += mros_topic_connector_factory_cimpl.o
+OBJS += mros_name.o
+OBJS += mros_os_config.o
+OBJS += mros_sys_config.o
+OBJS += lwip_linux.o
+OBJS += os_asp.o
+OBJS += athrill_mros_device.o
+
+all:	$(LIBTARGET)
+
+$(LIBTARGET):	$(OBJS)
+	$(AR) $(AFLAGS) $(LIBTARGET) $(OBJS)
+
+clean:
+	$(RM) -f $(OBJS) $(LIBTARGET)
+
+
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/build/core/linux/Makefile.std
@@ -0,0 +1,38 @@
+include Makefile.env
+
+LIBTARGET	:= libstd.a
+
+IFLAGS	:= -I$(CORE_DIR)/inc
+IFLAGS	+= -I$(CORE_DIR)/lib
+
+VPATH	:=	$(CORE_DIR)/lib
+VPATH	+=	$(CORE_DIR)/lib/winsock_wrapper
+VPATH	+=	$(CORE_DIR)/lib/udp
+VPATH	+=	$(CORE_DIR)/lib/tcp
+
+
+CFLAGS	:= $(WFLAGS)
+CFLAGS	+= $(IFLAGS)
+
+OBJS	:=	hash.o
+OBJS	+=	token.o
+OBJS	+=	file.o
+OBJS	+=	winsock_wrapper.o
+OBJS	+=	udp_comm.o
+OBJS	+=	tcp_socket.o
+OBJS	+=	tcp_client.o
+OBJS	+=	tcp_connection.o
+OBJS	+=	tcp_server.o
+OBJS	+=	comm_buffer.o
+
+
+all:	$(LIBTARGET)
+
+$(LIBTARGET):	$(OBJS)
+	$(AR) $(AFLAGS) $(LIBTARGET) $(OBJS)
+
+clean:
+	$(RM) -f $(OBJS) $(LIBTARGET)
+
+
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/command/remote/remote_cui_client/Makefile
@@ -0,0 +1,42 @@
+ROOTDIR		:= ../../../src
+TARGETDIR	:= .
+BINDIR		:= ../../../bin/linux/
+TARGET		:= athrill_remote
+
+WFLAGS		:= -g -Wall
+GCC		:= gcc
+
+IFLAGS		:= -I$(ROOTDIR)/inc
+IFLAGS		+= -I$(ROOTDIR)/lib
+
+VPATH		:= $(TARGETDIR)
+VPATH		+= $(ROOTDIR)/lib/winsock_wrapper
+VPATH		+= $(ROOTDIR)/lib/udp
+
+
+
+CFLAGS		:= $(WFLAGS)
+CFLAGS		+= $(IFLAGS)
+CFLAGS		+= -DOS_LINUX
+
+LFLAGS		:= -Wl,--allow-multiple-definition
+
+LIBS		:= -lpthread
+
+OBJS		:= main.o
+OBJS		+= udp_comm.o
+
+
+.SUFFIXES:	.c .o
+
+all:	$(TARGET)
+
+$(TARGET):	$(OBJS)
+	$(GCC) -O3 $(LFLAGS) $(OBJS) -o $(TARGET)  $(LIBS)
+	cp $(TARGET) $(BINDIR)/$(TARGET)
+
+.c.o:	$<
+	$(GCC) -O3 -c $(CFLAGS) $<
+
+clean:
+	rm -f $(OBJS) $(TARGET) $(BINDIR)/$(TARGET)
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/command/remote/remote_cui_client/cpuemu_config.h
@@ -0,0 +1,13 @@
+#ifndef _CPUEMU_CONFIG_H_
+#define _CPUEMU_CONFIG_H_
+
+/*
+ * symbol table config
+ */
+#define CPUEMU_CONFIG_FUNC_SYMBOL_TABLE_NUM		10240
+#define CPUEMU_CONFIG_OBJECT_SYMBOL_TABLE_NUM	10240
+
+#define CPUEMU_CONFIG_CUI_EMULATOR_PORTNO		49152
+#define CPUEMU_CONFIG_CUI_CLIENT_PORTNO			49153
+
+#endif /* _CPUEMU_CONFIG_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/command/remote/remote_cui_client/main.c
@@ -0,0 +1,134 @@
+#include "udp/udp_comm.h"
+#include "target/target_os_api.h"
+#include <getopt.h>
+#include <string.h>
+#include <stdio.h>
+#include "cpuemu_config.h"
+
+typedef struct {
+	uint16	athrill_listen_port;
+	uint16	remote_client_listen_port;
+	bool    is_verbose;
+	bool    is_help;
+	bool    is_parse_error;
+} CmdOptionType;
+
+CmdOptionType parse_option(int argc, const char* argv[]);
+
+static int cmd_buffer_len = 0;
+static char cmd_buffer[4096];
+
+int main(int argc, const char* argv[])
+{
+	int i;
+	UdpCommConfigType config;
+	UdpCommType comm;
+	int len;
+
+	CmdOptionType opt = parse_option(argc, argv);
+
+	if (argc - optind < 1 || opt.is_help || opt.is_parse_error) {
+		printf("Usage: athrill_remote [OPTION]... COMMAND\n");
+		printf("       -a, --athrill-listen-port<port no>       : set Athrill listen port.\n");
+		printf("       -r, --remote-client-listen-port<port no> : set athrill_remote listen port.\n");
+		printf("       -v, --verbose                            : print verbose message.\n");
+		printf("       -h, --help                               : print this message.\n");
+		return 1;
+	}
+
+	if (opt.is_verbose) {
+		printf("athrill_listen_port: %d\n", opt.athrill_listen_port);
+		printf("remote_client_listen_port: %d\n", opt.remote_client_listen_port);
+	}
+
+	for (i = optind; i < argc; i++) {
+		len = strlen(argv[i]);
+		if ((cmd_buffer_len + (len + 2)) > UDP_BUFFER_LEN) {
+			printf("argument length is too large.len=%d\n", len);
+			return 1;
+		}
+		memcpy(&cmd_buffer[cmd_buffer_len], argv[i], len);
+		cmd_buffer_len += (len + 1);
+		cmd_buffer[cmd_buffer_len] = ' ';
+	}
+
+	config.server_port = opt.remote_client_listen_port;
+	config.client_port = opt.athrill_listen_port;
+	config.is_wait = TRUE;
+
+	comm.write_data.len = cmd_buffer_len;
+	memcpy(comm.write_data.buffer, cmd_buffer, cmd_buffer_len);
+	cmd_buffer[cmd_buffer_len] = '\0';
+
+#ifdef OS_LINUX
+#else
+	if (winsock_init() < 0) {
+		printf("ERROR:winsock_init failed.\n");
+		return 1;
+	}
+#endif
+
+	if (udp_comm_create(&config, &comm) != STD_E_OK) {
+		printf("ERROR:udp_comm_create failed.\n");
+		return 1;
+	}
+
+	if (udp_comm_write(&comm) != STD_E_OK) {
+		printf("ERROR:udp_comm_write failed.\n");
+		return 1;
+	}
+	if (udp_comm_read(&comm) != STD_E_OK) {
+		printf("ERROR:udp_comm_read failed.\n");
+		return 1;
+	}
+#ifdef OS_LINUX
+#else
+	winsock_fini();
+#endif
+
+	printf("%s", comm.read_data.buffer);
+	return 0;
+}
+
+CmdOptionType parse_option(int argc, const char* argv[]) {
+	CmdOptionType options = {
+		.athrill_listen_port = CPUEMU_CONFIG_CUI_CLIENT_PORTNO,
+		.remote_client_listen_port = CPUEMU_CONFIG_CUI_EMULATOR_PORTNO,
+		.is_verbose = FALSE,
+		.is_help = FALSE,
+		.is_parse_error = FALSE,
+	};
+
+	struct option longopts[] = {
+		{ "remote-client-listen-port", required_argument, NULL, 'r' },
+		{ "athrill-listen-port",       required_argument, NULL, 'a' },
+		{ "verbose",                   no_argument,       NULL, 'v' },
+		{ "help",                      no_argument,       NULL, 'h' },
+		{ 0,                           0,                 0,     0  },
+	};
+
+	int opt, longindex;
+	while ((opt = getopt_long(argc, (char**)argv, "a:r:vh", longopts, &longindex)) != -1) {
+		switch (opt) {
+		case 'r':
+			options.remote_client_listen_port = atoi(optarg);
+			break;
+		case 'a':
+			options.athrill_listen_port = atoi(optarg);
+			break;
+		case 'v':
+			options.is_verbose = TRUE;
+			break;
+		case 'h':
+			options.is_help = TRUE;
+			break;
+		default:
+			options.is_parse_error = TRUE;
+			break;
+		}
+	}
+
+	return options;
+
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/bus/bus.c
@@ -0,0 +1,42 @@
+#include "bus.h"
+
+typedef struct {
+	BusAccessType		access_type;
+	uint32				access_size;
+	uint32 				access_addr;
+	uint32				access_last_data;
+} BusAccessLogType;
+
+uint32			 bus_access_log_size  = 0;
+BusAccessLogType bus_access_log[BUS_ACCESS_LOG_SIZE];
+
+#undef bus_access_set_log
+void bus_access_set_log(BusAccessType type, uint32 size, uint32 access_addr, uint32 data)
+{
+	if (type == BUS_ACCESS_TYPE_NONE) {
+		bus_access_log_size = 0;
+		return;
+	}
+	else if (bus_access_log_size >= BUS_ACCESS_LOG_SIZE) {
+		return;
+	}
+	bus_access_log[bus_access_log_size].access_type = type;
+	bus_access_log[bus_access_log_size].access_size = size;
+	bus_access_log[bus_access_log_size].access_addr = access_addr;
+	bus_access_log[bus_access_log_size].access_last_data = data;
+	bus_access_log_size++;
+	return;
+}
+
+Std_ReturnType bus_access_get_log(BusAccessType *type, uint32 *size, uint32 *access_addr, uint32 *last_data)
+{
+	if (bus_access_log_size == 0) {
+		return STD_E_NOENT;
+	}
+	bus_access_log_size--;
+	*type = bus_access_log[bus_access_log_size].access_type;
+	*size = bus_access_log[bus_access_log_size].access_size;
+	*access_addr = bus_access_log[bus_access_log_size].access_addr;
+	*last_data = bus_access_log[bus_access_log_size].access_last_data;
+	return STD_E_OK;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/bus/bus.h
@@ -0,0 +1,93 @@
+#ifndef _BUS_H_
+#define _BUS_H_
+
+#include "std_types.h"
+#include "std_errno.h"
+#include "mpu_ops.h"
+#include <stdio.h>
+
+typedef enum {
+	BUS_ACCESS_TYPE_NONE = 0,
+	BUS_ACCESS_TYPE_READ,
+	BUS_ACCESS_TYPE_WRITE,
+} BusAccessType;
+#define BUS_ACCESS_LOG_SIZE	128
+
+extern void bus_access_set_log(BusAccessType type, uint32 size, uint32 access_addr, uint32 data);
+extern Std_ReturnType bus_access_get_log(BusAccessType *type, uint32 *size, uint32 *access_addr, uint32 *data);
+
+
+#ifdef DISABLE_BUS_ACCESS_LOG
+#define bus_access_set_log bus_access_set_log_not_use
+static inline void bus_access_set_log_not_use(BusAccessType type, uint32 size, uint32 access_addr, uint32 data)
+{}
+#endif
+
+/*
+ * データ取得するための操作関数群
+ */
+static inline Std_ReturnType bus_get_data8(CoreIdType core_id, uint32 addr, uint8 *data)
+{
+	Std_ReturnType err;
+
+	err = mpu_get_data8(core_id, addr, data);
+	if (err != STD_E_OK) {
+		printf("ERROR:can not load data:addr=0x%x size=1byte\n", addr);
+	}
+	bus_access_set_log(BUS_ACCESS_TYPE_READ, 1U, addr, *data);
+	return err;
+}
+static inline Std_ReturnType bus_get_data16(CoreIdType core_id, uint32 addr, uint16 *data)
+{
+	Std_ReturnType err;
+
+	err = mpu_get_data16(core_id, addr, data);
+	if (err != STD_E_OK) {
+		printf("ERROR:can not load data:addr=0x%x size=2byte\n", addr);
+	}
+	bus_access_set_log(BUS_ACCESS_TYPE_READ, 2U, addr, *data);
+	return err;
+}
+static inline Std_ReturnType bus_get_data32(CoreIdType core_id, uint32 addr, uint32 *data)
+{
+	Std_ReturnType err;
+
+	err = mpu_get_data32(core_id, addr, data);
+	if (err != STD_E_OK) {
+		printf("ERROR:can not load data:addr=0x%x size=4byte\n", addr);
+	}
+	bus_access_set_log(BUS_ACCESS_TYPE_READ, 4U, addr, *data);
+	return err;
+}
+
+/*
+ * データ転送するための操作関数群
+ */
+static inline Std_ReturnType bus_put_data8(CoreIdType core_id, uint32 addr, uint8 data)
+{
+	bus_access_set_log(BUS_ACCESS_TYPE_WRITE, 1U, addr, data);
+	return mpu_put_data8(core_id, addr, data);
+}
+static inline Std_ReturnType bus_put_data16(CoreIdType core_id, uint32 addr, uint16 data)
+{
+	bus_access_set_log(BUS_ACCESS_TYPE_WRITE, 2U, addr, data);
+	return mpu_put_data16(core_id, addr, data);
+}
+static inline Std_ReturnType bus_put_data32(CoreIdType core_id, uint32 addr, uint32 data)
+{
+	bus_access_set_log(BUS_ACCESS_TYPE_WRITE, 4U, addr, data);
+	return mpu_put_data32(core_id, addr, data);
+}
+
+/*
+ * 注意：本APIは基本的には使用しないこと．
+ *
+ * 性能向上を目的として使用する場合は，
+ * ROM/RAM領域のメモリに限り，当該領域のポインタ変数を本関数を使用して取得する．
+ */
+static inline Std_ReturnType bus_get_pointer(CoreIdType core_id, uint32 addr, uint8 **data)
+{
+	return mpu_get_pointer(core_id, addr, data);
+}
+
+#endif /* _BUS_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/cpu/cpu.h
@@ -0,0 +1,125 @@
+﻿#ifndef _CPU_H_
+#define _CPU_H_
+
+#include "std_types.h"
+#include "cpu_config.h"
+#include "target_cpu.h"
+#include "assert.h"
+#include "athrill_memory.h"
+
+typedef struct {
+	/*
+	 * core must be top.
+	 * do not add member on this region. 
+	 */
+	TargetCoreType		core;
+	uint64				elaps;
+} CpuCoreType;
+
+typedef struct {
+	OpDecodedCodeType	decoded_code;
+#ifndef ARCH_V850ES_FK3
+	OpCodeId			code_id;
+#endif /* ARCH_V850ES_FK3 */
+	int (*op_exec) (TargetCoreType *cpu);
+	/*
+	 * not supported yet..
+	 * use this flag if cache region is rewrite by user program.
+	 * then cache reconstruction is needed!!
+	 */
+	bool				is_dirty;
+} CpuOperationCodeType;
+
+typedef struct {
+	uint32				code_start_addr;
+	uint32				code_size;
+	CpuOperationCodeType	*codes;
+} CachedOperationCodeType;
+
+#define DEFAULT_CPU_FREQ		100 /* MHz */
+typedef struct {
+	uint32						cpu_freq; /* Mhz */
+	CpuCoreType					*current_core;
+	uint32						core_id_num;
+	CpuCoreType					cores[CPU_CONFIG_CORE_NUM];
+	uint32						cached_code_num;
+	CachedOperationCodeType		**cached_code;
+} CpuType;
+
+extern CpuType	virtual_cpu;
+#define CPU_CONFIG_GET_CORE_ID_NUM()	((int)virtual_cpu.core_id_num)
+
+static inline CachedOperationCodeType *virtual_cpu_get_cached_code(uint32 pc)
+{
+	uint32 i;
+	static CachedOperationCodeType *last = NULL;
+
+	if (last != NULL) {
+		if ((pc >= last->code_start_addr) && (pc < (last->code_start_addr + last->code_size))) {
+			return last;
+		}
+	}
+
+	for (i = 0; i < virtual_cpu.cached_code_num; i++) {
+		if (pc < virtual_cpu.cached_code[i]->code_start_addr) {
+			continue;
+		}
+		else if (pc >= (virtual_cpu.cached_code[i]->code_start_addr + virtual_cpu.cached_code[i]->code_size)) {
+			continue;
+		}
+		last = virtual_cpu.cached_code[i];
+		return virtual_cpu.cached_code[i];
+	}
+	/*
+	 * not reached.
+	 */
+	return NULL;
+}
+
+static inline void virtual_cpu_add_cached_code(CachedOperationCodeType *cached_code)
+{
+	virtual_cpu.cached_code_num++;
+	virtual_cpu.cached_code = realloc(virtual_cpu.cached_code, virtual_cpu.cached_code_num * (sizeof (CachedOperationCodeType*)));
+	ASSERT(virtual_cpu.cached_code != NULL);
+	virtual_cpu.cached_code[virtual_cpu.cached_code_num - 1] = cached_code;
+	return;
+}
+/*
+ * start_addr: 	unit=byte
+ * memsz: 		unit=byte
+ */
+static inline void virtual_cpu_cache_code_add_with_check(uint32 memsz, uint32 start_addr)
+{
+	CachedOperationCodeType *cached_code = virtual_cpu_get_cached_code(start_addr);
+	if (cached_code != NULL) {
+		return;
+	}
+
+	cached_code = athrill_mem_alloc(sizeof(CachedOperationCodeType));
+	ASSERT(cached_code != NULL);
+	cached_code->codes = calloc(memsz, sizeof(CpuOperationCodeType));
+	ASSERT(cached_code->codes != NULL);
+	cached_code->code_start_addr = start_addr;
+	cached_code->code_size = (memsz);
+
+	virtual_cpu_add_cached_code(cached_code);
+	return;
+}
+
+
+extern uint32 cpu_get_current_core_id(void);
+extern uint32 cpu_get_ep(const TargetCoreType *core);
+
+extern uint32 cpu_get_current_core_register(uint32 inx);
+extern uint32 cpu_get_current_core_pc(void);
+extern void cpu_set_core_pc(CoreIdType core_id, uint32 pc);
+extern uint32 cpu_get_current_core_sp(void);
+extern uint32 cpu_get_current_core_ep(void);
+extern uint32 cpu_get_return_addr(const TargetCoreType *core);
+
+extern CoreIdType cpu_get_core_id(const TargetCoreType *core);
+extern void intc_cpu_trigger_interrupt(CoreIdType core_id, int intno);
+
+extern bool cpu_may_store_on_stack_overflow(uint32 start_addr, uint32 size);
+
+#endif /* _CPU_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/debugger/executor/concrete_executor/dbg_std_executor.c
@@ -0,0 +1,1021 @@
+#include "dbg_executor.h"
+#include "file_address_mapping.h"
+#include "concrete_executor/dbg_std_executor.h"
+#include "front/parser/concrete_parser/dbg_std_parser.h"
+#include "cpu_control/dbg_cpu_control.h"
+#include "cpu_control/dbg_cpu_thread_control.h"
+#include "cpuemu_ops.h"
+#include "dbg_log.h"
+#include "assert.h"
+#include "concrete_executor/target/dbg_target_serial.h"
+#include "concrete_executor/util/dbg_print_data_type.h"
+#include "symbol_ops.h"
+#include "cui/cui_ops.h"
+#include "dbg_target_cpu.h"
+#include <stdio.h>
+#include "target/target_os_api.h"
+#include "dwarf/data_type/elf_dwarf_data_type.h"
+#include <string.h>
+#include "file.h"
+#ifdef OS_LINUX
+#include <sys/time.h>
+#endif /* OS_LINUX */
+#define SYMBOL_CANDIATE_NUM		10
+
+
+void dbg_std_executor_parse_error(void *executor)
+{
+	 DbgCmdExecutorType *arg = (DbgCmdExecutorType *)executor;
+
+	 printf("ERROR: %s :command not found\n", arg->original_str);
+	 CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "NG\n"));
+
+	 return;
+}
+
+typedef struct {
+	char *classname;
+	char *methodname;
+	char *linkagename;
+} ClassMethodNameType;
+static char class_method_name_buffer[4096];
+static bool get_class_method(char *symbol, ClassMethodNameType *container)
+{
+	char *tp[2];
+
+	memcpy(class_method_name_buffer, symbol, strlen(symbol) + 1);
+
+	tp[0] = strtok(class_method_name_buffer, ".");
+	tp[1] = strtok(NULL, ".");
+
+	if (tp[1] == NULL) {
+		return FALSE;
+	}
+	container->classname = tp[0];
+	container->methodname = tp[1];
+	container->linkagename = elf_dwarf_get_class_method_linkagename(container->classname, container->methodname);
+	if (container->linkagename == NULL) {
+		return FALSE;
+	}
+	return TRUE;
+}
+
+void dbg_std_executor_break(void *executor)
+{
+	 DbgCmdExecutorType *arg = (DbgCmdExecutorType *)executor;
+	 DbgCmdExecutorBreakType *parsed_args = (DbgCmdExecutorBreakType *)(arg->parsed_args);
+	 uint32 func_len;
+	 uint32 addr;
+	 uint32 size;
+
+	 if (parsed_args->type == DBG_CMD_BBREAK_SET_SYMBOL) {
+		 ClassMethodNameType container;
+		 char *symbol;
+		 if (get_class_method((char*)parsed_args->symbol.str, &container) == FALSE) {
+			 func_len = strlen((char*)parsed_args->symbol.str);
+			 symbol = (char*)parsed_args->symbol.str;
+		 }
+		 else {
+			 func_len = strlen(container.linkagename);
+			 symbol = container.linkagename;
+			 printf("linkagename=%s\n", symbol);
+		 }
+		 if (symbol_get_func(symbol, func_len, &addr, &size) < 0) {
+			 printf("ERROR: not found symbol %s\n", parsed_args->symbol.str);
+			 symbol_print_func(symbol, SYMBOL_CANDIATE_NUM);
+			 CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "NG\n"));
+		 }
+		 else {
+			 if (cpuctrl_set_break(addr, BREAK_POINT_TYPE_FOREVER) == TRUE) {
+				 printf("break %s 0x%x\n", parsed_args->symbol.str, addr);
+				 CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "OK\n"));
+				 arg->result_ok = TRUE;
+			 }
+			 else {
+				 printf("ERROR: can not break %s\n", parsed_args->symbol.str);
+				 CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "NG\n"));
+			 }
+		 }
+	 }
+	 else if (parsed_args->type == DBG_CMD_BBREAK_SET) {
+		 if (cpuctrl_set_break(parsed_args->break_addr, BREAK_POINT_TYPE_FOREVER) == TRUE) {
+			 printf("break 0x%x\n", parsed_args->break_addr);
+			 CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "OK\n"));
+			 arg->result_ok = TRUE;
+		 }
+		 else {
+			 printf("ERROR: can not break 0x%x\n", parsed_args->break_addr);
+			 CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "NG\n"));
+		 }
+	 }
+	 else if (parsed_args->type == DBG_CMD_BREAK_SET_FILE_LINE) {
+		 Std_ReturnType err;
+		 KeyAddressType value;
+		 err = file_address_mapping_get_addr((char*)parsed_args->symbol.str, parsed_args->line, &value);
+		 if (err != STD_E_OK) {
+			 ValueFileType candidate;
+			 printf("ERROR: can not found break addr:%s %u\n", (char*)parsed_args->symbol.str, parsed_args->line);
+			 err = file_address_mapping_get_candidate((char*)parsed_args->symbol.str, parsed_args->line, &candidate);
+			 if (err == STD_E_OK) {
+				 printf("candidate : %s %u\n", candidate.file, candidate.line);
+			 }
+			 CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "NG\n"));
+		 }
+		 else {
+			 if (cpuctrl_set_break(value.addr, BREAK_POINT_TYPE_FOREVER) == TRUE) {
+				 printf("break 0x%x\n", value.addr);
+				 CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "OK\n"));
+				 arg->result_ok = TRUE;
+			 }
+			 else {
+				 printf("ERROR: can not break 0x%x\n", value.addr);
+				 CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "NG\n"));
+			 }
+		 }
+	 }
+	 else if (parsed_args->type == DBG_CMD_BREAK_INFO) {
+		 uint32 i;
+		 uint32 addr;
+		 for (i = 0; i < DBG_CPU_CONTROL_BREAK_SETSIZE; i++) {
+			 int funcid;
+			 uint32 funcaddr;
+			 if (cpuctrl_get_break(i, &addr) == TRUE) {
+				 funcid = symbol_pc2funcid(addr, &funcaddr);
+				 if (funcid >= 0) {
+					 printf("[%u] 0x%x %s(+0x%x)\n", i, addr, symbol_funcid2funcname(funcid), addr - funcaddr);
+				 }
+				 else {
+					 printf("[%u] 0x%x\n", i, addr);
+				 }
+			 }
+		 }
+		 CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "OK\n"));
+	 }
+	 return;
+}
+static char* watch_type_string(DataWatchPointEumType type)
+{
+	if (type == DATA_WATCH_POINT_TYPE_READ) {
+		return "r";
+	}
+	if (type == DATA_WATCH_POINT_TYPE_WRITE) {
+		return "w";
+	}
+	if (type == DATA_WATCH_POINT_TYPE_RW) {
+		return "rw";
+	}
+	return "none";
+}
+static bool dbg_std_executor_watch_data_info(DbgCmdExecutorWatchDataType *arg)
+{
+	 uint32 i;
+	 uint32 addr;
+	 uint32 size;
+	 DataWatchPointEumType type;
+
+	 for (i = 0; i < DBG_CPU_CONTROL_WATCH_DATA_SETSIZE; i++) {
+		 int glid;
+		 uint32 gladdr;
+		 if (cpuctrl_get_data_watch_point(i, &addr, &size, &type) == TRUE) {
+			 glid = symbol_addr2glid(addr, &gladdr);
+			 if (glid >= 0) {
+				 printf("[%u] %-4s 0x%x %u %s(+0x%x)\n", i, watch_type_string(type), addr, size, symbol_glid2glname(glid), addr - gladdr);
+			 }
+			 else {
+				 printf("[%u] %-4s 0x%x %u\n", i, watch_type_string(type), addr, size);
+			 }
+		 }
+	 }
+	return TRUE;
+}
+static bool dbg_std_executor_watch_data_delete(DbgCmdExecutorWatchDataType *arg)
+{
+	 if (arg->type == DBG_CMD_WATCH_DELETE_ONE) {
+		 if (cpuctrl_del_data_watch_point(arg->delno) == FALSE) {
+			 printf("ERROR: can not delete %u\n", arg->delno);
+			 return FALSE;
+		 }
+	 }
+	 else if (arg->type == DBG_CMD_WATCH_DELETE_ALL) {
+		 cpuctrl_del_all_data_watch_points();
+	 }
+
+	 return TRUE;
+}
+static bool dbg_std_executor_watch_data_set(DbgCmdExecutorWatchDataType *arg)
+{
+	uint32 addr;
+	uint32 size;
+	DataWatchPointEumType type;
+
+	if (arg->type == DBG_CMD_WATCH_SET_SYMBOL) {
+		/*
+		 * symbol指定の場合は，アドレス，サイズ変換する
+		 */
+		 if (symbol_get_gl((char*)arg->symbol.str, arg->symbol.len, &addr, &size) < 0) {
+			 printf("ERROR: not found symbol %s\n", arg->symbol.str);
+			 symbol_print_gl((char*)arg->symbol.str, SYMBOL_CANDIATE_NUM);
+			 return FALSE;
+		 }
+	}
+	else {
+		addr = arg->addr;
+		size = arg->size;
+	}
+
+	if ((arg->watch_type & DBG_CMD_WATCH_TYPE_RW) == DBG_CMD_WATCH_TYPE_READ) {
+		type = DATA_WATCH_POINT_TYPE_READ;
+	}
+	else if ((arg->watch_type & DBG_CMD_WATCH_TYPE_RW) == DBG_CMD_WATCH_TYPE_WRITE) {
+		type = DATA_WATCH_POINT_TYPE_WRITE;
+	}
+	else if ((arg->watch_type & DBG_CMD_WATCH_TYPE_RW) == DBG_CMD_WATCH_TYPE_RW) {
+		type = DATA_WATCH_POINT_TYPE_RW;
+	}
+	else {
+		return FALSE;
+	}
+
+	if (cpuctrl_set_data_watch(type, addr, size) == TRUE) {
+		 printf("set watch point 0x%x %u\n", addr, size);
+	 }
+	 else {
+		 printf("ERROR: can not set watch point 0x%x %u\n", addr, size);
+		 return FALSE;
+	 }
+	return TRUE;
+}
+
+void dbg_std_executor_watch_data(void *executor)
+{
+	bool result = FALSE;
+	 DbgCmdExecutorType *arg = (DbgCmdExecutorType *)executor;
+	 DbgCmdExecutorWatchDataType *parsed_args = (DbgCmdExecutorWatchDataType *)(arg->parsed_args);
+
+	 switch (parsed_args->type) {
+	 case DBG_CMD_WATCH_SET:
+	 case DBG_CMD_WATCH_SET_SYMBOL:
+		 result = dbg_std_executor_watch_data_set(parsed_args);
+		 break;
+	 case DBG_CMD_WATCH_DELETE_ALL:
+	 case DBG_CMD_WATCH_DELETE_ONE:
+		 result = dbg_std_executor_watch_data_delete(parsed_args);
+		 break;
+	 case DBG_CMD_WATCH_INFO:
+		 result = dbg_std_executor_watch_data_info(parsed_args);
+		 break;
+	 default:
+		 break;
+	 }
+
+	 if (result == TRUE) {
+		 CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "OK\n"));
+		 arg->result_ok = TRUE;
+	 }
+	 else {
+		 CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "NG\n"));
+	 }
+	 return;
+}
+
+
+void dbg_std_executor_delete(void *executor)
+{
+	 DbgCmdExecutorType *arg = (DbgCmdExecutorType *)executor;
+	 DbgCmdExecutorDeleteType *parsed_args = (DbgCmdExecutorDeleteType *)(arg->parsed_args);
+
+	 if (parsed_args->type == DBG_CMD_DELETE_ONE) {
+		 if (cpuctrl_del_break(parsed_args->delete_break_no) == FALSE) {
+			 printf("ERROR: can not delete %u\n", parsed_args->delete_break_no);
+			 CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "NG\n"));
+		 }
+		 else {
+			 CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "OK\n"));
+			 arg->result_ok = TRUE;
+		 }
+	 }
+	 else if (parsed_args->type == DBG_CMD_DELETE_ALL) {
+		 cpuctrl_del_all_break(BREAK_POINT_TYPE_FOREVER);
+		 CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "OK\n"));
+		 arg->result_ok = TRUE;
+	 }
+	 return;
+}
+
+void dbg_std_executor_cont(void *executor)
+{
+	DbgCmdExecutorType *arg = (DbgCmdExecutorType *)executor;
+	DbgCmdExecutorContType *parsed_args = (DbgCmdExecutorContType *)(arg->parsed_args);
+
+	cpuctrl_set_debug_mode(FALSE);
+	if (parsed_args->type == DBG_CMD_CONT_ALL) {
+		cpuctrl_set_cont_clocks(FALSE, 0);
+		cputhr_control_dbg_wakeup_cpu();
+	}
+	else {
+		cpuctrl_set_cont_clocks(TRUE, parsed_args->cont_clocks);
+		cputhr_control_dbg_wakeup_cpu_and_wait_for_cpu_stopped();
+	}
+	CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "OK\n"));
+	return;
+}
+
+void dbg_std_executor_core(void *executor)
+{
+	CoreIdType i;
+	DbgCmdExecutorType *arg = (DbgCmdExecutorType *)executor;
+	DbgCmdExecutorCoreType *parsed_args = (DbgCmdExecutorCoreType *)(arg->parsed_args);
+
+	if (parsed_args->type == DBG_CMD_CORE_SINGLE) {
+		bool isAllNotDebugMode = TRUE;
+		dbg_cpu_debug_mode_set(parsed_args->core_id, parsed_args->is_debug_mode);
+		for (i = 0; i < cpu_config_get_core_id_num(); i++) {
+			if (dbg_cpu_debug_mode_get(i) == TRUE) {
+				isAllNotDebugMode = FALSE;
+				break;
+			}
+		}
+		if (isAllNotDebugMode == TRUE) {
+			dbg_cpu_debug_mode_set(parsed_args->core_id, TRUE);
+			printf("ERROR: Core%d can not be set non-debug mode, because all core must not be in non-debug mode. athrill does not controll cpu...\n", parsed_args->core_id);
+			CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "NG\n"));
+			return;
+		}
+		printf("Core%d debug mode=%s\n", parsed_args->core_id,
+				dbg_cpu_debug_mode_get(parsed_args->core_id) == TRUE ? "TRUE" : "FALSE");
+	}
+	else {
+		CoreIdType current = cpu_get_current_core_id();
+		for (i = 0; i < cpu_config_get_core_id_num(); i++) {
+			if (parsed_args->type == DBG_CMD_CORE_ALL) {
+				dbg_cpu_debug_mode_set(i, parsed_args->is_debug_mode);
+			}
+			printf("%s Core%d debug mode=%s\n",
+					i == current ? "*" : "-",
+					i,
+					dbg_cpu_debug_mode_get(i) == TRUE ? "TRUE" : "FALSE");
+		}
+	}
+
+	CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "OK\n"));
+	return;
+}
+void dbg_std_executor_intr(void *executor)
+{
+	DbgCmdExecutorType *arg = (DbgCmdExecutorType *)executor;
+	DbgCmdExecutorIntrType *parsed_args = (DbgCmdExecutorIntrType *)(arg->parsed_args);
+
+	(void)cpuemu_raise_intr(parsed_args->intno);
+
+	CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "OK\n"));
+	return;
+}
+
+void dbg_std_executor_next(void *executor)
+{
+	bool org_view_mode = dbg_log_is_view_mode();
+	cpuctrl_set_cont_clocks(FALSE, 0);
+
+	cpuctrl_set_debug_mode(TRUE);
+	dbg_log_set_view_mode(TRUE);
+	dbg_log_set_print_mode(TRUE);
+#ifdef OS_LINUX
+	cpuemu_start_elaps();
+#endif /* OS_LINUX */
+
+	cputhr_control_dbg_wakeup_cpu_and_wait_for_cpu_stopped();
+
+#ifdef OS_LINUX
+	cpuemu_end_elaps();
+#endif /* OS_LINUX */
+
+	/*
+	 * ここにsleepを入れないと，cont => q コマンド実行後，ログ出力されなくなるため，
+	 * 一時的に本修正対応する．
+	 */
+	target_os_api_sleep(50);
+	dbg_log_set_print_mode(FALSE);
+	dbg_log_set_view_mode(org_view_mode);
+	return;
+}
+
+void dbg_std_executor_return(void *executor)
+{
+	uint32 retaddr;
+	CoreIdType core_id;
+
+	cpuctrl_set_cont_clocks(FALSE, 0);
+
+	if (cpuctrl_get_current_debugged_core(&core_id) == TRUE) {
+		retaddr = cpuemu_get_retaddr(core_id);
+		 if (cpuctrl_set_break(retaddr, BREAK_POINT_TYPE_ONLY_ONCE) == TRUE) {
+			 printf("break 0x%x\n", retaddr);
+		 }
+		 else {
+			 printf("ERROR: can not break 0x%x\n", retaddr);
+		 }
+		cpuctrl_set_debug_mode(FALSE);
+		cputhr_control_dbg_wakeup_cpu();
+	}
+	else {
+		ASSERT(0);
+	}
+
+	return;
+}
+
+void dbg_std_executor_quit(void *executor)
+{
+	cpuctrl_set_force_debug_mode();
+	cputhr_control_dbg_waitfor_cpu_stopped();
+	cpuctrl_set_debug_mode(TRUE);
+}
+
+void dbg_std_executor_list(void *executor)
+{
+	dbg_cpu_control_update_editor();
+	CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "OK\n"));
+	return;
+}
+
+void dbg_std_executor_exit(void *executor)
+{
+	cpuctrl_set_debug_mode(TRUE);
+	cputhr_control_dbg_waitfor_cpu_stopped();
+	printf("Exit\n");
+	CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "OK\n"));
+	exit(1);
+	return;
+}
+
+void dbg_std_executor_elaps(void *executor)
+{
+	int core_id;
+	CpuEmuElapsType elaps;
+	cpuemu_get_elaps(&elaps);
+
+	for (core_id = 0; core_id < elaps.core_id_num; core_id++) {
+		printf("cpu_clock[%d] = "PRINT_FMT_UINT64"\n", core_id, elaps.cpu_clocks[core_id]);
+	}
+
+#ifdef OS_LINUX
+#ifdef OS_MAC
+printf("loops "PRINT_FMT_UINT64" intc "PRINT_FMT_UINT64" real_time  %ld.%06d\n",
+        elaps.total_clocks, elaps.intr_clocks, elaps.elaps_tv.tv_sec, elaps.elaps_tv.tv_usec);
+#else
+	printf("loops "PRINT_FMT_UINT64" intc "PRINT_FMT_UINT64" real_time  %ld.%06ld\n",
+			elaps.total_clocks, elaps.intr_clocks, elaps.elaps_tv.tv_sec, elaps.elaps_tv.tv_usec);
+#endif /* OS_MAC */
+#else
+	printf("loops "PRINT_FMT_UINT64" intc "PRINT_FMT_UINT64"\n", elaps.total_clocks, elaps.intr_clocks);
+#endif /* OS_LINUX */
+	CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), PRINT_FMT_UINT64 " " PRINT_FMT_UINT64 "  OK", elaps.total_clocks, elaps.cpu_clocks[0]));
+	return;
+}
+void dbg_std_executor_view(void *executor)
+{
+	bool view_mode = dbg_log_is_view_mode();
+
+	if (view_mode == TRUE) {
+		dbg_log_set_view_mode(FALSE);
+		printf("VIEW_MODE=OFF\n");
+		CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "VIEW_MODE=OFF\n"));
+	}
+	else {
+		dbg_log_set_view_mode(TRUE);
+		printf("VIEW_MODE=ON\n");
+		CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "VIEW_MODE=ON\n"));
+	}
+	return;
+}
+
+static void print_memory(uint32 vaddr, uint8 *top_addr, uint32 size)
+{
+	uint32 i;
+	printf("size=%u byte\n", size);
+	for (i = 0; i < size; i++) {
+		printf("%4u 0x%x 0x%x	(%c)\n", i, (vaddr + i), *(top_addr + i), *(top_addr + i));
+	}
+	CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "%x  OK", *top_addr));
+	return;
+}
+static void print_memory_type(char *variable_name, uint32 vaddr, uint8 *top_addr, uint32 size)
+{
+	if (variable_name != NULL) {
+		bool ret = print_variable_with_data_type(variable_name, vaddr, top_addr, size);
+		if (ret == TRUE) {
+			CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "0x%x  %u  OK", vaddr, size));
+			return;
+		}
+	}
+
+	if (size == 2) {
+		uint16 *data = (uint16*)top_addr;
+		printf("size=%u byte\n", size);
+		printf("0x%x 0x%x\n", (vaddr), *(data));
+		CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "%x  OK",  *(data)));
+	}
+	else if (size == 4) {
+		uint32 *data = (uint32*)top_addr;
+		printf("size=%u byte\n", size);
+		printf("0x%x 0x%x\n", (vaddr), *(data));
+		CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "%x  OK",  *(data)));
+	}
+	else {
+		print_memory(vaddr, top_addr, size);
+	}
+	return;
+}
+static void print_memory_by_typename(uint32 vaddr, uint8 *top_addr, char* dataType, char* dataTypeName)
+{
+	if (print_addr_with_data_type(vaddr, top_addr, dataType, dataTypeName) == TRUE) {
+		CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "OK\n"));
+	}
+	else {
+		CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "NG\n"));
+	}
+}
+
+void dbg_std_executor_print(void *executor)
+{
+	 DbgCmdExecutorType *arg = (DbgCmdExecutorType *)executor;
+	 DbgCmdExecutorPrintType *parsed_args = (DbgCmdExecutorPrintType *)(arg->parsed_args);
+	 uint8 *data;
+	 uint32 gl_len;
+	 uint32 addr;
+	 uint32 size;
+
+	 if (parsed_args->type == DBG_CMD_PRINT_SYMBOL) {
+		 gl_len = strlen((char*)parsed_args->symbol.str);
+		 if (symbol_get_gl((char*)parsed_args->symbol.str, gl_len, &addr, &size) < 0) {
+			 if (print_local_variable_type((char*)parsed_args->symbol.str) == FALSE) {
+				 printf("ERROR: not found symbol %s\n", parsed_args->symbol.str);
+				 symbol_print_gl((char*)parsed_args->symbol.str, SYMBOL_CANDIATE_NUM);
+				 CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "NG\n"));
+			 }
+		 }
+		 else {
+			 cpuemu_get_addr_pointer(addr, &data);
+			 print_memory_type((char*)(parsed_args->symbol.str), addr, data, size);
+		 }
+	 }
+	 else if (parsed_args->type == DBG_CMD_PRINT_ADDR) {
+		 printf("ERROR: not supported:print addr(0x%x)\n", parsed_args->addr);
+		 CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "NG\n"));
+	 }
+	 else if (parsed_args->type == DBG_CMD_PRINT_ADDR_SIZE) {
+		 cpuemu_get_addr_pointer(parsed_args->addr, &data);
+		 print_memory_type(NULL, parsed_args->addr, data, parsed_args->size);
+	 }
+	 else if (parsed_args->type == DBG_CMD_PRINT_ADDR_TYPE) {
+		 cpuemu_get_addr_pointer(parsed_args->addr, &data);
+		//printf("DBG_CMD_PRINT_ADDR_TYPE\n");
+		//printf("type:%s\n", parsed_args->dataType.str);
+		//printf("typeName:%s\n", parsed_args->dataTypeName.str);
+		 print_memory_by_typename(parsed_args->addr, data, (char*)parsed_args->dataType.str, (char*)parsed_args->dataTypeName.str);
+	 }
+	 return;
+}
+
+void dbg_std_executor_memset(void *executor)
+{
+	Std_ReturnType ret;
+	DbgCmdExecutorType *arg = (DbgCmdExecutorType *)executor;
+	DbgCmdExecutorMemsetType *parsed_args = (DbgCmdExecutorMemsetType *)(arg->parsed_args);
+	uint8 *data;
+	uint32 addr;
+	uint8 value;
+
+	addr = parsed_args->addr;
+	value = parsed_args->value;
+
+	ret = cpuemu_get_addr_pointer(addr, &data);
+	if (ret == STD_E_OK) {
+		*data = value;
+		CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "OK\n"));
+	} else {
+		printf("ERROR:can not find addr:0x%x\n", addr);
+		CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "NG\n"));
+	}
+	 return;
+}
+void dbg_std_executor_serialin(void *executor)
+{
+	uint32 i;
+	Std_ReturnType err;
+	DbgCmdExecutorType *arg = (DbgCmdExecutorType *)executor;
+	DbgCmdExecutorSerialInType *parsed_args = (DbgCmdExecutorSerialInType *)(arg->parsed_args);
+
+	for (i = 0; i < parsed_args->input.len; i++) {
+		err = dbg_serial_in(parsed_args->channel, parsed_args->input.str[i]);
+		if (err != STD_E_OK) {
+			printf("ERROR:can not put serial data:%c\n", parsed_args->input.str[i]);
+			CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "NG\n"));
+			return;
+		}
+	}
+	CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "OK\n"));
+
+	return;
+}
+
+void dbg_std_executor_info_cpu(void *executor)
+{
+	CoreIdType i;
+	DbgCmdExecutorType *arg = (DbgCmdExecutorType *)executor;
+	DbgCmdExecutorInfoCpuType *parsed_args = (DbgCmdExecutorInfoCpuType *)(arg->parsed_args);
+
+	if (parsed_args->type == DBG_CMD_CORE_ALL) {
+		for (i = 0; i < cpu_config_get_core_id_num(); i++) {
+			dbg_target_print_cpu(i);
+		}
+	}
+	else {
+		if (parsed_args->core_id >= CPU_CONFIG_CORE_NUM) {
+			CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "NG\n"));
+			printf("ERROR: Invalid core_id=%d max_core_num=%d\n", parsed_args->core_id, cpu_config_get_core_id_num());
+			return;
+		}
+		dbg_target_print_cpu(parsed_args->core_id);
+	}
+	CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "OK\n"));
+	return;
+}
+
+static void dbg_std_executor_fun_trace_toward_older(uint32 coreId, uint32 bt_number)
+{
+	int i;
+	uint32 funcpcoff;
+	uint32 funcid;
+	char *funcname;
+	uint32 sp;
+	uint32 glid;
+	uint32 gladdr;
+	char *stackp;
+
+	for (i = (bt_number - 1); i >= 0; i--) {
+		funcname = cpuctrl_get_func_log_trace_info(coreId, i, &funcpcoff, &funcid, &sp);
+		if (funcname == NULL) {
+			break;
+		}
+		glid = symbol_addr2glid(sp, &gladdr);
+		stackp = symbol_glid2glname(glid);
+		printf("core%d: <%-30s(0x%03x)> [%3u] <0x%03x> %s\n", coreId, stackp, sp - gladdr, i, funcpcoff, funcname);
+	}
+	return;
+}
+static void dbg_std_executor_fun_trace_toward_newer(uint32 coreId, uint32 bt_number)
+{
+	int i;
+	uint32 funcpcoff;
+	uint32 funcid;
+	char *funcname;
+	uint32 sp;
+	uint32 glid;
+	uint32 gladdr;
+	char *stackp;
+	uint32 lognum = cpuctrl_get_func_log_trace_num(coreId);
+
+	for (i = 0; i < bt_number; i++) {
+		funcname = cpuctrl_get_func_log_trace_info(coreId, i, &funcpcoff, &funcid, &sp);
+		if (funcname == NULL) {
+			break;
+		}
+		glid = symbol_addr2glid(sp, &gladdr);
+		stackp = symbol_glid2glname(glid);
+		printf("core%d: <%-30s(0x%03x)> [%3u] <0x%03x> %s\n", coreId, stackp, sp - gladdr, (lognum - 1 - i), funcpcoff, funcname);
+	}
+	return;
+}
+
+void dbg_std_executor_func_trace(void *executor)
+{
+	DbgCmdExecutorType *arg = (DbgCmdExecutorType *)executor;
+	DbgCmdExecutorFuncTraceType *parsed_args = (DbgCmdExecutorFuncTraceType *)(arg->parsed_args);
+	uint32 coreId;
+	uint32 bt_number = parsed_args->bt_number;
+
+	for (coreId = 0; coreId < cpu_config_get_core_id_num(); coreId++) {
+		uint32 lognum = cpuctrl_get_func_log_trace_num(coreId);
+		if (bt_number > lognum) {
+			bt_number = lognum;
+		}
+		if (parsed_args->bt_way == FALSE) {
+			dbg_std_executor_fun_trace_toward_older(coreId, bt_number);
+		}
+		else {
+			dbg_std_executor_fun_trace_toward_newer(coreId, bt_number);
+		}
+	}
+	CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "OK\n"));
+
+	return;
+}
+
+static bool dbg_data_access_compare(const ObjectSortElementType *obj1, const ObjectSortElementType *obj2)
+{
+	DataAccessContextType *dp1 = (DataAccessContextType *)obj1->p;
+	DataAccessContextType *dp2 = (DataAccessContextType *)obj2->p;
+
+	if (dp1->access_time > dp2->access_time) {
+		return TRUE;
+	}
+	return FALSE;
+}
+
+static FileType data_access_file;
+static uint32 data_access_glid = 0;
+
+static void dbg_data_access_print(const void *p)
+{
+	const ObjectSortElementType *sp = (const ObjectSortElementType*)p;
+	const DataAccessContextType *dp = (const DataAccessContextType*)sp->p;
+
+	printf(" + <"PRINT_FMT_UINT64"> [%5s] [core%u] [%40s] [%30s()]\n",
+						dp->access_time,
+						(dp->access_type == ACCESS_TYPE_READ) ? "READ" : "WRITE",
+						dp->core_id,
+						symbol_glid2glname(dp->sp),
+						symbol_funcid2funcname(dp->funcid));
+	return;
+}
+static void dbg_data_access_print_csv(const void *p)
+{
+	const ObjectSortElementType *sp = (const ObjectSortElementType*)p;
+	const DataAccessContextType *dp = (const DataAccessContextType*)sp->p;
+	char *glname = symbol_glid2glname(data_access_glid);
+
+	(void)snprintf((char*)data_access_file.buffer,
+						sizeof(data_access_file.buffer),
+						"%s, "PRINT_FMT_UINT64", %s, core%u, %s, %s(),",
+						glname,
+						dp->access_time,
+						(dp->access_type == ACCESS_TYPE_READ) ? "READ" : "WRITE",
+						dp->core_id,
+						symbol_glid2glname(dp->sp),
+						symbol_funcid2funcname(dp->funcid));
+	file_appendline(&data_access_file);
+	return;
+}
+
+static void dbg_std_executor_data_access_context(DataAccessInfoHeadType *context,  void (*object_action) (const void *p))
+{
+	ObjectContainerType *sort = object_container_sort(context->access_context, dbg_data_access_compare);
+
+	object_container_foreach(sort, object_action);
+
+	object_container_delete(sort);
+	return;
+}
+
+static void show_all_data_access_info(void)
+{
+	uint32 gl_num = symbol_get_gl_num();
+	(void)snprintf((char*)data_access_file.buffer,
+						sizeof(data_access_file.buffer),
+						"variable,access_clock,type,core,stack,access_func,");
+	file_appendline(&data_access_file);
+
+	for (data_access_glid = 0; data_access_glid < gl_num; data_access_glid++) {
+		DataAccessInfoType *table = cpuctrl_get_func_access_info_table_glid(data_access_glid);
+		if (table != NULL) {
+			if (table[0].head.access_num > 0) {
+				dbg_std_executor_data_access_context(&table[0].head, dbg_data_access_print_csv);
+			}
+		}
+	}
+	return;
+}
+
+void dbg_std_executor_data_access_info(void *executor)
+{
+	DbgCmdExecutorType *arg = (DbgCmdExecutorType *)executor;
+	DbgCmdExecutorDataAccessInfoType *parsed_args = (DbgCmdExecutorDataAccessInfoType *)(arg->parsed_args);
+	DataAccessInfoType *table;
+	DataAccessInfoType *p;
+	bool ret;
+
+	if (parsed_args->symbol.str[0] == '-') {
+		/*
+		 * show all access
+		 */
+		token_string_set(&data_access_file.filepath, "./data_access.csv");
+		ret = file_wopen(&data_access_file);
+		if (ret == FALSE) {
+			printf("ERROR: can not open file ./data_access.csv\n");
+			CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "NG\n"));
+			return;
+		}
+		else {
+			show_all_data_access_info();
+			file_close(&data_access_file);
+			CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "OK\n"));
+		}
+		return;
+	}
+	else {
+		/*
+		 * show one symbol access
+		 */
+		table = cpuctrl_get_func_access_info_table((const char*)parsed_args->symbol.str);
+		if (table == NULL) {
+			 printf("ERROR: not found symbol %s\n", parsed_args->symbol.str);
+			 symbol_print_gl((char*)parsed_args->symbol.str, SYMBOL_CANDIATE_NUM);
+			 CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "NG\n"));
+			return;
+		}
+
+		printf("* %s\n", parsed_args->symbol.str);
+		p = &table[0];
+
+		if (p->head.access_num > 0) {
+			dbg_std_executor_data_access_context(&p->head, dbg_data_access_print);
+		}
+		else {
+			printf("Not accessed yet.\n");
+		}
+
+		CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "OK\n"));
+		return;
+	}
+}
+static void print_stack_data(uint32 addr)
+{
+	 uint32 funcaddr;
+	 int funcid;
+	 uint32 gladdr;
+	 int glid;
+	 uint32 *datap;
+	 uint32 data;
+
+
+	 cpuemu_get_addr_pointer(addr, (uint8**)&datap);
+	 data = *datap;
+
+	 funcid = symbol_pc2funcid(data, &funcaddr);
+	 if (funcid >= 0) {
+		printf("					0x%x 0x%x %s(+0x%x)", addr, data, symbol_funcid2funcname(funcid), data - funcaddr);
+	 }
+	 else {
+		glid = symbol_addr2glid(data, &gladdr);
+		if (glid >= 0) {
+			printf("					0x%x 0x%x %s(+0x%x)", addr, data, symbol_glid2glname(glid), data - gladdr);
+		}
+		else {
+			printf("					0x%x 0x%x", addr, data);
+		}
+	 }
+	printf("\n");
+	CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "OK\n"));
+	return;
+}
+#define DBG_CMD_BACK_TRACE_SHOW_MAX		10
+void dbg_std_executor_back_trace(void *executor)
+{
+	int i;
+	uint32 prev_sp = -1;
+	uint32 sp;
+	Std_ReturnType err;
+	uint32 gl_num = symbol_get_gl_num();
+	int inx;
+
+	for (inx = 0; inx < gl_num; inx++) {
+		i = DBG_STACK_LOG_SIZE - 1;
+		if (cpuctrl_get_stack_pointer(inx, 0, &sp) == STD_E_OK) {
+			prev_sp = -1;
+			printf("*************************************\n");
+			while (i >= 0) {
+				err = cpuctrl_get_stack_pointer(inx, i, &sp);
+				if (err == STD_E_OK) {
+					if (prev_sp != -1) {
+						uint32 addr_inx;
+						uint32 addr = prev_sp;
+						uint32 num = (sp - prev_sp)/4;
+						if (num > DBG_CMD_BACK_TRACE_SHOW_MAX) num = DBG_CMD_BACK_TRACE_SHOW_MAX;
+						for (addr_inx = 0; addr_inx < num; addr_inx++) {
+							print_stack_data(addr);
+							addr += 4;
+						}
+					}
+					prev_sp = sp;
+					printf(" %-30s [%4u] 0x%08x\n", symbol_glid2glname(inx), i, sp);
+					}
+				i--;
+			}
+			printf("\n");
+		}
+	}
+	CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "OK\n"));
+
+
+	return;
+}
+#ifdef CONFIG_STAT_PERF
+#include "cpu_exec/op_exec.h"
+#endif /* CONFIG_STAT_PERF */
+void dbg_std_executor_profile(void *executor)
+{
+	uint32 funcnum;
+	uint32 funcid;
+	char *funcname;
+	CpuProfileType profile;
+	uint32 coreId;
+
+	funcnum = symbol_get_func_num();
+
+	for (coreId = 0; coreId < cpu_config_get_core_id_num(); coreId++) {
+		printf("*** coreId=%d ***\n", coreId);
+		printf("%-50s %-15s %-15s %-15s\n", "funcname", "call_num", "func_time", "total_time");
+		for (funcid = 0; funcid < funcnum; funcid++) {
+			cpuctrl_profile_get(coreId, funcid, &profile);
+			if (profile.call_num == 0) {
+				continue;
+			}
+			funcname = symbol_funcid2funcname(funcid);
+			printf("%-50s %-15"FMT_UINT64" %-15"FMT_UINT64" %-15"FMT_UINT64"\n",
+					funcname, profile.call_num,
+					profile.func_time/profile.call_num, profile.total_time/profile.call_num);
+		}
+		printf("****************\n");
+	}
+
+#ifdef CONFIG_STAT_PERF
+	/* cpu exec */
+	{
+		int i;
+		OpCodeId code_id;
+		uint64 total_elaps = 0;
+		printf("%-15s %-10s %-15s %-15s\n", "code_id", "max", "total", "count");
+		for (code_id = 0; code_id < OP_EXEC_TABLE_NUM; code_id++) {
+			printf("%-15s %-10"FMT_UINT64" %-15"FMT_UINT64" %-15"FMT_UINT64"\n",
+					op_exec_string_table[code_id].code_name,
+					op_exec_stat_table[code_id].max,
+					op_exec_stat_table[code_id].total/1000,
+					op_exec_stat_table[code_id].count);
+			total_elaps += op_exec_stat_table[code_id].total;
+		}
+		printf("cpu_instr_total_elaps=%-10"FMT_UINT64"\n", total_elaps/1000);
+		printf("cpuemu_cpu_total_prof max=%-10"FMT_UINT64" total=%-10"FMT_UINT64"count=%-10"FMT_UINT64"\n", 
+			cpuemu_cpu_total_prof.max, cpuemu_cpu_total_prof.total/1000, cpuemu_cpu_total_prof.count);
+		printf("cpuemu_dev_total_prof max=%-10"FMT_UINT64" total=%-10"FMT_UINT64"count=%-10"FMT_UINT64"\n", 
+			cpuemu_dev_total_prof.max, cpuemu_dev_total_prof.total/1000, cpuemu_dev_total_prof.count);
+		for (i = 0; i < DEBUG_STAT_NUM; i++) {
+			printf("cpuemu_dbg%d_total_prof max=%-10"FMT_UINT64" total=%-10"FMT_UINT64"count=%-10"FMT_UINT64"\n", i, 
+				cpuemu_dbg_total_prof[i].max, cpuemu_dbg_total_prof[i].total/1000, cpuemu_dbg_total_prof[i].count);
+		}
+		printf("cpuemu_dev_timer_prof max=%-10"FMT_UINT64" total=%-10"FMT_UINT64"count=%-10"FMT_UINT64"\n", 
+			cpuemu_dev_timer_prof.max, cpuemu_dev_timer_prof.total/1000, cpuemu_dev_timer_prof.count);
+		printf("cpuemu_dev_serial_prof max=%-10"FMT_UINT64" total=%-10"FMT_UINT64"count=%-10"FMT_UINT64"\n", 
+			cpuemu_dev_serial_prof.max, cpuemu_dev_serial_prof.total/1000, cpuemu_dev_serial_prof.count);
+		printf("cpuemu_dev_intr_prof max=%-10"FMT_UINT64" total=%-10"FMT_UINT64"count=%-10"FMT_UINT64"\n", 
+			cpuemu_dev_intr_prof.max, cpuemu_dev_intr_prof.total/1000, cpuemu_dev_intr_prof.count);
+		printf("cpuemu_dev_adev1_prof max=%-10"FMT_UINT64" total=%-10"FMT_UINT64"count=%-10"FMT_UINT64"\n", 
+			cpuemu_dev_adev1_prof.max, cpuemu_dev_adev1_prof.total/1000, cpuemu_dev_adev1_prof.count);
+		printf("cpuemu_dev_adev2_prof max=%-10"FMT_UINT64" total=%-10"FMT_UINT64"count=%-10"FMT_UINT64"\n", 
+			cpuemu_dev_adev2_prof.max, cpuemu_dev_adev2_prof.total/1000, cpuemu_dev_adev2_prof.count);
+		printf("cpuemu_tool1_prof max=%-10"FMT_UINT64" total=%-10"FMT_UINT64"count=%-10"FMT_UINT64"\n", 
+			cpuemu_tool1_prof.max, cpuemu_tool1_prof.total/1000, cpuemu_tool1_prof.count);
+		printf("cpuemu_tool2_prof max=%-10"FMT_UINT64" total=%-10"FMT_UINT64"count=%-10"FMT_UINT64"\n", 
+			cpuemu_tool2_prof.max, cpuemu_tool2_prof.total/1000, cpuemu_tool2_prof.count);
+		memset(op_exec_stat_table, 0, sizeof(op_exec_stat_table));
+		memset(&cpuemu_cpu_total_prof, 0, sizeof(cpuemu_cpu_total_prof));
+		memset(&cpuemu_dev_total_prof, 0, sizeof(cpuemu_dev_total_prof));
+		memset(cpuemu_dbg_total_prof, 0, sizeof(cpuemu_dbg_total_prof));
+		memset(&cpuemu_dev_timer_prof, 0, sizeof(cpuemu_dev_timer_prof));
+		memset(&cpuemu_dev_serial_prof, 0, sizeof(cpuemu_dev_serial_prof));
+		memset(&cpuemu_dev_intr_prof, 0, sizeof(cpuemu_dev_intr_prof));
+		memset(&cpuemu_dev_adev1_prof, 0, sizeof(cpuemu_dev_intr_prof));
+		memset(&cpuemu_dev_adev2_prof, 0, sizeof(cpuemu_dev_intr_prof));
+		memset(&cpuemu_tool1_prof, 0, sizeof(cpuemu_dev_intr_prof));
+		memset(&cpuemu_tool2_prof, 0, sizeof(cpuemu_dev_intr_prof));
+	}
+#endif /* CONFIG_STAT_PERF */
+	CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "OK\n"));
+
+	return;
+}
+void dbg_std_executor_help(void *executor)
+{
+	int i;
+	int j;
+	DbgCmdExecutorType *arg = (DbgCmdExecutorType *)executor;
+	DbgCmdExecutorHelpType *parsed_args = (DbgCmdExecutorHelpType *)(arg->parsed_args);
+
+	printf("LIst of commands:\n");
+	for (i = 0; i < parsed_args->arg->cmd_num; i++) {
+		if (parsed_args->arg->cmd[i].name_shortcut != NULL) {
+			printf(" * %s(%s):\n", parsed_args->arg->cmd[i].name->str, parsed_args->arg->cmd[i].name_shortcut->str);
+		}
+		else {
+			printf(" * %s(%s):\n", parsed_args->arg->cmd[i].name->str, "-");
+		}
+		for (j = 0; j < parsed_args->arg->cmd[i].opt_num; j++) {
+			printf("   %u) %s\n", j+1, parsed_args->arg->cmd[i].opts[j].semantics);
+			printf("      %s\n", parsed_args->arg->cmd[i].opts[j].description);
+		}
+	}
+
+	CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "OK\n"));
+
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/debugger/executor/concrete_executor/dbg_std_executor.h
@@ -0,0 +1,32 @@
+#ifndef _DBG_STD_EXECUTOR_H_
+#define _DBG_STD_EXECUTOR_H_
+
+extern void dbg_std_executor_parse_error(void *executor);
+extern void dbg_std_executor_break(void *executor);
+extern void dbg_std_executor_delete(void *executor);
+extern void dbg_std_executor_cont(void *executor);
+extern void dbg_std_executor_core(void *executor);
+extern void dbg_std_executor_watch_data(void *executor);
+extern void dbg_std_executor_intr(void *executor);
+
+extern void dbg_std_executor_next(void *executor);
+extern void dbg_std_executor_return(void *executor);
+extern void dbg_std_executor_quit(void *executor);
+extern void dbg_std_executor_exit(void *executor);
+
+extern void dbg_std_executor_elaps(void *executor);
+extern void dbg_std_executor_view(void *executor);
+extern void dbg_std_executor_print(void *executor);
+extern void dbg_std_executor_memset(void *executor);
+
+extern void dbg_std_executor_serialin(void *executor);
+extern void dbg_std_executor_info_cpu(void *executor);
+extern void dbg_std_executor_func_trace(void *executor);
+extern void dbg_std_executor_data_access_info(void *executor);
+extern void dbg_std_executor_back_trace(void *executor);
+extern void dbg_std_executor_profile(void *executor);
+extern void dbg_std_executor_list(void *executor);
+extern void dbg_std_executor_help(void *executor);
+
+
+#endif /* _DBG_STD_EXECUTOR_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/debugger/executor/concrete_executor/target/dbg_target_cpu.h
@@ -0,0 +1,9 @@
+#ifndef _DBG_TARGET_CPU_H_
+#define _DBG_TARGET_CPU_H_
+
+#include "std_types.h"
+
+extern void dbg_target_print_cpu(uint32 core_id);
+extern void cpu_debug_print_mpu_status(uint32 core_id);
+
+#endif /* _DBG_TARGET_CPU_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/debugger/executor/concrete_executor/target/dbg_target_serial.h
@@ -0,0 +1,23 @@
+#ifndef _DBG_TARGET_SERIAL_H_
+#define _DBG_TARGET_SERIAL_H_
+
+#include "std_types.h"
+#include "std_errno.h"
+
+extern Std_ReturnType dbg_serial_in(uint8 channel, uint8 data);
+
+extern bool dbg_serial_getchar(uint8 channel, uint8 *data);
+extern bool dbg_serial_putchar(uint8 channel, uint8 data);
+
+extern bool dbg_serial_getchar_file(uint8 channel, uint8 *data);
+extern bool dbg_serial_putchar_file(uint8 channel, uint8 data);
+extern void dbg_serial_flush_file(uint8 channel);
+
+
+extern Std_ReturnType dbg_serial_init_tcp(uint8 channel_num);
+extern Std_ReturnType dbg_serial_open_tcp(uint8 channel, uint32 server_portno);
+extern bool dbg_serial_getchar_tcp(uint8 channel, uint8 *data);
+extern bool dbg_serial_putchar_tcp(uint8 channel, uint8 data);
+
+
+#endif /* _DBG_TARGET_SERIAL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/debugger/executor/concrete_executor/util/dbg_print_data_type.c
@@ -0,0 +1,591 @@
+#include "concrete_executor/util/dbg_print_data_type.h"
+#include "dwarf/data_type/elf_dwarf_data_type.h"
+#include "dwarf/data_type/elf_dwarf_base_type.h"
+#include "dwarf/elf_dwarf_loc.h"
+#include "dwarf/elf_section.h"
+#include "cpu.h"
+#include "symbol_ops.h"
+#include "cpuemu_ops.h"
+#include <stdio.h>
+#include "target/target_os_api.h"
+
+typedef struct {
+	uint32 vaddr;
+	uint32 level;
+} PrintControlType;
+
+static bool print_any_data_type(PrintControlType *ctrl, DwarfDataType *obj, uint8 *top_addr, uint32 off);
+static void print_ref_typename(PrintControlType *ctrl, DwarfDataType *type);
+static uint32 get_ref_typesize(PrintControlType *ctrl, DwarfDataType *type);
+
+static void print_base_type_address(uint8 *addr, uint32 size)
+{
+	uint32 value;
+	value = elf_get_data32(addr, 0);
+	printf("0x%x", value);
+	return;
+}
+static void print_base_type_boolean(uint8 *addr, uint32 size)
+{
+	uint32 value = 0;
+	switch (size) {
+	case 1:
+		value = elf_get_data8(addr, 0);
+		break;
+	case 2:
+		value = elf_get_data16(addr, 0);
+		break;
+	case 4:
+		value = elf_get_data32(addr, 0);
+		break;
+	default:
+		break;
+	}
+	if (value == 0) {
+		printf("FALSE");
+	}
+	else {
+		printf("TRUE");
+	}
+	return;
+}
+static void print_base_type_signed(uint8 *addr, uint32 size)
+{
+	sint32 value = 0;
+	sint64 value64 = 0;
+	switch (size) {
+	case 1:
+		value = ((sint8)elf_get_data8(addr, 0));
+		break;
+	case 2:
+		value = ((sint16)elf_get_data16(addr, 0));
+		break;
+	case 4:
+		value = ((sint32)elf_get_data32(addr, 0));
+		break;
+	case 8:
+		value64 = ((sint64)elf_get_data64(addr, 0));
+		printf(PRINT_FMT_SINT64, value64);
+		return;
+	default:
+		break;
+	}
+	printf("%d", value);
+	if (size == 1) {
+		printf("(%c)", value);
+	}
+	return;
+}
+static void print_base_type_unsigned(uint8 *addr, uint32 size)
+{
+	sint32 value = 0;
+	uint64 value64 = 0;
+	switch (size) {
+	case 1:
+		value = ((uint8)elf_get_data8(addr, 0));
+		break;
+	case 2:
+		value = ((uint16)elf_get_data16(addr, 0));
+		break;
+	case 4:
+		value = ((uint32)elf_get_data32(addr, 0));
+		break;
+	case 8:
+		value64 = ((uint64)elf_get_data64(addr, 0));
+		printf(PRINT_FMT_UINT64, value64);
+		return;
+	default:
+		break;
+	}
+	printf("%u", value);
+	return;
+}
+
+static void print_base_type_float(uint8 *addr, uint32 size)
+{
+	float32 value32 = 0;
+	float64 value64 = 0;
+	switch (size) {
+	case 4:
+		value32 = elf_get_float32(addr, 0);
+		printf("%lf", value32);
+		break;
+	case 8:
+		value64 = elf_get_float64(addr, 0);
+		printf("%lf", value64);
+		return;
+	default:
+		break;
+	}
+	return;
+}
+static void print_base_type_data(PrintControlType *ctrl, DwarfDataBaseType *obj, uint8 *addr, uint32 off)
+{
+	uint32 type_size = obj->info.size;
+	switch (obj->encoding) {
+	case DW_ATE_address:
+		print_base_type_address(&addr[off], type_size);
+		break;
+	case DW_ATE_boolean:
+		print_base_type_boolean(&addr[off], type_size);
+		break;
+	case DW_ATE_signed:
+	case DW_ATE_signed_char:
+		print_base_type_signed(&addr[off], type_size);
+		break;
+	case DW_ATE_unsigned:
+	case DW_ATE_unsigned_char:
+		print_base_type_unsigned(&addr[off], type_size);
+		break;
+	case DW_ATE_float:
+		//TODO
+		print_base_type_float(&addr[off], type_size);
+		break;
+	case DW_ATE_complex_float:
+	default:
+		printf("Unknown base type");
+		break;
+	}
+	printf(" (%s:%u) @ 0x%x(0x%x)\n", obj->info.typename, type_size, ctrl->vaddr + off, off);
+	return;
+}
+static void print_space(PrintControlType *ctrl)
+{
+	int space_i;
+	for (space_i = 0; space_i < (ctrl->level); space_i++) {
+		printf("  ");
+	}
+	return;
+}
+
+static void print_struct_type_data(PrintControlType *ctrl, DwarfDataStructType *type, uint8 *top_addr, uint32 off)
+{
+	int i;
+
+	printf("struct %s { \n", type->info.typename);
+	for (i = 0; i < type->members->current_array_size; i++) {
+		DwarfDataStructMember *memp = (DwarfDataStructMember *)type->members->data[i];
+		print_space(ctrl);
+		printf("%s = ", memp->name);
+		(void)print_any_data_type(ctrl, memp->ref, top_addr, off + memp->off);
+	}
+	print_space(ctrl);
+	printf("}\n");
+	return;
+}
+static void print_class_type_data(PrintControlType *ctrl, DwarfDataStructType *type, uint8 *top_addr, uint32 off)
+{
+	int i;
+
+	printf("class %s { \n", type->info.typename);
+	if (type->members == NULL) {
+		goto done;
+	}
+	for (i = 0; i < type->members->current_array_size; i++) {
+		DwarfDataStructMember *memp = (DwarfDataStructMember *)type->members->data[i];
+		print_space(ctrl);
+		if (memp->ref != NULL) {
+			printf("%s = ", memp->name);
+			(void)print_any_data_type(ctrl, memp->ref, top_addr, off + memp->off);
+		}
+		else if (memp->linkage_name != NULL) {
+			printf("%s = ", memp->name);
+			printf("%s\n", memp->linkage_name);
+		}
+	}
+done:
+	print_space(ctrl);
+	printf("}\n");
+	return;
+}
+
+static void print_typedef_type_data(PrintControlType *ctrl, DwarfDataTypedefType *type, uint8 *top_addr, uint32 off)
+{
+	if (type->ref == NULL) {
+		printf("ERROR:not found die ref (typedef %s )... please use resolved type.\n", type->info.typename);
+		return;
+	}
+	printf("(typedef %s )", type->info.typename);
+	print_any_data_type(ctrl, type->ref, top_addr, off);
+	return;
+}
+
+static void print_ref_base_typename(PrintControlType *ctrl, DwarfDataBaseType *type)
+{
+	printf("%s", type->info.typename);
+	return;
+}
+static void print_ref_enum_typename(PrintControlType *ctrl, DwarfDataEnumulatorType *type)
+{
+#if 0
+	int i;
+	printf("enum %s {\n", type->info.typename);
+	for (i = 0; i < type->members->current_array_size; i++) {
+		DwarfDataEnumMember *memp = (DwarfDataEnumMember *)type->members->data[i];
+		print_space(ctrl);
+		printf("%s\n", memp->name);
+	}
+	printf("}");
+#else
+	printf("enum %s", type->info.typename);
+#endif
+	return;
+}
+
+static void print_ref_pointer_typename(PrintControlType *ctrl, DwarfDataPointerType *type)
+{
+	if (type->ref == NULL) {
+		printf("Unknown type");
+		return;
+	}
+	print_ref_typename(ctrl, type->ref);
+	printf(" *");
+	return;
+}
+static void print_ref_typedef_typename(PrintControlType *ctrl, DwarfDataTypedefType *type)
+{
+	printf("%s", type->info.typename);
+	return;
+}
+static void print_ref_struct_typename(PrintControlType *ctrl, DwarfDataStructType *type)
+{
+	printf("struct %s", type->info.typename);
+	return;
+}
+
+static void print_ref_typename(PrintControlType *ctrl, DwarfDataType *type)
+{
+	switch (type->type) {
+	case DATA_TYPE_BASE:
+		print_ref_base_typename(ctrl, (DwarfDataBaseType *)type);
+		break;
+	case DATA_TYPE_ENUM:
+		print_ref_enum_typename(ctrl, (DwarfDataEnumulatorType *)type);
+		break;
+	case DATA_TYPE_POINTER:
+		print_ref_pointer_typename(ctrl, (DwarfDataPointerType *)type);
+		break;
+	case DATA_TYPE_TYPEDEF:
+		print_ref_typedef_typename(ctrl, (DwarfDataTypedefType *)type);
+		break;
+	case DATA_TYPE_STRUCT:
+		print_ref_struct_typename(ctrl, (DwarfDataStructType *)type);
+		break;
+	case DATA_TYPE_ARRAY:
+		//TODO
+		break;
+	case DATA_TYPE_UNION:
+		break;
+	default:
+		break;
+	}
+	return;
+}
+
+
+static uint32 get_ref_base_typesize(PrintControlType *ctrl, DwarfDataBaseType *type)
+{
+	return type->info.size;
+}
+static uint32 get_ref_enum_typesize(PrintControlType *ctrl, DwarfDataEnumulatorType *type)
+{
+	return type->info.size;
+}
+static uint32 get_ref_pointer_typesize(PrintControlType *ctrl, DwarfDataPointerType *type)
+{
+	return type->info.size;
+}
+static uint32 get_ref_typedef_typesize(PrintControlType *ctrl, DwarfDataTypedefType *type)
+{
+	return get_ref_typesize(ctrl, type->ref);
+}
+static uint32 get_ref_struct_typesize(PrintControlType *ctrl, DwarfDataStructType *type)
+{
+	return type->info.size;
+}
+static uint32 get_ref_array_typesize(PrintControlType *ctrl, DwarfDataArrayType *type)
+{
+	return type->info.size;
+}
+static uint32 get_ref_typesize(PrintControlType *ctrl, DwarfDataType *type)
+{
+	switch (type->type) {
+	case DATA_TYPE_BASE:
+		return get_ref_base_typesize(ctrl, (DwarfDataBaseType *)type);
+	case DATA_TYPE_ENUM:
+		return get_ref_enum_typesize(ctrl, (DwarfDataEnumulatorType *)type);
+	case DATA_TYPE_POINTER:
+		return get_ref_pointer_typesize(ctrl, (DwarfDataPointerType *)type);
+	case DATA_TYPE_TYPEDEF:
+		return get_ref_typedef_typesize(ctrl, (DwarfDataTypedefType *)type);
+	case DATA_TYPE_STRUCT:
+		return get_ref_struct_typesize(ctrl, (DwarfDataStructType *)type);
+	case DATA_TYPE_ARRAY:
+		return get_ref_array_typesize(ctrl, (DwarfDataArrayType *)type);
+	case DATA_TYPE_UNION:
+		//TODO
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static void print_pointer_type_data(PrintControlType *ctrl, DwarfDataPointerType *type, uint8 *top_addr, uint32 off)
+{
+	printf("(");
+	print_ref_typename(ctrl, (DwarfDataType *)type);
+	printf(": %u )", type->info.size);
+	printf(" 0x%x", elf_get_data32(&top_addr[off], 0));
+	printf("  @ 0x%x(0x%x)\n", ctrl->vaddr + off, off);
+	return;
+}
+
+static void print_enum_type_data(PrintControlType *ctrl, DwarfDataEnumulatorType *type, uint8 *top_addr, uint32 off)
+{
+	int i;
+	DwarfDataEnumMember *memp = NULL;
+	uint32 value;
+	uint32 type_size = type->info.size;
+
+	switch (type_size) {
+	case 1:
+		value = elf_get_data8(&top_addr[off], 0);
+		break;
+	case 2:
+		value = elf_get_data16(&top_addr[off], 0);
+		break;
+	case 4:
+		value = elf_get_data32(&top_addr[off], 0);
+		break;
+	default:
+		printf("unknown enum\n");
+		return;
+	}
+
+	for (i = 0; i < type->members->current_array_size; i++) {
+		memp = (DwarfDataEnumMember *)type->members->data[i];
+		if (memp->const_value == value) {
+			printf("%s.%s(%d)", type->info.typename, memp->name, memp->const_value);
+			printf("  @ 0x%x(0x%x)\n", ctrl->vaddr + off, off);
+			return;
+		}
+	}
+	printf("unknown enum\n");
+
+	return;
+}
+
+static void print_array_type_data(PrintControlType *ctrl, DwarfDataArrayType *type, uint8 *top_addr, uint32 off)
+{
+	uint32 roff;
+	int i;
+	int j;
+	int dim_size;
+	int total_num = 1;
+	int typesize;
+	static int stack_level = 0;
+	static ElfPointerArrayType *stack = NULL;
+	DwarfUint32ArrayType *dims;
+
+	if (stack == NULL) {
+		stack = elf_array_alloc();
+	}
+	if (stack_level >= stack->current_array_size) {
+		dims = dwarf_uint32_array_alloc();
+		elf_array_add_entry(stack, dims);
+	}
+	else {
+		dims = stack->data[stack_level];
+	}
+
+	/*
+	 * 初期化
+	 */
+	typesize = get_ref_typesize(ctrl, type->ref);
+	dim_size = type->dimension->current_array_size;
+	dims->current_array_size = 0;
+	for (i = 0; i < dim_size; i++) {
+		dwarf_uint32_array_add_entry(dims, 0);
+		total_num *= type->dimension->data[i];
+	}
+
+	print_space(ctrl);
+	printf("( ");
+	print_ref_typename(ctrl, type->ref);
+	printf(" ) = { \n");
+
+	for (j = 0; j < total_num; j++) {
+		roff = (j * typesize);
+		//インデックス表示
+		print_space(ctrl);
+		printf("  ");
+		for (i = 0; i < dim_size; i++) {
+			printf("[%u]", dims->data[i]);
+		}
+		printf(" = ");
+		//値表示
+		ctrl->level++;
+		stack_level++;
+		print_any_data_type(ctrl, type->ref, top_addr, off + roff);
+		stack_level--;
+		ctrl->level--;
+		//ctrl->current_addr += type->ref->size;
+
+		//桁上げ計算
+		for (i = dim_size - 1; i >= 0; i--) {
+			dims->data[i]++;
+			if (i == 0) {
+				break;
+			}
+			else if (dims->data[i] >= type->dimension->data[i]) {
+				dims->data[i] = 0;
+			}
+			else {
+				break;
+			}
+		}
+
+	}
+	print_space(ctrl);
+	printf("}\n");
+	return;
+}
+static bool print_any_data_type(PrintControlType *ctrl, DwarfDataType *obj, uint8 *top_addr, uint32 off)
+{
+	bool ret = FALSE;
+	//printf("print_any_data_type:obj=0x%p\n", obj);
+
+	switch (obj->type) {
+	case DATA_TYPE_BASE:
+		print_base_type_data(ctrl, (DwarfDataBaseType *)obj, top_addr, off);
+		ret = TRUE;
+		break;
+	case DATA_TYPE_ENUM:
+		print_enum_type_data(ctrl, (DwarfDataEnumulatorType *)obj, top_addr, off);
+		break;
+	case DATA_TYPE_POINTER:
+		print_pointer_type_data(ctrl, (DwarfDataPointerType *)obj, top_addr, off);
+		ret = TRUE;
+		break;
+	case DATA_TYPE_TYPEDEF:
+		print_typedef_type_data(ctrl, (DwarfDataTypedefType *)obj, top_addr, off);
+		ret = TRUE;
+		break;
+	case DATA_TYPE_STRUCT:
+		ctrl->level++;
+		print_struct_type_data(ctrl, (DwarfDataStructType *)obj, top_addr, off);
+		ctrl->level--;
+		ret = TRUE;
+		break;
+	case DATA_TYPE_CLASS:
+		ctrl->level++;
+		print_class_type_data(ctrl, (DwarfDataStructType *)obj, top_addr, off);
+		ctrl->level--;
+		ret = TRUE;
+		break;
+	case DATA_TYPE_ARRAY:
+		//ctrl->level++;
+		print_array_type_data(ctrl, (DwarfDataArrayType *)obj, top_addr, off);
+		//ctrl->level--;
+		ret = TRUE;
+		break;
+	case DATA_TYPE_UNION:
+		//TODO
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+
+bool print_local_variable_type(char *variable_name)
+{
+	DwarfDataSubprogramType *subprogram;
+	DwarfLocalVariableType *localVariable;
+	PrintControlType ctrl;
+	uint8 *top_addr;
+	sint32 vaddr;
+	uint32 pc = cpu_get_current_core_pc();
+	int funcId;
+	uint32 funcaddr;
+	char *func_Name;
+	bool needPrint = TRUE;
+
+	funcId = symbol_pc2funcid(pc, &funcaddr);
+	if (funcId < 0) {
+		printf("not found pc=0x%x\n", pc);
+		return FALSE;
+	}
+	func_Name = symbol_funcid2funcname(funcId);
+	printf("func=%s\n", func_Name);
+
+	subprogram = elf_dwarf_search_subprogram(func_Name);
+	if (subprogram == NULL) {
+		return FALSE;
+	}
+	localVariable = elf_dwarf_search_local_variable(subprogram, variable_name);
+	if (localVariable == NULL) {
+		printf("ERROR not found local_val=%s\n", variable_name);
+		return FALSE;
+	}
+	printf("val=%s\n", localVariable->name);
+
+	needPrint = printLocalValueV850(subprogram, localVariable, pc, funcaddr, (uint32*)&vaddr);
+
+	if (needPrint == TRUE) {
+		ctrl.vaddr = (uint32)((sint32)(vaddr + localVariable->stackLocOff));
+		ctrl.level = 0;
+		cpuemu_get_addr_pointer(ctrl.vaddr, &top_addr);
+		printf("%s = ", variable_name);
+		return print_any_data_type(&ctrl, localVariable->ref, top_addr, 0);
+	}
+	return needPrint;
+}
+
+
+bool print_variable_with_data_type(char *variable_name, uint32 vaddr, uint8 *top_addr, uint32 size)
+{
+	DwarfDataVariableType *variable;
+	DwarfDataType *type;
+	PrintControlType ctrl;
+
+	variable = (DwarfDataVariableType *)dwarf_search_data_type(DATA_TYPE_VARIABLE, NULL, NULL, variable_name);
+	if (variable == NULL || variable->ref == NULL) {
+		return FALSE;
+	}
+	//printf("%s(%p) 0x%x ref=0x%x type=0x%x\n", variable->info.typename, variable, variable->info.die->offset, variable->ref->die->offset, variable->ref->type);
+	type = (DwarfDataType *)dwarf_search_data_type_from_die(variable->ref->type, variable->ref->die->offset);
+	if (type == NULL) {
+		return FALSE;
+	}
+	ctrl.vaddr = vaddr;
+	ctrl.level = 0;
+	printf("%s = ", variable_name);
+	return print_any_data_type(&ctrl, type, top_addr, 0);
+}
+
+bool print_addr_with_data_type(uint32 vaddr, uint8 *top_addr, char* dataType, char* dataTypeName)
+{
+	PrintControlType ctrl;
+	DwarfDataType *type;
+	ctrl.vaddr = vaddr;
+	ctrl.level = 0;
+
+	if (dataType[0] == 's') {
+		type = (DwarfDataType *)dwarf_search_data_type(DATA_TYPE_STRUCT, NULL, NULL, dataTypeName);
+	}
+	else if (dataType[0] == 'c') {
+		type = (DwarfDataType *)dwarf_search_data_type(DATA_TYPE_CLASS, NULL, NULL, dataTypeName);
+	}
+	else {
+		type = (DwarfDataType *)dwarf_search_data_type(DATA_TYPE_TYPEDEF, NULL, NULL, dataTypeName);
+	}
+	if (type == NULL) {
+		printf("Not Found Type: %s %s\n", dataType, dataTypeName);
+		return FALSE;
+	}
+	return print_any_data_type(&ctrl, type, top_addr, 0);
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/debugger/executor/concrete_executor/util/dbg_print_data_type.h
@@ -0,0 +1,10 @@
+#ifndef _DBG_PRINT_DATA_TYPE_H_
+#define _DBG_PRINT_DATA_TYPE_H_
+
+#include "std_types.h"
+
+extern bool print_variable_with_data_type(char *variable_name, uint32 vaddr, uint8 *top_addr, uint32 size);
+extern bool print_addr_with_data_type(uint32 vaddr, uint8 *top_addr, char* dataType, char* dataTypeName);
+extern bool print_local_variable_type(char *variable_name);
+
+#endif /* _DBG_PRINT_DATA_TYPE_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/debugger/executor/cpu_control/dbg_cpu_callback.c
@@ -0,0 +1,132 @@
+#include "cpu.h"
+#include "bus.h"
+#include "cpu_control/dbg_cpu_callback.h"
+#include "cpu_control/dbg_cpu_thread_control.h"
+#include "cpu_control/dbg_cpu_control.h"
+#include "cpuemu_ops.h"
+#include "cui/cui_ops.h"
+#include "symbol_ops.h"
+#include "file_address_mapping.h"
+
+void dbg_notify_cpu_clock_supply_start(const TargetCoreType *core)
+{
+	CoreIdType core_id;
+	bool need_stop = FALSE;
+	uint32 pc = cpu_get_pc(core);
+	bool is_debug_mode;
+
+
+	is_debug_mode = cpuctrl_is_debug_mode();
+
+	core_id = cpu_get_core_id(core);
+	if ((cpuctrl_is_force_debug_mode() == FALSE) && (dbg_cpu_debug_mode_get(core_id) == FALSE)) {
+		return;
+	}
+	/*
+	 * cont timeout check
+	 * break point check
+	 * debug mode check
+	 */
+	if (cpuctrl_is_timeout_cont_clocks(core_id) == TRUE) {
+		need_stop = TRUE;
+		printf("\nCONT TIMEOUT\n");
+		//printf("[DBG>");
+	}
+	else if ((cpuctrl_is_break_point(pc) == TRUE)) {
+		 uint32 funcaddr;
+		 int funcid;
+		 need_stop = TRUE;
+		 funcid = symbol_pc2funcid(pc, &funcaddr);
+		 if (funcid >= 0) {
+			 printf("\nHIT break:0x%x %s(+0x%x)\n", pc, symbol_funcid2funcname(funcid), pc - funcaddr);
+		 }
+		 else {
+			 printf("\nHIT break:0x%x\n", pc);
+		 }
+
+	}
+	else if (is_debug_mode == TRUE) {
+		need_stop = TRUE;
+	}
+
+	if (need_stop == TRUE) {
+		ValueFileType value;
+		Std_ReturnType err = file_address_mapping_get(pc, &value);
+		dbg_cpu_control_print_source(pc);
+		if (err == STD_E_OK) {
+			CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "%s %u\n", value.file, value.line));
+		}
+		else {
+			CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "OK\n"));
+		}
+		//fflush(stdout);
+		//CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "core[%u].pc = 0x%x\n", cpu_get_core_id(core), pc));
+		cpuctrl_set_current_debugged_core(cpu_get_core_id(core));
+		cpuctrl_set_debug_mode(TRUE);
+		dbg_log_sync();
+		/*
+		 * return コマンド実行時の一時的なブレークポイントを削除する．
+		 */
+		cpuctrl_del_all_break(BREAK_POINT_TYPE_ONLY_ONCE);
+		cputhr_control_cpu_wait();
+	}
+	return;
+}
+
+void dbg_notify_cpu_clock_supply_end(const TargetCoreType *core, const DbgCpuCallbackFuncEnableType *enable_dbg)
+{
+	uint32 pc = cpu_get_pc(core);
+	uint32 sp = cpu_get_sp(core);
+	BusAccessType type;
+	uint32 size;
+	uint32 access_addr;
+	bool need_stop = FALSE;
+
+	/*
+	 * call callback
+	 */
+	if (enable_dbg->enable_ft == TRUE) {
+		cpuctrl_set_func_log_trace(core->core_id, pc, sp);
+	}
+	if (enable_dbg->enable_prof == TRUE) {
+		cpuctrl_profile_collect(core->core_id, pc);
+	}
+	if (enable_dbg->enable_bt == TRUE) {
+		cpuctrl_set_stack_pointer(sp);
+	}
+	if (enable_dbg->enable_watch == TRUE) {
+		/*
+		 * data watch check
+		 */
+		while (TRUE) {
+			int inx;
+			Std_ReturnType err;
+			uint32 last_data;
+
+			err = bus_access_get_log(&type, &size, &access_addr, &last_data);
+			if (err != STD_E_OK) {
+				break;
+			}
+			if (type == BUS_ACCESS_TYPE_READ) {
+				inx = cpuctrl_is_break_read_access(access_addr, size);
+				if (inx >= 0) {
+					need_stop = TRUE;
+					printf("\nore%d HIT watch data : read access : [%u] 0x%x 0x%x %u\n", core->core_id, inx, access_addr, last_data, size);
+				}
+			}
+			else if (type == BUS_ACCESS_TYPE_WRITE) {
+				inx = cpuctrl_is_break_write_access(access_addr, size);
+				if (inx >= 0) {
+					need_stop = TRUE;
+					printf("\ncore%d HIT watch data : write access : [%u] 0x%x 0x%x %u\n", core->core_id, inx, access_addr, last_data, size);
+				}
+			}
+		}
+
+		if (need_stop == TRUE) {
+			cpuctrl_set_debug_mode(TRUE);
+		}
+	}
+
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/debugger/executor/cpu_control/dbg_cpu_callback.h
@@ -0,0 +1,31 @@
+#ifndef _DBG_CPU_CALLBACK_H_
+#define _DBG_CPU_CALLBACK_H_
+
+#include "std_types.h"
+#include "cpu_config.h"
+#include "target_cpu.h"
+#include "dbg_log.h"
+
+typedef struct {
+	uint32 enable_ft;
+	uint32 enable_bt;
+	uint32 enable_prof;
+	uint32 enable_watch;
+	/*
+	 * enable sync real time and virtual time.
+	 */
+	uint32 enable_sync_time;
+	uint32 show_skip_time;
+	uint32 reset_pc;
+} DbgCpuCallbackFuncEnableType;
+
+extern void dbg_notify_cpu_clock_supply_start(const TargetCoreType *core);
+extern void dbg_notify_cpu_clock_supply_end(const TargetCoreType *core, const DbgCpuCallbackFuncEnableType *enable_dbg);
+
+extern std_bool private_cpuemu_is_cui_mode;
+
+static inline std_bool cpuemu_cui_mode(void)
+{
+	return private_cpuemu_is_cui_mode;
+}
+#endif /* _DBG_CPU_CALLBACK_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/debugger/executor/cpu_control/dbg_cpu_control.c
@@ -0,0 +1,958 @@
+#include "cpu_control/dbg_cpu_control.h"
+#include "cpu.h"
+#include "cpu_config.h"
+#include "symbol_ops.h"
+#include "assert.h"
+#include "file.h"
+#include "cpuemu_ops.h"
+#include "std_errno.h"
+#include "mpu_types.h"
+#include <stdlib.h>
+#include <string.h>
+
+typedef struct {
+	bool 				is_set;
+	BreakPointEumType	type;
+	uint32 				addr;
+} DbgCpuCtrlBreakPointType;
+
+static int dbg_cpuctrl_break_points_num = 0U;
+DbgCpuCtrlBreakPointType dbg_cpuctrl_break_points[DBG_CPU_CONTROL_BREAK_SETSIZE] = {
+		{ TRUE, BREAK_POINT_TYPE_FOREVER, 0x00 },
+};
+
+typedef struct {
+	bool					is_set;
+	DataWatchPointEumType	type;
+	uint32					addr;
+	uint32					size;
+} DbgCpuCtrlDataWatchType;
+DbgCpuCtrlDataWatchType dbg_cpuctrl_data_watch_points[DBG_CPU_CONTROL_WATCH_DATA_SETSIZE];
+
+typedef enum {
+	DBG_CPUCTRL_DBG_MODE_NONE = 0,
+	DBG_CPUCTRL_DBG_MODE_NORMAL,
+	DBG_CPUCTRL_DBG_MODE_FORCE
+} DbgCpuctrlDbgModeType;
+DbgCpuctrlDbgModeType dbg_cpuctrl_dbg_mode = DBG_CPUCTRL_DBG_MODE_NORMAL;
+
+typedef struct {
+	bool is_stopped;
+	CoreIdType core_id;
+} DbgCpuStoppedCoreType;
+DbgCpuStoppedCoreType dbg_cpu_stopped_core;
+
+typedef struct {
+	bool	is_timeout;
+	uint64 	cont_clocks;
+} DbgCpuContType;
+
+static DbgCpuContType dbg_cpu_cont[CPU_CONFIG_CORE_NUM];
+
+typedef struct {
+	bool is_debug_mode;
+} DbgCpuDebugModeType;
+static DbgCpuDebugModeType dbg_cpu_debug_mode[CPU_CONFIG_CORE_NUM];
+void dbg_cpu_debug_mode_set(uint32 core_id, bool dbg_mode)
+{
+	dbg_cpu_debug_mode[core_id].is_debug_mode = dbg_mode;
+	return;
+}
+bool dbg_cpu_debug_mode_get(uint32 core_id)
+{
+	return dbg_cpu_debug_mode[core_id].is_debug_mode;
+}
+
+static int current_funcid;
+static uint32 current_pc;
+static uint32 current_sp;
+static uint32 current_access_glid = -1;
+
+void dbg_cpu_callback_start(uint32 pc, uint32 sp)
+{
+	uint32 funcpc;
+	current_pc = pc;
+	current_funcid = symbol_pc2funcid(pc, &funcpc);
+	current_sp = sp;
+	return;
+}
+void dbg_cpu_callback_start_nodbg(uint32 pc, uint32 sp)
+{
+	current_pc = pc;
+	current_sp = sp;
+	return;
+}
+
+typedef struct {
+	uint32 sp;
+	uint32 funcid;
+	uint32 funcoff;
+	uint32 funcpc;
+	char *funcname;
+} DbgFuncLogTraceEntryType;
+
+typedef struct {
+	uint32	current;
+	uint32	lognum;
+	uint32	logmax;
+	DbgFuncLogTraceEntryType *entry_array;
+} DbgFuncLogTraceType;
+
+static DbgFuncLogTraceType dbg_func_log_trace[CPU_CONFIG_CORE_NUM];
+
+#include "file.h"
+#include "file_address_mapping.h"
+static FileType dbg_std_executor_file;
+
+static char *search_filepath(char *dir, char *file)
+{
+	uint32 param_num;
+	uint32 i;
+	Std_ReturnType err;
+	char *candiate_path;
+	static char buffer[4096];
+	static char parameter[4096];
+
+	//printf("%s\n", dir);
+	snprintf(buffer, sizeof(buffer), "%s/%s", dir, file);
+	if (file_exist(buffer) == TRUE) {
+		return buffer;
+	}
+	err = cpuemu_get_devcfg_value("EDITOR_SEARCH_PATH_NUM", &param_num);
+	if (err != STD_E_OK) {
+		return NULL;
+	}
+	//printf("param_num=%d\n", param_num);
+	for (i = 0; i < param_num; i++) {
+		snprintf(parameter, sizeof(parameter), "EDITOR_SEARCH_PATH_%d", i);
+		err = cpuemu_get_devcfg_string(parameter, &candiate_path);
+		if (err != STD_E_OK) {
+			printf("not found param=%s\n", parameter);
+			return NULL;
+		}
+		snprintf(buffer, sizeof(buffer), "%s/%s/%s", candiate_path, dir, file);
+		if (candiate_path[0] == '/') {
+			candiate_path[0] = candiate_path[1];
+			candiate_path[1] = ':';
+		}
+		//printf("%s = %s %s\n", parameter, candiate_path, buffer);
+		if (file_exist(buffer) == TRUE) {
+			return buffer;
+		}
+	}
+	return NULL;
+}
+
+void dbg_cpu_control_print_source(uint32 pc)
+{
+	Std_ReturnType err = STD_E_OK;
+	ValueFileType value;
+	err = file_address_mapping_get(pc, &value);
+	if (err == STD_E_OK) {
+		char *path = search_filepath(value.dir, value.file);
+		if (path != NULL) {
+			token_string_set(&dbg_std_executor_file.filepath, "./arg_sakura.txt");
+			file_wopen(&dbg_std_executor_file);
+#ifdef OS_LINUX
+			int len = snprintf((char*)dbg_std_executor_file.buffer,
+					sizeof(dbg_std_executor_file.buffer),
+					"-l %u %s\n", value.line, path);
+#else
+			int len = snprintf((char*)dbg_std_executor_file.buffer,
+					sizeof(dbg_std_executor_file.buffer),
+					"-Y=%u %s\n", value.line, path);
+#endif
+			file_putline(&dbg_std_executor_file, (char*)dbg_std_executor_file.buffer, len);
+			file_close(&dbg_std_executor_file);
+			printf("[NEXT> pc=0x%x %s %u\n", pc, value.file, value.line);
+			/*
+			 * サクラエディタが常にフォーカスされてしまい，デバッグを阻害するため，コメントアウト
+			 */
+			//dbg_cpu_control_update_editor();
+		}
+	}
+	else {
+		printf("Not found symbole pc=0x%x\n", pc);
+	}
+	return;
+}
+char *dbg_cpu_control_get_print_args(void)
+{
+	return (char*)dbg_std_executor_file.buffer;
+}
+void dbg_cpu_control_update_editor(void)
+{
+	char cmd[256];
+#ifdef OS_LINUX
+	snprintf(cmd, sizeof(cmd), "geany.sh");
+#else
+	snprintf(cmd, sizeof(cmd), "sh sakura.sh");
+#endif
+	if (system(cmd) < 0) {
+		printf("can not execute sakura\n");
+	}
+	return;
+}
+
+
+/*
+ * データ×アクセス関数マッピング表
+ */
+static DataAccessInfoType *data_access_info;
+static DataAccessInfoType **data_access_info_table_gl;
+
+DataAccessInfoType *cpuctrl_get_func_access_info_table(const char* glname)
+{
+	uint32 addr;
+	uint32 size;
+	int glid;
+	glid = symbol_get_gl((char*)glname, strlen(glname), &addr, &size);
+	if (glid < 0) {
+		return NULL;
+	}
+	return data_access_info_table_gl[glid];
+}
+DataAccessInfoType *cpuctrl_get_func_access_info_table_glid(uint32 glid)
+{
+	return data_access_info_table_gl[glid];
+}
+static void cpuctrl_init_func_log_trace(void)
+{
+	uint32 coreId;
+	uint32 entry_num = DBG_FUNCLOG_TRACE_SIZE;
+
+	(void)cpuemu_get_devcfg_value("DEBUG_FUNC_FT_LOG_SIZE", (uint32*)&entry_num);
+	printf("DEBUG_FUNC_FT_LOG_SIZE=%u\n", entry_num);
+
+	for (coreId = 0; coreId < cpu_config_get_core_id_num(); coreId++) {
+		dbg_func_log_trace[coreId].entry_array = malloc(sizeof(DbgFuncLogTraceEntryType) * entry_num);
+		ASSERT(dbg_func_log_trace[coreId].entry_array != NULL);
+		dbg_func_log_trace[coreId].logmax = entry_num;
+		dbg_func_log_trace[coreId].lognum = 0;
+		dbg_func_log_trace[coreId].current = 0;
+	}
+	return;
+}
+
+void cpuctrl_set_func_log_trace(uint32 coreId, uint32 pc, uint32 sp)
+{
+	uint32 inx;
+	uint32 next;
+	uint32 funcpc;
+	char *funcname;
+	int funcid;
+
+	funcid = symbol_pc2funcid(pc, &funcpc);
+	if (funcid < 0) {
+		return;
+	}
+	funcname = symbol_funcid2funcname(funcid);
+
+	if (dbg_func_log_trace[coreId].lognum > 0) {
+		inx = dbg_func_log_trace[coreId].current;
+		if (dbg_func_log_trace[coreId].entry_array[inx].funcpc == funcpc) {
+			return;
+		}
+		next = inx + 1;
+		if (next >= dbg_func_log_trace[coreId].logmax) {
+			next = 0;
+		}
+	} else {
+		next = 0;
+	}
+
+	dbg_func_log_trace[coreId].current = next;
+	dbg_func_log_trace[coreId].entry_array[next].sp = sp;
+	dbg_func_log_trace[coreId].entry_array[next].funcid = funcid;
+	dbg_func_log_trace[coreId].entry_array[next].funcoff = pc - funcpc;
+	dbg_func_log_trace[coreId].entry_array[next].funcname = funcname;
+	dbg_func_log_trace[coreId].entry_array[next].funcpc = funcpc;
+	if (dbg_func_log_trace[coreId].lognum < dbg_func_log_trace[coreId].logmax) {
+		dbg_func_log_trace[coreId].lognum++;
+	}
+	return;
+}
+uint32 cpuctrl_get_func_log_trace_num(uint32 coreId)
+{
+	return dbg_func_log_trace[coreId].lognum;
+}
+
+char *cpuctrl_get_func_log_trace_info(uint32 coreId, uint32 bt_number, uint32 *funcpcoff, uint32 *funcid, uint32 *sp)
+{
+	int off;
+	if (bt_number >= dbg_func_log_trace[coreId].logmax) {
+		return NULL;
+	}
+	if (bt_number >= dbg_func_log_trace[coreId].lognum) {
+		return NULL;
+	}
+
+	if (dbg_func_log_trace[coreId].current >= bt_number) {
+		off = dbg_func_log_trace[coreId].current - bt_number;
+	}
+	else {
+		off = dbg_func_log_trace[coreId].logmax - (bt_number - dbg_func_log_trace[coreId].current);
+	}
+	*sp = dbg_func_log_trace[coreId].entry_array[off].sp;
+	*funcid = dbg_func_log_trace[coreId].entry_array[off].funcid;
+	*funcpcoff = dbg_func_log_trace[coreId].entry_array[off].funcoff;
+	return dbg_func_log_trace[coreId].entry_array[off].funcname;
+
+}
+
+void cpuctrl_set_cont_clocks(bool is_timeout, uint64 cont_clocks)
+{
+	dbg_cpu_cont[dbg_cpu_stopped_core.core_id].is_timeout = is_timeout;
+	dbg_cpu_cont[dbg_cpu_stopped_core.core_id].cont_clocks = cont_clocks;
+	return;
+}
+bool cpuctrl_is_timeout_cont_clocks(CoreIdType core_id)
+{
+	if (dbg_cpu_cont[core_id].is_timeout == TRUE) {
+		if (dbg_cpu_cont[core_id].cont_clocks > 1) {
+			dbg_cpu_cont[core_id].cont_clocks--;
+			return FALSE;
+		}
+		return TRUE;
+	}
+	else {
+		return FALSE;
+
+	}
+}
+
+void cpuctrl_set_current_debugged_core(CoreIdType core_id)
+{
+	dbg_cpu_stopped_core.is_stopped = TRUE;
+	dbg_cpu_stopped_core.core_id = core_id;
+	return;
+}
+bool cpuctrl_get_current_debugged_core(CoreIdType *core_id)
+{
+	if (dbg_cpu_stopped_core.is_stopped == TRUE) {
+		*core_id = dbg_cpu_stopped_core.core_id;
+		return TRUE;
+	}
+	return FALSE;
+}
+void cpuctrl_clr_current_debugged_core(void)
+{
+	dbg_cpu_stopped_core.is_stopped = FALSE;
+	return;
+}
+
+
+static DbgCpuCtrlBreakPointType *search_free_break_point_space(void)
+{
+	uint32 i;
+	for (i = 0; i < DBG_CPU_CONTROL_BREAK_SETSIZE; i++) {
+		if (dbg_cpuctrl_break_points[i].is_set == FALSE) {
+			return &dbg_cpuctrl_break_points[i];
+		}
+	}
+	return NULL;
+}
+
+static DbgCpuCtrlBreakPointType *search_break_point(uint32 addr)
+{
+	uint32 i;
+	for (i = 0; i < DBG_CPU_CONTROL_BREAK_SETSIZE; i++) {
+		if (dbg_cpuctrl_break_points[i].is_set == FALSE) {
+			continue;
+		}
+		else if (dbg_cpuctrl_break_points[i].addr == addr) {
+			return &dbg_cpuctrl_break_points[i];
+		}
+	}
+	return NULL;
+}
+
+static DbgCpuCtrlBreakPointType *search_break_point_with_type(uint32 addr, BreakPointEumType type)
+{
+	uint32 i;
+	for (i = 0; i < DBG_CPU_CONTROL_BREAK_SETSIZE; i++) {
+		if (dbg_cpuctrl_break_points[i].is_set == FALSE) {
+			continue;
+		}
+		else if (dbg_cpuctrl_break_points[i].type != type) {
+			continue;
+		}
+		else if (dbg_cpuctrl_break_points[i].addr == addr) {
+			return &dbg_cpuctrl_break_points[i];
+		}
+	}
+	return NULL;
+}
+
+bool cpuctrl_get_break(uint32 index, uint32 *addrp)
+{
+	if (index >= DBG_CPU_CONTROL_BREAK_SETSIZE) {
+		return FALSE;
+	}
+	if (dbg_cpuctrl_break_points[index].is_set == FALSE) {
+		return FALSE;
+	}
+	*addrp = dbg_cpuctrl_break_points[index].addr;
+	return TRUE;
+}
+
+bool cpuctrl_is_break_point(uint32 addr)
+{
+	if (dbg_cpuctrl_break_points_num > 0) {
+		if (search_break_point(addr) != NULL) {
+			return TRUE;
+		}
+	}
+	else if (dbg_cpuctrl_break_points[0].addr == addr) {
+		return TRUE;
+	}
+	return FALSE;
+}
+
+bool cpuctrl_is_debug_mode(void)
+{
+	return (dbg_cpuctrl_dbg_mode != DBG_CPUCTRL_DBG_MODE_NONE);
+}
+
+bool cpuctrl_set_break(uint32 addr, BreakPointEumType type)
+{
+	DbgCpuCtrlBreakPointType *bp;
+	if (search_break_point_with_type(addr, type) != NULL) {
+		return TRUE;
+	}
+	bp = search_free_break_point_space();
+	if (bp != NULL) {
+		bp->type = type;
+		bp->is_set = TRUE;
+		bp->addr = addr;
+		if (type != BREAK_POINT_TYPE_ONLY_ONCE) {
+			dbg_cpuctrl_break_points_num++;
+		}
+		return TRUE;
+	}
+	return FALSE;
+}
+
+
+bool cpuctrl_del_break(uint32 index)
+{
+	if (index > 0) {
+		if (dbg_cpuctrl_break_points[index].is_set == TRUE) {
+			dbg_cpuctrl_break_points_num--;
+		}
+		dbg_cpuctrl_break_points[index].is_set = FALSE;
+		return TRUE;
+	}
+	return FALSE;
+}
+void cpuctrl_del_all_break(BreakPointEumType type)
+{
+	 uint32 i;
+	 for (i = 0; i < DBG_CPU_CONTROL_BREAK_SETSIZE; i++) {
+		 if (dbg_cpuctrl_break_points[i].type == type) {
+			 cpuctrl_del_break(i);
+		 }
+	 }
+	 if (type != BREAK_POINT_TYPE_ONLY_ONCE) {
+		 dbg_cpuctrl_break_points_num = 0;
+	 }
+	 return;
+}
+#ifndef SUPRESS_DETECT_WARNING_MESSAGE
+static bool data_access_object_write_filter(const void *p)
+{
+	DataAccessContextType *dp = (DataAccessContextType *)p;
+
+	if (dp->access_type == ACCESS_TYPE_WRITE) {
+		return TRUE;
+	}
+	return FALSE;
+}
+#endif /* SUPRESS_DETECT_WARNING_MESSAGE */
+
+static void cpuctrl_access_context_add(uint8 access_type, DataAccessInfoType *access_info)
+{
+	DataAccessContextType context;
+	int glid;
+	uint32 gladdr;
+	uint32 index = 0;
+	DataAccessContextType *dp = NULL;
+	CpuEmuElapsType elaps;
+	DataAccessInfoHeadType *acp = &access_info->head;
+
+	glid = symbol_addr2glid(current_sp, &gladdr);
+	if (glid < 0) {
+		return;
+	}
+
+	acp->access_num++;
+	if (acp->access_context == NULL) {
+		acp->access_context = object_container_create(sizeof(DataAccessContextType), 2U);
+	}
+
+	if ((access_info->region_type != READONLY_MEMORY) && (access_type == ACCESS_TYPE_READ)) {
+#ifndef SUPRESS_DETECT_WARNING_MESSAGE
+		void *write_objp = object_container_find_first(acp->access_context, data_access_object_write_filter);
+		if (write_objp == NULL) {
+			printf("WARNING: Unitialized data read : variable=>%s : %s()@%s\n",
+					symbol_glid2glname(current_access_glid),
+					symbol_funcid2funcname(current_funcid),
+					symbol_glid2glname(glid));
+		}
+#endif
+	}
+
+	context.access_type = access_type;
+	context.core_id = cpu_get_core_id((const TargetCoreType *)virtual_cpu.current_core);
+	context.sp = glid;
+	context.funcid = current_funcid;
+	//search context
+	do {
+		dp = object_container_get_element(acp->access_context, index);
+		if (dp != NULL) {
+			if ((dp->access_type == context.access_type)
+					&& (dp->core_id == context.core_id)
+					&& (dp->sp == context.sp)
+					&& (dp->funcid == context.funcid)) {
+				break;
+			}
+		}
+		index++;
+	} while (dp != NULL);
+
+	if (dp == NULL) {
+		dp = object_container_create_element(acp->access_context);
+		dp->access_type = access_type;
+		dp->access_num = 0;
+		dp->core_id = context.core_id;
+		dp->sp = context.sp;
+		dp->funcid = context.funcid;
+	}
+	//printf("gladdr=0x%x glid=%u access_type=%u\n", gladdr, glid, access_type);
+
+	dp->access_num++;
+	cpuemu_get_elaps(&elaps);
+	dp->access_time = elaps.total_clocks;
+
+	return;
+}
+static void cpuctrl_set_access(uint32 access_type, uint32 access_addr, uint32 size)
+{
+	uint32 i;
+	sint32 prev_glid = -1;
+	sint32 glid;
+	uint32 gladdr;
+	DataAccessInfoType *access_infop;
+#ifndef SUPRESS_DETECT_WARNING_MESSAGE
+	bool found = FALSE;
+#endif
+
+	for (i = 0; i < size; i++) {
+		glid = symbol_addr2glid(access_addr + i, &gladdr);
+		if (glid < 0) {
+			continue;
+		}
+		if (glid == prev_glid) {
+			continue;
+		}
+#ifndef SUPRESS_DETECT_WARNING_MESSAGE
+		found = TRUE;
+#endif
+		current_access_glid = glid;
+		access_infop = data_access_info_table_gl[glid];
+		if (access_infop == NULL) {
+			continue;
+		}
+		cpuctrl_access_context_add(access_type, access_infop);
+		prev_glid = glid;
+	}
+
+#ifndef SUPRESS_DETECT_WARNING_MESSAGE
+	/*
+	 * invalid region access detection
+	 */
+	if ((found == FALSE) && (access_type == ACCESS_TYPE_WRITE)) {
+		bool is_malloc;
+		MpuAddressRegionEnumType type = mpu_address_region_type_get(access_addr, &is_malloc);
+
+		if ((type != DEVICE) && (is_malloc == FALSE)) {
+			uint32 gladdr;
+			int stack_glid = symbol_addr2glid(current_sp, &gladdr);
+
+			printf("WARNING: Found invalid data write on not variable region(addr=0x%x size=%u) : %s(0x%x)@%s\n",
+					access_addr, size,
+					symbol_funcid2funcname(current_funcid),
+					current_pc,
+					(stack_glid > 0) ? symbol_glid2glname(stack_glid) : "unknown_stack");
+		}
+	}
+#endif
+	return;
+}
+bool cpu_may_store_on_stack_overflow(uint32 start_addr, uint32 size)
+{
+	uint32 i;
+	sint32 glid;
+	uint32 gladdr;
+
+	int stack_glid = symbol_addr2glid(current_sp, &gladdr);
+
+	for (i = 0; i < size; i++) {
+		glid = symbol_addr2glid(start_addr + i, &gladdr);
+		if (glid != stack_glid) {
+			//printf("i=%d glid=%s stack_glid=%s\n", i, symbol_glid2glname(glid), symbol_glid2glname(stack_glid));
+			printf("ERROR: Found invalid data write over stack(addr=0x%x size=%u) : %s(0x%x)@%s\n",
+					start_addr, size,
+					symbol_funcid2funcname(current_funcid),
+					current_pc,
+					(stack_glid > 0) ? symbol_glid2glname(stack_glid) : "unknown_stack");
+			return TRUE;
+		}
+	}
+	return FALSE;
+}
+
+int cpuctrl_is_break_read_access(uint32 access_addr, uint32 size)
+{
+	uint32 i;
+	uint32 watch_start;
+	uint32 watch_end;
+	uint32 access_end = access_addr + size;
+
+	cpuctrl_set_access(ACCESS_TYPE_READ, access_addr, size);
+
+	for (i = 0; i < DBG_CPU_CONTROL_WATCH_DATA_SETSIZE; i++) {
+		if (dbg_cpuctrl_data_watch_points[i].is_set == FALSE) {
+			continue;
+		}
+		if (dbg_cpuctrl_data_watch_points[i].type == DATA_WATCH_POINT_TYPE_WRITE) {
+			continue;
+		}
+		watch_start = dbg_cpuctrl_data_watch_points[i].addr;
+		watch_end = watch_start + dbg_cpuctrl_data_watch_points[i].size;
+		if (access_end <= watch_start) {
+			continue;
+		}
+		else if (access_addr >= watch_end) {
+			continue;
+		}
+		return i;
+	}
+	return -1;
+}
+
+int cpuctrl_is_break_write_access(uint32 access_addr, uint32 size)
+{
+	uint32 i;
+	uint32 watch_start;
+	uint32 watch_end;
+	uint32 access_end = access_addr + size;
+
+	cpuctrl_set_access(ACCESS_TYPE_WRITE, access_addr, size);
+
+	for (i = 0; i < DBG_CPU_CONTROL_WATCH_DATA_SETSIZE; i++) {
+		if (dbg_cpuctrl_data_watch_points[i].is_set == FALSE) {
+			continue;
+		}
+		if (dbg_cpuctrl_data_watch_points[i].type == DATA_WATCH_POINT_TYPE_READ) {
+			continue;
+		}
+		watch_start = dbg_cpuctrl_data_watch_points[i].addr;
+		watch_end = watch_start + dbg_cpuctrl_data_watch_points[i].size;
+		if (access_end <= watch_start) {
+			continue;
+		}
+		else if (access_addr >= watch_end) {
+			continue;
+		}
+		//printf("watch_start=0x%x watch_end=0x%x\n", watch_start, watch_end);
+		//printf("acces_start=0x%x acces_end=0x%x\n", access_addr, access_end);
+		return i;
+	}
+	return -1;
+}
+bool cpuctrl_get_data_watch_point(uint32 index, uint32 *addrp, uint32 *sizep, DataWatchPointEumType *type)
+{
+	if (index >= DBG_CPU_CONTROL_WATCH_DATA_SETSIZE) {
+		return FALSE;
+	}
+	if (dbg_cpuctrl_data_watch_points[index].is_set == FALSE) {
+		return FALSE;
+	}
+	*addrp = dbg_cpuctrl_data_watch_points[index].addr;
+	*sizep = dbg_cpuctrl_data_watch_points[index].size;
+	*type = dbg_cpuctrl_data_watch_points[index].type;
+	return TRUE;
+}
+
+bool cpuctrl_set_data_watch(DataWatchPointEumType watch_type, uint32 addr, uint32 size)
+{
+	uint32 i;
+	/*
+	 * 既存のものを探し，上書きする
+	 */
+	for (i = 0; i < DBG_CPU_CONTROL_WATCH_DATA_SETSIZE; i++) {
+		if (dbg_cpuctrl_data_watch_points[i].is_set == FALSE) {
+			continue;
+		}
+		if (dbg_cpuctrl_data_watch_points[i].addr == addr) {
+			dbg_cpuctrl_data_watch_points[i].type = watch_type;
+			dbg_cpuctrl_data_watch_points[i].addr = addr;
+			dbg_cpuctrl_data_watch_points[i].size = size;
+			return TRUE;
+		}
+	}
+	/*
+	 * 既存のものがない場合は，新規設定する
+	 */
+	for (i = 0; i < DBG_CPU_CONTROL_WATCH_DATA_SETSIZE; i++) {
+		if (dbg_cpuctrl_data_watch_points[i].is_set == FALSE) {
+			dbg_cpuctrl_data_watch_points[i].is_set = TRUE;
+			dbg_cpuctrl_data_watch_points[i].type = watch_type;
+			dbg_cpuctrl_data_watch_points[i].addr = addr;
+			dbg_cpuctrl_data_watch_points[i].size = size;
+			return TRUE;
+		}
+	}
+	return FALSE;
+}
+bool cpuctrl_del_data_watch_point(uint32 delno)
+{
+	if (delno >= DBG_CPU_CONTROL_WATCH_DATA_SETSIZE) {
+		return FALSE;
+	}
+	dbg_cpuctrl_data_watch_points[delno].is_set = FALSE;
+	return TRUE;
+}
+void cpuctrl_del_all_data_watch_points(void)
+{
+	uint32 i;
+
+	for (i = 0; i < DBG_CPU_CONTROL_WATCH_DATA_SETSIZE; i++) {
+		cpuctrl_del_data_watch_point(i);
+	}
+	return;
+}
+
+
+void cpuctrl_set_debug_mode(bool on)
+{
+	if (on == TRUE) {
+		/*
+		 * CPU ==> DBG
+		 */
+#ifdef OS_LINUX
+		if (dbg_cpuctrl_dbg_mode != DBG_CPUCTRL_DBG_MODE_NORMAL) {
+			cpuemu_end_elaps();
+		}
+#endif /* OS_LINUX */
+		dbg_cpuctrl_dbg_mode = DBG_CPUCTRL_DBG_MODE_NORMAL;
+	}
+	else {
+		/*
+		 * DBG ==> CPU
+		 */
+#ifdef OS_LINUX
+		if (dbg_cpuctrl_dbg_mode != DBG_CPUCTRL_DBG_MODE_NONE) {
+			cpuemu_start_elaps();
+		}
+#endif /* OS_LINUX */
+		dbg_cpuctrl_dbg_mode = DBG_CPUCTRL_DBG_MODE_NONE;
+	}
+	return;
+}
+void cpuctrl_set_force_break(void)
+{
+	cpuctrl_set_debug_mode(TRUE);
+
+	return;
+}
+bool cpuctrl_is_force_debug_mode(void)
+{
+	return (dbg_cpuctrl_dbg_mode == DBG_CPUCTRL_DBG_MODE_FORCE);
+}
+void cpuctrl_set_force_debug_mode(void)
+{
+	dbg_cpuctrl_dbg_mode = DBG_CPUCTRL_DBG_MODE_FORCE;
+	return;
+}
+
+/*
+ * profile機能
+ */
+static CpuProfileType *CpuProfile[CPU_CONFIG_CORE_NUM];
+typedef struct {
+	uint32	prev_funcid;
+	uint32	current_funcid;
+} CpuProfileCurrentInfoType;
+static CpuProfileCurrentInfoType CpuProfileCurrentInfo[CPU_CONFIG_CORE_NUM];
+
+static void cpuctrl_init_func_log_trace(void);
+
+void cpuctrl_init(void)
+{
+	uint32 i;
+	uint32 func_num = symbol_get_func_num();
+	uint32 gl_num = symbol_get_gl_num();
+	uint32 coreId;
+
+
+	for (coreId = 0; coreId < cpu_config_get_core_id_num(); coreId++) {
+		CpuProfile[coreId] = malloc(func_num * sizeof(CpuProfileType));
+		ASSERT(CpuProfile[coreId] != NULL);
+		CpuProfileCurrentInfo[coreId].current_funcid = func_num;
+		memset(CpuProfile[coreId], 0, func_num * sizeof(CpuProfileType));
+	}
+
+	data_access_info = malloc(gl_num * sizeof(DataAccessInfoType));
+	ASSERT(data_access_info != NULL);
+	memset(data_access_info, 0, gl_num * sizeof(DataAccessInfoType));
+
+	//printf("data_access_info:start=%p\n", data_access_info);
+	//printf("data_access_info:end=%p\n", ((char*)data_access_info) + func_num * gl_num * sizeof(DataAccessInfoType));
+
+	data_access_info_table_gl = malloc(gl_num * sizeof(DataAccessInfoType *));
+	for (i = 0; i < gl_num; i++) {
+		uint32 type = mpu_address_region_type_get(symbol_glid2gladdr(i), NULL);
+		if (type != REGION_UNKNOWN) {
+			data_access_info[i].region_type = mpu_address_region_type_get(symbol_glid2gladdr(i), NULL);
+			data_access_info_table_gl[i] = &data_access_info[i];
+		}
+		else {
+			data_access_info[i].region_type = REGION_UNKNOWN;
+			data_access_info_table_gl[i] = NULL;
+		}
+	}
+	cpuctrl_init_func_log_trace();
+
+	return;
+}
+void cpuctrl_profile_collect(uint32 coreId, uint32 pc)
+{
+	int funcid;
+	uint32 funcpc;
+	uint32 funcaddr;
+	CpuEmuElapsType elaps;
+
+	funcid = symbol_pc2funcid(pc, &funcaddr);
+	if (funcid < 0) {
+		return;
+	}
+	cpuemu_get_elaps(&elaps);
+	funcpc = symbol_funcid2funcaddr(funcid);
+
+	if (pc == funcpc) {
+		/*
+		 * 関数入場
+		 */
+		CpuProfile[coreId][funcid].call_num++;
+
+		if (CpuProfile[coreId][funcid].recursive_num == 0U) {
+			/*
+			 * 初回入場
+			 */
+			CpuProfile[coreId][funcid].sp_func_enter = cpu_get_current_core_sp(); //TODO coreid
+			CpuProfile[coreId][funcid].start_time = elaps.total_clocks;
+			CpuProfile[coreId][funcid].recursive_num++;
+			//printf("func_enter:funcid=%s start_time=%I64u\n", symbol_funcid2funcname(funcid), CpuProfile[funcid].start_time);
+		}
+	}
+	else if (CpuProfileCurrentInfo[coreId].current_funcid != funcid) {
+		uint32 i;
+		uint32 func_num = symbol_get_func_num();
+
+		CpuProfileCurrentInfo[coreId].prev_funcid = CpuProfileCurrentInfo[coreId].current_funcid;
+
+		for (i = 0; i < func_num; i++) {
+			if (CpuProfile[coreId][i].recursive_num > 0) {
+				if (cpu_get_current_core_sp() == CpuProfile[coreId][i].sp_func_enter) {
+					/*
+					 * 最終退場
+					 */
+					CpuProfile[coreId][i].total_time += (elaps.total_clocks - CpuProfile[coreId][i].start_time);
+					CpuProfile[coreId][i].recursive_num--;
+					//printf("func_exit:funcid=%s ctime=%I64u\n", symbol_funcid2funcname(i), elaps.total_clocks);
+					//printf("func_exit:func_time=%Iu total_time=%Iu\n", CpuProfile[i].func_time, CpuProfile[i].total_time);
+					//printf("func_exit:stime=%I64u ", CpuProfile[i].start_time);
+					//printf("ctime=%I64u ", elaps.total_clocks);
+					//printf("ttime=%I64u\n", CpuProfile[i].total_time);
+					break;
+				}
+			}
+		}
+	}
+	CpuProfileCurrentInfo[coreId].current_funcid = funcid;
+	CpuProfile[coreId][funcid].func_time++;
+	return;
+}
+void cpuctrl_profile_get(uint32 coreId, uint32 funcid, CpuProfileType *profile)
+{
+	*profile = CpuProfile[coreId][funcid];
+	return;
+}
+/*
+ * 関数フレーム記録
+ */
+typedef struct {
+	uint32	current;
+	uint32	lognum;
+	uint32	sp[DBG_STACK_LOG_SIZE];
+} DbgFuncFrameType;
+static DbgFuncFrameType dbg_func_frame[DBG_STACK_NUM];
+
+void cpuctrl_set_stack_pointer(uint32 sp)
+{
+	uint32 inx;
+	uint32 next;
+	uint32 prev;
+	uint32 gladdr;
+	int glid;
+
+	glid = symbol_addr2glid(sp, &gladdr);
+	if (glid < 0) {
+		return;
+	}
+	if (dbg_func_frame[glid].lognum > 0) {
+		inx = dbg_func_frame[glid].current;
+		/*
+		 * 同じスタックポインタの場合は終了
+		 */
+		if (dbg_func_frame[glid].sp[inx] == sp) {
+			return;
+		}
+		/*
+		 * 一個前のスタックポインタの場合は縮小する．
+		 */
+		for (prev = 0; prev < dbg_func_frame[glid].lognum; prev++) {
+			if (dbg_func_frame[glid].sp[prev] == sp) {
+				dbg_func_frame[glid].lognum = prev + 1;
+				dbg_func_frame[glid].current = prev;
+				return;
+			}
+		}
+		/*
+		 * 新しいスタックポインタの場合は追加する
+		 */
+		next = inx + 1;
+		ASSERT(next <= DBG_STACK_LOG_SIZE);
+	} else {
+		next = 0;
+	}
+	dbg_func_frame[glid].current = next;
+	dbg_func_frame[glid].sp[next] = sp;
+	dbg_func_frame[glid].lognum++;
+	return;
+}
+
+Std_ReturnType cpuctrl_get_stack_pointer(int glid, uint32 bt_number, uint32 *sp)
+{
+	if (dbg_func_frame[glid].lognum <= 1) {
+		return STD_E_NOENT;
+	}
+
+	if (bt_number >= dbg_func_frame[glid].lognum) {
+		return STD_E_NOENT;
+	}
+	*sp = dbg_func_frame[glid].sp[bt_number];
+	return STD_E_OK;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/debugger/executor/cpu_control/dbg_cpu_control.h
@@ -0,0 +1,142 @@
+#ifndef _DBG_CPU_CONTROL_H_
+#define _DBG_CPU_CONTROL_H_
+
+#include "std_types.h"
+#include "object_container.h"
+
+/*
+ * 共通機能
+ */
+extern void cpuctrl_init(void);
+extern bool cpuctrl_is_debug_mode(void);
+extern void cpuctrl_set_debug_mode(bool on);
+
+extern bool cpuctrl_is_force_debug_mode(void);
+extern void cpuctrl_set_force_debug_mode(void);
+
+
+extern void cpuctrl_set_force_break(void);
+extern void cpuctrl_set_current_debugged_core(CoreIdType core_id);
+extern void cpuctrl_clr_current_debugged_core(void);
+extern bool cpuctrl_get_current_debugged_core(CoreIdType *core_id);
+extern void dbg_cpu_control_print_source(uint32 pc);
+extern char *dbg_cpu_control_get_print_args(void);
+extern void dbg_cpu_control_update_editor(void);
+extern void dbg_cpu_debug_mode_set(uint32 core_id, bool dbg_mode);
+extern bool dbg_cpu_debug_mode_get(uint32 core_id);
+extern void dbg_cpu_callback_start(uint32 pc, uint32 sp);
+extern void dbg_cpu_callback_start_nodbg(uint32 pc, uint32 sp);
+
+/*
+ * break機能
+ */
+#define DBG_CPU_CONTROL_BREAK_SETSIZE	128
+
+typedef enum {
+	BREAK_POINT_TYPE_FOREVER,
+	BREAK_POINT_TYPE_ONLY_ONCE,
+} BreakPointEumType;
+extern bool cpuctrl_is_break_point(uint32 addr);
+extern bool cpuctrl_get_break(uint32 index, uint32 *addrp);
+extern bool cpuctrl_set_break(uint32 addr, BreakPointEumType type);
+extern bool cpuctrl_del_break(uint32 index);
+extern void cpuctrl_del_all_break(BreakPointEumType type);
+
+/*
+ * データウォッチ機能
+ */
+#define DBG_CPU_CONTROL_WATCH_DATA_SETSIZE	128
+
+typedef enum {
+	DATA_WATCH_POINT_TYPE_READ,
+	DATA_WATCH_POINT_TYPE_WRITE,
+	DATA_WATCH_POINT_TYPE_RW,
+} DataWatchPointEumType;
+extern int cpuctrl_is_break_read_access(uint32 access_addr, uint32 size);
+extern int cpuctrl_is_break_write_access(uint32 access_addr, uint32 size);
+extern bool cpuctrl_get_data_watch_point(uint32 index, uint32 *addrp, uint32 *sizep, DataWatchPointEumType *type);
+extern bool cpuctrl_set_data_watch(DataWatchPointEumType watch_type, uint32 addr, uint32 size);
+extern bool cpuctrl_del_data_watch_point(uint32 delno);
+extern void cpuctrl_del_all_data_watch_points(void);
+
+#define ACCESS_TYPE_READ	0x01
+#define ACCESS_TYPE_WRITE	0x02
+/*
+ * データアクセス情報取得機能
+ */
+typedef struct {
+	uint8		access_type;
+	CoreIdType 	core_id;
+	uint32 		sp;
+	uint32		funcid;
+	uint64 		access_num;
+	uint64		access_time;
+} DataAccessContextType;
+typedef struct {
+	uint64					access_num;
+	ObjectContainerType		*access_context;
+} DataAccessInfoHeadType;
+typedef struct {
+	uint32						region_type;
+	DataAccessInfoHeadType		head;
+} DataAccessInfoType;
+
+extern DataAccessInfoType *cpuctrl_get_func_access_info_table(const char* glname);
+extern DataAccessInfoType *cpuctrl_get_func_access_info_table_glid(uint32 glid);
+
+/*
+ * cont機能
+ */
+extern void cpuctrl_set_cont_clocks(bool is_timeout, uint64 cont_clocks);
+extern bool cpuctrl_is_timeout_cont_clocks(CoreIdType core_id);
+
+/*
+ * 関数ログ機能
+ */
+#define DBG_FUNCLOG_TRACE_SIZE			1024
+extern void cpuctrl_set_func_log_trace(uint32 coreId, uint32 pc, uint32 sp);
+extern char *cpuctrl_get_func_log_trace_info(uint32 coreId, uint32 bt_number, uint32 *funcpcoff, uint32 *funcid, uint32 *sp);
+extern uint32 cpuctrl_get_func_log_trace_num(uint32 coreId);
+
+/*
+ * profile機能
+ */
+typedef struct {
+	/*
+	 * 呼び出し回数
+	 */
+	uint64 call_num;
+	/*
+	 * 関数呼び出し開始時の時間
+	 */
+	uint64 start_time;
+	/*
+	 * 最後にプログラムカウンタが関数内に滞留していた時間
+	 */
+	uint64 func_time;
+	/*
+	 * 関数が他関数を呼び出していた総合時間
+	 * 再起呼び出し時間は含める
+	 */
+	uint64 total_time;
+	/*
+	 * 再起呼び出し回数(一時管理用)
+	 */
+	uint64 recursive_num;
+	/*
+	 * 関数入場時のスタックポインタアドレス
+	 */
+	uint32 sp_func_enter;
+} CpuProfileType;
+extern void cpuctrl_profile_collect(uint32 coreId, uint32 pc);
+extern void cpuctrl_profile_get(uint32 coreId, uint32 funcid, CpuProfileType *profile);
+
+/*
+ * 関数フレーム記録
+ */
+#define DBG_STACK_LOG_SIZE				1024
+#define DBG_STACK_NUM					1024
+extern void cpuctrl_set_stack_pointer(uint32 sp);
+extern Std_ReturnType cpuctrl_get_stack_pointer(int glid, uint32 bt_number, uint32 *sp);
+
+#endif /* _DBG_CPU_CONTROL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/debugger/executor/cpu_control/dbg_cpu_thread_control.c
@@ -0,0 +1,130 @@
+#include "cpu_control/dbg_cpu_thread_control.h"
+#include "std_types.h"
+#include "target/target_os_api.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <sys/time.h>
+
+
+typedef enum {
+	THREAD_STATE_RUNNING,
+	THREAD_STATE_WAIT,
+} DbgCpuThrStateType;
+static pthread_mutex_t dbg_mutex;
+static pthread_cond_t dbg_cv;
+static pthread_cond_t cpu_cv;
+static volatile DbgCpuThrStateType dbgthr_state = THREAD_STATE_RUNNING;
+static volatile DbgCpuThrStateType cputhr_state = THREAD_STATE_WAIT;
+
+void cputhr_control_init(void)
+{
+	pthread_mutex_init(&dbg_mutex, NULL);
+	pthread_cond_init(&dbg_cv, NULL);
+	pthread_cond_init(&cpu_cv, NULL);
+	return;
+
+}
+#if 0 /* for test */
+#include "cpu.h"
+#include "cpu_control/dbg_cpu_callback.h"
+#include <stdio.h>
+#include <time.h>
+#include <sys/time.h>
+
+static void *cpuemu_thread_run(void* arg)
+{
+	TargetCoreType core;
+
+
+	core.core_id = 0;
+	core.reg.pc = 0;
+	while (TRUE) {
+		DBG_PRINT((DBG_EXEC_OP_BUF(), DBG_EXEC_OP_BUF_LEN(), "pc=0x%x\n", core.reg.pc));
+		fflush(stdout);
+
+		dbg_notify_cpu_clock_supply_start(&core);
+
+		Sleep(100);
+
+		core.reg.pc++;
+	}
+	return NULL;
+}
+#endif
+void cputhr_control_start(void *(*cpu_run) (void *))
+{
+	pthread_t thread;
+	cputhr_state = THREAD_STATE_RUNNING;
+	pthread_create(&thread , NULL , cpu_run , NULL);
+}
+
+
+void cputhr_control_cpu_wait(void)
+{
+	pthread_mutex_lock(&dbg_mutex);
+	cputhr_state = THREAD_STATE_WAIT;
+	pthread_cond_wait(&cpu_cv, &dbg_mutex);
+	cputhr_state = THREAD_STATE_RUNNING;
+	pthread_mutex_unlock(&dbg_mutex);
+	return;
+}
+void cputhr_control_dbg_wait(void)
+{
+	pthread_mutex_lock(&dbg_mutex);
+	dbgthr_state = THREAD_STATE_WAIT;
+	pthread_cond_wait(&dbg_cv, &dbg_mutex);
+	dbgthr_state = THREAD_STATE_RUNNING;
+	pthread_mutex_unlock(&dbg_mutex);
+	return;
+}
+
+void cputhr_control_dbg_wakeup_cpu_and_wait_for_cpu_stopped(void)
+{
+	pthread_mutex_lock(&dbg_mutex);
+	if (cputhr_state == THREAD_STATE_WAIT) {
+		cputhr_state = THREAD_STATE_RUNNING;
+		pthread_cond_signal(&cpu_cv);
+	}
+	while (cputhr_state == THREAD_STATE_RUNNING) {
+		pthread_mutex_unlock(&dbg_mutex);
+
+		target_os_api_sleep(50);
+
+		pthread_mutex_lock(&dbg_mutex);
+	}
+	pthread_mutex_unlock(&dbg_mutex);
+	return;
+}
+
+void cputhr_control_dbg_waitfor_cpu_stopped(void)
+{
+	pthread_mutex_lock(&dbg_mutex);
+	while (cputhr_state == THREAD_STATE_RUNNING) {
+		pthread_mutex_unlock(&dbg_mutex);
+
+		target_os_api_sleep(50);
+
+		pthread_mutex_lock(&dbg_mutex);
+	}
+	pthread_mutex_unlock(&dbg_mutex);
+	return;
+}
+
+void cputhr_control_dbg_wakeup_cpu(void)
+{
+	pthread_mutex_lock(&dbg_mutex);
+	pthread_cond_signal(&cpu_cv);
+	pthread_mutex_unlock(&dbg_mutex);
+}
+void cputhr_control_cpu_wakeup_dbg(void)
+{
+	pthread_mutex_lock(&dbg_mutex);
+	pthread_cond_signal(&dbg_cv);
+	pthread_mutex_unlock(&dbg_mutex);
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/debugger/executor/cpu_control/dbg_cpu_thread_control.h
@@ -0,0 +1,22 @@
+#ifndef _DBG_CPU_THREAD_CONTROL_H_
+#define _DBG_CPU_THREAD_CONTROL_H_
+
+extern void cputhr_control_init(void);
+extern void cputhr_control_start(void *(*cpu_run) (void *));
+
+/*
+ * for debugger
+ */
+extern void cputhr_control_dbg_waitfor_cpu_stopped(void);
+extern void cputhr_control_dbg_wakeup_cpu_and_wait_for_cpu_stopped(void);
+extern void cputhr_control_dbg_wait(void);
+extern void cputhr_control_dbg_wakeup_cpu(void);
+
+/*
+ * for cpu
+ */
+extern void cputhr_control_cpu_wait(void);
+extern void cputhr_control_cpu_wakeup_dbg(void);
+
+
+#endif /* _DBG_CPU_THREAD_CONTROL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/debugger/executor/dbg_executor.h
@@ -0,0 +1,19 @@
+#ifndef _DBG_EXECUTOR_H_
+#define _DBG_EXECUTOR_H_
+
+#include "dbg_interaction_std_ids.h"
+#include "dbg_interaction_target_ids.h"
+#include "std_types.h"
+
+
+#define DBG_CMD_BUFFER_SIZE		(4096*256U)
+typedef struct {
+	DbgCmdStdIdType			std_id;
+	DbgCmdTargetIdType		target_id;
+	uint8	original_str[DBG_CMD_BUFFER_SIZE];
+	uint8	parsed_args[DBG_CMD_BUFFER_SIZE];
+	void (*run) (void *executor);
+	bool result_ok;
+} DbgCmdExecutorType;
+
+#endif /* _DBG_EXECUTOR_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/debugger/interaction/front/parser/concrete_parser/dbg_std_parser.c
@@ -0,0 +1,1275 @@
+#include "front/parser/concrete_parser/dbg_std_parser.h"
+#include "concrete_executor/dbg_std_executor.h"
+#include "cpu_config.h"
+#include "cpu_config_ops.h"
+#include <string.h>
+
+/************************************************************************************
+ * break コマンド
+ *
+ *
+ ***********************************************************************************/
+static const TokenStringType break_string = {
+		.len = 5,
+		.str = { 'b', 'r', 'e', 'a', 'k', '\0' },
+};
+static const TokenStringType break_string_short = {
+		.len = 1,
+		.str = { 'b', '\0' },
+};
+
+
+static const TokenStringType break_info_string = {
+		.len = 4,
+		.str = { 'i', 'n', 'f', 'o', '\0' },
+};
+
+DbgCmdExecutorType *dbg_parse_break(DbgCmdExecutorType *arg, const TokenContainerType *token_container)
+{
+	DbgCmdExecutorBreakType *parsed_args = (DbgCmdExecutorBreakType *)arg->parsed_args;
+
+	if ((token_container->num != 2) && (token_container->num != 3)) {
+		return NULL;
+	}
+
+	if (token_container->array[0].type != TOKEN_TYPE_STRING) {
+		return NULL;
+	}
+
+	if ((token_strcmp(&token_container->array[0].body.str, &break_string) == TRUE) ||
+			(token_strcmp(&token_container->array[0].body.str, &break_string_short) == TRUE)) {
+		if (token_container->array[1].type == TOKEN_TYPE_VALUE_HEX) {
+			arg->std_id = DBG_CMD_STD_ID_BREAK;
+			arg->run = dbg_std_executor_break;
+			parsed_args->type = DBG_CMD_BBREAK_SET;
+			parsed_args->break_addr = token_container->array[1].body.hex.value;
+			return arg;
+		}
+		else if (token_container->array[1].type == TOKEN_TYPE_STRING) {
+			if (token_container->num == 2) {
+				arg->std_id = DBG_CMD_STD_ID_BREAK;
+				parsed_args->type = DBG_CMD_BBREAK_SET_SYMBOL;
+				parsed_args->symbol = token_container->array[1].body.str;
+				arg->run = dbg_std_executor_break;
+				return arg;
+			}
+			else if ((token_container->num == 3) && (token_container->array[2].type == TOKEN_TYPE_VALUE_DEC)) {
+				arg->std_id = DBG_CMD_STD_ID_BREAK;
+				parsed_args->type = DBG_CMD_BREAK_SET_FILE_LINE;
+				parsed_args->symbol = token_container->array[1].body.str;
+				parsed_args->line = token_container->array[2].body.dec.value;
+				arg->run = dbg_std_executor_break;
+				return arg;
+			}
+		}
+	}
+	else if (token_strcmp(&token_container->array[0].body.str, &break_info_string) == TRUE) {
+		if (token_strcmp(&token_container->array[1].body.str, &break_string) == TRUE) {
+			arg->std_id = DBG_CMD_STD_ID_BREAK;
+			arg->run = dbg_std_executor_break;
+			parsed_args->type = DBG_CMD_BREAK_INFO;
+			return arg;
+		}
+	}
+	return NULL;
+}
+
+/************************************************************************************
+ * watch コマンド
+ *
+ *
+ ***********************************************************************************/
+static const TokenStringType watch_string = {
+		.len = 5,
+		.str = { 'w', 'a', 't', 'c', 'h', '\0' },
+};
+static const TokenStringType watch_string_short = {
+		.len = 1,
+		.str = { 'w', '\0' },
+};
+static const TokenStringType watch_info_string = {
+		.len = 4,
+		.str = { 'i', 'n', 'f', 'o', '\0' },
+};
+static const TokenStringType watch_option_string_readset = {
+		.len = 1,
+		.str = { 'r', '\0' },
+};
+static const TokenStringType watch_option_string_writeset = {
+		.len = 1,
+		.str = { 'w', '\0' },
+};
+static const TokenStringType watch_option_string_rwset = {
+		.len = 2,
+		.str = { 'r', 'w', '\0' },
+};
+static const TokenStringType watch_option_string_delete = {
+		.len = 1,
+		.str = { 'd', '\0' },
+};
+
+DbgCmdExecutorType *dbg_parse_watch_data(DbgCmdExecutorType *arg, const TokenContainerType *token_container)
+{
+	DbgCmdExecutorWatchDataType *parsed_args = (DbgCmdExecutorWatchDataType *)arg->parsed_args;
+
+	if (token_container->num < 2) {
+		return NULL;
+	}
+
+	if (token_container->array[0].type != TOKEN_TYPE_STRING) {
+		return NULL;
+	}
+	if (token_container->array[1].type != TOKEN_TYPE_STRING) {
+		return NULL;
+	}
+
+	if ((token_strcmp(&token_container->array[0].body.str, &watch_string) == TRUE) ||
+			(token_strcmp(&token_container->array[0].body.str, &watch_string_short) == TRUE)) {
+		/*
+		 * delete
+		 */
+		if ((token_strcmp(&token_container->array[1].body.str, &watch_option_string_delete) == TRUE)) {
+			if (token_container->num == 2) {
+				arg->std_id = DBG_CMD_STD_ID_DATA_WATCH;
+				parsed_args->type = DBG_CMD_WATCH_DELETE_ALL;
+				arg->run = dbg_std_executor_watch_data;
+				return arg;
+			}
+			else if ((token_container->num == 3) && (token_container->array[2].type == TOKEN_TYPE_VALUE_DEC)) {
+				arg->std_id = DBG_CMD_STD_ID_DATA_WATCH;
+				parsed_args->type = DBG_CMD_WATCH_DELETE_ONE;
+				parsed_args->delno = token_container->array[2].body.dec.value;
+				arg->run = dbg_std_executor_watch_data;
+				return arg;
+			}
+		}
+		/*
+		 * set
+		 */
+		if ((token_strcmp(&token_container->array[1].body.str, &watch_option_string_readset) == TRUE)) {
+			parsed_args->watch_type = DBG_CMD_WATCH_TYPE_READ;
+		}
+		else if ((token_strcmp(&token_container->array[1].body.str, &watch_option_string_writeset) == TRUE)) {
+			parsed_args->watch_type = DBG_CMD_WATCH_TYPE_WRITE;
+		}
+		else if ((token_strcmp(&token_container->array[1].body.str, &watch_option_string_rwset) == TRUE)) {
+			parsed_args->watch_type = DBG_CMD_WATCH_TYPE_RW;
+		}
+		else {
+			return NULL;
+		}
+
+		/*
+		 * check symbol or addr/size
+		 */
+		if ((token_container->num == 3) &&
+				(token_container->array[2].type == TOKEN_TYPE_STRING)) {
+			arg->std_id = DBG_CMD_STD_ID_DATA_WATCH;
+			parsed_args->type = DBG_CMD_WATCH_SET_SYMBOL;
+			parsed_args->symbol = token_container->array[2].body.str;
+			arg->run = dbg_std_executor_watch_data;
+			return arg;
+		}
+		else if ((token_container->num == 4) &&
+				(token_container->array[2].type == TOKEN_TYPE_VALUE_HEX) &&
+				(token_container->array[3].type == TOKEN_TYPE_VALUE_DEC)) {
+			arg->std_id = DBG_CMD_STD_ID_DATA_WATCH;
+			parsed_args->type = DBG_CMD_WATCH_SET;
+			parsed_args->addr = token_container->array[2].body.hex.value;
+			parsed_args->size = token_container->array[3].body.dec.value;
+			arg->run = dbg_std_executor_watch_data;
+			return arg;
+		}
+	}
+	else if (token_strcmp(&token_container->array[0].body.str, &watch_info_string) == TRUE) {
+		if (token_strcmp(&token_container->array[1].body.str, &watch_string) == TRUE) {
+			arg->std_id = DBG_CMD_STD_ID_DATA_WATCH;
+			parsed_args->type = DBG_CMD_WATCH_INFO;
+			arg->run = dbg_std_executor_watch_data;
+			return arg;
+		}
+	}
+	return NULL;
+}
+/************************************************************************************
+ * delete コマンド
+ *
+ *
+ ***********************************************************************************/
+static const TokenStringType delete_string = {
+		.len = 6,
+		.str = { 'd', 'e', 'l', 'e', 't', 'e', '\0' },
+};
+static const TokenStringType delete_string_short = {
+		.len = 1,
+		.str = { 'd', '\0' },
+};
+
+DbgCmdExecutorType *dbg_parse_delete(DbgCmdExecutorType *arg, const TokenContainerType *token_container)
+{
+	DbgCmdExecutorDeleteType *parsed_args = (DbgCmdExecutorDeleteType *)arg->parsed_args;
+
+	if (token_container->num > 2) {
+		return NULL;
+	}
+
+	if (token_container->array[0].type != TOKEN_TYPE_STRING) {
+		return NULL;
+	}
+
+	if ((token_strcmp(&token_container->array[0].body.str, &delete_string) == TRUE) ||
+			(token_strcmp(&token_container->array[0].body.str, &delete_string_short) == TRUE)) {
+		if (token_container->num == 1) {
+			arg->std_id = DBG_CMD_STD_ID_DELETE;
+			parsed_args->type = DBG_CMD_DELETE_ALL;
+			arg->run = dbg_std_executor_delete;
+			return arg;
+		}
+		else if ((token_container->num == 2) &&  (token_container->array[1].type == TOKEN_TYPE_VALUE_DEC)) {
+			arg->std_id = DBG_CMD_STD_ID_DELETE;
+			parsed_args->type = DBG_CMD_DELETE_ONE;
+			parsed_args->delete_break_no = token_container->array[1].body.dec.value;
+			arg->run = dbg_std_executor_delete;
+			return arg;
+		}
+	}
+	return NULL;
+}
+
+
+/************************************************************************************
+ * cont コマンド
+ *
+ *
+ ***********************************************************************************/
+static const TokenStringType cont_string = {
+		.len = 4,
+		.str = { 'c', 'o', 'n', 't', '\0' },
+};
+static const TokenStringType cont_string_short = {
+		.len = 1,
+		.str = { 'c', '\0' },
+};
+
+DbgCmdExecutorType *dbg_parse_cont(DbgCmdExecutorType *arg, const TokenContainerType *token_container)
+{
+	DbgCmdExecutorContType *parsed_args = (DbgCmdExecutorContType *)arg->parsed_args;
+
+	if (token_container->num > 2) {
+		return NULL;
+	}
+
+	if (token_container->array[0].type != TOKEN_TYPE_STRING) {
+		return NULL;
+	}
+	if ((token_container->num == 2) &&
+			(token_container->array[1].type != TOKEN_TYPE_VALUE_DEC)) {
+		return NULL;
+	}
+
+
+	if ((token_strcmp(&token_container->array[0].body.str, &cont_string) == TRUE) ||
+			(token_strcmp(&token_container->array[0].body.str, &cont_string_short) == TRUE)) {
+		arg->std_id = DBG_CMD_STD_ID_CONT;
+		if (token_container->num == 1) {
+			parsed_args->type = DBG_CMD_CONT_ALL;
+		}
+		else {
+			parsed_args->type = DBG_CMD_CONT_CLOCKS;
+			parsed_args->cont_clocks = token_container->array[1].body.dec.value;
+		}
+		arg->run = dbg_std_executor_cont;
+		return arg;
+	}
+	return NULL;
+}
+
+
+/************************************************************************************
+ * core コマンド
+ *
+ *
+ ***********************************************************************************/
+static const TokenStringType core_string = {
+		.len = 4,
+		.str = { 'c', 'o', 'r', 'e', '\0' },
+};
+
+DbgCmdExecutorType *dbg_parse_core(DbgCmdExecutorType *arg, const TokenContainerType *token_container)
+{
+	DbgCmdExecutorCoreType *parsed_args = (DbgCmdExecutorCoreType *)arg->parsed_args;
+	TokenStringType cpu_all = {
+			.len = 3,
+			.str = { 'a', 'l', 'l', '\0' },
+	};
+	TokenStringType dbg_mode_true = {
+			.len = 1,
+			.str = { 't', '\0' },
+	};
+	if ((token_container->num != 1) && (token_container->num != 3)) {
+		return NULL;
+	}
+
+	if (token_container->array[0].type != TOKEN_TYPE_STRING) {
+		return NULL;
+	}
+	if ((token_container->num == 3)) {
+		if (token_container->array[1].type == TOKEN_TYPE_STRING) {
+			if (token_strcmp(&token_container->array[1].body.str, &cpu_all) == FALSE) {
+				return NULL;
+			}
+		}
+		else if (token_container->array[1].type != TOKEN_TYPE_VALUE_DEC) {
+			return NULL;
+		}
+		else if (token_container->array[1].body.dec.value >= cpu_config_get_core_id_num()){
+			return NULL;
+		}
+		if (token_container->array[2].type != TOKEN_TYPE_STRING) {
+			return NULL;
+		}
+	}
+
+	if ((token_strcmp(&token_container->array[0].body.str, &core_string) == TRUE)) {
+		arg->std_id = DBG_CMD_STD_ID_CORE;
+		if ((token_container->num == 3)) {
+			parsed_args->is_debug_mode = FALSE;
+			if (token_container->array[1].type == TOKEN_TYPE_STRING) {
+				parsed_args->type = DBG_CMD_CORE_ALL;
+				parsed_args->is_debug_mode = TRUE;
+				if (token_strcmp(&token_container->array[2].body.str, &dbg_mode_true) == FALSE) {
+					return NULL;
+				}
+			}
+			else {
+				parsed_args->type = DBG_CMD_CORE_SINGLE;
+				parsed_args->core_id = token_container->array[1].body.dec.value;
+				if (token_strcmp(&token_container->array[2].body.str, &dbg_mode_true) == TRUE) {
+					parsed_args->is_debug_mode = TRUE;
+				}
+			}
+		}
+		else {
+			parsed_args->type = DBG_CMD_CORE_SHOW;
+		}
+		arg->run = dbg_std_executor_core;
+		return arg;
+	}
+	return NULL;
+}
+
+/************************************************************************************
+ * intr コマンド
+ *
+ *
+ ***********************************************************************************/
+static const TokenStringType intr_string = {
+		.len = 4,
+		.str = { 'i', 'n', 't', 'r', '\0' },
+};
+static const TokenStringType intr_string_short = {
+		.len = 1,
+		.str = { 'i', '\0' },
+};
+
+DbgCmdExecutorType *dbg_parse_intr(DbgCmdExecutorType *arg, const TokenContainerType *token_container)
+{
+	DbgCmdExecutorIntrType *parsed_args = (DbgCmdExecutorIntrType *)arg->parsed_args;
+
+	if (token_container->num != 2) {
+		return NULL;
+	}
+
+	if (token_container->array[0].type != TOKEN_TYPE_STRING) {
+		return NULL;
+	}
+	if ((token_container->array[1].type != TOKEN_TYPE_VALUE_DEC)) {
+		return NULL;
+	}
+
+
+	if ((token_strcmp(&token_container->array[0].body.str, &intr_string) == TRUE) ||
+			(token_strcmp(&token_container->array[0].body.str, &intr_string_short) == TRUE)) {
+		arg->std_id = DBG_CMD_STD_ID_INTR;
+		parsed_args->intno = token_container->array[1].body.dec.value;
+		arg->run = dbg_std_executor_intr;
+		return arg;
+	}
+	return NULL;
+}
+
+
+
+/************************************************************************************
+ * elaps コマンド
+ *
+ *
+ ***********************************************************************************/
+static const TokenStringType elaps_string = {
+		.len = 5,
+		.str = { 'e', 'l', 'a', 'p', 's', '\0' },
+};
+static const TokenStringType elaps_string_short = {
+		.len = 1,
+		.str = { 'e', '\0' },
+};
+DbgCmdExecutorType *dbg_parse_elaps(DbgCmdExecutorType *arg, const TokenContainerType *token_container)
+{
+	if (token_container->num != 1) {
+		return NULL;
+	}
+
+	if (token_container->array[0].type != TOKEN_TYPE_STRING) {
+		return NULL;
+	}
+
+	if ((token_strcmp(&token_container->array[0].body.str, &elaps_string) == TRUE) ||
+			(token_strcmp(&token_container->array[0].body.str, &elaps_string_short) == TRUE)) {
+		arg->std_id = DBG_CMD_STD_ID_ELAPS;
+		arg->run = dbg_std_executor_elaps;
+		return arg;
+	}
+	return NULL;
+}
+
+
+/************************************************************************************
+ * next コマンド
+ *
+ *
+ ***********************************************************************************/
+static const TokenStringType next_string = {
+		.len = 4,
+		.str = { 'n', 'e', 'x', 't', '\0' },
+};
+static const TokenStringType next_string_short = {
+		.len = 1,
+		.str = { 'n', '\0' },
+};
+DbgCmdExecutorType *dbg_parse_next(DbgCmdExecutorType *arg, const TokenContainerType *token_container)
+{
+	if (token_container->num != 1) {
+		return NULL;
+	}
+
+	if (token_container->array[0].type != TOKEN_TYPE_STRING) {
+		return NULL;
+	}
+
+	if ((token_strcmp(&token_container->array[0].body.str, &next_string) == TRUE) ||
+			(token_strcmp(&token_container->array[0].body.str, &next_string_short) == TRUE)) {
+		arg->std_id = DBG_CMD_STD_ID_NEXT;
+		arg->run = dbg_std_executor_next;
+		return arg;
+	}
+	return NULL;
+}
+
+
+/************************************************************************************
+ * return コマンド
+ *
+ *
+ ***********************************************************************************/
+static const TokenStringType return_string = {
+		.len = 6,
+		.str = { 'r', 'e', 't', 'u', 'r', 'n', '\0' },
+};
+static const TokenStringType return_string_short = {
+		.len = 1,
+		.str = { 'r', '\0' },
+};
+DbgCmdExecutorType *dbg_parse_return(DbgCmdExecutorType *arg, const TokenContainerType *token_container)
+{
+	if (token_container->num != 1) {
+		return NULL;
+	}
+
+	if (token_container->array[0].type != TOKEN_TYPE_STRING) {
+		return NULL;
+	}
+
+	if ((token_strcmp(&token_container->array[0].body.str, &return_string) == TRUE) ||
+			(token_strcmp(&token_container->array[0].body.str, &return_string_short) == TRUE)) {
+		arg->std_id = DBG_CMD_STD_ID_RETURN;
+		arg->run = dbg_std_executor_return;
+		return arg;
+	}
+	return NULL;
+}
+
+
+/************************************************************************************
+ * view コマンド
+ *
+ *
+ ***********************************************************************************/
+static const TokenStringType view_string = {
+		.len = 4,
+		.str = { 'v', 'i', 'e', 'w', '\0' },
+};
+static const TokenStringType view_string_short = {
+		.len = 1,
+		.str = { 'v', '\0' },
+};
+DbgCmdExecutorType *dbg_parse_view(DbgCmdExecutorType *arg, const TokenContainerType *token_container)
+{
+	if (token_container->num != 1) {
+		return NULL;
+	}
+
+	if (token_container->array[0].type != TOKEN_TYPE_STRING) {
+		return NULL;
+	}
+
+	if ((token_strcmp(&token_container->array[0].body.str, &view_string) == TRUE) ||
+			(token_strcmp(&token_container->array[0].body.str, &view_string_short) == TRUE)) {
+		arg->std_id = DBG_CMD_STD_ID_VIEW;
+		arg->run = dbg_std_executor_view;
+		return arg;
+	}
+	return NULL;
+}
+
+
+/************************************************************************************
+ * print コマンド
+ *
+ *
+ ***********************************************************************************/
+static const TokenStringType print_string = {
+		.len = 5,
+		.str = { 'p', 'r', 'i', 'n', 't', '\0' },
+};
+static const TokenStringType print_string_short = {
+		.len = 1,
+		.str = { 'p', '\0' },
+};
+DbgCmdExecutorType *dbg_parse_print(DbgCmdExecutorType *arg, const TokenContainerType *token_container)
+{
+	DbgCmdExecutorPrintType *parsed_args = (DbgCmdExecutorPrintType *)arg->parsed_args;
+
+	if ((token_container->num != 2) && (token_container->num != 3) && (token_container->num != 4)) {
+		return NULL;
+	}
+
+	if (token_container->array[0].type != TOKEN_TYPE_STRING) {
+		return NULL;
+	}
+
+	if ((token_strcmp(&token_container->array[0].body.str, &print_string) == FALSE) &&
+			(token_strcmp(&token_container->array[0].body.str, &print_string_short) == FALSE)) {
+		return NULL;
+	}
+
+	if (token_container->num == 2) {
+		if (token_container->array[1].type == TOKEN_TYPE_STRING) {
+			arg->std_id = DBG_CMD_STD_ID_PRINT;
+			parsed_args->type = DBG_CMD_PRINT_SYMBOL;
+			parsed_args->symbol = token_container->array[1].body.str;
+			arg->run = dbg_std_executor_print;
+			return arg;
+		}
+		else if (token_container->array[1].type == TOKEN_TYPE_VALUE_HEX) {
+			arg->std_id = DBG_CMD_STD_ID_PRINT;
+			parsed_args->type = DBG_CMD_PRINT_ADDR;
+			parsed_args->addr = token_container->array[1].body.dec.value;
+			arg->run = dbg_std_executor_print;
+			return arg;
+		}
+	}
+	else if (token_container->num == 3) {
+		if ((token_container->array[1].type == TOKEN_TYPE_VALUE_HEX) &&
+				(token_container->array[2].type == TOKEN_TYPE_VALUE_DEC)) {
+			arg->std_id = DBG_CMD_STD_ID_PRINT;
+			parsed_args->type = DBG_CMD_PRINT_ADDR_SIZE;
+			parsed_args->addr = token_container->array[1].body.dec.value;
+			parsed_args->size = token_container->array[2].body.dec.value;
+			arg->run = dbg_std_executor_print;
+			return arg;
+		}
+	}
+	else {
+		if ((token_container->array[1].type == TOKEN_TYPE_VALUE_HEX) &&
+				(token_container->array[2].type == TOKEN_TYPE_STRING) &&
+				(token_container->array[3].type == TOKEN_TYPE_STRING)) {
+			arg->std_id = DBG_CMD_STD_ID_PRINT;
+			parsed_args->type = DBG_CMD_PRINT_ADDR_TYPE;
+			parsed_args->addr = token_container->array[1].body.dec.value;
+			parsed_args->dataType = token_container->array[2].body.str;
+			parsed_args->dataTypeName = token_container->array[3].body.str;
+			arg->run = dbg_std_executor_print;
+			return arg;
+		}
+	}
+
+	return NULL;
+}
+/************************************************************************************
+ * memset コマンド
+ *
+ *
+ ***********************************************************************************/
+static const TokenStringType memset_string = {
+		.len = 3,
+		.str = { 's', 'e', 't', '\0' },
+};
+static const TokenStringType memset_string_short = {
+		.len = 1,
+		.str = { 's', '\0' },
+};
+DbgCmdExecutorType *dbg_parse_memset(DbgCmdExecutorType *arg, const TokenContainerType *token_container)
+{
+	DbgCmdExecutorMemsetType *parsed_args = (DbgCmdExecutorMemsetType *)arg->parsed_args;
+
+	if ((token_container->num != 3)) {
+		return NULL;
+	}
+	if (token_container->array[0].type != TOKEN_TYPE_STRING) {
+		return NULL;
+	}
+
+	if ((token_strcmp(&token_container->array[0].body.str, &memset_string) == FALSE) &&
+			(token_strcmp(&token_container->array[0].body.str, &memset_string_short) == FALSE)) {
+		return NULL;
+	}
+
+	if (token_container->array[1].type != TOKEN_TYPE_VALUE_HEX) {
+		return NULL;
+	}
+	if (token_container->array[2].type != TOKEN_TYPE_VALUE_DEC) {
+		return NULL;
+	}
+
+	parsed_args->addr = token_container->array[1].body.hex.value;
+	parsed_args->value = token_container->array[2].body.dec.value;
+	arg->run = dbg_std_executor_memset;
+	return arg;
+}
+
+/************************************************************************************
+ * quit コマンド
+ *
+ *
+ ***********************************************************************************/
+static const TokenStringType quit_string = {
+		.len = 4,
+		.str = { 'q', 'u', 'i', 't', '\0' },
+};
+static const TokenStringType quit_string_short = {
+		.len = 1,
+		.str = { 'q', '\0' },
+};
+DbgCmdExecutorType *dbg_parse_quit(DbgCmdExecutorType *arg, const TokenContainerType *token_container)
+{
+	if (token_container->num != 1) {
+		return NULL;
+	}
+
+	if (token_container->array[0].type != TOKEN_TYPE_STRING) {
+		return NULL;
+	}
+
+	if ((token_strcmp(&token_container->array[0].body.str, &quit_string) == TRUE) ||
+			(token_strcmp(&token_container->array[0].body.str, &quit_string_short) == TRUE)) {
+		arg->std_id = DBG_CMD_STD_ID_QUIT;
+		arg->run = dbg_std_executor_quit;
+		return arg;
+	}
+	return NULL;
+}
+
+/************************************************************************************
+ * list コマンド
+ *
+ *
+ ***********************************************************************************/
+static const TokenStringType list_string = {
+		.len = 4,
+		.str = { 'l', 'i', 's', 't', '\0' },
+};
+static const TokenStringType list_string_short = {
+		.len = 1,
+		.str = { 'l', '\0' },
+};
+DbgCmdExecutorType *dbg_parse_list(DbgCmdExecutorType *arg, const TokenContainerType *token_container)
+{
+	if (token_container->num != 1) {
+		return NULL;
+	}
+
+	if (token_container->array[0].type != TOKEN_TYPE_STRING) {
+		return NULL;
+	}
+
+	if ((token_strcmp(&token_container->array[0].body.str, &list_string) == TRUE) ||
+			(token_strcmp(&token_container->array[0].body.str, &list_string_short) == TRUE)) {
+		arg->std_id = DBG_CMD_STD_ID_LIST;
+		arg->run = dbg_std_executor_list;
+		return arg;
+	}
+	return NULL;
+}
+/************************************************************************************
+ * exit コマンド
+ *
+ *
+ ***********************************************************************************/
+static const TokenStringType exit_string = {
+		.len = 4,
+		.str = { 'e', 'x', 'i', 't', '\0' },
+};
+DbgCmdExecutorType *dbg_parse_exit(DbgCmdExecutorType *arg, const TokenContainerType *token_container)
+{
+	if (token_container->num != 1) {
+		return NULL;
+	}
+
+	if (token_container->array[0].type != TOKEN_TYPE_STRING) {
+		return NULL;
+	}
+
+	if ((token_strcmp(&token_container->array[0].body.str, &exit_string) == TRUE)) {
+		arg->std_id = DBG_CMD_STD_ID_EXIT;
+		arg->run = dbg_std_executor_exit;
+		return arg;
+	}
+	return NULL;
+}
+
+
+/************************************************************************************
+ * serial コマンド
+ *
+ *
+ ***********************************************************************************/
+static const TokenStringType serial_string = {
+		.len = 6,
+		.str = { 's', 'e', 'r', 'i', 'a', 'l', '\0' },
+};
+static const TokenStringType serial_string_short = {
+		.len = 1,
+		.str = { 'S', '\0' },
+};
+DbgCmdExecutorType *dbg_parse_serialin(DbgCmdExecutorType *arg, const TokenContainerType *token_container)
+{
+	DbgCmdExecutorSerialInType *parsed_args = (DbgCmdExecutorSerialInType *)arg->parsed_args;
+
+	if (token_container->num < 3) {
+		return NULL;
+	}
+
+	if (token_container->array[0].type != TOKEN_TYPE_STRING) {
+		return NULL;
+	}
+	if (token_container->array[1].type != TOKEN_TYPE_VALUE_DEC) {
+		return NULL;
+	}
+
+
+	if ((token_strcmp(&token_container->array[0].body.str, &serial_string) == TRUE) ||
+			(token_strcmp(&token_container->array[0].body.str, &serial_string_short) == TRUE)) {
+		arg->std_id = DBG_CMD_STD_ID_SERIALIN;
+		arg->run = dbg_std_executor_serialin;
+		parsed_args->channel = token_container->array[1].body.dec.value;
+		(void)token_split_merge(token_container, 2, &parsed_args->input);
+		token_trim_newline(&parsed_args->input);
+#if 0
+		int i;
+		for (i = 0; i < parsed_args->input.len; i++) {
+			printf("str[%d]=%x\n", i, parsed_args->input.str[i]);
+		}
+#endif
+		return arg;
+	}
+	return NULL;
+}
+
+
+
+/************************************************************************************
+ * info cpu コマンド
+ *
+ *
+ ***********************************************************************************/
+static const TokenStringType info_cpu_string = {
+		.len = 3,
+		.str = { 'c', 'p', 'u', '\0' },
+};
+
+DbgCmdExecutorType *dbg_parse_info_cpu(DbgCmdExecutorType *arg, const TokenContainerType *token_container)
+{
+	DbgCmdExecutorInfoCpuType *parsed_args = (DbgCmdExecutorInfoCpuType *)arg->parsed_args;
+	if ((token_container->num != 1) && (token_container->num != 2)) {
+		return NULL;
+	}
+
+	if (token_container->array[0].type != TOKEN_TYPE_STRING) {
+		return NULL;
+	}
+	if ((token_container->num == 2)) {
+		if (token_container->array[1].type != TOKEN_TYPE_VALUE_DEC) {
+			return NULL;
+		}
+	}
+
+	if ((token_strcmp(&token_container->array[0].body.str, &info_cpu_string) == TRUE)) {
+		arg->std_id = DBG_CMD_STD_ID_INFO_CPU;
+		if (token_container->num == 1) {
+			parsed_args->type = DBG_CMD_CORE_ALL;
+		}
+		else {
+			parsed_args->type = DBG_CMD_CORE_SINGLE;
+			parsed_args->core_id = token_container->array[1].body.dec.value;
+		}
+		arg->run = dbg_std_executor_info_cpu;
+		return arg;
+	}
+	return NULL;
+}
+
+/************************************************************************************
+ * func trace コマンド
+ *
+ *
+ ***********************************************************************************/
+static const TokenStringType func_trace_string = {
+		.len = 2,
+		.str = { 'f', 't', '\0' },
+};
+extern DbgCmdExecutorType *dbg_parse_func_trace(DbgCmdExecutorType *arg, const TokenContainerType *token_container)
+{
+	DbgCmdExecutorFuncTraceType *parsed_args = (DbgCmdExecutorFuncTraceType *)arg->parsed_args;
+
+	if (token_container->num == 2) {
+		parsed_args->bt_way = FALSE;
+	}
+	else if (token_container->num == 3) {
+		parsed_args->bt_way = TRUE;
+	}
+	else {
+		return NULL;
+	}
+
+	if (token_container->array[0].type != TOKEN_TYPE_STRING) {
+		return NULL;
+	}
+	if (token_container->array[1].type != TOKEN_TYPE_VALUE_DEC) {
+		return NULL;
+	}
+
+	if ((token_strcmp(&token_container->array[0].body.str, &func_trace_string) == TRUE)) {
+		arg->std_id = DBG_CMD_STD_ID_FUNC_TRACE;
+		parsed_args->bt_number = token_container->array[1].body.dec.value;
+		arg->run = dbg_std_executor_func_trace;
+		return arg;
+	}
+	return NULL;
+}
+
+/************************************************************************************
+ * data access info コマンド
+ *
+ *
+ ***********************************************************************************/
+static const TokenStringType data_access_info_string = {
+		.len = 6,
+		.str = { 'a', 'c', 'c', 'e', 's', 's', '\0' },
+};
+extern DbgCmdExecutorType *dbg_parse_data_access_info(DbgCmdExecutorType *arg, const TokenContainerType *token_container)
+{
+	DbgCmdExecutorDataAccessInfoType *parsed_args = (DbgCmdExecutorDataAccessInfoType *)arg->parsed_args;
+
+	if (token_container->num != 2) {
+		return NULL;
+	}
+
+	if (token_container->array[0].type != TOKEN_TYPE_STRING) {
+		return NULL;
+	}
+	if (token_container->array[1].type != TOKEN_TYPE_STRING) {
+		return NULL;
+	}
+
+	if ((token_strcmp(&token_container->array[0].body.str, &data_access_info_string) == TRUE)) {
+		arg->std_id = DBG_CMD_STD_ID_DATA_ACCESS_INFO;
+		parsed_args->symbol = token_container->array[1].body.str;
+		arg->run = dbg_std_executor_data_access_info;
+		return arg;
+	}
+	return NULL;
+}
+
+
+/************************************************************************************
+ * back trace コマンド
+ *
+ *
+ ***********************************************************************************/
+static const TokenStringType back_trace_string = {
+		.len = 2,
+		.str = { 'b', 't', '\0' },
+};
+extern DbgCmdExecutorType *dbg_parse_back_trace(DbgCmdExecutorType *arg, const TokenContainerType *token_container)
+{
+	if (token_container->num != 1) {
+		return NULL;
+	}
+
+	if (token_container->array[0].type != TOKEN_TYPE_STRING) {
+		return NULL;
+	}
+
+	if ((token_strcmp(&token_container->array[0].body.str, &back_trace_string) == TRUE)) {
+		arg->std_id = DBG_CMD_STD_ID_BACK_TRACE;
+		arg->run = dbg_std_executor_back_trace;
+		return arg;
+	}
+	return NULL;
+}
+
+/************************************************************************************
+ * profile コマンド
+ *
+ *
+ ***********************************************************************************/
+static const TokenStringType prof_string = {
+		.len = 4,
+		.str = { 'p', 'r', 'o', 'f', '\0' },
+};
+DbgCmdExecutorType *dbg_parse_profile(DbgCmdExecutorType *arg, const TokenContainerType *token_container)
+{
+	if (token_container->num != 1) {
+		return NULL;
+	}
+
+	if (token_container->array[0].type != TOKEN_TYPE_STRING) {
+		return NULL;
+	}
+
+	if ((token_strcmp(&token_container->array[0].body.str, &prof_string) == TRUE)) {
+		arg->std_id = DBG_CMD_STD_ID_PROFILE;
+		arg->run = dbg_std_executor_profile;
+		return arg;
+	}
+	return NULL;
+}
+
+/************************************************************************************
+ * help コマンド
+ *
+ *
+ ***********************************************************************************/
+static const TokenStringType help_string = {
+		.len = 4,
+		.str = { 'h', 'e', 'l', 'p', '\0' },
+};
+static const DbgCmdHelpType help_list = {
+	.cmd_num = DBG_CMD_STD_ID_NUM,
+	.cmd = {
+			{
+					.name = &break_string,
+					.name_shortcut = &break_string_short,
+					.opt_num = 2,
+					.opts = {
+							{
+									.semantics = "break {<addr(hex)>|<funcname>}",
+									.description = "set a break point. Break points are shown using 'info break' command.",
+							},
+							{
+									.semantics = "break <file> <lineno>",
+									.description = "set a break point on the {<file>, <lineno>}. Break points are shown using 'info break' command.",
+							},
+					},
+			},
+			{
+					.name = &delete_string,
+					.name_shortcut = &delete_string_short,
+					.opt_num = 2,
+					.opts = {
+							{
+									.semantics = "delete",
+									.description = "delete all break points",
+							},
+							{
+									.semantics = "delete <break_no>",
+									.description = "delete the break point of <break_no>",
+							},
+					},
+			},
+			{
+					.name = &watch_string,
+					.name_shortcut = &watch_string_short,
+					.opt_num = 3,
+					.opts = {
+							{
+									.semantics = "watch {r|w|rw} {<addr(hex)> size(dec)|<variable_name>}",
+									.description = "set a watch point. Watch points are shown using 'info watch' command.",
+							},
+							{
+									.semantics = "watch d",
+									.description = "delete all watch points",
+							},
+							{
+									.semantics = "watch d <watch_no>",
+									.description = "delete the watch point of <watch_no>",
+							},
+					},
+			},
+
+			{
+					.name = &cont_string,
+					.name_shortcut = &cont_string_short,
+					.opt_num = 2,
+					.opts = {
+							{
+									.semantics = "cont",
+									.description = "continue program",
+							},
+							{
+									.semantics = "cont <clocks>",
+									.description = "continue program until cpu has elapsed <clocks> times",
+							},
+					},
+			},
+			{
+					.name = &core_string,
+					.name_shortcut = NULL,
+					.opt_num = 2,
+					.opts = {
+							{
+									.semantics = "core <core_id> <debug_mode>",
+									.description = "set cpu(core_id(all|<id>)) <debug_mode(t|f)>",
+							},
+							{
+									.semantics = "core",
+									.description = "show cpu debug_mode",
+							},
+					},
+			},
+
+			{
+					.name = &intr_string,
+					.name_shortcut = &intr_string_short,
+					.opt_num = 1,
+					.opts = {
+							{
+									.semantics = "intr <intno>",
+									.description = "generate an interruption of <intno>",
+							},
+					},
+			},
+			{
+					.name = &elaps_string,
+					.name_shortcut = &elaps_string_short,
+					.opt_num = 1,
+					.opts = {
+							{
+									.semantics = "elaps",
+									.description = "show elapsed cpu clocks",
+							},
+					},
+			},
+			{
+					.name = &next_string,
+					.name_shortcut = &next_string_short,
+					.opt_num = 1,
+					.opts = {
+							{
+									.semantics = "next",
+									.description = "step forward",
+							},
+					},
+			},
+			{
+					.name = &return_string,
+					.name_shortcut = &return_string_short,
+					.opt_num = 1,
+					.opts = {
+							{
+									.semantics = "return",
+									.description = "return from the current function",
+							},
+					},
+			},
+			{
+					.name = &view_string,
+					.name_shortcut = &view_string_short,
+					.opt_num = 1,
+					.opts = {
+							{
+									.semantics = "view",
+									.description = "select the logging mode",
+							},
+					},
+			},
+			{
+					.name = &print_string,
+					.name_shortcut = &print_string_short,
+					.opt_num = 3,
+					.opts = {
+							{
+									.semantics = "print <variable_name>",
+									.description = "show memory information of the <variable_name>",
+							},
+							{
+									.semantics = "print <addr(hex)> <size>",
+									.description = "show memory information from <addr> to (<addr> + <size>)",
+							},
+							{
+									.semantics = "print <addr(hex)> <type(s|c|t)> <typename>",
+									.description = "show memory information from <addr> by <typename>)",
+							},
+					},
+			},
+			{
+					.name = &memset_string,
+					.name_shortcut = &memset_string_short,
+					.opt_num = 1,
+					.opts = {
+							{
+									.semantics = "set <addr(hex)> <value>",
+									.description = "set <value> on memory <addr> by byte",
+							},
+					},
+			},
+			{
+					.name = &quit_string,
+					.name_shortcut = &quit_string_short,
+					.opt_num = 1,
+					.opts = {
+							{
+									.semantics = "quit",
+									.description = "quit form CPU mode",
+							},
+					},
+			},
+			{
+					.name = &exit_string,
+					.name_shortcut = NULL,
+					.opt_num = 1,
+					.opts = {
+							{
+									.semantics = "exit",
+									.description = "exit from this program",
+							},
+					},
+			},
+			{
+					.name = &serial_string,
+					.name_shortcut = &serial_string_short,
+					.opt_num = 1,
+					.opts = {
+							{
+									.semantics = "serial <channel> <input_data(string)>",
+									.description = "set <input_data> on the serial(<channel>) as an input",
+							},
+					},
+			},
+			{
+					.name = &info_cpu_string,
+					.name_shortcut = NULL,
+					.opt_num = 2,
+					.opts = {
+							{
+									.semantics = "cpu",
+									.description = "show all cpu registers",
+							},
+							{
+									.semantics = "cpu <core_id>",
+									.description = "show cpu(<core_id>)",
+							},
+					},
+			},
+			{
+					.name = &func_trace_string,
+					.name_shortcut = NULL,
+					.opt_num = 2,
+					.opts = {
+							{
+									.semantics = "ft <number>",
+									.description = "show function trace log(show size=<number>) from latest log",
+							},
+							{
+									.semantics = "ft <number> r",
+									.description = "show function trace log(show size=<number>) from oldest log",
+							},
+					},
+			},
+			{
+					.name = &data_access_info_string,
+					.name_shortcut = NULL,
+					.opt_num = 1,
+					.opts = {
+							{
+									.semantics = "access <variable_name>",
+									.description = "show variable access functions",
+							},
+					},
+			},
+			{
+					.name = &back_trace_string,
+					.name_shortcut = NULL,
+					.opt_num = 1,
+					.opts = {
+							{
+									.semantics = "bt",
+									.description = "show back trace result",
+							},
+					},
+			},
+			{
+					.name = &prof_string,
+					.name_shortcut = NULL,
+					.opt_num = 1,
+					.opts = {
+							{
+									.semantics = "profile",
+									.description = "show profile result",
+							},
+					},
+			},
+			{
+					.name = &list_string,
+					.name_shortcut = &list_string_short,
+					.opt_num = 1,
+					.opts = {
+							{
+									.semantics = "list",
+									.description = "show the program code where the pc is stopped.",
+							},
+					},
+			},
+			{
+					.name = &help_string,
+					.name_shortcut = NULL,
+					.opt_num = 1,
+					.opts = {
+							{
+									.semantics = "help",
+									.description = "show all commands",
+							},
+					},
+			},
+	},
+};
+
+DbgCmdExecutorType *dbg_parse_help(DbgCmdExecutorType *arg, const TokenContainerType *token_container)
+{
+	DbgCmdExecutorHelpType *parsed_args = (DbgCmdExecutorHelpType *)arg->parsed_args;
+	if (token_container->num != 1) {
+		return NULL;
+	}
+
+	if (token_container->array[0].type != TOKEN_TYPE_STRING) {
+		return NULL;
+	}
+
+	if ((token_strcmp(&token_container->array[0].body.str, &help_string) == TRUE)) {
+		arg->std_id = DBG_CMD_STD_ID_HELP;
+		parsed_args->arg = &help_list;
+		arg->run = dbg_std_executor_help;
+		return arg;
+	}
+	return NULL;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/debugger/interaction/front/parser/concrete_parser/dbg_std_parser.h
@@ -0,0 +1,157 @@
+#ifndef _DBG_STD_PARSER_H_
+#define _DBG_STD_PARSER_H_
+
+#include "dbg_executor.h"
+#include "token.h"
+
+typedef enum {
+	DBG_CMD_BBREAK_SET,
+	DBG_CMD_BBREAK_SET_SYMBOL,
+	DBG_CMD_BREAK_SET_FILE_LINE,
+	DBG_CMD_BREAK_INFO
+} DbgCmdBreakType;
+typedef struct {
+	DbgCmdBreakType		type;
+	uint32 				break_addr;
+	TokenStringType		symbol;
+	uint32				line;
+} DbgCmdExecutorBreakType;
+extern DbgCmdExecutorType *dbg_parse_break(DbgCmdExecutorType *arg, const TokenContainerType *token_container);
+
+typedef enum {
+	DBG_CMD_DELETE_ALL,
+	DBG_CMD_DELETE_ONE
+} DbgCmdDeleteType;
+typedef struct {
+	DbgCmdDeleteType 	type;
+	uint32 				delete_break_no;
+} DbgCmdExecutorDeleteType;
+extern DbgCmdExecutorType *dbg_parse_delete(DbgCmdExecutorType *arg, const TokenContainerType *token_container);
+
+
+typedef enum {
+	DBG_CMD_CONT_ALL,
+	DBG_CMD_CONT_CLOCKS
+} DbgCmdContType;
+typedef struct {
+	DbgCmdContType 		type;
+	uint32 				cont_clocks;
+} DbgCmdExecutorContType;
+extern DbgCmdExecutorType *dbg_parse_cont(DbgCmdExecutorType *arg, const TokenContainerType *token_container);
+
+typedef enum {
+	DBG_CMD_CORE_ALL,
+	DBG_CMD_CORE_SINGLE,
+	DBG_CMD_CORE_SHOW
+} DbgCmdCoreType;
+typedef struct {
+	DbgCmdCoreType 		type;
+	CoreIdType			core_id;
+	bool				is_debug_mode;
+} DbgCmdExecutorCoreType;
+extern DbgCmdExecutorType *dbg_parse_core(DbgCmdExecutorType *arg, const TokenContainerType *token_container);
+
+extern DbgCmdExecutorType *dbg_parse_elaps(DbgCmdExecutorType *arg, const TokenContainerType *token_container);
+extern DbgCmdExecutorType *dbg_parse_next(DbgCmdExecutorType *arg, const TokenContainerType *token_container);
+extern DbgCmdExecutorType *dbg_parse_return(DbgCmdExecutorType *arg, const TokenContainerType *token_container);
+extern DbgCmdExecutorType *dbg_parse_view(DbgCmdExecutorType *arg, const TokenContainerType *token_container);
+typedef enum {
+	DBG_CMD_PRINT_SYMBOL,
+	DBG_CMD_PRINT_ADDR,
+	DBG_CMD_PRINT_ADDR_SIZE,
+	DBG_CMD_PRINT_ADDR_TYPE,
+} DbgCmdDPrintType;
+typedef struct {
+	DbgCmdDPrintType	type;
+	TokenStringType		symbol;
+	uint32 				addr;
+	uint32 				size;
+	TokenStringType		dataType;
+	TokenStringType		dataTypeName;
+} DbgCmdExecutorPrintType;
+extern DbgCmdExecutorType *dbg_parse_print(DbgCmdExecutorType *arg, const TokenContainerType *token_container);
+typedef struct {
+	uint32 				addr;
+	uint8 				value;
+} DbgCmdExecutorMemsetType;
+extern DbgCmdExecutorType *dbg_parse_memset(DbgCmdExecutorType *arg, const TokenContainerType *token_container);
+extern DbgCmdExecutorType *dbg_parse_quit(DbgCmdExecutorType *arg, const TokenContainerType *token_container);
+extern DbgCmdExecutorType *dbg_parse_exit(DbgCmdExecutorType *arg, const TokenContainerType *token_container);
+
+typedef struct {
+	uint32				channel;
+	TokenStringType		input;
+} DbgCmdExecutorSerialInType;
+extern DbgCmdExecutorType *dbg_parse_serialin(DbgCmdExecutorType *arg, const TokenContainerType *token_container);
+
+typedef struct {
+	DbgCmdCoreType 		type;
+	CoreIdType			core_id;
+} DbgCmdExecutorInfoCpuType;
+extern DbgCmdExecutorType *dbg_parse_info_cpu(DbgCmdExecutorType *arg, const TokenContainerType *token_container);
+
+
+typedef struct {
+	uint32 				bt_number;
+	bool				bt_way; /* FALSE: latest, TRUE: oldest */
+} DbgCmdExecutorFuncTraceType;
+extern DbgCmdExecutorType *dbg_parse_func_trace(DbgCmdExecutorType *arg, const TokenContainerType *token_container);
+
+extern DbgCmdExecutorType *dbg_parse_back_trace(DbgCmdExecutorType *arg, const TokenContainerType *token_container);
+
+extern DbgCmdExecutorType *dbg_parse_profile(DbgCmdExecutorType *arg, const TokenContainerType *token_container);
+
+typedef enum {
+	DBG_CMD_WATCH_SET,
+	DBG_CMD_WATCH_SET_SYMBOL,
+	DBG_CMD_WATCH_DELETE_ONE,
+	DBG_CMD_WATCH_DELETE_ALL,
+	DBG_CMD_WATCH_INFO
+} DbgCmdDWatchDataType;
+#define DBG_CMD_WATCH_TYPE_READ		0x01
+#define DBG_CMD_WATCH_TYPE_WRITE	0x10
+#define DBG_CMD_WATCH_TYPE_RW		(DBG_CMD_WATCH_TYPE_READ|DBG_CMD_WATCH_TYPE_WRITE)
+typedef struct {
+	DbgCmdDWatchDataType	type;
+	uint8					watch_type;
+	TokenStringType			symbol;
+	uint32 					addr;
+	uint32 					size;
+	uint32					delno;
+} DbgCmdExecutorWatchDataType;
+extern DbgCmdExecutorType *dbg_parse_watch_data(DbgCmdExecutorType *arg, const TokenContainerType *token_container);
+
+
+typedef struct {
+	TokenStringType			symbol;
+} DbgCmdExecutorDataAccessInfoType;
+extern DbgCmdExecutorType *dbg_parse_data_access_info(DbgCmdExecutorType *arg, const TokenContainerType *token_container);
+
+
+typedef struct {
+	uint32 				intno;
+} DbgCmdExecutorIntrType;
+extern DbgCmdExecutorType *dbg_parse_intr(DbgCmdExecutorType *arg, const TokenContainerType *token_container);
+
+extern DbgCmdExecutorType *dbg_parse_list(DbgCmdExecutorType *arg, const TokenContainerType *token_container);
+
+
+#define DBG_CMD_ARG_TYPES_MAX	3U
+typedef struct {
+	uint32			cmd_num;
+	struct {
+		const TokenStringType *name;
+		const TokenStringType *name_shortcut;
+		uint32			opt_num;
+		struct {
+			const char*		description;
+			const char*		semantics;
+		} opts[DBG_CMD_ARG_TYPES_MAX];
+	} cmd[DBG_CMD_STD_ID_NUM];
+} DbgCmdHelpType;
+
+typedef struct {
+	const DbgCmdHelpType *arg;
+} DbgCmdExecutorHelpType;
+extern DbgCmdExecutorType *dbg_parse_help(DbgCmdExecutorType *arg, const TokenContainerType *token_container);
+#endif /* _DBG_STD_PARSER_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/debugger/interaction/front/parser/dbg_parser.c
@@ -0,0 +1,99 @@
+#include "std_errno.h"
+#include "front/parser/dbg_parser.h"
+#include "front/parser/dbg_parser_config.h"
+#include "concrete_executor/dbg_std_executor.h"
+#include "cpu_control/dbg_cpu_control.h"
+#include "cui/cui_ops.h"
+#include <string.h>
+#include <stdio.h>
+
+static DbgCmdExecutorType *last_command = NULL;
+static DbgCmdExecutorType parse_command;
+
+static bool can_execute(DbgCmdExecutorType *res, DbgModeType *mode)
+{
+	if (cpuctrl_is_debug_mode() == TRUE) {
+		*mode = DBG_MODE_DEBUG;
+		if (res->std_id != DBG_CMD_STD_ID_QUIT) {
+			return TRUE;
+		}
+	}
+	else { //DBG_MODE_CPU
+		*mode = DBG_MODE_CPU;
+		if (res->std_id == DBG_CMD_STD_ID_QUIT) {
+			return TRUE;
+		}
+	}
+	return FALSE;
+}
+
+DbgCmdExecutorType *dbg_parse(uint8 *str, uint32 len)
+{
+	Std_ReturnType err;
+	uint32 i;
+	DbgCmdExecutorType *res = NULL;
+	DbgCmdExecutorType *arg = NULL;
+	TokenContainerType token_container;
+	DbgModeType mode;
+	//printf("dbg_parse:str=%s len=%u\n", str, len);
+
+	//memset(&token_container, 0, sizeof(TokenContainerType));
+	if ((len == 0) && (last_command != NULL)) {
+		/*
+		 * 改行の場合は，最後のコマンドを実行する．
+		 */
+		arg = last_command;
+		return arg;
+	}
+	else {
+		/*
+		 * デフォルトエラーを作成する．
+		 */
+		arg = &parse_command;
+		memcpy(arg->original_str, str, len);
+		arg->original_str[len] = '\0';
+		arg->std_id = DBG_CMD_STD_ID_PARSE_ERROR;
+		arg->run = dbg_std_executor_parse_error;
+		memset(arg->parsed_args, 0, sizeof(arg->parsed_args));
+	}
+
+	/*
+	 * 文字列をトークン分割する
+	 */
+	err = token_split(&token_container, str, len);
+	if (err != STD_E_OK) {
+		goto errdone;
+	}
+
+
+	/*
+	 * パースする．
+	 */
+	for (i = 0; i < DBG_CMD_STD_ID_NUM; i++) {
+		res = dbg_cmd_parser_std_table[i].parse(arg, &token_container);
+		if (res != NULL) {
+			break;
+		}
+	}
+	if (res == NULL) {
+		goto errdone;
+	}
+
+	if (can_execute(res, &mode) == FALSE) {
+		printf("ERROR:can not execute command on %s\n", (mode == DBG_MODE_DEBUG) ? "DEBUG_MODE" : "CPU_MODE");
+		CUI_PRINTF((CPU_PRINT_BUF(), CPU_PRINT_BUF_LEN(), "NG\n"));
+		return NULL;
+	}
+	/*
+	 * 成功の場合は，最後のコマンドを記録する．
+	 */
+	last_command = res;
+
+	return res;
+errdone:
+	last_command = NULL;
+	/*
+	 * ヒットしない場合は，デフォルトエラーを返す．
+	 */
+	return &parse_command;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/debugger/interaction/front/parser/dbg_parser.h
@@ -0,0 +1,13 @@
+#ifndef _DBG_PARSER_H_
+#define _DBG_PARSER_H_
+
+#include "dbg_executor.h"
+
+typedef enum {
+	DBG_MODE_DEBUG,
+	DBG_MODE_CPU,
+} DbgModeType;
+extern DbgCmdExecutorType *dbg_parse(uint8 *str, uint32 len);
+
+
+#endif /* _DBG_PARSER_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/debugger/interaction/front/parser/dbg_parser_config.c
@@ -0,0 +1,27 @@
+#include "front/parser/dbg_parser_config.h"
+#include "front/parser/concrete_parser/dbg_std_parser.h"
+
+DbgCmdParserTableType dbg_cmd_parser_std_table[DBG_CMD_STD_ID_NUM] = {
+		{ dbg_parse_break, },
+		{ dbg_parse_delete, },
+		{ dbg_parse_intr, },
+		{ dbg_parse_watch_data, },
+		{ dbg_parse_cont, },
+		{ dbg_parse_core, },
+		{ dbg_parse_elaps, },
+		{ dbg_parse_next, },
+		{ dbg_parse_return, },
+		{ dbg_parse_view, },
+		{ dbg_parse_print, },
+		{ dbg_parse_memset, },
+		{ dbg_parse_quit, },
+		{ dbg_parse_exit, },
+		{ dbg_parse_serialin, },
+		{ dbg_parse_info_cpu, },
+		{ dbg_parse_func_trace, },
+		{ dbg_parse_data_access_info, },
+		{ dbg_parse_back_trace, },
+		{ dbg_parse_profile, },
+		{ dbg_parse_list, },
+		{ dbg_parse_help, },
+};
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/debugger/interaction/front/parser/dbg_parser_config.h
@@ -0,0 +1,15 @@
+#ifndef _DBG_PARSER_CONFIG_H_
+#define _DBG_PARSER_CONFIG_H_
+
+#include "dbg_interaction_std_ids.h"
+#include "dbg_parser_config.h"
+#include "dbg_executor.h"
+#include "token.h"
+
+typedef struct {
+	DbgCmdExecutorType* (*parse) (DbgCmdExecutorType *arg, const TokenContainerType *token_container);
+} DbgCmdParserTableType;
+
+extern DbgCmdParserTableType dbg_cmd_parser_std_table[DBG_CMD_STD_ID_NUM];
+
+#endif /* _DBG_PARSER_CONFIG_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/debugger/interaction/inc/dbg_interaction_std_ids.h
@@ -0,0 +1,33 @@
+#ifndef _DBG_INTERACTION_STD_IDS_H_
+#define _DBG_INTERACTION_STD_IDS_H_
+
+typedef enum {
+	DBG_CMD_STD_ID_PARSE_ERROR = 0,
+	DBG_CMD_STD_ID_BREAK,
+	DBG_CMD_STD_ID_DELETE,
+	DBG_CMD_STD_ID_CONT,
+	DBG_CMD_STD_ID_CORE,
+	DBG_CMD_STD_ID_INTR,
+	DBG_CMD_STD_ID_DATA_WATCH,
+	DBG_CMD_STD_ID_ELAPS,
+	DBG_CMD_STD_ID_NEXT,
+	DBG_CMD_STD_ID_RETURN,
+	DBG_CMD_STD_ID_VIEW,
+	DBG_CMD_STD_ID_PRINT,
+	DBG_CMD_STD_ID_MEMSET,
+	DBG_CMD_STD_ID_QUIT,
+	DBG_CMD_STD_ID_EXIT,
+	DBG_CMD_STD_ID_SERIALIN,
+	DBG_CMD_STD_ID_INFO_CPU,
+	DBG_CMD_STD_ID_FUNC_TRACE,
+	DBG_CMD_STD_ID_DATA_ACCESS_INFO,
+	DBG_CMD_STD_ID_BACK_TRACE,
+	DBG_CMD_STD_ID_PROFILE,
+	DBG_CMD_STD_ID_LIST,
+	DBG_CMD_STD_ID_HELP,
+	DBG_CMD_STD_ID_TARGET
+} DbgCmdStdIdType;
+
+#define DBG_CMD_STD_ID_NUM	(DBG_CMD_STD_ID_TARGET - 1) //DBG_CMD_STD_ID_PARSE_ERRORは含まない．
+
+#endif /* _DBG_INTERACTION_STD_IDS_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/debugger/interaction/inc/target/rh850/dbg_interaction_target_ids.h
@@ -0,0 +1,10 @@
+#ifndef _DBG_INTERACTION_TARGET_IDS_H_
+#define _DBG_INTERACTION_TARGET_IDS_H_
+
+#include "dbg_interaction_std_ids.h"
+
+typedef enum {
+	DBG_CMD_TARGET_ID_XXX = DBG_CMD_STD_ID_TARGET,
+} DbgCmdTargetIdType;
+
+#endif /* _DBG_INTERACTION_TARGET_IDS_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/debugger/interaction/inc/target/v850e2m/dbg_interaction_target_ids.h
@@ -0,0 +1,10 @@
+#ifndef _DBG_INTERACTION_TARGET_IDS_H_
+#define _DBG_INTERACTION_TARGET_IDS_H_
+
+#include "dbg_interaction_std_ids.h"
+
+typedef enum {
+	DBG_CMD_TARGET_ID_XXX = DBG_CMD_STD_ID_TARGET,
+} DbgCmdTargetIdType;
+
+#endif /* _DBG_INTERACTION_TARGET_IDS_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/debugger/interaction/inc/target/v850esfk3/dbg_interaction_target_ids.h
@@ -0,0 +1,10 @@
+#ifndef _DBG_INTERACTION_TARGET_IDS_H_
+#define _DBG_INTERACTION_TARGET_IDS_H_
+
+#include "dbg_interaction_std_ids.h"
+
+typedef enum {
+	DBG_CMD_TARGET_ID_XXX = DBG_CMD_STD_ID_TARGET,
+} DbgCmdTargetIdType;
+
+#endif /* _DBG_INTERACTION_TARGET_IDS_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/mpu/loader/loader.c
@@ -0,0 +1,237 @@
+#include "loader/loader.h"
+#include "cpu.h"
+#include "mpu.h"
+#include "mpu_ops.h"
+#include "loader/elf.h"
+#include "elf_section.h"
+#include "elf_dwarf_line.h"
+#include "elf_dwarf_abbrev.h"
+#include "elf_dwarf_info.h"
+#include "elf_dwarf_loc.h"
+#include "elf_dwarf_data_type.h"
+#include "athrill_device.h"
+#include "assert.h"
+#include <string.h>
+#include <stdio.h>
+
+static Std_ReturnType Elf_Check(const Elf32_Ehdr *elf_image);
+static Std_ReturnType Elf_LoadProgram(const Elf32_Ehdr *elf_image, MemoryAddressMapType *memap);
+
+Std_ReturnType binary_load(uint8 *binary_data, uint32 load_addr, uint32 binary_data_len)
+{
+	Std_ReturnType err;
+	uint8 *data = NULL;
+
+	err = mpu_get_pointer(CPU_CONFIG_CORE_ID_0, load_addr, &data);
+	if (err != STD_E_OK) {
+		return err;
+	}
+
+	memcpy(data, binary_data, binary_data_len);
+
+	return STD_E_OK;
+}
+
+Std_ReturnType elf_load(uint8 *elf_data, MemoryAddressMapType *memap)
+{
+	Std_ReturnType err;
+	uint32 disable_debug_data_type = 0;
+
+	err = Elf_Check((const Elf32_Ehdr*)elf_data);
+	if (err != STD_E_OK) {
+		return err;
+	}
+	err = Elf_LoadProgram((const Elf32_Ehdr*)elf_data, memap);
+	if (err != STD_E_OK) {
+		return err;
+	}
+	err = elf_symbol_load(elf_data);
+	if (err != STD_E_OK) {
+		return err;
+	}
+	err = elf_dwarf_line_load(elf_data);
+	if (err != STD_E_OK) {
+		return err;
+	}
+	err = elf_dwarf_abbrev_load(elf_data);
+	if (err != STD_E_OK) {
+		return err;
+	}
+	err = elf_dwarf_info_load(elf_data);
+	if (err != STD_E_OK) {
+		return err;
+	}
+	err = elf_dwarf_loc_load(elf_data);
+	if (err != STD_E_OK) {
+		return err;
+	}
+	cpuemu_get_devcfg_value("DEBUG_FUNC_DISABLE_DEBUG_DATA_TYPE", &disable_debug_data_type);
+	if (disable_debug_data_type == 0) {
+		dwarf_build_data_type_set();
+	}
+
+	return err;
+}
+
+
+static Std_ReturnType Elf_Check(const Elf32_Ehdr *elf_image)
+{
+	// magic check
+	if (IS_ELF(*elf_image) == FALSE) {
+		return STD_E_INVALID;
+	}
+	if (elf_image->e_ident[EI_CLASS] != ELFCLASS32) {
+		return STD_E_INVALID;
+	}
+	if (elf_image->e_ident[EI_DATA] != ELFDATA2LSB) {
+		return STD_E_INVALID;
+	}
+	if (elf_image->e_ident[EI_VERSION] != EV_CURRENT) {
+		return STD_E_INVALID;
+	}
+	if (elf_image->e_ident[EI_OSABI] != ELFOSABI_SYSV) {
+		return STD_E_INVALID;
+	}
+	if (elf_image->e_ident[EI_ABIVERSION] != 0U) {
+		return STD_E_INVALID;
+	}
+	if (elf_image->e_type != ET_EXEC) {
+		return STD_E_INVALID;
+	}
+	if (elf_image->e_machine != ELF_MACHINE_TYPE) {
+		return STD_E_INVALID;
+	}
+	if (elf_image->e_version != EV_CURRENT) {
+		return STD_E_INVALID;
+	}
+	return STD_E_OK;
+}
+
+static void set_malloc_region(MemoryAddressMapType *memap, uint32 i)
+{
+	int j;
+	uint32 start = memap->ram[i].start;
+	uint32 unit_num = memap->ram[i].size / MPU_MALLOC_REGION_UNIT_SIZE;
+
+	for (j = 0; j < unit_num; j++) {
+		mpu_address_set_malloc_region(start, MPU_MALLOC_REGION_UNIT_SIZE * 1024);
+		start += (MPU_MALLOC_REGION_UNIT_SIZE * 1024);
+	}
+	return;
+}
+static void set_cache_code_from_map(const MemoryAddressType *memory_map)
+{
+	if (memory_map->region_executable != FALSE) {
+		virtual_cpu_cache_code_add_with_check((memory_map->size * 1024), memory_map->start);
+		printf("MEMSETTING SET CACHE RIGION:addr=0x%x size=%u [KB]\n", memory_map->start, memory_map->size);
+	}
+	return;
+}
+static void set_cache_code_from_elf(const Elf32_Ehdr *elf_image)
+{
+	uint32 i;
+	Elf32_Phdr *phdr;
+	for (i = 0; i < elf_image->e_phnum; i++) {
+		phdr = (Elf32_Phdr*) (
+				((uint8_t*)elf_image)
+				+ elf_image->e_phoff
+				+ (elf_image->e_phentsize * i)
+				);
+		//printf("p_type=0x%x\n", phdr->p_type);
+		//printf("p_paddr=0x%x\n", phdr->p_paddr);
+		//printf("p_flags=0x%x\n", phdr->p_flags);
+		if ((phdr->p_flags & (PF_X)) == PF_X) {
+			virtual_cpu_cache_code_add_with_check(phdr->p_memsz, phdr->p_vaddr);
+			printf("ELF SET CACHE RIGION:addr=0x%x size=%u [KB]\n", phdr->p_vaddr, phdr->p_memsz / 1024);
+		}
+	}
+	return;
+}
+
+static Std_ReturnType Elf_LoadProgram(const Elf32_Ehdr *elf_image, MemoryAddressMapType *memap)
+{
+	Std_ReturnType err;
+	uint32_t i;
+	Elf32_Phdr *phdr;
+	uint8 *ptr = NULL;
+
+	/*
+	 * alloc memory region
+	 */
+	for (i = 0; i < memap->rom_num; i++) {
+		ptr = mpu_address_set_rom_ram((MpuAddressGetType)memap->rom[i].type, memap->rom[i].start, memap->rom[i].size * 1024, NULL);
+		if (ptr == NULL) {
+			printf("Invalid elf file: can not load rom addr=0x%x\n", memap->rom[i].start);
+			return STD_E_INVALID;
+		}
+		set_cache_code_from_map(&memap->rom[i]);
+	}
+	for (i = 0; i < memap->ram_num; i++) {
+		if (memap->ram[i].type != MemoryAddressImplType_MALLOC) {
+			ptr = mpu_address_set_rom_ram((MpuAddressGetType)memap->ram[i].type, memap->ram[i].start, memap->ram[i].size * 1024, memap->ram[i].mmap_addr);
+			if (ptr == NULL) {
+				printf("Invalid elf file: can not load ram addr=0x%x\n", memap->ram[i].start);
+				return STD_E_INVALID;
+			}
+		}
+		else {
+			int j;
+			uint32 start = memap->ram[i].start;
+			uint32 unit_num = memap->ram[i].size / MPU_MALLOC_REGION_UNIT_SIZE;
+
+			for (j = 0; j < unit_num; j++) {
+				(void)mpu_address_set_rom_ram((MpuAddressGetType)memap->ram[i].type, start, MPU_MALLOC_REGION_UNIT_SIZE * 1024, NULL);
+				start += (MPU_MALLOC_REGION_UNIT_SIZE * 1024);
+			}
+		}
+		set_cache_code_from_map(&memap->ram[i]);
+	}
+	for (i = 0; i < memap->ram_num; i++) {
+		if (memap->ram[i].type == MemoryAddressImplType_MALLOC) {
+			set_malloc_region(memap, i);
+		}
+	}
+	for (i = 0; i < memap->dev_num; i++) {
+		ptr = mpu_address_set_dev(memap->dev[i].start, memap->dev[i].size, memap->dev[i].extdev_handle);
+		if (ptr == NULL) {
+			printf("Invalid dev file: can not load dev addr=0x%x\n", memap->dev[i].start);
+			return STD_E_INVALID;
+		}
+	}
+	/*
+	 * set cache from elf file.
+	 */
+	set_cache_code_from_elf(elf_image);
+	/*
+	 * load program from elf file.
+	 */
+	for (i = 0; i < elf_image->e_phnum; i++) {
+		phdr = (Elf32_Phdr*) (
+				((uint8_t*)elf_image)
+				+ elf_image->e_phoff
+				+ (elf_image->e_phentsize * i)
+				);
+		if (phdr->p_type != PT_LOAD) {
+			continue;
+		}
+		/*
+		 * ROM領域のみロードする．
+		 */
+		ptr = mpu_address_get_rom(phdr->p_paddr, phdr->p_filesz);
+		if (ptr == NULL) {
+			continue;
+		}
+		err = mpu_get_pointer(CPU_CONFIG_CORE_ID_0, phdr->p_paddr, &ptr);
+		if (err != STD_E_OK) {
+			printf("Invalid elf file: can not load addr=0x%x\n", phdr->p_paddr);
+			return STD_E_INVALID;
+		}
+
+		memcpy(ptr,
+				( ((uint8_t*)elf_image) + phdr->p_offset ),
+				phdr->p_filesz);
+
+		printf("Elf loading was succeeded:0x%x - 0x%x : %u.%u KB\n", phdr->p_paddr, phdr->p_paddr + phdr->p_memsz, phdr->p_filesz/1024, phdr->p_filesz % 1024);
+	}
+	return 0;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/mpu/loader/loader.h
@@ -0,0 +1,11 @@
+#ifndef _LOADER_H_
+#define _LOADER_H_
+
+#include "std_errno.h"
+#include "std_types.h"
+#include "cpuemu_ops.h"
+
+extern Std_ReturnType binary_load(uint8 *binary_data, uint32 load_addr, uint32 binary_data_len);
+extern Std_ReturnType elf_load(uint8 *elf_data, MemoryAddressMapType *memap);
+
+#endif /* _LOADER_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/mpu/mpu.c
@@ -0,0 +1,589 @@
+#include "cpu_config.h"
+#include "mpu.h"
+#include "mpu_ops.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#ifdef OS_LINUX
+#include <dlfcn.h>
+#endif /* OS_LINUX */
+#include "assert.h"
+#include "mpu_malloc.h"
+#include "athrill_device.h"
+
+static Std_ReturnType memory_get_data8(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 *data);
+static Std_ReturnType memory_get_data16(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint16 *data);
+static Std_ReturnType memory_get_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 *data);
+static Std_ReturnType memory_put_data8(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 data);
+static Std_ReturnType memory_put_data16(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint16 data);
+static Std_ReturnType memory_put_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 data);
+static Std_ReturnType memory_get_pointer(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 **data);
+
+MpuAddressRegionOperationType	default_memory_operation = {
+		.get_data8 		= 	memory_get_data8,
+		.get_data16		=	memory_get_data16,
+		.get_data32		=	memory_get_data32,
+
+		.put_data8 		= 	memory_put_data8,
+		.put_data16		=	memory_put_data16,
+		.put_data32		=	memory_put_data32,
+
+		.get_pointer	= memory_get_pointer
+};
+
+#if 0
+static inline bool has_permission(MpuAddressRegionType *region, CoreIdType core_id)
+{
+	if (	(region->permission != MPU_ADDRESS_REGION_PERM_ALL) &&
+			((region->permission & (1U << core_id)) == FALSE) ) {
+		return FALSE;
+	}
+	return TRUE;
+}
+#endif
+
+// オリジナルのsearch_region
+// 最適化の際はこちらをwrite用、search_region_rをreadように使用することで同じページ内へのアクセスを
+// 発生しやすくする。ここを治す場合はsearch_region_rも同じように直すこと
+static inline MpuAddressRegionType *search_region(CoreIdType core_id, uint32 addr, uint32 search_size)
+{
+	uint32 i;
+
+	//printf("addr=0x%x\n", addr);
+
+#ifdef SEARCH_REGION_OPTIMIZE
+	// 4Kを1ページとすることでキャッシュを効かせる
+	// cache for rom/ram
+	static uint32 previous_page = 0;
+	static int previous_index = -1;
+	#define GET_PAGE(address) ((address) & (uint32)(~(uint32)0x3ff))
+
+	// check previous page first
+	if ( addr && ( GET_PAGE(addr) == previous_page) ) {
+			return &mpu_address_map.dynamic_map[previous_index];
+	}
+
+#endif
+
+
+	for (i = 0U; i < mpu_address_map.dynamic_map_num; i++) {
+		uint32 start = mpu_address_map.dynamic_map[i].start;
+		uint32 end = mpu_address_map.dynamic_map[i].start  + mpu_address_map.dynamic_map[i].size;
+		uint32 paddr_str = (addr & mpu_address_map.dynamic_map[i].mask);
+		uint32 paddr_end = paddr_str + search_size;
+
+		if (	((start <= paddr_str) && (paddr_str < end)) &&
+				((start <  paddr_end) && (paddr_end <= end))
+			) {
+
+#if 0
+			//printf("1:passed1\n");
+			if (has_permission( &mpu_address_map.dynamic_map[i], core_id) == FALSE) {
+				printf("search_region:permission error:addr=0x%x\n", addr);
+				return NULL;
+			}
+#endif
+			if (mpu_address_map.dynamic_map[i].data == NULL) {
+				//MALLOC not malloced region
+				return NULL;
+			}
+			//printf("2:passed1:%u:0x%p\n", i,  &mpu_address_map.map[i]);
+#ifdef SEARCH_REGION_OPTIMIZE
+			previous_page = GET_PAGE(addr);
+			previous_index = i;
+#endif
+			return &mpu_address_map.dynamic_map[i];
+		}
+	}
+
+
+	for (i = 0U; i < MPU_CONFIG_REGION_NUM; i++) {
+		uint32 start = mpu_address_map.map[i].start;
+		uint32 end = mpu_address_map.map[i].start  + mpu_address_map.map[i].size;
+		uint32 paddr_str = (addr & mpu_address_map.map[i].mask);
+		uint32 paddr_end = paddr_str + search_size;
+
+#if 0
+		printf("%u:start=0x%x end=0x%x mask=0x%x\n", i, start, end, mpu_address_map.map[i].mask);
+		printf("%u:pstart=0x%x pend=0x%x\n", i, paddr_str, paddr_end);
+#endif
+		if (	((start <= paddr_str) && (paddr_str < end)) &&
+				((start <  paddr_end) && (paddr_end <= end))
+			) {
+#if 0
+			//printf("1:passed1\n");
+			if (has_permission( &mpu_address_map.map[i], core_id) == FALSE) {
+				printf("search_region:permission error:addr=0x%x\n", addr);
+				return NULL;
+			}
+#endif
+			//printf("2:passed1:%u:0x%p\n", i,  &mpu_address_map.map[i]);
+			return &mpu_address_map.map[i];
+		}
+	}
+	printf("%s():search_region:not found error:addr=0x%x\n", __FUNCTION__, addr);
+	return NULL;
+}
+
+// Read region
+// 
+#ifdef SEARCH_REGION_OPTIMIZE
+static inline MpuAddressRegionType *search_region_r(CoreIdType core_id, uint32 addr, uint32 search_size)
+{
+	uint32 i;
+
+	//printf("addr=0x%x\n", addr);
+
+#ifdef SEARCH_REGION_OPTIMIZE
+	// cache for rom/ram
+	// 4Kを1ページとすることでキャッシュを効かせる
+	static uint32 previous_page = 0;
+	static int previous_index = -1;
+//	#define GET_PAGE(address) ((address) & (uint32)(~(uint32)0x3ff))
+
+	// check previous page first
+	if ( addr && ( GET_PAGE(addr) == previous_page) ) {
+			return &mpu_address_map.dynamic_map[previous_index];
+	}
+
+#endif
+
+
+	for (i = 0U; i < mpu_address_map.dynamic_map_num; i++) {
+		uint32 start = mpu_address_map.dynamic_map[i].start;
+		uint32 end = mpu_address_map.dynamic_map[i].start  + mpu_address_map.dynamic_map[i].size;
+		uint32 paddr_str = (addr & mpu_address_map.dynamic_map[i].mask);
+		uint32 paddr_end = paddr_str + search_size;
+
+		if (	((start <= paddr_str) && (paddr_str < end)) &&
+				((start <  paddr_end) && (paddr_end <= end))
+			) {
+
+#if 0
+			//printf("1:passed1\n");
+			if (has_permission( &mpu_address_map.dynamic_map[i], core_id) == FALSE) {
+				printf("search_region:permission error:addr=0x%x\n", addr);
+				return NULL;
+			}
+#endif
+			if (mpu_address_map.dynamic_map[i].data == NULL) {
+				//MALLOC not malloced region
+				return NULL;
+			}
+			//printf("2:passed1:%u:0x%p\n", i,  &mpu_address_map.map[i]);
+#ifdef SEARCH_REGION_OPTIMIZE
+			previous_page = GET_PAGE(addr);
+			previous_index = i;
+#endif
+			return &mpu_address_map.dynamic_map[i];
+		}
+	}
+
+
+	for (i = 0U; i < MPU_CONFIG_REGION_NUM; i++) {
+		uint32 start = mpu_address_map.map[i].start;
+		uint32 end = mpu_address_map.map[i].start  + mpu_address_map.map[i].size;
+		uint32 paddr_str = (addr & mpu_address_map.map[i].mask);
+		uint32 paddr_end = paddr_str + search_size;
+
+#if 0
+		printf("%u:start=0x%x end=0x%x mask=0x%x\n", i, start, end, mpu_address_map.map[i].mask);
+		printf("%u:pstart=0x%x pend=0x%x\n", i, paddr_str, paddr_end);
+#endif
+		if (	((start <= paddr_str) && (paddr_str < end)) &&
+				((start <  paddr_end) && (paddr_end <= end))
+			) {
+#if 0
+			//printf("1:passed1\n");
+			if (has_permission( &mpu_address_map.map[i], core_id) == FALSE) {
+				printf("search_region:permission error:addr=0x%x\n", addr);
+				return NULL;
+			}
+#endif
+			//printf("2:passed1:%u:0x%p\n", i,  &mpu_address_map.map[i]);
+			return &mpu_address_map.map[i];
+		}
+	}
+	printf("%s():search_region:not found error:addr=0x%x\n", __FUNCTION__, addr);
+	return NULL;
+}
+#else
+// Original 
+#define search_region_r search_region
+#endif
+
+static MpuAddressRegionType *mpu_address_search_region(uint32 addr, uint32 size)
+{
+	uint32 i;
+	MpuAddressRegionType *region = NULL;
+
+	for (i = 0U; i < mpu_address_map.dynamic_map_num; i++) {
+		uint32 start = mpu_address_map.dynamic_map[i].start;
+		uint32 end = mpu_address_map.dynamic_map[i].start  + mpu_address_map.dynamic_map[i].size;
+		uint32 paddr_str = (addr & mpu_address_map.dynamic_map[i].mask);
+		uint32 paddr_end = paddr_str + size;
+
+		if (	((start <= paddr_str) && (paddr_str < end)) &&
+				((start <  paddr_end) && (paddr_end <= end))
+			) {
+			region = &mpu_address_map.dynamic_map[i];
+			break;
+		}
+	}
+
+	return region;
+}
+
+uint8 *mpu_address_get_rom(uint32 addr, uint32 size)
+{
+	MpuAddressRegionType *region = NULL;
+
+	region = mpu_address_search_region(addr, size);
+	if ((region != NULL) && (region->type == READONLY_MEMORY)) {
+		return region->data;
+	}
+	return NULL;
+}
+uint8 *mpu_address_get_ram(uint32 addr, uint32 size)
+{
+	MpuAddressRegionType *region = NULL;
+
+	region = mpu_address_search_region(addr, size);
+	if ((region != NULL) && (region->type == GLOBAL_MEMORY)) {
+		return region->data;
+	}
+	return NULL;
+}
+
+uint8 *mpu_address_set_rom_ram(MpuAddressGetType getType, uint32 addr, uint32 size, void *mmap_addr)
+{
+	MpuAddressRegionType *region = NULL;
+
+	region = mpu_address_search_region(addr, size);
+
+	if (region == NULL) {
+		mpu_address_map.dynamic_map_num++;
+		mpu_address_map.dynamic_map = realloc(mpu_address_map.dynamic_map, (sizeof(MpuAddressRegionType)) * mpu_address_map.dynamic_map_num);
+		ASSERT(mpu_address_map.dynamic_map != NULL);
+		mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].start = addr;
+		mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].is_malloc = FALSE;
+
+		mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].permission	= MPU_ADDRESS_REGION_PERM_ALL;
+		mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].mask		= MPU_ADDRESS_REGION_MASK_ALL;
+		mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].ops			= &default_memory_operation;
+
+		if (getType == MpuAddressGetType_ROM) {
+			mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].type = READONLY_MEMORY;
+			mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].size = size;
+			mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].data = malloc(size);
+		}
+		else if (getType == MpuAddressGetType_RAM) {
+			mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].type = GLOBAL_MEMORY;
+			mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].size = size;
+			mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].data = calloc(1U, size);
+		}
+		else {
+#ifdef OS_LINUX
+			mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].size = size;
+			if (getType == MpuAddressGetType_MMAP) {
+				/* MMAP */
+				mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].type = GLOBAL_MEMORY;
+				mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].data = mmap_addr;
+			}
+			else if (getType == MpuAddressGetType_MALLOC) {
+				/* MALLOC */
+				mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].type = GLOBAL_MEMORY;
+				mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].is_malloc = TRUE;
+				mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].data = NULL;
+			}
+#endif /* OS_LINUX */
+		}
+		if (getType == MpuAddressGetType_MALLOC) {
+			ASSERT(mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].data == NULL);
+		}
+		else {
+			ASSERT(mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].data != NULL);
+		}
+		return mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].data;
+	}
+	else {
+		return region->data;
+	}
+}
+#ifdef OS_LINUX
+#include "cpu.h"
+#include "athrill_exdev.h"
+uint8 *mpu_address_set_dev(uint32 addr, uint32 size, void *handler)
+{
+	MpuAddressRegionType *region = NULL;
+
+	region = mpu_address_search_region(addr, size);
+	if (region != NULL) {
+		printf("ERROR: addr=0x%x size=%u already found existing region(soff=0x%x size=%u)\n",
+				addr, size, region->start, region->size);
+		return NULL;
+	}
+	AthrillExDeviceType *exdev = dlsym(handler, "athrill_ex_device");
+	if (exdev->devinit == NULL) {
+		printf("ERROR: addr=0x%x size=%u not found ex_device_init\n", addr, size);
+		return NULL;
+	}
+	if (exdev->supply_clock == NULL) {
+		printf("ERROR: addr=0x%x size=%u not found ex_device_supply_clock\n", addr, size);
+		return NULL;
+	}
+
+	if (exdev->ops == NULL) {
+		printf("INFO: addr=0x%x size=%u: default memory operation\n", addr, size);
+		exdev->ops = &default_memory_operation;
+	}
+	if (exdev->datap == NULL) {
+		printf("INFO: addr=0x%x size=%u: default memory\n", addr, size);
+		exdev->datap = malloc(size);
+		ASSERT(exdev->datap != NULL);
+		memset(exdev->datap, 0, size);
+	}
+
+	mpu_address_map.dynamic_map_num++;
+	mpu_address_map.dynamic_map = realloc(mpu_address_map.dynamic_map, (sizeof(MpuAddressRegionType)) * mpu_address_map.dynamic_map_num);
+	ASSERT(mpu_address_map.dynamic_map != NULL);
+	mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].type = DEVICE;
+	mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].start = addr;
+	mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].size = size;
+	mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].is_malloc = FALSE;
+
+	mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].permission	= MPU_ADDRESS_REGION_PERM_ALL;
+	mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].mask		= MPU_ADDRESS_REGION_MASK_ALL;
+	mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].data		= (uint8*)exdev->datap;
+	mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].ops			= exdev->ops;
+
+	device_add_athrill_exdev(exdev, &mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1]);
+	return mpu_address_map.dynamic_map[mpu_address_map.dynamic_map_num -1].data;
+}
+#endif /* OS_LINUX */
+
+void mpu_address_set_malloc_region(uint32 addr, uint32 size)
+{
+	MpuAddressRegionType *region = NULL;
+
+	region = mpu_address_search_region(addr, size);
+
+	mpu_malloc_add_region(region);
+	return;
+}
+
+MpuAddressRegionEnumType mpu_address_region_type_get(uint32 addr, std_bool *is_malloc)
+{
+	uint32 i;
+
+	for (i = 0U; i < mpu_address_map.dynamic_map_num; i++) {
+		uint32 start = mpu_address_map.dynamic_map[i].start;
+		uint32 end = mpu_address_map.dynamic_map[i].start  + mpu_address_map.dynamic_map[i].size;
+		uint32 paddr_str = (addr & mpu_address_map.dynamic_map[i].mask);
+
+		if ((start <= paddr_str) && (paddr_str < end)) {
+			if (is_malloc != NULL) {
+				*is_malloc = mpu_address_map.dynamic_map[i].is_malloc;
+			}
+			return mpu_address_map.dynamic_map[i].type;
+		}
+	}
+
+	for (i = 0U; i < MPU_CONFIG_REGION_NUM; i++) {
+		uint32 start = mpu_address_map.map[i].start;
+		uint32 end = mpu_address_map.map[i].start  + mpu_address_map.map[i].size;
+		uint32 paddr_str = (addr & mpu_address_map.map[i].mask);
+
+		if ((start <= paddr_str) && (paddr_str < end)) {
+			if (is_malloc != NULL) {
+				*is_malloc = FALSE;
+			}
+			return mpu_address_map.map[i].type;
+		}
+	}
+	//printf("%s():search_region:not found error:addr=0x%x\n", __FUNCTION__, addr);
+	return REGION_UNKNOWN;
+}
+
+
+Std_ReturnType mpu_get_data8(CoreIdType core_id, uint32 addr, uint8 *data)
+{
+	MpuAddressRegionType *region = search_region_r(core_id, addr, 1U);
+	if (region == NULL) {
+		printf("%s():addr=0x%x\n", __FUNCTION__, addr);
+		return STD_E_SEGV;
+	}
+	if (region->ops->get_data8 == NULL) {
+		return STD_E_SEGV;
+	}
+	if (!CPU_HAS_PERMISSION(core_id, region->type, CpuMemoryAccess_READ, addr, 1U)) {
+		return STD_E_SEGV;
+	}
+	uint32 paddr = (addr & region->mask);
+	return region->ops->get_data8(region, core_id, paddr, data);
+}
+Std_ReturnType mpu_get_data16(CoreIdType core_id, uint32 addr, uint16 *data)
+{
+	MpuAddressRegionType *region = search_region_r(core_id, addr, 2U);
+	if (region == NULL) {
+		printf("%s():addr=0x%x\n", __FUNCTION__, addr);
+		return STD_E_SEGV;
+	}
+	if (region->ops->get_data16 == NULL) {
+		return STD_E_SEGV;
+	}
+	if (!CPU_HAS_PERMISSION(core_id, region->type, CpuMemoryAccess_READ, addr, 2U)) {
+		return STD_E_SEGV;
+	}
+	uint32 paddr = (addr & region->mask);
+	return region->ops->get_data16(region, core_id, paddr, data);
+}
+
+Std_ReturnType mpu_get_data32(CoreIdType core_id, uint32 addr, uint32 *data)
+{
+	MpuAddressRegionType *region = search_region_r(core_id, addr, 4U);
+	if (region == NULL) {
+		printf("%s():addr=0x%x\n", __FUNCTION__, addr);
+		return STD_E_SEGV;
+	}
+	if (region->ops->get_data32 == NULL) {
+		return STD_E_SEGV;
+	}
+	if (!CPU_HAS_PERMISSION(core_id, region->type, CpuMemoryAccess_READ, addr, 4U)) {
+		return STD_E_SEGV;
+	}
+	uint32 paddr = (addr & region->mask);
+	return region->ops->get_data32(region, core_id, paddr, data);
+}
+
+
+Std_ReturnType mpu_put_data8(CoreIdType core_id, uint32 addr, uint8 data)
+{
+	Std_ReturnType err;
+	MpuAddressRegionType *region = search_region(core_id, addr, 1U);
+	if (region == NULL) {
+		printf("mpu_put_data8:error1:addr=0x%x data=%u\n", addr, data);
+		return STD_E_SEGV;
+	}
+	if (region->ops->put_data8 == NULL) {
+		printf("mpu_put_data8:error2:addr=0x%x data=%u\n", addr, data);
+		return STD_E_SEGV;
+	}
+	if (region->type == READONLY_MEMORY) {
+		printf("mpu_put_data8:error: can not write data on ROM :addr=0x%x data=%u\n", addr, data);
+		return STD_E_SEGV;
+	}
+	if (!CPU_HAS_PERMISSION(core_id, region->type, CpuMemoryAccess_WRITE, addr, 1U)) {
+		return STD_E_SEGV;
+	}
+	uint32 paddr = (addr & region->mask);
+	err = region->ops->put_data8(region, core_id, paddr, data);
+	if (err != STD_E_OK) {
+		printf("mpu_put_data8:error3:addr=0x%x data=%u\n", addr, data);
+	}
+	return err;
+}
+
+Std_ReturnType mpu_put_data16(CoreIdType core_id, uint32 addr, uint16 data)
+{
+	MpuAddressRegionType *region = search_region(core_id, addr, 2U);
+	if (region == NULL) {
+		printf("%s():addr=0x%x\n", __FUNCTION__, addr);
+		return STD_E_SEGV;
+	}
+	if (region->ops->put_data16 == NULL) {
+		return STD_E_SEGV;
+	}
+	if (region->type == READONLY_MEMORY) {
+		printf("mpu_put_data16:error: can not write data on ROM :addr=0x%x data=%u\n", addr, data);
+		return STD_E_SEGV;
+	}
+	if (!CPU_HAS_PERMISSION(core_id, region->type, CpuMemoryAccess_WRITE, addr, 2U)) {
+		return STD_E_SEGV;
+	}
+	uint32 paddr = (addr & region->mask);
+	return region->ops->put_data16(region, core_id, paddr, data);
+}
+
+Std_ReturnType mpu_put_data32(CoreIdType core_id, uint32 addr, uint32 data)
+{
+	MpuAddressRegionType *region = search_region(core_id, addr, 4U);
+	if (region == NULL) {
+		printf("%s():addr=0x%x\n", __FUNCTION__, addr);
+		return STD_E_SEGV;
+	}
+	if (region->ops->put_data32 == NULL) {
+		return STD_E_SEGV;
+	}
+	if (region->type == READONLY_MEMORY) {
+		printf("mpu_put_data32:error: can not write data on ROM :addr=0x%x data=%u\n", addr, data);
+		return STD_E_SEGV;
+	}
+	if (!CPU_HAS_PERMISSION(core_id, region->type, CpuMemoryAccess_WRITE, addr, 4U)) {
+		return STD_E_SEGV;
+	}
+	uint32 paddr = (addr & region->mask);
+	return region->ops->put_data32(region, core_id, paddr, data);
+}
+
+
+Std_ReturnType mpu_get_pointer(CoreIdType core_id, uint32 addr, uint8 **data)
+{
+	MpuAddressRegionType *region = search_region(core_id, addr, 1U);
+	if (region == NULL) {
+		printf("%s():addr=0x%x\n", __FUNCTION__, addr);
+		return STD_E_SEGV;
+	}
+	if (region->ops->get_pointer == NULL) {
+		return STD_E_INVALID;
+	}
+	uint32 paddr = (addr & region->mask);
+	return region->ops->get_pointer(region, core_id, paddr, data);
+}
+
+
+
+
+
+static Std_ReturnType memory_get_data8(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 *data)
+{
+	uint32 off = (addr - region->start);
+	*data = *((uint8*)(&region->data[off]));
+	return STD_E_OK;
+}
+static Std_ReturnType memory_get_data16(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint16 *data)
+{
+	uint32 off = (addr - region->start);
+	*data = *((uint16*)(&region->data[off]));
+	return STD_E_OK;
+}
+static Std_ReturnType memory_get_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 *data)
+{
+	uint32 off = (addr - region->start);
+	*data = *((uint32*)(&region->data[off]));
+	return STD_E_OK;
+}
+static Std_ReturnType memory_put_data8(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 data)
+{
+	uint32 off = (addr - region->start);
+	*((uint8*)(&region->data[off])) = data;
+	return STD_E_OK;
+}
+static Std_ReturnType memory_put_data16(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint16 data)
+{
+	uint32 off = (addr - region->start);
+	*((uint16*)(&region->data[off])) = data;
+	return STD_E_OK;
+}
+static Std_ReturnType memory_put_data32(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 data)
+{
+	uint32 off = (addr - region->start);
+	*((uint32*)(&region->data[off])) = data;
+	return STD_E_OK;
+}
+static Std_ReturnType memory_get_pointer(MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 **data)
+{
+	uint32 off = (addr - region->start);
+	*data = ((uint8*)(&region->data[off]));
+	return STD_E_OK;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/mpu/mpu.h
@@ -0,0 +1,20 @@
+#ifndef _MPU_H_
+#define _MPU_H_
+
+#include "std_types.h"
+#include "std_errno.h"
+#include "mpu_types.h"
+#include "mpu_config.h"
+
+typedef struct {
+	MpuAddressRegionType	map[MPU_CONFIG_REGION_NUM];
+	uint32					dynamic_map_num;
+	MpuAddressRegionType	*dynamic_map;
+} MpuAddressMapType;
+
+extern MpuAddressMapType	mpu_address_map;
+
+extern void mpu_add_dynamic_map(MpuAddressRegionType *p);
+extern MpuAddressRegionType *mpu_search_dynamic_map(uint32 start, uint32 size);
+
+#endif /* _MPU_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/mpu/mpu_malloc.c
@@ -0,0 +1,291 @@
+#include "mpu_malloc.h"
+#include "mpu_ops.h"
+#include "assert.h"
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+typedef enum {
+    MallocSize_32 = 0,
+    MallocSize_64,
+    MallocSize_128,
+    MallocSize_256,
+    MallocSize_512,
+    MallocSize_1024,
+    MallocSize_2048,
+    MallocSize_4096,
+    MallocSize_8192,
+    MallocSize_16384,
+    MallocSize_Num,
+} MallocSIzeType;
+
+typedef struct {
+    uint32	memsize; /* byte */
+    uint32	bitmaxnum;
+    uint32	bitmapsize; /* byte */
+} MallocDataInfoType;
+
+#define SIZE_TO_BITMAXNUM(size) ( ( MPU_MALLOC_REGION_UNIT_SIZE * 1024 ) / (size) )
+#define SIZE_TO_BITMAPSIZE(size) ( ( (SIZE_TO_BITMAXNUM(size) + 63) / 64 ) * 8 )
+static const MallocDataInfoType malloc_data_info_table[MallocSize_Num] = {
+    { 32,    SIZE_TO_BITMAXNUM(32),    SIZE_TO_BITMAPSIZE(32) },
+    { 64,    SIZE_TO_BITMAXNUM(64),    SIZE_TO_BITMAPSIZE(64) },
+    { 128,   SIZE_TO_BITMAXNUM(128),   SIZE_TO_BITMAPSIZE(128) },
+    { 256,   SIZE_TO_BITMAXNUM(256),   SIZE_TO_BITMAPSIZE(256) },
+    { 512,   SIZE_TO_BITMAXNUM(512),   SIZE_TO_BITMAPSIZE(512) },
+    { 1024,  SIZE_TO_BITMAXNUM(1024),  SIZE_TO_BITMAPSIZE(1024) },
+    { 2048,  SIZE_TO_BITMAXNUM(2048),  SIZE_TO_BITMAPSIZE(2048) },
+    { 4096,  SIZE_TO_BITMAXNUM(4096),  SIZE_TO_BITMAPSIZE(4096) },
+    { 8192,  SIZE_TO_BITMAXNUM(8192),  SIZE_TO_BITMAPSIZE(8192) },
+    { 16384, SIZE_TO_BITMAXNUM(16384), SIZE_TO_BITMAPSIZE(16384) },
+};
+
+#define BIT_IS_FREE8(bits8, index)  ( ( ((uint8)1 << (index)) & bits8 ) == 0U )
+#define BIT_SET(bits8, index) ( ( (uint8)1 << (index) ) | (bits8) )
+#define BIT_CLR(bits8, index) ( (~( (uint8)1 << (index) )) & (bits8) )
+
+static int set_bit(char *bitmap, uint32 bitmaxnum, uint32 bitmapsize)
+{
+    uint32 bit64_off;
+    uint32 bit64_num = (bitmapsize / 8);
+    uint32 ret;
+    uint64* p;
+
+    //printf("bitmaxnum=%d bitmapsize=%d\n", bitmaxnum, bitmapsize);
+
+    p = (uint64*)bitmap;
+    //printf("p=0x%x\n", p);
+    for (bit64_off = 0; bit64_off < bit64_num; bit64_off++) {
+        if ((~(p[bit64_off])) == 0ULL) {
+            //printf("p[%d]=0x%llx : 0x%llx\n", bit64_off, ~p[bit64_off], 0ULL);
+            continue;
+        }
+        //printf("FOUND:p[%d]=0x%llx : 0x%llx\n", bit64_off, ~p[bit64_off], 0ULL);
+        break;
+    }
+    if (bit64_off == bit64_num) {
+        //printf("set_bit:not found1\n");
+        return -1;
+    }
+
+    int bit8_off;
+    int bit8_mod;
+    uint8* bitmap8 = (uint8*)(&p[bit64_off]);
+
+    for (bit8_off = 0; bit8_off < 8; bit8_off++) {
+        if ((~(bitmap8[bit8_off])) == 0U) {
+            continue;
+        }
+        for (bit8_mod = 0; bit8_mod < 8; bit8_mod++) {
+            if (BIT_IS_FREE8(bitmap8[bit8_off], bit8_mod)) {
+                goto done;
+            }
+        }
+    }
+done:
+    //printf("bi64_off=%d bit8_off=%d bit8_mod=%d\n", bit64_off, bit8_off, bit8_mod);
+
+    ret = ( (bit64_off * 64) + (bit8_off * 8) + bit8_mod );
+    if (ret >= bitmaxnum) {
+        //printf("set_bit:not found2:ret=%d\n", ret);
+        return -1;
+    }
+    //printf("&bitmap8[bit8_off]=0x%x value=0x%x\n", &bitmap8[bit8_off], BIT_SET(bitmap8[bit8_off], bit8_mod));
+    bitmap8[bit8_off] = BIT_SET(bitmap8[bit8_off], bit8_mod);
+    //printf("bitmap8[bit8_off]=0x%x bitmap[0]=0x%x\n", bitmap8[bit8_off], bitmap[0]);
+    return ret;
+}
+
+typedef struct {
+    MpuAddressRegionType *region;
+    char*	bitmap;
+    uint32	bitfreenum;
+} MallocRegionUnitType;
+
+typedef struct {
+    uint32 unit_num;
+    MallocRegionUnitType unit[MallocSize_Num];
+} MallocRegionGroupType;
+
+typedef struct {
+    uint32 group_num;
+    MallocRegionGroupType **groups;
+} MallocRegionType;
+
+static MallocRegionType malloc_region = {
+    0,
+    NULL,
+};
+
+
+uint32 mpu_malloc_get_memory(uint32 size)
+{
+    int i;
+    int j;
+    int candidate_index = -1;
+    MallocRegionUnitType *unit = NULL;
+
+    for (i = 0; i < MallocSize_Num; i++) {
+        if (malloc_data_info_table[i].memsize >= size) {
+            candidate_index = i;
+            break;
+        }
+    }
+    //printf("candidate=%d\n", candidate_index);
+    if (candidate_index < 0) {
+        return 0;
+    }
+
+    for (i = candidate_index; i < MallocSize_Num; i++) {
+        for (j = 0; j < malloc_region.group_num; j++) {
+            if (malloc_region.groups[j]->unit[i].bitfreenum > 0) {
+                unit = &malloc_region.groups[j]->unit[i];
+                goto done;
+            }
+        }
+    }
+done:
+    //printf("i=%d j=%d unit=0x%x\n", i, j, unit);
+    if (unit == NULL) {
+        return 0;
+    }
+    int index = set_bit(unit->bitmap, malloc_data_info_table[i].bitmaxnum, malloc_data_info_table[i].bitmapsize);
+    //printf("index=%d\n", index);
+    if (index < 0) {
+        return 0;
+    }
+    if (unit->region->data == NULL) {
+        unit->region->data = malloc(MPU_MALLOC_REGION_UNIT_SIZE * 1024);
+        ASSERT(unit->region->data != NULL);
+    }
+    unit->bitfreenum--;
+    return ( unit->region->start + (index * malloc_data_info_table[i].memsize));
+}
+
+static MallocRegionUnitType* search_unit(uint32 addr, int* indexp)
+{
+    int i;
+    int j;
+    MallocRegionUnitType *unit = NULL;
+    for (i = 0; i < MallocSize_Num; i++) {
+        for (j = 0; j < malloc_region.group_num; j++) {
+            unit = &malloc_region.groups[j]->unit[i];
+            if ((unit->region->start <= addr) &&
+                                        (addr < (unit->region->start + unit->region->size))) {
+                *indexp = i;
+                return unit;
+            }
+        }
+    }
+    return NULL;
+}
+
+void mpu_malloc_rel_memory(uint32 addr)
+{
+    MallocRegionUnitType* unit;
+    int index;
+    
+    unit = search_unit(addr, &index);
+    if (unit == NULL) {
+        return;
+    }
+
+    uint32 bits = ( (addr - unit->region->start) / malloc_data_info_table[index].memsize );
+    uint32 bit64_off = bits / 64;
+    uint32 bit64_mod = bits % 64;
+    uint32 bit8_off  = bit64_mod / 8;
+    uint32 bit8_mod  = bit64_mod % 8;
+
+    uint64* bitmap64 = &(((uint64*)unit->bitmap)[bit64_off]);
+    uint8* bimtap8 = &(((uint8*)bitmap64)[bit8_off]);
+
+    *bimtap8 = BIT_CLR(*bimtap8, bit8_mod);
+    unit->bitfreenum++;
+    return;
+}
+
+uint32 mpu_malloc_ref_size(uint32 addr)
+{
+    MallocRegionUnitType* unit;
+    int index;
+    
+    unit = search_unit(addr, &index);
+    ASSERT(unit != NULL);
+
+    return malloc_data_info_table[index].memsize;
+}
+
+static void group_init(MallocRegionGroupType* group)
+{
+    group->unit_num = 0;
+    memset(group->unit, 0, sizeof(MallocRegionUnitType) * MallocSize_Num);
+    int i;
+    for (i = 0; i < MallocSize_Num; i++) {
+        group->unit[i].bitfreenum = malloc_data_info_table[i].bitmaxnum;
+    }
+    return;
+}
+
+static void group_add_region(MallocRegionGroupType* group, MpuAddressRegionType *region)
+{
+    int index = group->unit_num;
+
+    group->unit[index].region = region;
+    group->unit[index].bitmap = malloc(malloc_data_info_table[index].bitmapsize);
+    memset(group->unit[index].bitmap, 0, malloc_data_info_table[index].bitmapsize);
+    ASSERT(group->unit[index].bitmap != NULL);
+
+    group->unit_num++;
+    return;
+}
+
+static bool group_has_free_unit(MallocRegionGroupType *group)
+{
+    int i;
+    if (group->unit_num < MallocSize_Num) {
+        return TRUE;
+    }
+    for (i = 0; i < group->unit_num; i++) {
+        if (group->unit[i].region == NULL) {
+            return TRUE;
+        }
+    }
+    return FALSE;
+}
+
+static MallocRegionGroupType* group_alloc(void)
+{
+    int index = malloc_region.group_num;
+
+    malloc_region.group_num++;
+    malloc_region.groups = (MallocRegionGroupType**)realloc(malloc_region.groups, 
+                                malloc_region.group_num * sizeof(MallocRegionGroupType*));
+    ASSERT(malloc_region.groups != NULL);
+
+    malloc_region.groups[index] = (MallocRegionGroupType*)malloc(sizeof(MallocRegionGroupType));
+    ASSERT(malloc_region.groups[index] != NULL);
+
+    group_init(malloc_region.groups[index]);
+    return malloc_region.groups[index];
+}
+
+static MallocRegionGroupType* group_get(void)
+{
+    int index;
+    if (malloc_region.groups == NULL) {
+        return group_alloc();
+    }
+    index = malloc_region.group_num - 1;
+    MallocRegionGroupType *group = malloc_region.groups[index];
+    if (group_has_free_unit(group) == TRUE) {
+        return group;
+    }
+    return group_alloc();
+}
+
+void  mpu_malloc_add_region(MpuAddressRegionType *region)
+{
+    MallocRegionGroupType* group = group_get();
+    group_add_region(group, region);
+    return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/mpu/mpu_malloc.h
@@ -0,0 +1,15 @@
+#ifndef _MPU_MALLOC_H_
+#define _MPU_MALLOC_H_
+
+#include "std_types.h"
+#include "std_errno.h"
+#include "mpu_types.h"
+#include "mpu_types.h"
+
+extern void  mpu_malloc_add_region(MpuAddressRegionType *region);
+extern uint32 mpu_malloc_get_memory(uint32 size);
+extern void  mpu_malloc_rel_memory(uint32 addr);
+extern uint32 mpu_malloc_ref_size(uint32 addr);
+
+
+#endif /* _MPU_MALLOC_H_ */
\ No newline at end of file
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/mpu/mpu_ops.h
@@ -0,0 +1,35 @@
+#ifndef _MPU_OPS_H_
+#define _MPU_OPS_H_
+
+#include "std_types.h"
+
+extern Std_ReturnType mpu_get_data8(CoreIdType core_id, uint32 addr, uint8 *data);
+extern Std_ReturnType mpu_get_data16(CoreIdType core_id, uint32 addr, uint16 *data);
+extern Std_ReturnType mpu_get_data32(CoreIdType core_id, uint32 addr, uint32 *data);
+
+extern Std_ReturnType mpu_put_data8(CoreIdType core_id, uint32 addr, uint8 data);
+extern Std_ReturnType mpu_put_data16(CoreIdType core_id, uint32 addr, uint16 data);
+extern Std_ReturnType mpu_put_data32(CoreIdType core_id, uint32 addr, uint32 data);
+
+extern Std_ReturnType mpu_get_pointer(CoreIdType core_id, uint32 addr, uint8 **data);
+
+
+/*
+ * the following enum values must be equal MemoryAddressImplType(cpuemu_ops.h).
+ */
+typedef enum {
+    MpuAddressGetType_ROM = 0,
+    MpuAddressGetType_RAM,
+    MpuAddressGetType_MMAP,
+    MpuAddressGetType_MALLOC,
+} MpuAddressGetType;
+#define MPU_MALLOC_REGION_UNIT_SIZE         1024    /* KB */
+#define MPU_MALLOC_REGION_UNIT_GROUP_NUM    10      /* 10MB */
+
+extern uint8 *mpu_address_set_rom_ram(MpuAddressGetType getType, uint32 addr, uint32 size, void *mmap_addr);
+extern uint8 *mpu_address_set_dev(uint32 addr, uint32 size, void *handler);
+extern uint8 *mpu_address_get_rom(uint32 addr, uint32 size);
+extern uint8 *mpu_address_get_ram(uint32 addr, uint32 size);
+extern void mpu_address_set_malloc_region(uint32 addr, uint32 size);
+
+#endif /* _MPU_OPS_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/mpu/mpu_types.h
@@ -0,0 +1,61 @@
+#ifndef _MPU_TYPES_H_
+#define _MPU_TYPES_H_
+
+#include "std_types.h"
+
+typedef enum {
+	READONLY_MEMORY = 0,
+	GLOBAL_MEMORY,
+	LOCAL_MEMORY,
+	PRIVATE_MEMORY,
+	DEVICE,
+	REGION_UNKNOWN,
+} MpuAddressRegionEnumType;
+
+extern MpuAddressRegionEnumType mpu_address_region_type_get(uint32 addr, std_bool *is_malloc);
+
+#define MPU_ADDRESS_REGION_MASK_ALL				0xFFFFFFFF
+#define MPU_ADDRESS_REGION_PERM_ALL				0xFFFFFFFF
+
+struct mpu_address_region_operation_type;
+typedef struct {
+	MpuAddressRegionEnumType					type;
+	bool										is_malloc;
+	/*
+	 * 本メモリ領域にアクセスできるcore_idのビットマップ
+	 * ビット位置がCPUのコアIDに対応する
+	 * 0：許可されてない
+	 * 1:許可されている
+	 */
+	uint32										permission;
+	uint32										start;
+	uint32										size;
+	uint32										mask;
+	uint8										*data;
+	struct mpu_address_region_operation_type	*ops;
+} MpuAddressRegionType;
+
+typedef struct mpu_address_region_operation_type {
+	Std_ReturnType (*get_data8) (MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 *data);
+	Std_ReturnType (*get_data16) (MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint16 *data);
+	Std_ReturnType (*get_data32) (MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 *data);
+
+	Std_ReturnType (*put_data8) (MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 data);
+	Std_ReturnType (*put_data16) (MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint16 data);
+	Std_ReturnType (*put_data32) (MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint32 data);
+
+	Std_ReturnType (*get_pointer) (MpuAddressRegionType *region, CoreIdType core_id, uint32 addr, uint8 **data);
+} MpuAddressRegionOperationType;
+
+extern MpuAddressRegionOperationType	default_memory_operation;
+
+
+#ifdef CPU_CONFIG_MEMORY_PROTECTION_ENABLE
+#include "target_cpu.h"
+extern bool cpu_has_permission(CoreIdType core_id, MpuAddressRegionEnumType region_type, CpuMemoryAccessType access_type, uint32 addr, uint32 size);
+#define CPU_HAS_PERMISSION(core_id, region_type, access_type, addr, size) cpu_has_permission(core_id, region_type, access_type, addr, size)
+#else
+#define CPU_HAS_PERMISSION(core_id, region_type, access_type, addr, size) TRUE
+#endif /* MPU_CONFIG_PROTECTION_ENABLE */
+
+#endif /* _MPU_TYPES_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/athrill_device.c
@@ -0,0 +1,274 @@
+#ifdef OS_LINUX
+
+#include "athrill_device.h"
+#include "mpu_ops.h"
+#include "symbol_ops.h"
+#include <string.h>
+#include <sys/file.h>
+#include "assert.h"
+#include "std_device_ops.h"
+#include "athrill_exdev.h"
+#include "cpuemu_ops.h"
+
+
+AthrillExDevOperationType athrill_exdev_operation;
+
+static uint32 athrill_device_func_call_addr = 0x0;
+static uint32 athrill_device_raise_interrupt_addr = 0x0;
+
+typedef struct {
+	bool isLocked;
+	AthrillDeviceMmapInfoType info;
+} AthrillDeviceMmapInfoTableEntryType;
+
+typedef struct {
+	uint32 count;
+	AthrillDeviceMmapInfoTableEntryType *entry;
+} AthrillDeviceMmapInfoTableType;
+
+static AthrillDeviceMmapInfoTableType athrill_mmap_table;
+
+void device_init_athrill_device(void)
+{
+    uint32 addr;
+    uint32 size;
+    int err;
+
+    err = symbol_get_gl("athrill_device_func_call", 
+        strlen("athrill_device_func_call"), &addr, &size);
+    if (err >= 0) {
+		printf("athrill_device_func_call=0x%x\n", addr);
+	    athrill_device_func_call_addr = addr;
+    }
+    err = symbol_get_gl("athrill_device_raise_interrupt", 
+        strlen("athrill_device_raise_interrupt"), &addr, &size);
+    if (err >= 0) {
+		printf("athrill_device_raise_interrupt=0x%x\n", addr);
+	    athrill_device_raise_interrupt_addr = addr;
+    }
+
+    return;
+}
+static Std_ReturnType athrill_device_get_memory(uint32 addr, uint8 **data)
+{
+	return mpu_get_pointer(0U, addr, data);
+}
+typedef struct {
+	AthrillExDeviceType *devp;
+	MpuAddressRegionType *region;
+} AthrillExtDevEntryType;
+typedef struct {
+	uint32 num;
+	AthrillExtDevEntryType **exdevs;
+} AthrillExtDevType;
+static AthrillExtDevType athrill_exdev;
+
+void device_init_athrill_exdev(void)
+{
+    /*
+     * device operation setting
+     */
+    athrill_exdev_operation.param.get_devcfg_string = &cpuemu_get_devcfg_string;
+    athrill_exdev_operation.param.get_devcfg_value = &cpuemu_get_devcfg_value;
+    athrill_exdev_operation.param.get_devcfg_value_hex = &cpuemu_get_devcfg_value_hex;
+
+    athrill_exdev_operation.intr.add_intr = NULL; //TODO
+    athrill_exdev_operation.intr.raise_intr = &cpuemu_raise_intr;
+
+    athrill_exdev_operation.dev.get_memory = &athrill_device_get_memory;
+    athrill_exdev_operation.dev.get_serial_fifo = &athrill_device_get_serial_fifo_buffer;
+
+    athrill_exdev_operation.libs.fifo.create = &comm_fifo_buffer_create;
+    athrill_exdev_operation.libs.fifo.add = &comm_fifo_buffer_add;
+    athrill_exdev_operation.libs.fifo.get = &comm_fifo_buffer_get;
+    athrill_exdev_operation.libs.fifo.close = &comm_fifo_buffer_close;
+    athrill_exdev_operation.libs.fifo.destroy = &comm_fifo_buffer_destroy;
+
+    athrill_exdev_operation.libs.tcp.client_close = &tcp_connection_close;
+    athrill_exdev_operation.libs.tcp.client_create = &tcp_client_create;
+    athrill_exdev_operation.libs.tcp.client_connect = &tcp_client_connect;
+
+    athrill_exdev_operation.libs.tcp.receive = &tcp_connection_receive;
+    athrill_exdev_operation.libs.tcp.receive_nblk = &tcp_connection_receive_nblk;
+    athrill_exdev_operation.libs.tcp.send = &tcp_connection_send;
+    athrill_exdev_operation.libs.tcp.send_nblk = &tcp_connection_send_nblk;
+
+    athrill_exdev_operation.libs.tcp.server_accept = &tcp_server_accept;
+    athrill_exdev_operation.libs.tcp.server_create = &tcp_server_create;
+    athrill_exdev_operation.libs.tcp.server_close = &tcp_server_close;
+
+    athrill_exdev_operation.libs.udp.create = &udp_comm_create;
+    athrill_exdev_operation.libs.udp.create_ipaddr = &udp_comm_create_ipaddr;
+    athrill_exdev_operation.libs.udp.read = &udp_comm_read;
+    athrill_exdev_operation.libs.udp.write = &udp_comm_write;
+    athrill_exdev_operation.libs.udp.remote_write = &udp_comm_remote_write;
+    athrill_exdev_operation.libs.udp.delete = &udp_server_delete;
+
+    athrill_exdev_operation.libs.thread.init = &mpthread_init;
+    athrill_exdev_operation.libs.thread.thr_register = &mpthread_register;
+    athrill_exdev_operation.libs.thread.lock = &mpthread_lock;
+    athrill_exdev_operation.libs.thread.unlock = &mpthread_unlock;
+    athrill_exdev_operation.libs.thread.get_status = &mpthread_get_status;
+    athrill_exdev_operation.libs.thread.start_proc = &mpthread_start_proc;
+    athrill_exdev_operation.libs.thread.wait_proc = &mpthread_wait_proc;
+    athrill_exdev_operation.libs.thread.timedwait_proc = &mpthread_timedwait_proc;
+
+    int i;
+    for (i = 0; i < athrill_exdev.num; i++) {
+    	athrill_exdev.exdevs[i]->devp->devinit(athrill_exdev.exdevs[i]->region, &athrill_exdev_operation);
+    }
+
+    return;
+}
+void device_add_athrill_exdev(void *devp, void *region)
+{
+	AthrillExtDevEntryType *entryp = malloc(sizeof(AthrillExtDevEntryType));
+	ASSERT(entryp != NULL);
+	entryp->devp = (AthrillExDeviceType*)devp;
+	entryp->region = (MpuAddressRegionType*)region;
+	athrill_exdev.num++;
+	athrill_exdev.exdevs = realloc(athrill_exdev.exdevs,
+			 sizeof(AthrillExtDevEntryType*) * athrill_exdev.num);
+	ASSERT(athrill_exdev.exdevs != NULL);
+	athrill_exdev.exdevs[athrill_exdev.num - 1] = entryp;
+	return;
+}
+void athrill_device_set_mmap_info(AthrillDeviceMmapInfoType *info)
+{
+	int inx = athrill_mmap_table.count;
+	athrill_mmap_table.count++;
+	athrill_mmap_table.entry = realloc(athrill_mmap_table.entry,
+			sizeof(AthrillDeviceMmapInfoTableEntryType) * athrill_mmap_table.count);
+	ASSERT(athrill_mmap_table.entry != NULL);
+
+	athrill_mmap_table.entry[inx].isLocked = FALSE;
+	athrill_mmap_table.entry[inx].info = *info;
+	return;
+}
+
+static inline AthrillDeviceMmapInfoTableEntryType *getMmapInfo(void *addr)
+{
+	int i;
+	for (i = 0; i < athrill_mmap_table.count; i++) {
+		if (addr == athrill_mmap_table.entry[i].info.addr) {
+			return &athrill_mmap_table.entry[i];
+		}
+	}
+	return NULL;
+}
+
+// 最適化のために、ポインタを覚えておくようにする
+// staticにすると値が最適化で値が変化しない可能性があるので、グローバルにしておく
+volatile uint32 *athrill_syscall_p = 0;
+
+static void do_athrill_device_func_call(void)
+{
+    Std_ReturnType err;
+    uint32 data;
+
+    if ( athrill_syscall_p ) {
+        data = *athrill_syscall_p;
+    } else {
+        if (athrill_device_func_call_addr == 0x0) {
+            return;
+        }
+
+//    err = mpu_get_data32(0U, athrill_device_func_call_addr, &data);
+        err = mpu_get_pointer(0,athrill_device_func_call_addr,(uint8 **)&athrill_syscall_p);
+        if (err != 0) {
+           return;
+        }
+        data = *athrill_syscall_p;
+
+    }
+    if (data == 0U) {
+        return;
+    }
+
+    AthrillDeviceMmapInfoTableEntryType *mmapInfo = getMmapInfo(CAST_UINT32_TO_ADDR(data));
+    if (mmapInfo == NULL) {
+        athrill_syscall_device(data);
+    }
+    else {
+    	int err;
+    	if (mmapInfo->isLocked == FALSE) {
+    		err = flock(mmapInfo->info.fd, LOCK_EX);
+    		mmapInfo->isLocked = TRUE;
+    	}
+    	else {
+    		err = flock(mmapInfo->info.fd, LOCK_UN);
+    		mmapInfo->isLocked = FALSE;
+    	}
+		ASSERT(err == 0);
+    }
+
+    (void)mpu_put_data32(0U, athrill_device_func_call_addr, 0U);
+	return;
+}
+static void do_athrill_device_external_raise_interrupt(void)
+{
+    Std_ReturnType err;
+    uint32 data;
+
+    if (athrill_device_raise_interrupt_addr == 0x0) {
+        return;
+    }
+
+    err = mpu_get_data32(0U, athrill_device_raise_interrupt_addr, &data);
+    if (err != 0) {
+        return;
+    }
+    if (data == 0U) {
+        return;
+    }
+    (void)mpu_put_data32(0U, athrill_device_raise_interrupt_addr, 0U);
+	(void)intc_raise_intr(data);
+	return;
+}
+#ifdef CONFIG_STAT_PERF
+ProfStatType cpuemu_dev_adev1_prof;
+ProfStatType cpuemu_dev_adev2_prof;
+
+#define CPUEMU_DEV_ADEV1_PROF_START()	profstat_start(&cpuemu_dev_adev1_prof)
+#define CPUEMU_DEV_ADEV1_PROF_END()		profstat_end(&cpuemu_dev_adev1_prof)
+#define CPUEMU_DEV_ADEV2_PROF_START()	profstat_start(&cpuemu_dev_adev2_prof)
+#define CPUEMU_DEV_ADEV2_PROF_END()		profstat_end(&cpuemu_dev_adev2_prof)
+#else
+#define CPUEMU_DEV_ADEV1_PROF_START()
+#define CPUEMU_DEV_ADEV1_PROF_END()	
+#define CPUEMU_DEV_ADEV2_PROF_START()
+#define CPUEMU_DEV_ADEV2_PROF_END()	
+#endif /* CONFIG_STAT_PERF */
+void device_supply_clock_athrill_device(void)
+{
+    CPUEMU_DEV_ADEV1_PROF_START();
+	do_athrill_device_func_call();
+    CPUEMU_DEV_ADEV1_PROF_END();
+
+    CPUEMU_DEV_ADEV2_PROF_START();
+	do_athrill_device_external_raise_interrupt();
+    CPUEMU_DEV_ADEV2_PROF_END();
+    return;
+}
+
+void device_supply_clock_exdev(DeviceClockType *dev_clock)
+{
+    int i;
+    for (i = 0; i < athrill_exdev.num; i++) {
+    	athrill_exdev.exdevs[i]->devp->supply_clock(dev_clock);
+    }
+    return;
+}
+void athrill_device_cleanup(void)
+{
+    int i;
+    for (i = 0; i < athrill_exdev.num; i++) {
+	if (athrill_exdev.exdevs[i]->devp->cleanup == NULL) {
+		continue;
+	}
+    	athrill_exdev.exdevs[i]->devp->cleanup();
+    }
+    return;
+}
+
+#endif /* OS_LINUX */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/athrill_mpthread.c
@@ -0,0 +1,155 @@
+#include "athrill_mpthread.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <pthread.h>
+#include "assert.h"
+#include <time.h>
+
+typedef struct {
+    MpthrIdType         id;
+    uint32              timeout;
+    MpthrStatusType     status;
+    MpthrOperationType  *op;
+	pthread_t           thread;
+    pthread_mutex_t     mutex;
+    pthread_cond_t      cond;
+} MpthrInfoType;
+
+static uint32 mpthread_num = 0;
+static pthread_mutex_t     mpthread_mutex = PTHREAD_MUTEX_INITIALIZER;
+#define MPTHREAD_MAX_NUM	1024
+static MpthrInfoType mpthread_info[1024];
+
+
+static void *mpthread_run(void *arg)
+{
+    MpthrInfoType *infop = ((MpthrInfoType*)arg);
+    MpthrIdType id = infop->id;
+    struct timespec abstime;
+
+    mpthread_info[id].op->do_init(id);
+
+    mpthread_lock(id);
+    while (TRUE) {
+        if (mpthread_info[id].status != MPTHR_STATUS_RUNNING) {
+            if (mpthread_info[id].timeout == 0) {
+                pthread_cond_wait(&mpthread_info[id].cond, &mpthread_info[id].mutex);
+            }
+            else {
+                abstime.tv_sec = 0;
+                abstime.tv_nsec = mpthread_info[id].timeout * 1000;
+                pthread_cond_timedwait(&mpthread_info[id].cond, &mpthread_info[id].mutex, &abstime);
+            }
+            continue;
+        }
+        mpthread_unlock(id);
+
+        mpthread_info[id].op->do_proc(id);
+
+        mpthread_lock(id);
+    }
+    return NULL;
+}
+
+/*
+ * Manager api
+ */
+Std_ReturnType mpthread_init(void)
+{
+    //nothing to do
+    return STD_E_OK;
+}
+Std_ReturnType mpthread_register(MpthrIdType *id, MpthrOperationType *op)
+{
+    MpthrIdType new_id;
+    
+    pthread_mutex_lock(&mpthread_mutex);
+    if (mpthread_num >= MPTHREAD_MAX_NUM) {
+    	printf("ERROR: max(%u) mpthread creation litmit\n", MPTHREAD_MAX_NUM);
+        pthread_mutex_unlock(&mpthread_mutex);
+    	return STD_E_LIMIT;
+    }
+    new_id = mpthread_num;
+    mpthread_num++;
+
+    mpthread_info[new_id].id = new_id;
+    mpthread_info[new_id].timeout = 0;
+    mpthread_info[new_id].status = MPTHR_STATUS_INITIALIZING;
+    mpthread_info[new_id].op = op;
+
+    pthread_mutex_init(&mpthread_info[new_id].mutex, NULL);
+    pthread_cond_init(&mpthread_info[new_id].cond, NULL);
+    pthread_create(&mpthread_info[new_id].thread , NULL , mpthread_run , (void*)&mpthread_info[new_id]);
+
+    *id = new_id;
+    pthread_mutex_unlock(&mpthread_mutex);
+    return STD_E_OK;
+}
+
+/*
+ * Thread api
+ */
+void mpthread_lock(MpthrIdType id)
+{
+    if (id >= mpthread_num) {
+        return;
+    }
+    pthread_mutex_lock(&mpthread_info[id].mutex);
+    return;
+}
+
+void mpthread_unlock(MpthrIdType id)
+{
+    if (id >= mpthread_num) {
+        return;
+    }
+    pthread_mutex_unlock(&mpthread_info[id].mutex);
+    return;
+}
+
+MpthrStatusType mpthread_get_status(MpthrIdType id)
+{
+    if (id >= mpthread_num) {
+        return STD_E_INVALID;
+    }
+    return mpthread_info[id].status;
+}
+
+Std_ReturnType mpthread_start_proc(MpthrIdType id)
+{
+    if (id >= mpthread_num) {
+        return STD_E_INVALID;
+    }
+    mpthread_lock(id);
+    mpthread_info[id].status = MPTHR_STATUS_RUNNING;
+    pthread_cond_signal(&mpthread_info[id].cond);
+    mpthread_unlock(id);
+    return STD_E_OK;
+}
+Std_ReturnType mpthread_wait_proc(MpthrIdType id)
+{
+    if (id >= mpthread_num) {
+        return STD_E_INVALID;
+    }
+    mpthread_lock(id);
+    mpthread_info[id].timeout = 0;
+    mpthread_info[id].status = MPTHR_STATUS_WAITING;
+    mpthread_unlock(id);
+    return STD_E_OK;
+}
+Std_ReturnType mpthread_timedwait_proc(MpthrIdType id, sint32 timeout)
+{
+    if (id >= mpthread_num) {
+        return STD_E_INVALID;
+    }
+    mpthread_lock(id);
+    mpthread_info[id].timeout = timeout;
+    mpthread_info[id].status = MPTHR_STATUS_WAITING;
+    mpthread_unlock(id);
+    return STD_E_OK;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/athrill_syscall_device.c
@@ -0,0 +1,1112 @@
+#include "athrill_device.h"
+#include "mpu_ops.h"
+#define ATHRILL_SYSCALL_DEVICE
+#include "athrill_syscall.h"
+#include <stdio.h>
+#include <sys/fcntl.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include <sys/select.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include "mpu_malloc.h"
+#include "assert.h"
+#include "target/target_os_api.h"
+#include "cpuemu_ops.h"
+
+struct athrill_syscall_functable {
+    void (*func) (AthrillSyscallArgType *arg);
+};
+
+static void athrill_syscall_none(AthrillSyscallArgType *arg);
+static void athrill_syscall_socket(AthrillSyscallArgType *arg);
+static void athrill_syscall_sense(AthrillSyscallArgType *arg);
+static void athrill_syscall_bind(AthrillSyscallArgType *arg);
+static void athrill_syscall_listen(AthrillSyscallArgType *arg);
+static void athrill_syscall_accept(AthrillSyscallArgType *arg);
+static void athrill_syscall_connect(AthrillSyscallArgType *arg);
+static void athrill_syscall_select(AthrillSyscallArgType *arg);
+static void athrill_syscall_send(AthrillSyscallArgType *arg);
+static void athrill_syscall_recv(AthrillSyscallArgType *arg);
+static void athrill_syscall_shutdown(AthrillSyscallArgType *arg);
+static void athrill_syscall_system(AthrillSyscallArgType *arg);
+static void athrill_syscall_malloc(AthrillSyscallArgType *arg);
+static void athrill_syscall_calloc(AthrillSyscallArgType *arg);
+static void athrill_syscall_realloc(AthrillSyscallArgType *arg);
+static void athrill_syscall_free(AthrillSyscallArgType *arg);
+
+static void athrill_syscall_open_r(AthrillSyscallArgType *arg);
+static void athrill_syscall_read_r(AthrillSyscallArgType *arg);
+static void athrill_syscall_write_r(AthrillSyscallArgType *arg);
+static void athrill_syscall_close_r(AthrillSyscallArgType *arg);
+static void athrill_syscall_lseek_r(AthrillSyscallArgType *arg);
+
+static void athrill_syscall_set_virtfs_top(AthrillSyscallArgType *arg);
+
+static void athrill_syscall_ev3_opendir(AthrillSyscallArgType *arg);
+static void athrill_syscall_ev3_readdir(AthrillSyscallArgType *arg);
+static void athrill_syscall_ev3_closedir(AthrillSyscallArgType *arg);
+
+static void athrill_syscall_ev3_serial_open(AthrillSyscallArgType *arg);
+static void athrill_syscall_exit(AthrillSyscallArgType *arg);
+
+static void athrill_syscall_v850_set_intpri(AthrillSyscallArgType *arg);
+
+static void athrill_syscall_reset_time(AthrillSyscallArgType *arg);
+static void athrill_syscall_show_time(AthrillSyscallArgType *arg);
+
+
+
+
+
+static struct athrill_syscall_functable syscall_table[SYS_API_ID_NUM] = {
+    { athrill_syscall_none },
+    { athrill_syscall_socket },
+    { athrill_syscall_sense },
+    { athrill_syscall_bind },
+    { athrill_syscall_listen },
+    { athrill_syscall_accept },
+    { athrill_syscall_connect },
+    { athrill_syscall_select },
+    { athrill_syscall_send },
+    { athrill_syscall_recv },
+    { athrill_syscall_shutdown },
+    { athrill_syscall_system },
+    { athrill_syscall_malloc },
+    { athrill_syscall_calloc },
+    { athrill_syscall_realloc },
+    { athrill_syscall_free },
+
+    { athrill_syscall_open_r },
+    { athrill_syscall_read_r },
+    { athrill_syscall_write_r },
+    { athrill_syscall_close_r },
+    { athrill_syscall_lseek_r },
+    { athrill_syscall_set_virtfs_top },
+
+    { athrill_syscall_ev3_opendir },
+    { athrill_syscall_ev3_readdir },
+    { athrill_syscall_ev3_closedir },
+
+    { athrill_syscall_ev3_serial_open },
+
+    { athrill_syscall_exit },
+
+    { athrill_syscall_v850_set_intpri },
+    { athrill_syscall_reset_time },
+    { athrill_syscall_show_time }
+};
+
+void athrill_syscall_device(uint32 addr)
+{
+    Std_ReturnType err;
+    AthrillSyscallArgType *argp;
+
+    err = mpu_get_pointer(0U, addr, (uint8 **)&argp);
+    if (err != 0) {
+        return;
+    }
+
+    if (argp->api_id >= SYS_API_ID_NUM) {
+        return;
+    }
+    syscall_table[argp->api_id].func(argp);
+    return;
+}
+
+static void athrill_syscall_none(AthrillSyscallArgType *arg)
+{
+    //nothing to do
+    return;
+}
+static void athrill_syscall_socket(AthrillSyscallArgType *arg)
+{
+    int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);
+    if (sockfd < 0) {
+    	printf("ERROR:%s(): errno=%d\n", __FUNCTION__, errno);
+        return;
+    }
+    arg->ret_value = sockfd;
+    return;
+}
+
+static void athrill_syscall_sense(AthrillSyscallArgType *arg)
+{
+    fd_set fds;
+    struct timeval tv;
+    int retval;
+    int val;
+    socklen_t len = sizeof(val);
+
+    FD_ZERO(&fds);
+    FD_SET(arg->body.api_sense.sockfd, &fds);
+
+    tv.tv_sec = 0;
+    tv.tv_usec = 0;
+
+    switch (arg->body.api_sense.api_id) {
+    case SYS_API_ID_CONNECT:
+        retval = select(arg->body.api_sense.sockfd + 1, NULL, &fds, NULL, &tv);
+        break;
+    default:
+        return;;
+    }
+    if (retval < 0) {
+        arg->ret_value = -errno;
+    }
+    else if (retval == 0) {
+        arg->ret_value = -EAGAIN;
+    }
+    else {
+        retval = getsockopt(arg->body.api_sense.sockfd, SOL_SOCKET, SO_ERROR, &val, &len);
+        if (retval < 0) {
+            arg->ret_value = -errno;
+            return;
+        }
+        else {
+            arg->ret_value = -val;
+        }
+    }
+    return;
+}
+
+
+static void athrill_syscall_bind(AthrillSyscallArgType *arg)
+{
+    Std_ReturnType err;
+    struct sockaddr_in server_addr;
+    struct sys_sockaddr_in *sockaddrp;
+    int yes = 1;
+
+    err = mpu_get_pointer(0U, arg->body.api_bind.sockaddr, (uint8 **)&sockaddrp);
+    if (err != 0) {
+        return;
+    }
+    err = setsockopt(arg->body.api_bind.sockfd, SOL_SOCKET, SO_REUSEADDR, (const char*)&yes, sizeof(yes));
+    if (err != 0) {
+        return;
+    }
+
+    memset(&server_addr, 0, sizeof(server_addr));
+    server_addr.sin_family = PF_INET;
+    server_addr.sin_addr.s_addr = (sockaddrp->sin_addr);
+    server_addr.sin_port = (sockaddrp->sin_port);
+
+    int ret = bind(arg->body.api_bind.sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr));
+    if (ret < 0) {
+        arg->ret_value = -errno;
+    }
+    else {
+        arg->ret_value = SYS_API_ERR_OK;
+    }
+
+    return;
+}
+
+
+static void athrill_syscall_listen(AthrillSyscallArgType *arg)
+{
+    int ret = listen(arg->body.api_listen.sockfd, arg->body.api_listen.backlog);
+    if (ret < 0) {
+        arg->ret_value = -errno;
+    }
+    else {
+        arg->ret_value = SYS_API_ERR_OK;
+    }
+    return;
+}
+
+static void athrill_syscall_accept(AthrillSyscallArgType *arg)
+{
+    Std_ReturnType err;
+    struct sockaddr_in client_addr;
+    struct sys_sockaddr_in *sockaddrp;
+    socklen_t addrlen;
+    sys_uint32 *addrlenp;
+
+    err = mpu_get_pointer(0U, arg->body.api_accept.sockaddr, (uint8 **)&sockaddrp);
+    if (err != 0) {
+        return;
+    }
+    err = mpu_get_pointer(0U, arg->body.api_accept.addrlen, (uint8 **)&addrlenp);
+    if (err != 0) {
+        return;
+    }
+
+    memset(&client_addr, 0, sizeof(client_addr));
+    addrlen = sizeof(client_addr);
+    int ret = accept(arg->body.api_accept.sockfd, (struct sockaddr *)&client_addr, &addrlen);
+    if (ret < 0) {
+        arg->ret_value = -errno;
+    }
+    else {
+        sockaddrp->sin_family = PF_INET;
+        sockaddrp->sin_port = ntohs(client_addr.sin_port);
+        sockaddrp->sin_addr = ntohl(client_addr.sin_addr.s_addr);
+        *addrlenp = addrlen;
+        arg->ret_value = ret;
+    }
+    return;
+}
+
+static void athrill_syscall_connect(AthrillSyscallArgType *arg)
+{
+    Std_ReturnType err;
+    struct sockaddr_in client_addr;
+    struct sys_sockaddr_in *sockaddrp;
+
+    err = mpu_get_pointer(0U, arg->body.api_connect.sockaddr, (uint8 **)&sockaddrp);
+    if (err != 0) {
+        return;
+    }
+    memset(&client_addr, 0, sizeof(client_addr));
+    client_addr.sin_family = PF_INET;
+    client_addr.sin_addr.s_addr = (sockaddrp->sin_addr);
+    client_addr.sin_port = (sockaddrp->sin_port);
+
+    int ret = connect(arg->body.api_connect.sockfd, (struct sockaddr *)&client_addr, sizeof(client_addr));
+    if (ret < 0) {
+        arg->ret_value = -errno;
+    }
+    else {
+        arg->ret_value = SYS_API_ERR_OK;
+    }
+
+    return;
+}
+
+static sys_int32 fd_set_copy(unsigned char *dst, unsigned char *src)
+{
+    sys_int32 i;
+    sys_int32 j;
+    sys_int32 count = 0;
+    sys_int32 fd_size = sizeof(fd_set);
+    sys_int32 num = (fd_size < sizeof(sys_fd_set)) ? fd_size: sizeof(sys_fd_set);
+
+    if ((dst == NULL) || (src == NULL)) {
+        return 0;
+    }
+
+    for (i = 0; i < num; i++) {
+        dst[i] = src[i];
+        //printf("fd_set_copy:dst[%d]=0x%x\n", i, dst[i]);
+        //printf("fd_set_copy:src[%d]=0x%x\n", i, src[i]);
+        for (j = 0; j < 8; j++) {
+            if ( (dst[i] & (1 << j)) != 0) {
+                count++;
+            }
+        }
+    }
+    return count;
+}
+
+static void athrill_syscall_select(AthrillSyscallArgType *arg)
+{
+    Std_ReturnType err;
+    sys_fd_set *sys_readfds;
+    sys_fd_set *sys_writefds;
+    sys_fd_set *sys_exceptfds;
+    fd_set readfds;
+    fd_set writefds;
+    fd_set exceptfds;
+    struct timeval tmo;
+    sys_int32 count = 0;
+
+    if (arg->body.api_select.readfds == 0) {
+        sys_readfds = NULL;
+    }
+    else {
+        err = mpu_get_pointer(0U, (uint32)arg->body.api_select.readfds, (uint8 **)&sys_readfds);
+        if (err != 0) {
+            return;
+        }
+    }
+    if (arg->body.api_select.writefds == 0) {
+        sys_writefds = NULL;
+    }
+    else {
+        err = mpu_get_pointer(0U, (uint32)arg->body.api_select.writefds, (uint8 **)&sys_writefds);
+        if (err != 0) {
+            return;
+        }
+    }
+    if (arg->body.api_select.exceptfds == 0) {
+        sys_exceptfds = NULL;
+    }
+    else {
+        err = mpu_get_pointer(0U, (uint32)arg->body.api_select.exceptfds, (uint8 **)&sys_exceptfds);
+        if (err != 0) {
+            return;
+        }
+    }
+    FD_ZERO(&readfds);
+    FD_ZERO(&writefds);
+    FD_ZERO(&exceptfds);
+    count = fd_set_copy((unsigned char*)&readfds, (unsigned char*)sys_readfds);
+    count += fd_set_copy((unsigned char*)&writefds, (unsigned char*)sys_writefds);
+    count += fd_set_copy((unsigned char*)&exceptfds, (unsigned char*)sys_exceptfds);
+    tmo.tv_sec = 0;
+    tmo.tv_usec = 0;
+    int ret = select(sizeof(sys_fd_set) * 8, &readfds, &writefds, &exceptfds, &tmo);
+    if (ret < 0) {
+        arg->ret_value = -errno;
+    }
+    else {
+        if (sys_readfds != NULL) {
+            memset((unsigned char*)sys_readfds, 0, sizeof(sys_fd_set));
+        }
+        if (sys_writefds != NULL) {
+            memset((unsigned char*)sys_writefds, 0, sizeof(sys_fd_set));
+        }
+        if (sys_exceptfds != NULL) {
+            memset((unsigned char*)sys_exceptfds, 0, sizeof(sys_fd_set));
+        }
+
+        count = fd_set_copy((unsigned char*)sys_readfds, (unsigned char*)&readfds);
+        count += fd_set_copy((unsigned char*)sys_writefds, (unsigned char*)&writefds);
+        count += fd_set_copy((unsigned char*)sys_exceptfds, (unsigned char*)&exceptfds);
+        arg->ret_value = count;
+    }
+
+    return;
+}
+static void athrill_syscall_send(AthrillSyscallArgType *arg)
+{
+    Std_ReturnType err;
+    char *bufp;
+    ssize_t ret;
+
+    err = mpu_get_pointer(0U, arg->body.api_send.buf, (uint8 **)&bufp);
+    if (err != 0) {
+        return;
+    }
+    ret = send(arg->body.api_send.sockfd, bufp, arg->body.api_send.len, MSG_DONTWAIT);
+    if (ret < 0) {
+        arg->ret_value = -errno;
+    }
+    arg->ret_value = ret;
+    return;
+}
+
+static void athrill_syscall_recv(AthrillSyscallArgType *arg)
+{
+    Std_ReturnType err;
+    char *bufp;
+    ssize_t ret;
+
+    err = mpu_get_pointer(0U, arg->body.api_recv.buf, (uint8 **)&bufp);
+    if (err != 0) {
+        return;
+    }
+    ret = recv(arg->body.api_recv.sockfd, bufp, arg->body.api_recv.len, MSG_DONTWAIT);
+    if (ret < 0) {
+        arg->ret_value = -errno;
+    }
+    arg->ret_value = ret;
+    return;
+}
+
+static void athrill_syscall_shutdown(AthrillSyscallArgType *arg)
+{
+    arg->ret_value = SYS_API_ERR_OK;
+    (void)close(arg->body.api_shutdown.sockfd);
+    return;
+}
+
+static void athrill_syscall_system(AthrillSyscallArgType *arg)
+{
+	char cmd[256];
+   	snprintf(cmd, sizeof(cmd), "athrill_extfunc.sh %u", arg->body.api_system.id);
+   	if (system(cmd) < 0) {
+   		printf("can not execute athrill_extfunc.sh\n");
+        return;
+   	}
+    arg->ret_value = SYS_API_ERR_OK;
+    return;
+}
+
+static void athrill_syscall_malloc(AthrillSyscallArgType *arg)
+{
+    if (arg->body.api_malloc.size == 0) {
+        arg->body.api_malloc.rptr = 0;
+    }
+    else {
+        arg->body.api_malloc.rptr = mpu_malloc_get_memory(arg->body.api_malloc.size);
+    }
+    return;
+}
+
+static void athrill_syscall_calloc(AthrillSyscallArgType *arg)
+{
+    Std_ReturnType err;
+    uint32 size;
+    uint8 *addrp;
+
+    if ((arg->body.api_calloc.size == 0) || (arg->body.api_calloc.nmemb == 0)) {
+        arg->body.api_calloc.rptr = 0;
+        return;
+    }
+    size = arg->body.api_calloc.size * arg->body.api_calloc.nmemb;
+
+    arg->body.api_calloc.rptr = mpu_malloc_get_memory(size);
+    if (arg->body.api_calloc.rptr == 0) {
+        return;
+    }
+
+    err = mpu_get_pointer(0U, arg->body.api_calloc.rptr, (uint8 **)&addrp);
+    ASSERT(err == 0);
+
+    memset((void*)addrp, 0, size);
+    return;
+}
+
+static void athrill_syscall_realloc(AthrillSyscallArgType *arg)
+{
+    Std_ReturnType err;
+    uint8 *src_addrp;
+    uint8 *dest_addrp;
+
+    arg->body.api_realloc.rptr = mpu_malloc_get_memory(arg->body.api_realloc.size);
+    if (arg->body.api_realloc.rptr == 0) {
+        return;
+    }
+
+    err = mpu_get_pointer(0U, arg->body.api_realloc.ptr, (uint8 **)&src_addrp);
+    ASSERT(err == 0);
+
+    err = mpu_get_pointer(0U, arg->body.api_realloc.rptr, (uint8 **)&dest_addrp);
+    ASSERT(err == 0);
+
+    uint32 size = mpu_malloc_ref_size(arg->body.api_realloc.ptr);
+ 
+    memcpy((void*)dest_addrp, (void*)src_addrp, size);
+
+    mpu_malloc_rel_memory(arg->body.api_realloc.ptr);
+    return;
+}
+
+static void athrill_syscall_free(AthrillSyscallArgType *arg)
+{
+    mpu_malloc_rel_memory(arg->body.api_free.ptr);
+
+    return;
+}
+
+static int create_directory(const char* dir)
+{
+    int ret = 0;
+
+    if ( (mkdir(dir,0777) == -1) && (errno != EEXIST) ) {
+        printf("create_directory() mkdir failed path=%s errno=0x%x",
+            dir, errno);
+        ret = -1;
+    } 
+    return ret;
+}
+
+#ifdef ENABLE_EXTERNAL_BT_SERIAL
+#include "serial_fifo.h"
+typedef struct {
+    int file_descriptor;
+    AthrillSerialFifoType   *fifo;
+} ExternalSerialFifoMapType;
+typedef enum {
+    ExternalSerialFifoId_0 = 0,
+    ExternalSerialFifoId_1,
+    ExternalSerialFifoId_NUM
+} ExternalSerialFifoIdType;
+static ExternalSerialFifoMapType external_serial_fifo_map[ExternalSerialFifoId_NUM];
+static AthrillSerialFifoType *get_serial_fifo(ExternalSerialFifoIdType id)
+{
+    AthrillSerialFifoType *fifop = NULL;
+    Std_ReturnType err;
+    uint32 scid;
+    if (id == ExternalSerialFifoId_0) {
+        err = cpuemu_get_devcfg_value("DEVICE_CONFIG_EV3_CH0_SERIAL_ID", (uint32*)&scid);
+    }
+    else if (id == ExternalSerialFifoId_1) {
+        err = cpuemu_get_devcfg_value("DEVICE_CONFIG_EV3_CH1_SERIAL_ID", (uint32*)&scid);
+    }
+    else {
+        return NULL;
+    }
+    if (err != STD_E_OK) {
+        return NULL;
+    }
+    athrill_device_get_serial_fifo_buffer(scid, &fifop);
+    return fifop;
+}
+static AthrillSerialFifoType *get_serial_fifo_from_fd(int fd)
+{
+    int i;
+    for (i = 0; i < ExternalSerialFifoId_NUM; i++) {
+        if (fd == external_serial_fifo_map[i].file_descriptor) {
+            return external_serial_fifo_map[i].fifo;
+        }
+    }
+    return NULL;
+}
+
+static std_bool athrill_ev3_serial_is_opened(ExternalSerialFifoIdType id)
+{
+    if (external_serial_fifo_map[id].file_descriptor > 0) {
+        return TRUE;
+    }
+    else {
+        return FALSE;
+    }
+}
+static void athrill_ev3_serial_set_fd(ExternalSerialFifoIdType id, int fd, AthrillSerialFifoType *fifop)
+{
+    external_serial_fifo_map[id].file_descriptor = fd;
+    external_serial_fifo_map[id].fifo = fifop;
+    return;
+}
+#endif /* ENABLE_EXTERNAL_BT_SERIAL */
+
+char *virtual_file_top = 0;
+static char *getVirtualFileName(const char *file_name, char *buf)
+{
+    if ( !virtual_file_top ) {
+        virtual_file_top = "_ev3rtfs";
+        cpuemu_get_devcfg_string("DEVICE_CONFIG_VIRTFS_TOP",&virtual_file_top);
+        create_directory(virtual_file_top);
+    }
+    strcpy(buf,virtual_file_top);
+    strcat(buf,"/");
+    strcat(buf,file_name);
+    return buf;
+}
+
+// T.B.D. assume fd is not used so much
+#define SPECIAL_FD_NUM (1024)
+static int special_fd_table[SPECIAL_FD_NUM] = {0};
+static inline int get_correspond_fd(int fd)
+{
+	ASSERT( 0<= fd && fd < SPECIAL_FD_NUM);
+    if ( special_fd_table[fd] ) {
+        return special_fd_table[fd];
+    }
+	return fd;
+}
+static inline int set_correspond_fd(int fd, int curresponding_fd)
+{
+	ASSERT( 0<= fd && fd < SPECIAL_FD_NUM);	
+	return special_fd_table[fd] = curresponding_fd;
+}
+
+static inline int is_stream_fd(int fd)
+{
+    return get_correspond_fd(fd) != fd;
+}
+
+
+
+static void athrill_syscall_open_r(AthrillSyscallArgType *arg)
+{
+    Std_ReturnType err;
+    char *file_name;
+    int mode = arg->body.api_open_r.mode;
+    char buf[255];
+    int flags = athrill_syscall_open_r_flag(arg->body.api_open_r.flags);
+    int fd;
+
+    err = mpu_get_pointer(0U, arg->body.api_open_r.file_name,(uint8**)&file_name);
+    ASSERT(err == 0);
+    fd = open(getVirtualFileName(file_name,buf), flags, mode); 
+
+    //printf("open_r file=%s real_path=%s mode=%x fd=%d\n",file_name,buf,mode,fd);
+
+    arg->ret_value = fd;
+
+    return;
+
+}
+static void athrill_syscall_read_r(AthrillSyscallArgType *arg)
+{
+    Std_ReturnType err;
+    char *buf;
+    int fd = arg->body.api_read_r.fd;
+    size_t size = (size_t)arg->body.api_read_r.size;
+
+    err = mpu_get_pointer(0U, arg->body.api_read_r.buf,(uint8**)&buf);
+    if (err != STD_E_OK) {
+    	arg->ret_value = err;
+		return;
+    }
+
+#ifdef ENABLE_EXTERNAL_BT_SERIAL
+    AthrillSerialFifoType *fifop = get_serial_fifo_from_fd(fd);
+    if (fifop != NULL) {
+        arg->ret_value = 0;
+        arg->ret_errno = 0;
+    	mpthread_lock(fifop->rx_thread);
+        Std_ReturnType ret = comm_fifo_buffer_get(&fifop->rd, buf, size, (uint32*)&arg->ret_value);
+    	mpthread_unlock(fifop->rx_thread);
+        if (ret == STD_E_NOENT) {
+            arg->ret_value = -1;
+            arg->ret_errno = 0;
+        }
+        return;
+    }
+#endif /* ENABLE_EXTERNAL_BT_SERIAL */
+    // if fd has corresponding fd(for write), it is stream
+    int is_stream = is_stream_fd(fd);
+
+    int ret = read(fd, buf, size);
+    if ( ret == 0 && is_stream ) {
+        // this is stream. treat as EAGAIN
+        ret = -1;
+        errno = 0; // this means EOS
+    }
+
+    arg->ret_value = ret;
+    arg->ret_errno = 0;
+
+    if ( ret == -1 ) {
+        if ( (errno == EAGAIN) || (errno == ESPIPE) ) {
+            arg->ret_errno = SYS_API_ERR_AGAIN;
+        }
+    }        
+//    printf("read_r fd=%d buf=0x%x(real:%p) size=%zu ret=%d errno=%d ret_errno=%d\n",fd,arg->body.api_read_r.buf,buf,size,arg->ret_value,errno, arg->ret_errno);
+    
+    return;
+
+}
+
+static void athrill_syscall_write_r(AthrillSyscallArgType *arg)
+{
+    Std_ReturnType err;
+    char *buf;
+    int fd = arg->body.api_write_r.fd;
+    size_t size = (size_t)arg->body.api_write_r.size;
+
+    err = mpu_get_pointer(0U, arg->body.api_write_r.buf,(uint8**)&buf);
+    if (err != STD_E_OK) {
+    	arg->ret_value = err;
+		return;
+    }
+
+#ifdef ENABLE_EXTERNAL_BT_SERIAL
+    AthrillSerialFifoType *fifop = get_serial_fifo_from_fd(fd);
+    if (fifop != NULL) {
+        arg->ret_value = 0;
+    	mpthread_lock(fifop->tx_thread);
+        (void)comm_fifo_buffer_add(&fifop->wr, buf, size, (uint32*)&arg->ret_value);
+    	mpthread_unlock(fifop->tx_thread);
+        return;
+    }
+#endif /* ENABLE_EXTERNAL_BT_SERIAL */
+	int actual_fd = get_correspond_fd(fd);
+
+    arg->ret_value = write(actual_fd, buf, size);
+
+//    printf("write_r fd=%d buf=0x%x(real:%p) size=%zu ret=%d errno=%d\n",actual_fd,arg->body.api_write_r.buf,buf,size,arg->ret_value,errno);
+
+    return;
+
+}
+static void athrill_syscall_close_r(AthrillSyscallArgType *arg)
+{
+    int fd = arg->body.api_close_r.fd;
+
+	int correspondig_fd = get_correspond_fd(fd);
+	if ( correspondig_fd != fd) {
+		close(correspondig_fd);
+		// clear corresponding fd
+		set_correspond_fd(fd,0);
+	}
+
+    arg->ret_value = close(fd);
+
+    //printf("close_r fd=%d ret=%d\n",fd,arg->ret_value);
+
+    return;
+
+}
+
+static void athrill_syscall_lseek_r(AthrillSyscallArgType *arg)
+{
+    int fd = arg->body.api_lseek_r.fd;
+    off_t offset = arg->body.api_lseek_r.offset;
+    int whence = arg->body.api_lseek_r.whence;
+
+    arg->ret_value = lseek( fd, (size_t)offset, whence );
+
+    //printf("lseek_r fd=%d offset=%d whence=%d ret=%d\n", fd, offset, whence, arg->ret_value);
+
+    return;
+}
+
+
+/* Old implementation */
+static void athrill_syscall_set_virtfs_top(AthrillSyscallArgType *arg)
+{
+    arg->ret_value = -1;
+
+    if ( virtual_file_top ) {
+        // virtual_file_top is already set
+    } else {
+        Std_ReturnType err;
+        char *buf;
+        char *top_dir;
+
+        err = mpu_get_pointer(0U, arg->body.api_set_virtfs_top.top_dir,(uint8**)&top_dir);
+        ASSERT(err == 0);
+
+        if ( (mkdir(top_dir,0777) == -1) && (errno != EEXIST) ) {
+            printf("SYSCAL]set_virtfs_top mkdir failed path=%s errno=0x%x",
+            top_dir, errno);
+        } else {
+            int len = strlen(top_dir);
+            buf = malloc(len+1);
+            strcpy(buf,top_dir);
+            virtual_file_top = buf;
+            arg->ret_value = 0;
+            printf("SYSCAL]set_virtfs_top success path=%s",top_dir);
+
+        }
+    }
+    return;
+}
+
+#include <sys/types.h>
+#include <dirent.h>
+#include <time.h>
+
+struct dir_element {
+    int is_used;
+    char path[256+20]; // 20 for virtual topdir
+    DIR *dir;
+};
+// this variable asuume that bss area is cleared with NULL
+static struct dir_element dir_table[10]; // MAX 10
+
+#define ENDOF(table) (table + sizeof(table)/sizeof(table[0]))
+#define GETDIRID(p) (sys_int32)(p-dir_table +1 )
+static struct dir_element *get_free_dir(void)
+{
+    struct dir_element *p;
+    // TODO:thread safe
+    for ( p = dir_table; p < ENDOF(dir_table); p++ ) {
+        if ( !p->is_used ) {
+            break;
+        }
+    }
+    if ( p == ENDOF(dir_table) ) return 0;
+
+    // found free space;
+    p->is_used = 1;
+    return p;
+}
+
+static struct dir_element* GETDIR(sys_int32 dirid)
+{
+    dirid--; // convert to index;
+    if (!( dirid >= 0 && dirid < sizeof(dir_table)/sizeof(dir_table[0]))) {
+        return 0;
+    }
+    return dir_table+dirid;
+}
+
+static void release_dir(struct dir_element *p)
+{
+    p->is_used = 0;
+}
+
+static void athrill_syscall_ev3_opendir(AthrillSyscallArgType *arg)
+{
+    char *path = 0;
+    char buf[256];
+    struct dir_element *p = get_free_dir();
+
+    if ( !p ) {
+        arg->ret_value = -34; // E_NOID
+    } else {
+        Std_ReturnType err = mpu_get_pointer(0U, arg->body.api_ev3_opendir.path,(uint8**)&path);
+        ASSERT(err == 0);
+        p->dir = opendir(getVirtualFileName(path,buf));
+
+        if ( !p->dir ) {
+            switch( errno ) {
+                case EACCES:
+                case EBADF:
+                case ENOTDIR:
+                    arg->body.api_ev3_opendir.dirid = -17; // E_PAR
+                    break;
+                default:
+                    arg->body.api_ev3_opendir.dirid = -17; // E_PAR
+                    break;   
+            }
+            release_dir(p);
+        } else {
+            arg->ret_value = 0;
+            arg->body.api_ev3_opendir.dirid = GETDIRID(p);
+            strcpy(p->path,buf);
+        }
+    }
+
+//    printf("ev3_opendir path=%s real_path=%s ret=%d dirid=%d\n",path,buf,arg->ret_value,arg->body.api_ev3_opendir.dirid);
+
+    return;
+
+}
+        
+static void athrill_syscall_ev3_readdir(AthrillSyscallArgType *arg)
+{
+    int dirid = arg->body.api_ev3_readdir.dirid;
+    struct dir_element  *de= GETDIR(dirid);
+    char path[255];
+
+    path[0] = 0;
+    if ( !de) {
+        arg->ret_value = -18; // E_ID
+    } else {
+        Std_ReturnType err;
+        DIR *dirp = de->dir;
+        char *name;
+        errno = 0;
+        struct dirent *dir_ent;
+        while ( (dir_ent = readdir(dirp)) ) {
+            if ( strcmp(dir_ent->d_name,".") && strcmp(dir_ent->d_name,"..") ) break;
+        }
+        if ( dir_ent ) {
+            err = mpu_get_pointer(0U, (uint32)arg->body.api_ev3_readdir.name,(uint8**)&name);
+            ASSERT(err == 0);
+
+            strcpy(name, dir_ent->d_name);
+
+            strcpy(path,de->path);
+            strcat(path,"/");
+            strcat(path,name);
+            struct stat stat_buf;
+            if ( stat(path, &stat_buf) == 0 ) {
+                // TODO: fix date/time handling
+                struct tm *my_tm = localtime(&stat_buf.st_mtime);
+                arg->body.api_ev3_readdir.date = my_tm->tm_yday;
+                arg->body.api_ev3_readdir.time = my_tm->tm_hour * 60*60 + my_tm->tm_min*60 + my_tm->tm_sec;
+                arg->body.api_ev3_readdir.size = stat_buf.st_size;
+                arg->body.api_ev3_readdir.attrib = 0;
+                if ( S_ISDIR(stat_buf.st_mode) ) arg->body.api_ev3_readdir.attrib |= ((1 << 0)); // TA_FILE_DIR
+                // TODO: TA_FILE_HID,TA_FILE_RDO
+                arg->ret_value = 0;
+            } else {
+                arg->ret_value = -5; // E_SYS
+            }
+        } else {
+            switch (errno) {
+                case 0:
+                    arg->ret_value = -41; // E_OBJ
+                    break;
+                case EBADF:
+                default:
+                    arg->ret_value = -18; // E_ID
+                    break;
+            }
+        }
+    }
+    /*
+    if ( arg->ret_value == 0 ) {
+        printf("ev3readdir dirid=%d ret=%d name=%s size=%d attrib=%d date=%d time=%d\n",
+        dirid, arg->ret_value, path,arg->body.api_ev3_readdir.size, arg->body.api_ev3_readdir.attrib,
+         arg->body.api_ev3_readdir.date,  arg->body.api_ev3_readdir.time);
+    } else {
+        printf("ev3readdir dirid=%d ret=%d path=%s errno=0x%x\n",
+           dirid,  arg->ret_value , path, errno);
+    }
+    */
+   return;
+}
+
+
+static void athrill_syscall_ev3_closedir(AthrillSyscallArgType *arg)
+{
+    int dirid = arg->body.api_ev3_closedir.dirid;
+    struct dir_element  *de= GETDIR(dirid);
+
+    if ( !de ) {
+        arg->ret_value = -18; // E_ID
+        return;
+    }
+
+    int ret = closedir(de->dir);
+
+    if ( ret == 0) {
+        // Success
+        release_dir(de);
+        arg->ret_value = 0; // E_OK
+    } else {
+        arg->ret_value = -18; // E_ID
+        
+    }
+
+//    printf("ev3closedir dirid=%d ret=%d", dirid, arg->ret_value );
+    return;
+
+}
+
+static int create_pipe(const char *path, int is_read )
+{
+    struct stat stat_buf;
+    int ret;
+    if ( stat(path, &stat_buf) == 0 ) {
+        // as pipe name exist, remove it first
+        int tmp_fd = open(path, O_RDONLY|O_NONBLOCK);
+        char buf[255];
+
+        // clear pipe
+        do {
+            ret = read(tmp_fd,buf,sizeof(buf));
+        } while ( ret > 0 );
+        close(tmp_fd);
+    } else {
+         ret = mkfifo(path, 0666);
+    }
+    int mode = (is_read ? O_RDONLY : O_RDWR );
+    int fd = open(path,  mode | O_NONBLOCK);
+    //printf("open: path=%s fd=%d errno=%d\n",path,fd,errno);
+
+    return fd;
+}
+
+static int create_pipe_pair(const char *path)
+{
+    char path_out[255];
+    char path_in[255];
+
+    strcpy(path_out,path);
+    strcat(path_out,"_out");
+    strcpy(path_in,path);
+    strcat(path_in,"_in");
+
+    int fd_out = create_pipe( path_out, FALSE); 
+    int fd_in  = create_pipe( path_in, TRUE );
+
+    set_correspond_fd(fd_in, fd_out);
+
+    return fd_in;
+}
+
+static void athrill_syscall_ev3_serial_open(AthrillSyscallArgType *arg)
+{
+    char *path_base;
+    int fd;
+    sys_int32 port = arg->body.api_ev3_serial_open.port;
+
+#ifdef ENABLE_EXTERNAL_BT_SERIAL
+    int scid = 0;
+    AthrillSerialFifoType *fifop = NULL;
+
+    if ( port == SYS_SERIAL_UART ) {
+        scid = ExternalSerialFifoId_0;
+    } else if ( port == SYS_SERIAL_BT ) {
+        scid = ExternalSerialFifoId_1;
+    }
+    fifop = get_serial_fifo(scid);
+    if (fifop == NULL) {
+        arg->ret_value = -1;
+        return;
+    }
+    else if (athrill_ev3_serial_is_opened(scid) == TRUE) {
+        arg->ret_value = external_serial_fifo_map[scid].file_descriptor;
+        return;
+    }
+#endif /* ENABLE_EXTERNAL_BT_SERIAL */
+    if ( port == SYS_SERIAL_DEFAULT ) {
+        fd = 0;
+    } else if ( port == SYS_SERIAL_UART ) {
+        path_base ="__ev3rt_uart"; // UART Default name
+        (void)cpuemu_get_devcfg_string("DEVICE_CONFIG_UART_BASENAME",&path_base);
+        fd = create_pipe_pair(path_base);
+    } else if ( port == SYS_SERIAL_BT ) {
+        path_base ="__ev3rt_bt"; // BT Default name
+        (void)cpuemu_get_devcfg_string("DEVICE_CONFIG_BT_BASENAME",&path_base);
+        fd = create_pipe_pair(path_base);
+    } else {
+        fd = -1;
+    }
+#ifdef ENABLE_EXTERNAL_BT_SERIAL
+    if (fd > 0) {
+        athrill_ev3_serial_set_fd(scid, fd, fifop);
+    }
+#endif /* ENABLE_EXTERNAL_BT_SERIAL */
+    arg->ret_value = fd;
+
+    //printf("ev3_serial_open() port=%d fd=%d\n",port,fd);
+    return;
+
+}
+
+static void athrill_syscall_exit(AthrillSyscallArgType *arg)
+{
+    sys_int32 status = arg->body.api_exit.status;
+    printf("athrill exit(%d)\n", status);
+    sync();
+    sync();
+    sync();
+    sync();
+    sync();
+    exit(status);
+    arg->ret_value = SYS_API_ERR_OK;
+    return;
+}
+
+static void athrill_syscall_v850_set_intpri(AthrillSyscallArgType *args)
+{
+    uint16_t *imr_table;
+    uint16_t *disint_table;
+
+    // 0xfffff100 is IMR0 in arch/v850_gcc/v850esfk3.h
+    (void)mpu_get_pointer(0U, (uint32)args->body.api_v850_set_intpri.imr_table ,(uint8_t**)&imr_table);
+    (void)mpu_get_pointer(0U, (uint32)args->body.api_v850_set_intpri.disint_table ,(uint8_t**)&disint_table);
+
+    (void)mpu_put_data16(0U, 0xFFFFF100, (imr_table[0]|disint_table[0]));
+    (void)mpu_put_data16(0U, 0xFFFFF102, (imr_table[1]|disint_table[1]));
+    (void)mpu_put_data16(0U, 0xFFFFF104, (imr_table[2]|disint_table[2]));
+    (void)mpu_put_data16(0U, 0xFFFFF106, (imr_table[3]|disint_table[3]));
+    (void)mpu_put_data16(0U, 0xFFFFF108, (imr_table[4]|disint_table[4]));
+    (void)mpu_put_data16(0U, 0xFFFFF10A, (imr_table[5]|disint_table[5]));
+    (void)mpu_put_data16(0U, 0xFFFFF10C, (imr_table[6]|disint_table[6]));
+    (void)mpu_put_data8( 0U, 0xFFFFF10E,  (uint8_t)( imr_table[7] | disint_table[7] ));
+    return;
+}
+
+#include <time.h>
+static struct timespec start_time;
+void athrill_syscall_reset_time(AthrillSyscallArgType *arg)
+{
+    clock_gettime(CLOCK_MONOTONIC,&start_time);
+#ifndef OS_MAC
+    printf("Start %ld.%ld\n",start_time.tv_sec,start_time.tv_nsec);fflush(stdout);
+#else
+    printf("Start %d.%d\n",start_time.tv_sec,start_time.tv_nsec);fflush(stdout);
+#endif
+}
+
+void athrill_syscall_show_time(AthrillSyscallArgType *arg)
+{
+    struct timespec cur;
+    clock_gettime(CLOCK_MONOTONIC,&cur);
+    unsigned int tim;
+
+    if ( cur.tv_nsec >= start_time.tv_nsec ) {
+        tim = (cur.tv_sec - start_time.tv_sec)*1000 + (cur.tv_nsec - start_time.tv_nsec)/1000000;
+    } else {
+        tim = (cur.tv_sec - start_time.tv_sec-1)*1000 + (1000000000 + cur.tv_nsec - start_time.tv_nsec)/1000000;
+    }
+
+#ifndef OS_MAC
+    printf("####End %ld.%ld Spend Time=%u msec\n",cur.tv_sec,cur.tv_nsec,tim);fflush(stdout);
+#else
+    printf("####End %d.%d Spend Time=%u msec\n",cur.tv_sec,cur.tv_nsec,tim);fflush(stdout);
+#endif
+
+
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-athrill/api/ros_cimpl.c
@@ -0,0 +1,225 @@
+#include "ros_cimpl.h"
+#include "mros_node_cimpl.h"
+#include "mros_topic_cimpl.h"
+#include "mros_topic_connector_factory_cimpl.h"
+#include "mros_exclusive_area.h"
+#include "mros_wait_queue.h"
+#include "mros_protocol_master_cimpl.h"
+#include "mros_protocol_operation_cimpl.h"
+#include "mros_usr_config.h"
+#include "mros_topic_callback.h"
+#include <string.h>
+
+void ros_init(int argc, char *argv, const char* node_name)
+{
+	mRosNodeIdType id;
+	mRosReturnType ret;
+	mROsExclusiveUnlockObjType unlck_obj;
+
+	mros_exclusive_lock(&mros_exclusive_area, &unlck_obj);
+	ret = mros_node_create_inner(node_name, &id);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+	}
+	mros_exclusive_unlock(&unlck_obj);
+	return;
+}
+
+mRosSubscriberType *ros_topic_subscribe(const char* topic, int queue_size, void (*fp) (const char *))
+{
+	mRosReturnType ret;
+	mRosTopicConnectorType connector;
+	mRosTopicConnectorManagerType *mgrp;
+	mRosProtocolMasterRequestType req;
+	mRosWaitListEntryType client_wait;
+	mROsExclusiveUnlockObjType unlck_obj;
+	mros_uint32 type_id;
+	mRosSubscriberType *sub;
+
+	sub = malloc(sizeof(mRosSubscriberType));
+	if (sub == NULL) {
+		return NULL;
+	}
+	mros_client_wait_entry_init(&client_wait, &req);
+
+	mros_exclusive_lock(&mros_exclusive_area, &unlck_obj);
+
+	ret = mros_node_get_bytid(&connector.node_id);
+	if (ret != MROS_E_OK) {
+		mros_exclusive_unlock(&unlck_obj);
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return NULL;
+	}
+
+	ret = mros_topic_create(topic, "std_msgs/String", &connector.topic_id);
+	if (ret != MROS_E_OK) {
+		mros_exclusive_unlock(&unlck_obj);
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return NULL;
+	}
+	(void)mros_topic_set_typeid(connector.topic_id, 0);
+	(void)mros_topic_set_definition(connector.topic_id, NULL);
+	(void)mros_topic_get_typeid(connector.topic_id, &type_id);
+	(void)mros_topic_set_md5sum(connector.topic_id, "992ce8a1687cec8c8bd883ec73ca41d1");
+
+	mgrp = mros_topic_connector_factory_get(MROS_TOPIC_CONNECTOR_SUB);
+	if (mgrp == MROS_NULL) {
+		mros_exclusive_unlock(&unlck_obj);
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return NULL;
+	}
+	connector.func_id = (mRosFuncIdType)fp;
+
+	ret = mros_topic_connector_add(mgrp, &connector, queue_size, MROS_NULL);
+	if (ret != MROS_E_OK) {
+		mros_exclusive_unlock(&unlck_obj);
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return NULL;
+	}
+	mRosContainerObjType obj = mros_topic_connector_get_obj(mgrp, &connector);
+	if (obj == MROS_COBJ_NULL) {
+		mros_exclusive_unlock(&unlck_obj);
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return NULL;
+	}
+	sub->objp = (void*)obj;
+	sub->topic_id = connector.topic_id;
+
+	//ROSマスタへ登録する
+	req.req_type = MROS_PROTOCOL_MASTER_REQ_REGISTER_SUBSCRIBER;
+	req.connector_obj = obj;
+
+	mros_client_wait_for_request_done(&mros_master_wait_queue, &client_wait);
+	mros_exclusive_unlock(&unlck_obj);
+	return sub;
+}
+
+mRosPublisherType *ros_topic_advertise(const char* topic, int queue_size)
+{
+	mRosReturnType ret;
+	mRosTopicConnectorType connector;
+	mRosTopicConnectorManagerType *mgrp;
+	mRosProtocolMasterRequestType req;
+	mRosWaitListEntryType client_wait;
+	mROsExclusiveUnlockObjType unlck_obj;
+	mros_uint32 type_id;
+	mRosPublisherType *pub;
+
+	pub = malloc(sizeof(mRosPublisherType));
+	if (pub == NULL) {
+		return NULL;
+	}
+
+	mros_client_wait_entry_init(&client_wait, &req);
+
+	mros_exclusive_lock(&mros_exclusive_area, &unlck_obj);
+
+	ret = mros_node_get_bytid(&connector.node_id);
+	if (ret != MROS_E_OK) {
+		mros_exclusive_unlock(&unlck_obj);
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return NULL;
+	}
+
+	ret = mros_topic_create(topic, "std_msgs/String", &connector.topic_id);
+	if (ret != MROS_E_OK) {
+		mros_exclusive_unlock(&unlck_obj);
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return NULL;
+	}
+	(void)mros_topic_set_typeid(connector.topic_id, 0);
+	(void)mros_topic_set_definition(connector.topic_id, NULL);
+	(void)mros_topic_get_typeid(connector.topic_id, &type_id);
+	(void)mros_topic_set_md5sum(connector.topic_id, "992ce8a1687cec8c8bd883ec73ca41d1");
+
+	mgrp = mros_topic_connector_factory_get(MROS_TOPIC_CONNECTOR_PUB);
+	if (mgrp == MROS_NULL) {
+		mros_exclusive_unlock(&unlck_obj);
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return NULL;
+	}
+	connector.func_id = (mRosFuncIdType)MROS_ID_NONE;
+
+	ret = mros_topic_connector_add(mgrp, &connector, queue_size, &ros_inner_topic_publisher_mempool);
+	if (ret != MROS_E_OK) {
+		mros_exclusive_unlock(&unlck_obj);
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return NULL;
+	}
+	mRosContainerObjType obj = mros_topic_connector_get_obj(mgrp, &connector);
+	if (obj == MROS_COBJ_NULL) {
+		mros_exclusive_unlock(&unlck_obj);
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return NULL;
+	}
+
+	pub->objp = (void*)obj;
+	pub->topic_id = connector.topic_id;
+
+	//ROSマスタへ登録する
+	req.req_type = MROS_PROTOCOL_MASTER_REQ_REGISTER_PUBLISHER;
+	req.connector_obj = obj;
+
+	mros_client_wait_for_request_done(&mros_master_wait_queue, &client_wait);
+	mros_exclusive_unlock(&unlck_obj);
+	return pub;
+}
+
+
+int ros_topic_publish(mRosPublisherType* pub, void *data, int datalen)
+{
+	mRosReturnType ret;
+	char *snd_data;
+	char *bodyp;
+	mRosSizeType size;
+	mROsExclusiveUnlockObjType unlck_obj;
+
+	size = mros_protocol_get_buffersize(datalen + 4);
+
+	mros_exclusive_lock(&mros_exclusive_area, &unlck_obj);
+	ret = mros_topic_connector_alloc_data((mRosContainerObjType)pub->objp, &snd_data, size);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+	}
+	bodyp = mros_protocol_get_body(snd_data);
+    memcpy(bodyp, &datalen, 4);
+    bodyp += 4;
+	memcpy(bodyp, data, datalen);
+	mros_exclusive_unlock(&unlck_obj);
+	return 0;
+}
+
+static mros_uint32 mros_callback_topic_id = 0;
+static mros_uint32 mros_callback_topic_datalen = 0;
+void mros_topic_callback(mros_uint32 topic_id, mros_uint32 type_id, mRosFuncIdType func_id, const char *data, mros_uint32 len)
+{
+	void (*fp)(void *ptr);
+	fp = (void (*)(void *))func_id;
+
+	mros_callback_topic_id = topic_id;
+	mros_callback_topic_datalen = len - 8;
+	fp((char*)&data[8]);
+	return;
+}
+mRosCallbackTopicIdType ros_topic_callback_topic_id(void)
+{
+	return mros_callback_topic_id;
+}
+mRosCallbackDataLenType ros_topic_callback_datalen(void)
+{
+	return mros_callback_topic_datalen;
+}
+
+void ros_topic_callback_lock(void)
+{
+	mros_exclusive_lock(&mros_exclusive_area, NULL);
+	return;
+}
+
+void ros_topic_callback_unlock(void)
+{
+	mros_exclusive_unlock(NULL);
+	return;
+}
+
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-athrill/api/ros_cimpl.h
@@ -0,0 +1,36 @@
+#ifndef _ROS_CIMPL_H_
+#define _ROS_CIMPL_H_
+
+typedef struct {
+	void *objp;
+} mRosObjType;
+
+typedef struct {
+	mRosObjType 	*objp;
+	int				topic_id;
+} mRosPublisherType;
+
+typedef struct {
+	mRosObjType 	*objp;
+	int				topic_id;
+	void			*ptr;
+} mRosSubscriberType;
+
+extern void ros_init(int argc, char *argv, const char* node_name);
+extern mRosSubscriberType *ros_topic_subscribe(const char* topic, int queue_size, void (*fp) (const char *));
+extern mRosPublisherType *ros_topic_advertise(const char* topic, int queue_size);
+extern int ros_topic_publish(mRosPublisherType* pub, void *data, int datalen);
+
+typedef unsigned int mRosCallbackTopicIdType;
+typedef unsigned int mRosCallbackDataLenType;
+extern mRosCallbackTopicIdType ros_topic_callback_topic_id(void);
+extern mRosCallbackDataLenType ros_topic_callback_datalen(void);
+extern void ros_topic_callback_lock(void);
+extern void ros_topic_callback_unlock(void);
+
+extern void set_main_task(void);
+extern void set_athrill_task(void);
+
+#include "mros_log.h"
+
+#endif /* _ROS_CIMPL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-athrill/config/mros_sys_config.c
@@ -0,0 +1,18 @@
+#include "mros_types.h"
+#include "mros_memory.h"
+#include "mros_sys_config.h"
+#include "kernel.h"
+
+mRosMemoryManagerType ros_inner_topic_publisher_mempool;
+mRosMemoryManagerType ros_outer_topic_publisher_mempool;
+
+void mros_sys_config_init(void)
+{
+	return;
+}
+
+
+void usr_task_activation(void)
+{
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-athrill/config/mros_sys_config.h
@@ -0,0 +1,81 @@
+#ifndef _MROS_SYS_CONFIG_H_
+#define _MROS_SYS_CONFIG_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "std_types.h"
+#include "mros_usr_config.h"
+#include "mros_os_config.h"
+#include "mros_packet_config.h"
+
+
+
+/**************************************
+ * PROTOCOL
+ **************************************/
+/*
+ * portno of master
+ */
+#define MROS_MASTER_PORT_NO						11311
+/*
+ * ipaddr of master
+ */
+#define MROS_MASTER_IPADDR						"0.0.0.0"
+
+extern char *mros_master_ipaddr;
+extern char *mros_node_ipaddr;
+extern uint32 mros_slave_port_no;
+extern uint32 mros_publisher_port_no;
+extern char *mros_uri_slave;
+
+/*
+ * ipaddr of self node
+ */
+#define MROS_NODE_IPADDR						"127.0.0.1"
+
+/*
+ * portno of slave
+ */
+#define MROS_SLAVE_PORT_NO						11411
+
+/*
+ * portno of pub
+ */
+#define MROS_PUBLISHER_PORT_NO					11511
+
+/*
+ * uri of mROS slave
+ */
+#define MROS_URI_SLAVE							"http://127.0.0.1:11411"
+
+/*
+ * do not change this parameter
+ */
+#define MROS_TOPIC_TCP_CLIENT_MAX_NUM			( MROS_PUB_TOPIC_CONNECTOR_MAX_NUM + MROS_SUB_TOPIC_CONNECTOR_MAX_NUM )
+
+
+/*****************************************
+ * EXCLUSIVE AREA
+ *****************************************/
+
+/*
+ * do not change this parameter
+ */
+#define MROS_GIANT_EXCLUSIVE_AREA_PRIORITY		( \
+		( MROS_USR_TASK_PRI < MROS_TASK_PRI) ? \
+				MROS_USR_TASK_PRI : \
+				MROS_TASK_PRI \
+	)
+
+
+extern void mros_sys_config_init(void);
+extern void usr_task_activation(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MROS_SYS_CONFIG_H_ */
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-athrill/config/mros_usr_config.c
@@ -0,0 +1,2 @@
+
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-athrill/config/mros_usr_config.h
@@ -0,0 +1,91 @@
+#ifndef _MROS_USR_CONFIG_H_
+#define _MROS_USR_CONFIG_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_types.h"
+#include "mros_memory.h"
+#include "mros_os.h"
+
+
+/**************************************
+ * TOPIC
+ **************************************/
+
+/*
+ * num of max topics
+ */
+#define MROS_TOPIC_MAX_NUM						1024U
+
+/*
+ * max name length of topic name
+ */
+#define MROS_TOPIC_NAME_MAXLEN					1024U
+/*
+ * max name length of topic type name
+ */
+#define MROS_TOPIC_TYPENAME_MAXLEN				1024U
+
+
+/**************************************
+ * TOPIC CONNECTOR
+ **************************************/
+/*
+ * num of max publish topic connectors
+ */
+#define MROS_PUB_TOPIC_CONNECTOR_MAX_NUM		1024U
+
+/*
+ * num of max subscribe topic connectors
+ */
+#define MROS_SUB_TOPIC_CONNECTOR_MAX_NUM		1024U
+
+/*
+ * max queue length of outer connection topic data buffering
+ */
+#define MROS_OUTER_CONNECTOR_QUEUE_MAXLEN		1
+
+
+/**************************************
+ * NODE
+ **************************************/
+/*
+ * num of max nodes
+ */
+#define MROS_NODE_MAX_NUM						1024U
+/*
+ * max name length of node name
+ */
+#define MROS_NODE_NAME_MAXLEN					1024U
+
+/*
+ * do not change for mROS inner data
+ */
+extern mRosMemoryManagerType ros_inner_topic_publisher_mempool;
+extern mRosMemoryManagerType ros_outer_topic_publisher_mempool;
+
+/****************************************
+ * USR OS TASK
+ ****************************************/
+/*
+ * num of user task
+ *
+ * following config parameter is an example.
+ *
+ * please change corresponding variable definitions
+ * of mros_usr_config.c for changing these parameters.
+ */
+#define MROS_USR_TASK_NUM			1		// for athrill-thread
+/*
+ * do not change for mROS inner data
+ */
+extern mRosTaskIdType mros_usr_task_table[MROS_USR_TASK_NUM];
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MROS_USR_CONFIG_H_ */
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-athrill/config/os/target/os_asp/mros_os_config.c
@@ -0,0 +1,143 @@
+#include "mros_protocol_master_cimpl.h"
+#include "mros_protocol_slave_cimpl.h"
+#include "mros_protocol_subscribe_cimpl.h"
+#include "mros_protocol_publish_cimpl.h"
+#include "mros_os_config.h"
+#include "mros_comm_cimpl.h"
+#include "mros_comm_tcp_client_factory_cimpl.h"
+#include "mros_exclusive_area.h"
+#include "mros_node_cimpl.h"
+#include "mros_packet_decoder_cimpl.h"
+#include "mros_packet_encoder_cimpl.h"
+#include "mros_protocol_server_proc_cimpl.h"
+#include "mros_topic_cimpl.h"
+#include "mros_topic_data_publisher_cimpl.h"
+#include "mros_topic_data_subscriber_cimpl.h"
+#include "mros_topic_connector_factory_cimpl.h"
+#include "kernel_cfg.h"
+#include "mros_sys_config.h"
+
+void main_task()
+{
+	mRosReturnType ret;
+	ROS_INFO("**********mROS main task start**********");
+
+	mros_sys_config_init();
+	mros_comm_init();
+	mros_exclusive_area_init(XML_MAS_TASK, SUB_TASK);
+
+	ret = mros_comm_tcp_client_factory_init();
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return;
+	}
+	ret = mros_node_init();
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return;
+	}
+	ret = mros_topic_init();
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return;
+	}
+	mRosTopicConnectorManagerType *mgrp = mros_topic_connector_factory_create(MROS_TOPIC_CONNECTOR_PUB);
+	if (mgrp == MROS_NULL) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return;
+	}
+	mgrp = mros_topic_connector_factory_create(MROS_TOPIC_CONNECTOR_SUB);
+	if (mgrp == MROS_NULL) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return;
+	}
+	ret = mros_packet_decoder_init();
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return;
+	}
+	ret = mros_packet_encoder_init();
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return;
+	}
+	ret = mros_proc_init();
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return;
+	}
+	ret = mros_topic_data_publisher_init();
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return;
+	}
+	ret = mros_topic_data_subscriber_init();
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return;
+	}
+
+	ret = mros_protocol_subscribe_init();
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return;
+	}
+	ret = mros_protocol_publish_init();
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return;
+	}
+	ret = mros_protocol_slave_init();
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return;
+	}
+	ret = mros_protocol_master_init();
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return;
+	}
+
+	act_tsk(PUB_TASK);
+	act_tsk(SUB_TASK);
+	act_tsk(XML_SLV_TASK);
+	act_tsk(XML_MAS_TASK);
+	usr_task_activation();
+
+	ROS_INFO("**********mROS Main task finish**********");
+	return;
+}
+
+void sub_task()
+{
+	ROS_INFO("**********mROS sub task start**********");
+	mros_protocol_subscribe_run();
+	return;
+}
+
+void pub_task()
+{
+	ROS_INFO("**********mROS pub task start**********");
+	mros_protocol_publish_run();
+	return;
+}
+
+void xml_slv_task()
+{
+	ROS_INFO("**********mROS slv task start**********");
+	mros_protocol_slave_run();
+	return;
+}
+
+void xml_mas_task()
+{
+	ROS_INFO("**********mROS mas task start**********");
+	mros_protocol_master_run();
+	return;
+}
+
+void cyclic_handler(mros_intptr_t exinf)
+{
+	iwup_tsk(SUB_TASK);
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-athrill/config/os/target/os_asp/mros_os_config.h
@@ -0,0 +1,84 @@
+#ifndef _MROS_OS_CONFIG_H_
+#define _MROS_OS_CONFIG_H_
+
+#include "kernel.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern void main_task(void);
+extern void sub_task(void);
+extern void pub_task(void);
+extern void xml_slv_task(void);
+extern void xml_mas_task(void);
+extern void cyclic_handler(mros_intptr_t exinf);
+
+/****************************************
+ * kernel cfg
+ ****************************************/
+#ifndef MROS_USR_TASK_PRI
+/*
+ * main task priority
+ *
+ * do not change this parameter
+ */
+#define MAIN_TASK_PRI 			7
+/*
+ * mROS task priority
+ *
+ * do not change this parameter
+ */
+#define MROS_TASK_PRI  			6
+
+/*
+ * user task priority
+ *
+ * following config parameter is an example.
+ */
+
+/*
+ * user task max priority
+ *
+ * please set max priority of user tasks.
+ */
+#define MROS_USR_TASK_PRI		8
+#endif /* ROS_USR_TASK_PRI */
+
+#ifndef TASK_PORTID
+#define	TASK_PORTID		1			/* serial port ID for something typing */
+#endif /* TASK_PORTID */
+
+#ifndef MROS_TASK_STACK_SIZE
+/*
+ * user task stack size
+ */
+/*
+ * mROS task stack size
+ *
+ * do not change this parameter
+ */
+#define MROS_TASK_STACK_SIZE 1024 * 2	//for mros task
+#endif	/*MROS_TASK_STACK_SIZE*/
+
+/*
+ * do not change this parameter
+ */
+#ifndef CYC
+#define MROS_LOOP_RATE 100
+#define CYC
+#endif	/*CYC*/
+
+/*
+ * do not change this parameter
+ */
+#ifndef LOOP_REF
+#define LOOP_REF		ULONG_C(1000000)	/* number of loops to evaluate speed */
+#endif /* LOOP_REF */
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* _MROS_OS_CONFIG_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-athrill/device/athrill_mros_device.c
@@ -0,0 +1,242 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <signal.h>
+#include "cpuemu_ops.h"
+#include "std_errno.h"
+#include "athrill_mros_device.h"
+#include "mros_os_config.h"
+#include "mros_sys_config.h"
+
+typedef struct {
+	char 					*buffer;
+	int						recvlen;
+	int						buffer_len;
+	mRosSubscriberType		*sub;
+	void (*func) (const char *data, int datalen);
+} mRosTopicSubBufferType;
+
+static int mrostopic_sub_buffer_num;
+static mRosTopicSubBufferType *mros_topic_sub_buffer;
+
+static void *sub_buffer_realloc(mRosTopicSubBufferType *sub, int len)
+{
+	if (sub->buffer != NULL) {
+		free(sub->buffer);
+	}
+	sub->buffer = malloc(len);
+	if (sub->buffer == NULL) {
+		return NULL;
+	}
+	sub->buffer_len = len;
+	return sub->buffer;
+}
+
+static mRosTopicSubBufferType *sub_buffer_find(int topic_id)
+{
+	int i;
+	for (i = 0; i < mrostopic_sub_buffer_num; i++) {
+		if (mros_topic_sub_buffer[i].sub->topic_id == topic_id) {
+			return &mros_topic_sub_buffer[i];
+		}
+	}
+	return NULL;
+}
+
+static mRosTopicSubBufferType *get_subptr(int topic_id, mRosCallbackDataLenType len)
+{
+	mRosTopicSubBufferType *sub;
+	if (mros_topic_sub_buffer == NULL) {
+		return NULL;
+	}
+
+	sub = sub_buffer_find(topic_id);
+	if (sub == NULL) {
+		return NULL;
+	}
+	if (sub->buffer_len < len) {
+		if (sub_buffer_realloc(sub, len) == NULL) {
+			return NULL;
+		}
+	}
+	sub->recvlen = len;
+
+	return sub;
+}
+
+static void athrill_mros_callback(const char *msg)
+{
+	mRosCallbackTopicIdType topic_id;
+	mRosCallbackDataLenType datalen;
+
+	ros_topic_callback_lock();
+	{
+		topic_id = ros_topic_callback_topic_id();
+		datalen = ros_topic_callback_datalen();
+
+		mRosTopicSubBufferType *bp = get_subptr(topic_id, datalen + 1);
+		memcpy(bp->buffer, msg, datalen + 1);
+		bp->buffer[datalen] = '\0';
+		//printf("callback:topic_id=%u:datalen=%u: %s\n", topic_id, datalen, bp->buffer);
+		if (bp->func != NULL) {
+			bp->func(bp->buffer, datalen);
+		}
+	}
+	ros_topic_callback_unlock();
+	return;
+}
+
+typedef struct {
+	struct {
+		int req_num;
+		AthrillMrosDevPubReqType *reqs;
+	} pub;
+	struct {
+		int req_num;
+		AthrillMrosDevSubReqType *reqs;
+	} sub;
+} AthrillMrosDeviceRegisterType;
+
+static AthrillMrosDeviceRegisterType athrill_mros_device_register;
+
+int athrill_mros_device_pub_register(AthrillMrosDevPubReqType *reqs, int req_num)
+{
+	athrill_mros_device_register.pub.req_num = req_num;
+	athrill_mros_device_register.pub.reqs = reqs;
+	return 0;
+}
+
+int athrill_mros_device_sub_register(AthrillMrosDevSubReqType *reqs, int req_num)
+{
+	athrill_mros_device_register.sub.req_num = req_num;
+	athrill_mros_device_register.sub.reqs = reqs;
+	return 0;
+}
+
+static int athrill_mros_device_pub_init(AthrillMrosDevPubReqType *reqs, int req_num)
+{
+	mRosPublisherType *pub_cobj;
+	int i;
+
+	for (i = 0; i < req_num; i++) {
+		pub_cobj = ros_topic_advertise(reqs[i].topic_name, 1);
+		if (pub_cobj == NULL) {
+			return -1;
+		}
+		reqs[i].pub = pub_cobj;
+	}
+	return 0;
+}
+
+static int athrill_mros_device_sub_init(AthrillMrosDevSubReqType *reqs, int req_num)
+{
+	mRosSubscriberType *sub_cobj;
+	int i;
+
+	mros_topic_sub_buffer = malloc(sizeof(mRosTopicSubBufferType) * req_num);
+	if (mros_topic_sub_buffer == NULL) {
+		return -1;
+	}
+	mrostopic_sub_buffer_num = req_num;
+	for (i = 0; i < req_num; i++) {
+		sub_cobj = ros_topic_subscribe(reqs[i].topic_name, 1, athrill_mros_callback);
+		if (sub_cobj == NULL) {
+			return -1;
+		}
+		reqs[i].sub = sub_cobj;
+		reqs[i].sub->ptr = &mros_topic_sub_buffer[i];
+		mros_topic_sub_buffer[i].buffer = NULL;
+		mros_topic_sub_buffer[i].buffer_len = 0;
+		mros_topic_sub_buffer[i].sub = sub_cobj;
+		mros_topic_sub_buffer[i].func = reqs[i].callback;
+	}
+	return 0;
+}
+
+char *mros_master_ipaddr = MROS_MASTER_IPADDR;
+char *mros_node_ipaddr = MROS_NODE_IPADDR;
+uint32 mros_slave_port_no = MROS_SLAVE_PORT_NO;
+uint32 mros_publisher_port_no = MROS_PUBLISHER_PORT_NO;
+static char mros_uri_slave_buffer[4096];
+char *mros_uri_slave = &mros_uri_slave_buffer[0];
+
+static void *athrill_mros_device_main(void *arg)
+{
+	Std_ReturnType ret;
+	int err;
+	char *node_name;
+
+	memset(mros_uri_slave_buffer, 0, sizeof(mros_uri_slave_buffer));
+	(void)cpuemu_get_devcfg_string("DEBUG_FUNC_MROS_MASTER_IPADDR", &mros_master_ipaddr);
+	(void)cpuemu_get_devcfg_string("DEBUG_FUNC_MROS_NODE_IPADDR", &mros_node_ipaddr);
+	(void)cpuemu_get_devcfg_value("DEBUG_FUNC_MROS_SLAVE_PORT_NO", &mros_slave_port_no);
+	(void)cpuemu_get_devcfg_value("DEBUG_FUNC_MROS_PUBLISHER_PORT_NO", &mros_publisher_port_no);
+	printf("mros_master_ipaddr=%s\n", mros_master_ipaddr);
+	printf("mros_slave_port_no=%d\n", mros_slave_port_no);
+	snprintf(mros_uri_slave_buffer, sizeof(mros_uri_slave_buffer), "http://%s:%d", mros_node_ipaddr, mros_slave_port_no);
+	printf("mros_uri_slave=%s\n", mros_uri_slave);
+	printf("mros_publisher_port_no=%d\n", mros_publisher_port_no);
+
+	set_main_task();
+	main_task();
+
+	ret = cpuemu_get_devcfg_string("DEBUG_FUNC_MROS_NODE_NAME", &node_name);
+	if (ret == STD_E_OK) {
+		ros_init(0, NULL, node_name);
+	}
+	else {
+		ros_init(0, NULL, "athrill_node");
+	}
+	err = athrill_mros_device_pub_init(athrill_mros_device_register.pub.reqs, athrill_mros_device_register.pub.req_num);
+	if (err != 0) {
+		printf("ERROR: athrill_mros_device_pub_init()\n");
+		exit(1);
+	}
+	err = athrill_mros_device_sub_init(athrill_mros_device_register.sub.reqs, athrill_mros_device_register.sub.req_num);
+	if (err != 0) {
+		printf("ERROR: athrill_mros_device_pub_init()\n");
+		exit(1);
+	}
+
+
+
+	while (1) {
+		usleep(1000*100); /* 100msec */
+		cyclic_handler(0);
+	}
+
+	return NULL;
+}
+
+int athrill_mros_device_start(void)
+{
+	pthread_t thread;
+
+	set_athrill_task();
+	return pthread_create(&thread, NULL, athrill_mros_device_main, NULL);
+}
+
+int athrill_mros_device_sub_read(mRosSubscriberType *sub, char *datap, int datalen, int *res)
+{
+	int ret = -1;
+	int copylen = datalen;
+	mRosTopicSubBufferType *bp = sub_buffer_find(sub->topic_id);
+	if (bp == NULL) {
+		return -1;
+	}
+	ros_topic_callback_lock();
+	{
+		if (bp->buffer != NULL) {
+			if (datalen > bp->recvlen) {
+				copylen = bp->recvlen;
+			}
+			memcpy(datap, bp->buffer, copylen);
+			ret = 0;
+		}
+	}
+	ros_topic_callback_unlock();
+	*res = copylen;
+	return ret;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-athrill/device/athrill_mros_device.h
@@ -0,0 +1,23 @@
+#ifndef _ATHRILL_MROS_DEVICE_H_
+#define _ATHRILL_MROS_DEVICE_H_
+
+#include "ros_cimpl.h"
+
+typedef struct {
+	const char* topic_name;
+	mRosPublisherType *pub;
+} AthrillMrosDevPubReqType;
+
+typedef struct {
+	const char* topic_name;
+	void (*callback) (const char *data, int datalen);
+	mRosSubscriberType *sub;
+} AthrillMrosDevSubReqType;
+
+extern int athrill_mros_device_pub_register(AthrillMrosDevPubReqType *reqs, int req_num);
+extern int athrill_mros_device_sub_register(AthrillMrosDevSubReqType *reqs, int req_num);
+
+extern int athrill_mros_device_start(void);
+extern int athrill_mros_device_sub_read(mRosSubscriberType *sub, char *datap, int datalen, int *res);
+
+#endif /* _ATHRILL_MROS_DEVICE_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-athrill/target/lwip/lwip_linux.c
@@ -0,0 +1,151 @@
+#include <lwip/sockets.h>
+#include <unistd.h>
+#include "kernel.h"
+#include <pthread.h>
+
+void lwip_init(void)
+{
+	return;
+}
+extern int get_tskid(void);
+
+int lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
+{
+	int ret;
+	ret = accept(s, (struct sockaddr *)addr, addrlen);
+	return ret;
+}
+
+int lwip_bind(int s, const struct sockaddr *name, socklen_t namelen)
+{
+	return bind(s, (struct sockaddr *)name, namelen);
+}
+int lwip_shutdown(int s, int how)
+{
+	return shutdown(s, how);
+}
+
+int lwip_getpeername (int s, struct sockaddr *name, socklen_t *namelen)
+{
+	//TODO
+	return 0;
+}
+
+int lwip_getsockname (int s, struct sockaddr *name, socklen_t *namelen)
+{
+	//TODO
+	return 0;
+}
+
+int lwip_getsockopt (int s, int level, int optname, void *optval, socklen_t *optlen)
+{
+	//TODO
+	return 0;
+}
+
+int lwip_setsockopt (int s, int level, int optname, const void *optval, socklen_t optlen)
+{
+	//TODO
+	return 0;
+}
+
+int lwip_close(int s)
+{
+	return close(s);
+}
+
+
+int lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
+{
+	OsSaveLockType save;
+	os_save_unlock(&save);
+	int ret = connect(s, name, namelen);
+	os_restore_lock(&save);
+	return ret;
+}
+
+
+int lwip_listen(int s, int backlog)
+{
+	return listen(s, backlog);
+}
+
+
+int lwip_recv(int s, void *mem, size_t len, int flags)
+{
+	int ret;
+	OsSaveLockType save;
+	os_save_unlock(&save);
+	ret = recv(s, mem, len, flags);
+	os_restore_lock(&save);
+	return ret;
+}
+
+int lwip_read(int s, void *mem, size_t len)
+{
+	return read(s, mem, len);
+}
+
+int lwip_recvfrom(int s, void *mem, size_t len, int flags,
+      struct sockaddr *from, socklen_t *fromlen)
+{
+	return 0;
+}
+
+int lwip_send(int s, const void *dataptr, size_t size, int flags)
+{
+	return send(s, dataptr, size, flags);
+}
+
+int lwip_sendto(int s, const void *dataptr, size_t size, int flags,
+    const struct sockaddr *to, socklen_t tolen)
+{
+	return 0;
+}
+
+int lwip_socket(int domain, int type, int protocol)
+{
+	return socket(domain, type, protocol);
+}
+
+int lwip_write(int s, const void *dataptr, size_t size)
+{
+	return write(s, dataptr, size);
+}
+
+
+int lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
+                struct timeval *timeout)
+{
+	int ret;
+	OsSaveLockType save;
+	os_save_unlock(&save);
+	ret = select(maxfdp1, readset, writeset, exceptset, timeout);
+	os_restore_lock(&save);
+	return ret;
+}
+
+int lwip_ioctl(int s, long cmd, void *argp)
+{
+	//TODO
+	return 0;
+}
+
+int lwip_fcntl(int s, int cmd, int val)
+{
+	//TODO
+	return 0;
+}
+
+struct hostent *lwip_gethostbyname(const char *name)
+{
+	return gethostbyname(name);
+}
+
+char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen)
+{
+	//TODO
+	return 0;
+}
+
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-athrill/target/lwip/sockets.h
@@ -0,0 +1,55 @@
+#ifndef _MROS_SOCKET_H_
+#define _MROS_SOCKET_H_
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#ifdef OS_MAC
+#include <sys/time.h>
+#endif
+typedef unsigned int ip_addr_t;
+
+void lwip_init(void);
+
+void lwip_socket_init(void);
+
+int lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen);
+
+int lwip_bind(int s, const struct sockaddr *name, socklen_t namelen);
+int lwip_shutdown(int s, int how);
+int lwip_getpeername (int s, struct sockaddr *name, socklen_t *namelen);
+int lwip_getsockname (int s, struct sockaddr *name, socklen_t *namelen);
+int lwip_getsockopt (int s, int level, int optname, void *optval, socklen_t *optlen);
+int lwip_setsockopt (int s, int level, int optname, const void *optval, socklen_t optlen);
+int lwip_close(int s);
+
+int lwip_connect(int s, const struct sockaddr *name, socklen_t namelen);
+
+int lwip_listen(int s, int backlog);
+
+int lwip_recv(int s, void *mem, size_t len, int flags);
+
+int lwip_read(int s, void *mem, size_t len);
+int lwip_recvfrom(int s, void *mem, size_t len, int flags,
+      struct sockaddr *from, socklen_t *fromlen);
+int lwip_send(int s, const void *dataptr, size_t size, int flags);
+int lwip_sendto(int s, const void *dataptr, size_t size, int flags,
+    const struct sockaddr *to, socklen_t tolen);
+int lwip_socket(int domain, int type, int protocol);
+int lwip_write(int s, const void *dataptr, size_t size);
+
+int lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
+                struct timeval *timeout);
+
+int lwip_ioctl(int s, long cmd, void *argp);
+int lwip_fcntl(int s, int cmd, int val);
+struct hostent *lwip_gethostbyname(const char *name);
+char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen);
+
+#ifndef __cplusplus
+#define true 1
+#define false 0
+#endif
+
+#endif /* _MROS_SOCKET_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-athrill/target/os/kernel.h
@@ -0,0 +1,38 @@
+#ifndef _KERNEL_H_
+#define _KERNEL_H_
+
+#include <string.h>
+#include <stdlib.h>
+#include <pthread.h>
+typedef int ID;
+typedef int PRI;
+
+extern int slp_tsk(void);
+extern int act_tsk(ID);
+extern int get_tid(ID *p_tskid);
+extern int chg_pri(ID tskid, PRI tskpri);
+extern int iwup_tsk(ID tskid);
+extern int get_pri(ID tskid, PRI *p_tskpri);
+extern int dly_tsk(int dlytim);
+extern int wup_tsk(ID tskid);
+
+extern pthread_mutex_t mutex_lock;
+extern pthread_cond_t cond_wait;
+
+#include "kernel_cfg.h"
+
+
+typedef struct {
+	int tskid;
+	int lockCount;
+} OsSaveLockType;
+extern void os_save_unlock(OsSaveLockType *save);
+extern void os_restore_lock(OsSaveLockType *save);
+extern void os_lock_recursive(void);
+extern void os_unlock_recursive(void);
+
+#define TMAX_TPRI 1
+
+typedef int* mros_intptr_t;
+
+#endif
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-athrill/target/os/kernel_cfg.h
@@ -0,0 +1,14 @@
+/* kernel_cfg.h */
+#ifndef TOPPERS_KERNEL_CFG_H
+#define TOPPERS_KERNEL_CFG_H
+
+#define MAIN_TASK	0
+#define SUB_TASK	1
+#define PUB_TASK	2
+#define XML_SLV_TASK	3
+#define XML_MAS_TASK	4
+#define ATHRILL_TASK	5
+#define NUM_TASK	6
+
+#endif /* TOPPERS_KERNEL_CFG_H */
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-athrill/target/os/mros_exclusive_ops_linux.c
@@ -0,0 +1,21 @@
+#include "mros_os.h"
+#include "mros_exclusive_ops.h"
+#define _OPEN_THREADS
+#include "kernel.h"
+
+void mros_exclusive_init(mRosExclusiveObjectType *exobj, mRosTaskPriorityType priority)
+{
+	return;
+}
+
+void mros_exclusive_lock(mRosExclusiveObjectType *exobj, mROsExclusiveUnlockObjType *unlock_obj)
+{
+	os_lock_recursive();
+	return;
+}
+
+void mros_exclusive_unlock(mROsExclusiveUnlockObjType *unlock_obj)
+{
+	os_unlock_recursive();
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-athrill/target/os/os_asp.c
@@ -0,0 +1,201 @@
+#include "kernel.h"
+#include "kernel_cfg.h"
+#include <time.h>
+#include "mros_os_config.h"
+
+pthread_mutex_t mutex_lock = PTHREAD_MUTEX_INITIALIZER;
+pthread_cond_t cond_wait = PTHREAD_COND_INITIALIZER;
+
+typedef enum {
+	OsState_STOPPED = 0,
+	OsState_RUNNABLE,
+	OsState_RUNNING,
+	OsState_WAITING,
+} OsStateType;
+
+typedef struct {
+	int				lock_count;
+	pthread_t		thread;
+	OsStateType		state;
+	void (*task_func) (void);
+} OsTaskType;
+
+static OsTaskType os_task_table[NUM_TASK] = {
+		{ .task_func = main_task },
+		{ .task_func = sub_task },
+		{ .task_func = pub_task },
+		{ .task_func = xml_slv_task },
+		{ .task_func = xml_mas_task },
+		{ .task_func = NULL },
+};
+
+void set_main_task(void)
+{
+	pthread_mutex_lock(&mutex_lock);
+	os_task_table[MAIN_TASK].thread = pthread_self();
+	os_task_table[MAIN_TASK].state = OsState_RUNNING;
+	os_task_table[MAIN_TASK].lock_count = 0;
+	pthread_mutex_unlock(&mutex_lock);
+}
+void set_athrill_task(void)
+{
+	pthread_mutex_lock(&mutex_lock);
+	os_task_table[ATHRILL_TASK].thread = pthread_self();
+	os_task_table[ATHRILL_TASK].state = OsState_RUNNING;
+	os_task_table[ATHRILL_TASK].lock_count = 0;
+	pthread_mutex_unlock(&mutex_lock);
+}
+
+static int get_tskid(void)
+{
+	int i;
+	pthread_t self = pthread_self();
+	for (i = 0; i < NUM_TASK; i++) {
+		if (os_task_table[i].state == OsState_STOPPED) {
+			continue;
+		}
+		if (self == os_task_table[i].thread) {
+			return i;
+		}
+	}
+	return -1;
+}
+static void *os_asp_task_body(void *arg)
+{
+	void (*fp)(void);
+	fp = (void (*)(void))arg;
+	pthread_mutex_lock(&mutex_lock);
+	int tskid = get_tskid();
+	if (tskid >= 0) {
+		os_task_table[tskid].state = OsState_RUNNING;
+	}
+	pthread_mutex_unlock(&mutex_lock);
+	fp();
+	return NULL;
+}
+
+void os_lock_recursive(void)
+{
+	int tskid = get_tskid();
+	if (tskid < 0) {
+		return;
+	}
+	if (os_task_table[tskid].lock_count <= 0) {
+		pthread_mutex_lock(&mutex_lock);
+	}
+	os_task_table[tskid].lock_count++;
+	return;
+}
+
+void os_unlock_recursive(void)
+{
+	int tskid = get_tskid();
+	if (tskid < 0) {
+		return;
+	}
+	if (os_task_table[tskid].lock_count > 0) {
+		os_task_table[tskid].lock_count--;
+	}
+	if (os_task_table[tskid].lock_count <= 0) {
+		pthread_mutex_unlock(&mutex_lock);
+	}
+	return;
+}
+
+void os_save_unlock(OsSaveLockType *save)
+{
+	save->tskid = get_tskid();
+	save->lockCount = os_task_table[save->tskid].lock_count;
+	if (os_task_table[save->tskid].lock_count > 0) {
+		os_task_table[save->tskid].lock_count = 0;
+		pthread_mutex_unlock(&mutex_lock);
+	}
+	return;
+}
+
+void os_restore_lock(OsSaveLockType *save)
+{
+	if (save->lockCount > 0) {
+		pthread_mutex_lock(&mutex_lock);
+	}
+	os_task_table[save->tskid].lock_count = save->lockCount;
+	return;
+}
+
+
+int slp_tsk(void)
+{
+	OsSaveLockType save;
+	/*
+	 * already locked!
+	 */
+	save.tskid = get_tskid();
+	if (save.tskid < 0) {
+		return -1;
+	}
+	save.lockCount = os_task_table[save.tskid].lock_count;
+	os_task_table[save.tskid].state = OsState_WAITING;
+	while (os_task_table[save.tskid].state == OsState_WAITING) {
+		os_task_table[save.tskid].lock_count = 0;
+		pthread_cond_wait(&cond_wait, &mutex_lock);
+		os_task_table[save.tskid].lock_count = save.lockCount;
+	}
+	os_task_table[save.tskid].state = OsState_RUNNING;
+	return 0;
+}
+int act_tsk(ID id)
+{
+	os_lock_recursive();
+	os_task_table[id].state = OsState_RUNNABLE;
+	(void)pthread_create(&os_task_table[id].thread, NULL, os_asp_task_body, (void*)os_task_table[id].task_func);
+	os_unlock_recursive();
+	return 0;
+}
+int get_tid(ID *p_tskid)
+{
+	*p_tskid = get_tskid();
+	return 0;
+}
+int chg_pri(ID tskid, PRI tskpri)
+{
+	//TODO
+	return 0;
+}
+int iwup_tsk(ID tskid)
+{
+	os_lock_recursive();
+	os_task_table[tskid].state = OsState_RUNNABLE;
+	pthread_cond_broadcast(&cond_wait);
+	os_unlock_recursive();
+	return 0;
+}
+int get_pri(ID tskid, PRI *p_tskpri)
+{
+	//TODO
+	*p_tskpri = 0;
+	return 0;
+}
+int dly_tsk(int dlytim)
+{
+	struct timespec tv;
+	clock_gettime(CLOCK_REALTIME, &tv);
+	int tskid = get_tskid();
+	if (tskid < 0) {
+		return -1;
+	}
+	tv.tv_nsec += dlytim * 1000;
+	os_lock_recursive();
+	os_task_table[tskid].state = OsState_WAITING;
+	pthread_cond_timedwait(&cond_wait, &mutex_lock, &tv);
+	os_task_table[tskid].state = OsState_RUNNING;
+	os_unlock_recursive();
+	return 0;
+}
+int wup_tsk(ID tskid)
+{
+	os_lock_recursive();
+	os_task_table[tskid].state = OsState_RUNNABLE;
+	pthread_cond_broadcast(&cond_wait);
+	os_unlock_recursive();
+	return 0;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-athrill/target/os/t_syslog.h
@@ -0,0 +1,23 @@
+#ifndef _T_SYSLOG_H_
+#define _T_SYSLOG_H_
+
+#include <stdarg.h>
+#include <stdio.h>
+
+#define LOG_ERROR 1
+#define LOG_WARNING 1
+#define LOG_NOTICE 1
+
+static inline void syslog(int flag, const char* fmt, ...)
+{
+	  va_list arg_ptr;
+	  static char format[1024];
+
+	  sprintf(format, "%s\n", fmt);
+	  va_start(arg_ptr, fmt);
+	  vprintf(format, arg_ptr);
+	  va_end(arg_ptr);
+	  return;
+}
+
+#endif
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/api/mros_topic_callback.h
@@ -0,0 +1,18 @@
+#ifndef _MROS_INTEGRATION_H_
+#define _MROS_INTEGRATION_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_types.h"
+
+extern void mros_topic_callback(mros_uint32 topic_id, mros_uint32 type_id, mRosFuncIdType func_id, const char *data, mros_uint32 len);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* _MROS_INTEGRATION_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/comm/cimpl/mros_comm_cimpl.h
@@ -0,0 +1,62 @@
+/* Copyright (C) 2012 mbed.org, MIT License
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ * and associated documentation files (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge, publish, distribute,
+ * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+ * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef _MROS_COMM_CIMPL_H_
+#define _MROS_COMM_CIMPL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_types.h"
+
+
+extern mRosReturnType mros_comm_inet_get_ipaddr(const char *hostname, mros_uint32 *ipaddr);
+extern void mros_comm_inet_local_sockaddr_init(mRosSockAddrInType *addr, mros_int32 port);
+extern void mros_comm_inet_remote_sockaddr_init(mRosSockAddrInType *addr, mros_int32 port, const char* ipaddrp);
+extern void mros_comm_inet_remote_sockaddr_ip32_init(mRosSockAddrInType *addr, mros_int32 port, mros_uint32 ipaddrp);
+extern void mros_comm_timeval_set(mros_uint32 sec, mros_uint32 usec, mRosTimeValType *tv);
+
+extern void mros_comm_init(void);
+extern mros_int32 mros_comm_accept(mros_int32 s, mRosSockAddrType *addr, mRosSizeType *addrlen);
+extern mros_int32 mros_comm_bind(mros_int32 s, const mRosSockAddrType *name, mRosSizeType namelen);
+extern mros_int32 mros_comm_shutdown(mros_int32 s, mros_int32 how);
+extern mros_int32 mros_comm_getpeername (mros_int32 s, mRosSockAddrType *name, mRosSizeType *namelen);
+extern mros_int32 mros_comm_getsockname (mros_int32 s, mRosSockAddrType *name, mRosSizeType *namelen);
+extern mros_int32 mros_comm_getsockopt (mros_int32 s, mros_int32 level, mros_int32 optname, void *optval, mRosSizeType *optlen);
+extern mros_int32 mros_comm_setsockopt (mros_int32 s, mros_int32 level, mros_int32 optname, const void *optval, mRosSizeType optlen);
+extern mros_int32 mros_comm_close(mros_int32 s);
+extern mros_int32 mros_comm_connect(mros_int32 s, const mRosSockAddrType *name, mRosSizeType namelen);
+extern mros_int32 mros_comm_listen(mros_int32 s, mros_int32 backlog);
+extern mros_int32 mros_comm_recv(mros_int32 s, void *mem, mRosSizeType len, mros_int32 flags);
+extern mros_int32 mros_comm_read(mros_int32 s, void *mem, mRosSizeType len);
+extern mros_int32 mros_comm_recvfrom(mros_int32 s, void *mem, mRosSizeType len, mros_int32 flags, mRosSockAddrType *from, mRosSizeType *fromlen);
+extern mros_int32 mros_comm_send(mros_int32 s, const void *dataptr, mRosSizeType size, mros_int32 flags);
+extern mros_int32 mros_comm_sendto(mros_int32 s, const void *dataptr, mRosSizeType size, mros_int32 flags, const mRosSockAddrType *to, mRosSizeType tolen);
+extern mros_int32 mros_comm_socket(mros_int32 domain, mros_int32 type, mros_int32 protocol);
+extern mros_int32 mros_comm_write(mros_int32 s, const void *dataptr, mRosSizeType size);
+extern mros_int32 mros_comm_select(mros_int32 maxfdp1, mRosFdSetType *readset, mRosFdSetType *writeset, mRosFdSetType *exceptset, mRosTimeValType *timeout);
+extern mros_int32 mros_comm_ioctl(mros_int32 s, mros_int32 cmd, void *argp);
+extern mros_int32 mros_comm_fcntl(mros_int32 s, mros_int32 cmd, int val);
+extern mRosHostEntType *mros_comm_gethostbyname(const char *name);
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* _MROS_COMM_CIMPL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/comm/cimpl/mros_comm_socket_cimpl.c
@@ -0,0 +1,108 @@
+/* Copyright (C) 2012 mbed.org, MIT License
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ * and associated documentation files (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge, publish, distribute,
+ * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+ * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "mros_comm_socket_cimpl.h"
+#include "mros_comm_cimpl.h"
+
+mRosReturnType mros_comm_socket_init(mRosCommSocketType *socket, mRosCommSocketEnumType type)
+{
+	switch (type) {
+	case MROS_COMM_SOCKET_TYPE_TCP:
+		socket->comm_type = MROS_SOCK_STREAM;
+		break;
+	case MROS_COMM_SOCKET_TYPE_UDP:
+		socket->comm_type = MROS_SOCK_DGRAM;
+		break;
+	default:
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return MROS_E_INVAL;
+	}
+	socket->sock_fd = mros_comm_socket(MROS_SOCK_AF_INET, socket->comm_type, 0);
+	if (socket->sock_fd < 0) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return MROS_E_INVAL;
+	}
+
+    socket->blocking = MROS_TRUE;
+    socket->timeout = MROS_COMM_DEFAULT_TIMEOUT;
+	return MROS_E_OK;
+}
+
+mRosReturnType mros_comm_socket_open(mRosCommSocketType *socket)
+{
+	socket->sock_fd = mros_comm_socket(MROS_SOCK_AF_INET, socket->comm_type, 0);
+    if (socket->sock_fd < 0) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+    	return MROS_E_INVAL;
+    }
+	return MROS_E_OK;
+}
+
+void mros_comm_socket_close(mRosCommSocketType *socket)
+{
+	mros_comm_close(socket->sock_fd);
+	socket->sock_fd = -1;
+	return;
+}
+
+static mRosReturnType mros_comm_socket_select(mRosCommSocketType *socket, mros_uint32 timeout, mros_boolean read, mros_boolean write) {
+
+	mRosFdSetType fd_set;
+	mRosTimeValType tmo;
+
+	MROS_FD_ZERO(&fd_set);
+    MROS_FD_SET(socket->sock_fd, &fd_set);
+
+    mRosFdSetType* r_set = MROS_NULL;
+    mRosFdSetType* w_set = MROS_NULL;
+
+    if (read == MROS_TRUE) {
+    	r_set = &fd_set;
+    }
+    if (write == MROS_TRUE) {
+    	w_set = &fd_set;
+    }
+    mros_comm_set_timeval(timeout, &tmo);
+    mRosReturnType ret = mros_comm_select(MROS_FD_SETSIZE, r_set, w_set, MROS_NULL, &tmo);
+    if (ret < 0) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+    	return MROS_E_SYSERR;
+    }
+    if ((ret == 0 || !MROS_FD_ISSET(socket->sock_fd, &fd_set))) {
+    	return MROS_E_NOENT;
+    }
+    return MROS_E_OK;
+}
+
+
+mRosReturnType mros_comm_socket_set_blocking(mRosCommSocketType *socket, mros_boolean blocking, mros_uint32 timeout)
+{
+	socket->blocking = blocking;
+	socket->timeout = timeout;
+	return MROS_E_OK;
+}
+
+
+mRosReturnType mros_comm_socket_wait_readable(mRosCommSocketType *socket, mros_uint32 timeout)
+{
+	return mros_comm_socket_select(socket, timeout, MROS_TRUE, MROS_FALSE);
+}
+
+mRosReturnType mros_comm_socket_wait_writable(mRosCommSocketType *socket, mros_uint32 timeout)
+{
+	return mros_comm_socket_select(socket, timeout, MROS_FALSE, MROS_TRUE);
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/comm/cimpl/mros_comm_socket_cimpl.h
@@ -0,0 +1,61 @@
+/* Copyright (C) 2012 mbed.org, MIT License
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ * and associated documentation files (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge, publish, distribute,
+ * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+ * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef _MROS_COMM_SOCKET_CIMPL_H_
+#define _MROS_COMM_SOCKET_CIMPL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_comm_cimpl.h"
+
+typedef struct {
+	mros_int32		sock_fd;
+	mros_uint32		timeout;
+	mros_boolean	blocking;
+	mros_int32		comm_type;
+} mRosCommSocketType;
+
+static inline void mros_comm_set_timeval(mros_uint32 tmo_msec, mRosTimeValType *tv)
+{
+    mros_uint32 tv_sec = tmo_msec / 1000;
+    mros_uint32 tv_usec = (tmo_msec - (tv_sec * 1000)) * 1000;
+	mros_comm_timeval_set(tv_sec, tv_usec, tv);
+    return;
+}
+
+typedef enum {
+	MROS_COMM_SOCKET_TYPE_TCP = 0,
+	MROS_COMM_SOCKET_TYPE_UDP,
+} mRosCommSocketEnumType;
+
+#define MROS_COMM_DEFAULT_TIMEOUT		1500
+
+extern mRosReturnType mros_comm_socket_init(mRosCommSocketType *socket, mRosCommSocketEnumType type);
+extern mRosReturnType mros_comm_socket_open(mRosCommSocketType *socket);
+extern void mros_comm_socket_close(mRosCommSocketType *socket);
+extern mRosReturnType mros_comm_socket_set_blocking(mRosCommSocketType *socket, mros_boolean blocking, mros_uint32 timeout);
+
+extern mRosReturnType mros_comm_socket_wait_readable(mRosCommSocketType *socket, mros_uint32 timeout);
+extern mRosReturnType mros_comm_socket_wait_writable(mRosCommSocketType *socket, mros_uint32 timeout);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MROS_COMM_SOCKET_CIMPL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/comm/cimpl/mros_comm_tcp_client_cimpl.c
@@ -0,0 +1,195 @@
+/* Copyright (C) 2012 mbed.org, MIT License
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ * and associated documentation files (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge, publish, distribute,
+ * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+ * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "mros_comm_tcp_client_cimpl.h"
+
+mRosReturnType mros_comm_tcp_client_init(mRosCommTcpClientType *client, const char* host, mros_int32 port)
+{
+	client->connected = MROS_FALSE;
+	mros_comm_inet_remote_sockaddr_init(&client->remote, port, host);
+	return mros_comm_socket_init(&client->socket, MROS_COMM_SOCKET_TYPE_TCP);
+}
+mRosReturnType mros_comm_tcp_client_ip32_init(mRosCommTcpClientType *client, mros_uint32 ipaddr, mros_int32 port)
+{
+	client->connected = MROS_FALSE;
+	mros_comm_inet_remote_sockaddr_ip32_init(&client->remote, port, ipaddr);
+	return mros_comm_socket_init(&client->socket, MROS_COMM_SOCKET_TYPE_TCP);
+}
+
+void mros_comm_tcp_client_close(mRosCommTcpClientType *client)
+{
+	client->connected = MROS_FALSE;
+	mros_comm_socket_close(&client->socket);
+	return;
+}
+
+mRosReturnType mros_comm_tcp_client_connect(mRosCommTcpClientType *client)
+{
+	mRosReturnType ret;
+
+	if (client->connected == MROS_TRUE) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return MROS_E_INVAL;
+	}
+	if (client->socket.sock_fd < 0) {
+		ret = mros_comm_socket_init(&client->socket, MROS_COMM_SOCKET_TYPE_TCP);
+		if (ret != MROS_E_OK) {
+			ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+			return ret;
+		}
+	}
+
+	ret = mros_comm_connect(client->socket.sock_fd, (const mRosSockAddrType *)&client->remote, sizeof(mRosSockAddrInType));
+	if (ret != MROS_E_OK) {
+		struct sockaddr_in *sock = (struct sockaddr_in*)&client->remote;
+		ROS_ERROR("%s %s() %u ret=%d ipaddr=0x%x port=%u", __FILE__, __FUNCTION__, __LINE__, ret, sock->sin_addr, sock->sin_port);
+		return MROS_E_NOTCONN;
+	}
+	client->connected = MROS_TRUE;
+	return MROS_E_OK;
+}
+
+
+
+mros_boolean mros_comm_tcp_client_is_connected(mRosCommTcpClientType *client)
+{
+	return client->connected;
+}
+mRosReturnType mros_comm_tcp_client_send(mRosCommTcpClientType *client, const char* data, mRosSizeType length, mRosSizeType *res)
+{
+	mRosReturnType ret;
+	mros_int32 snd_size;
+
+    if ((client->socket.sock_fd < 0) || (client->connected == MROS_FALSE)) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+        return MROS_E_INVAL;
+    }
+
+    if (client->socket.blocking == MROS_FALSE) {
+    	ret = mros_comm_socket_wait_writable(&client->socket, client->socket.timeout);
+    	if (ret != MROS_E_OK) {
+    		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+    		return ret;
+    	}
+    }
+    snd_size = mros_comm_send(client->socket.sock_fd, data, length, 0);
+    if (snd_size == 0) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		client->connected = MROS_FALSE;
+    }
+    *res = snd_size;
+	return MROS_E_OK;
+}
+mRosReturnType mros_comm_tcp_client_send_all(mRosCommTcpClientType *client, const char* data, mRosSizeType length, mRosSizeType *res)
+{
+	mRosReturnType ret;
+    mros_int32 writtenLen = 0;
+
+    if ((client->socket.sock_fd < 0) || (client->connected == MROS_FALSE)) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+        return MROS_E_INVAL;
+    }
+
+    while (writtenLen < length) {
+        if (client->socket.blocking == MROS_FALSE) {
+        	ret = mros_comm_socket_wait_writable(&client->socket, client->socket.timeout);
+        	if (ret != MROS_E_OK) {
+        		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+        		return ret;
+        	}
+        }
+
+        mros_int32 retlen = mros_comm_send(client->socket.sock_fd, data + writtenLen, length - writtenLen, 0);
+        if (retlen > 0) {
+            writtenLen += retlen;
+            continue;
+        } else if (retlen == 0) {
+    		client->connected = MROS_FALSE;
+            *res = writtenLen;
+    		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_SYSERR);
+            return MROS_E_SYSERR;
+        } else {
+            *res = writtenLen;
+    		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_SYSERR);
+            return MROS_E_SYSERR;
+        }
+    }
+    *res = writtenLen;
+	return MROS_E_OK;
+}
+mRosReturnType mros_comm_tcp_client_receive(mRosCommTcpClientType *client, char* data, mRosSizeType length, mRosSizeType *res)
+{
+	mRosReturnType ret;
+	mros_int32 rcv_size;
+
+    if ((client->socket.sock_fd < 0) || (client->connected == MROS_FALSE)) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+        return MROS_E_INVAL;
+    }
+    if (client->socket.blocking == MROS_FALSE) {
+    	ret = mros_comm_socket_wait_readable(&client->socket, client->socket.timeout);
+    	if (ret != MROS_E_OK) {
+    		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+    		return ret;
+    	}
+    }
+    rcv_size = mros_comm_recv(client->socket.sock_fd, data, length, 0);
+    if (rcv_size == 0) {
+		client->connected = MROS_FALSE;
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_SYSERR);
+    }
+    *res = rcv_size;
+
+	return MROS_E_OK;
+}
+
+mRosReturnType mros_comm_tcp_client_receive_all(mRosCommTcpClientType *client, char* data, mRosSizeType length, mRosSizeType *res)
+{
+	mRosReturnType ret;
+    mros_int32 readLen = 0;
+
+    if ((client->socket.sock_fd < 0) || (client->connected == MROS_FALSE)) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+        return MROS_E_INVAL;
+    }
+
+    while (readLen < length) {
+        if (client->socket.blocking == MROS_FALSE) {
+        	ret = mros_comm_socket_wait_writable(&client->socket, client->socket.timeout);
+        	if (ret != MROS_E_OK) {
+        		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+        		return ret;
+        	}
+        }
+        mros_int32 retlen = mros_comm_recv(client->socket.sock_fd, data + readLen, length - readLen, 0);
+        if (retlen > 0) {
+        	readLen += retlen;
+            continue;
+        } else if (retlen == 0) {
+    		client->connected = MROS_FALSE;
+            *res = readLen;
+    		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_SYSERR);
+            return MROS_E_SYSERR;
+        } else {
+            *res = readLen;
+    		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_SYSERR);
+            return MROS_E_SYSERR;
+        }
+    }
+    *res = readLen;
+	return MROS_E_OK;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/comm/cimpl/mros_comm_tcp_client_cimpl.h
@@ -0,0 +1,51 @@
+/* Copyright (C) 2012 mbed.org, MIT License
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ * and associated documentation files (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge, publish, distribute,
+ * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+ * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef _MROS_COMM_TCP_CLIENT_CIMPL_H_
+#define _MROS_COMM_TCP_CLIENT_CIMPL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_comm_socket_cimpl.h"
+
+typedef struct {
+	mRosCommSocketType	socket;
+	mRosSockAddrInType	remote;
+	mros_boolean		connected;
+} mRosCommTcpClientType;
+
+
+extern mRosReturnType mros_comm_tcp_client_init(mRosCommTcpClientType *client, const char* host, mros_int32 port);
+extern mRosReturnType mros_comm_tcp_client_ip32_init(mRosCommTcpClientType *client, mros_uint32 ipaddr, mros_int32 port);
+
+extern void mros_comm_tcp_client_close(mRosCommTcpClientType *client);
+extern mRosReturnType mros_comm_tcp_client_connect(mRosCommTcpClientType *client);
+extern mRosReturnType mros_comm_tcp_client_connect_ip32(mRosCommTcpClientType *client, mros_uint32 ipaddr, mros_int32 port);
+extern mros_boolean mros_comm_tcp_client_is_connected(mRosCommTcpClientType *client);
+extern mRosReturnType mros_comm_tcp_client_send(mRosCommTcpClientType *client, const char* data, mRosSizeType length, mRosSizeType *res);
+extern mRosReturnType mros_comm_tcp_client_send_all(mRosCommTcpClientType *client, const char* data, mRosSizeType length, mRosSizeType *res);
+extern mRosReturnType mros_comm_tcp_client_receive(mRosCommTcpClientType *client, char* data, mRosSizeType length, mRosSizeType *res);
+extern mRosReturnType mros_comm_tcp_client_receive_all(mRosCommTcpClientType *client, char* data, mRosSizeType length, mRosSizeType *res);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MROS_COMM_TCP_CLIENT_CIMPL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/comm/cimpl/mros_comm_tcp_client_factory_cimpl.c
@@ -0,0 +1,60 @@
+/* Copyright (C) 2012 mbed.org, MIT License
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ * and associated documentation files (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge, publish, distribute,
+ * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+ * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "mros_comm_tcp_client_factory_cimpl.h"
+#include "mros_sys_config.h"
+
+static mRosCommTcpClientEntryHeadType mros_comm_tcp_client_factory MROS_MATTR_BSS_NOCLR;
+static mRosCommTcpClientListReqEntryType mros_comm_tcp_client_entries[MROS_TOPIC_TCP_CLIENT_MAX_NUM] MROS_MATTR_BSS_NOCLR;
+
+mRosReturnType mros_comm_tcp_client_factory_init(void)
+{
+
+	List_Init(&mros_comm_tcp_client_factory, mRosCommTcpClientListReqEntryType, MROS_TOPIC_TCP_CLIENT_MAX_NUM, mros_comm_tcp_client_entries);
+	return MROS_E_OK;
+}
+
+mRosCommTcpClientListReqEntryType *mros_comm_tcp_client_alloc(void)
+{
+	mRosCommTcpClientListReqEntryType *p;
+	ListEntry_Alloc(&mros_comm_tcp_client_factory, mRosCommTcpClientListReqEntryType, &p);
+	if (p == MROS_NULL) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_NOMEM);
+		return MROS_NULL;
+	}
+	ListEntry_AddEntry(&mros_comm_tcp_client_factory, p);
+	return p;
+}
+mRosCommTcpClientListReqEntryType *mros_comm_tcp_client_alloc_copy(mRosCommTcpClientType *client)
+{
+	mRosCommTcpClientListReqEntryType *p;
+
+	p = mros_comm_tcp_client_alloc();
+	if (p == MROS_NULL) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_NOMEM);
+		return MROS_NULL;
+	}
+	p->data.client = *client;
+
+	return p;
+}
+void mros_comm_tcp_client_free(mRosCommTcpClientListReqEntryType *client)
+{
+	ListEntry_RemoveEntry(&mros_comm_tcp_client_factory, client);
+	ListEntry_Free(&mros_comm_tcp_client_factory, client);
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/comm/cimpl/mros_comm_tcp_client_factory_cimpl.h
@@ -0,0 +1,61 @@
+/* Copyright (C) 2012 mbed.org, MIT License
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ * and associated documentation files (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge, publish, distribute,
+ * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+ * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef _MROS_COMM_TCP_CLIENT_FACTORY_CIMPL_H_
+#define _MROS_COMM_TCP_CLIENT_FACTORY_CIMPL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_comm_tcp_client_cimpl.h"
+#include "mros_memory.h"
+#include "mros_wait_queue.h"
+
+typedef struct {
+	mRosTopicIdType 		topic_id;
+	mros_uint32				ipaddr;
+	mros_int32				port;
+	void*					api_reqp;
+	mRosWaitListEntryType	waitobj;
+} mRosRquestObjectType;
+
+typedef struct {
+	mRosReturnType (*topic_data_send) (mRosCommTcpClientType *client, const char *data, mRosSizeType datalen);
+	mRosReturnType (*topic_data_receive) (mRosCommTcpClientType *client, mRosMemoryManagerType *mempool, mRosMemoryListEntryType **retp);
+	void (*free) (void* reqp);
+} mRosCommOperationType;
+
+typedef struct {
+	mRosCommTcpClientType 	client;
+	mRosCommOperationType	op;
+	mRosRquestObjectType	reqobj;
+} mRosCommTcpClientReqEntryType;
+typedef ListEntryType(mRosCommTcpClientListReqEntryType, mRosCommTcpClientReqEntryType) mRosCommTcpClientListReqEntryType;
+typedef ListHeadType(mRosCommTcpClientListReqEntryType) mRosCommTcpClientEntryHeadType;
+
+extern mRosReturnType mros_comm_tcp_client_factory_init(void);
+extern mRosCommTcpClientListReqEntryType *mros_comm_tcp_client_alloc(void);
+extern mRosCommTcpClientListReqEntryType *mros_comm_tcp_client_alloc_copy(mRosCommTcpClientType *client);
+extern void mros_comm_tcp_client_free(mRosCommTcpClientListReqEntryType *client);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MROS_COMM_TCP_CLIENT_FACTORY_CIMPL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/comm/cimpl/mros_comm_tcp_server_cimpl.c
@@ -0,0 +1,84 @@
+/* Copyright (C) 2012 mbed.org, MIT License
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ * and associated documentation files (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge, publish, distribute,
+ * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+ * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "mros_comm_tcp_server_cimpl.h"
+
+mRosReturnType mros_comm_tcp_server_init(mRosCommTcpServerType *server)
+{
+	return mros_comm_socket_init(&server->socket, MROS_COMM_SOCKET_TYPE_TCP);
+}
+
+mRosReturnType mros_comm_tcp_server_bind(mRosCommTcpServerType *server, mros_int32 port)
+{
+	mRosReturnType ret;
+    mRosSockAddrInType addr;
+
+    mros_comm_inet_local_sockaddr_init(&addr, port);
+    ret = mros_comm_bind(server->socket.sock_fd, (mRosSockAddrType*)&addr, sizeof(mRosSockAddrInType));
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return MROS_E_SYSERR;
+	}
+	return MROS_E_OK;
+}
+mRosReturnType mros_comm_tcp_server_listen(mRosCommTcpServerType *server, mros_int32 max)
+{
+	mRosReturnType ret;
+    if (server->socket.sock_fd < 0) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_SYSERR);
+		return MROS_E_SYSERR;
+    }
+
+    ret = mros_comm_listen(server->socket.sock_fd, max);
+    if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return MROS_E_SYSERR;
+    }
+	return MROS_E_OK;
+}
+
+mRosReturnType mros_comm_tcp_server_accept(mRosCommTcpServerType *server, mRosCommTcpClientType *client)
+{
+	mRosReturnType ret;
+	mRosSockAddrInType addr;
+
+    if (server->socket.sock_fd < 0) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_SYSERR);
+		return MROS_E_SYSERR;
+    }
+    if (server->socket.blocking == MROS_FALSE) {
+    	ret = mros_comm_socket_wait_readable(&server->socket, server->socket.timeout);
+    	if (ret != MROS_E_OK) {
+    		if (ret != MROS_E_NOENT) {
+        		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+    		}
+    		return ret;
+    	}
+    }
+
+    mRosSizeType len = sizeof(mRosSockAddrInType);
+    client->socket.sock_fd = mros_comm_accept(server->socket.sock_fd, (mRosSockAddrType*)&addr, &len);
+    if (client->socket.sock_fd < 0) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_SYSERR);
+		return MROS_E_SYSERR;
+    }
+    client->socket.blocking = MROS_TRUE;
+    client->socket.timeout = MROS_COMM_DEFAULT_TIMEOUT;
+    client->connected = MROS_TRUE;
+
+	return MROS_E_OK;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/comm/cimpl/mros_comm_tcp_server_cimpl.h
@@ -0,0 +1,41 @@
+/* Copyright (C) 2012 mbed.org, MIT License
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ * and associated documentation files (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge, publish, distribute,
+ * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+ * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef _MROS_COMM_TCP_SERVER_CIMPL_H_
+#define _MROS_COMM_TCP_SERVER_CIMPL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_comm_tcp_client_cimpl.h"
+
+typedef struct {
+	mRosCommSocketType socket;
+} mRosCommTcpServerType;
+
+extern mRosReturnType mros_comm_tcp_server_init(mRosCommTcpServerType *server);
+extern mRosReturnType mros_comm_tcp_server_bind(mRosCommTcpServerType *server, mros_int32 port);
+#define MROS_COMM_TCP_SERVER_LISTEN_MAX_DEFAULT_VALUE	1
+extern mRosReturnType mros_comm_tcp_server_listen(mRosCommTcpServerType *server, mros_int32 max);
+extern mRosReturnType mros_comm_tcp_server_accept(mRosCommTcpServerType *server, mRosCommTcpClientType *client);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MROS_COMM_TCP_SERVER_CIMPL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/comm/cimpl/target/lwip/mros_comm_cimpl.c
@@ -0,0 +1,364 @@
+/* Copyright (C) 2012 mbed.org, MIT License
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ * and associated documentation files (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge, publish, distribute,
+ * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+ * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "mros_types.h"
+#include "mros_comm_cimpl.h"
+#ifndef TARGET_ATHRILL
+#include <kernel.h>
+#include <t_syslog.h>
+#include <t_stdlib.h>
+#include "syssvc/serial.h"
+#include "syssvc/syslog.h"
+
+#include "kernel_cfg.h"
+#include "syssvc/logtask.h"
+
+#include "lwip/inet.h"
+#include "lwip/netif.h"
+#include "netif/etharp.h"
+#include "lwip/dhcp.h"
+#include "eth_arch.h"
+#include "lwip/tcpip.h"
+/*
+ * mbed_interface.h
+ */
+extern void mbed_mac_address(char *mac);
+#endif /* TARGET_ATHRILL */
+
+#include <string.h>
+#include <stdio.h>
+
+
+void mros_comm_inet_local_sockaddr_init(mRosSockAddrInType *addr, mros_int32 port)
+{
+    memset(addr, 0, sizeof(mRosSockAddrInType));
+
+    addr->sin_family = AF_INET;
+    addr->sin_port = htons(port);
+    addr->sin_addr.s_addr = INADDR_ANY;
+	return;
+}
+
+mRosReturnType mros_comm_inet_get_ipaddr(const char *hostname, mros_uint32 *ipaddr)
+{
+	mros_int32 result;
+	mros_uint8 addr_array[5];
+    mros_uint8 *paddr = addr_array;
+
+    result = sscanf(hostname, "%hhu.%hhu.%hhu.%hhu",
+    		(mros_uint8*)&addr_array[0],
+			(mros_uint8*)&addr_array[1],
+			(mros_uint8*)&addr_array[2],
+			(mros_uint8*)&addr_array[3]);
+
+    if (result != 4) {
+    	mRosHostEntType *host_address = mros_comm_gethostbyname(hostname);
+        if (host_address == MROS_NULL) {
+    		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+        	return MROS_E_INVAL;
+        }
+        paddr = (mros_uint8*)host_address->h_addr_list[0];
+    }
+    memcpy((void*)ipaddr, (void*)paddr, 4U);
+    return MROS_E_OK;
+}
+
+void mros_comm_inet_remote_sockaddr_init(mRosSockAddrInType *addr, mros_int32 port, const char* ipaddrp)
+{
+	mros_int32 result;
+	mros_uint8 addr_array[5];
+    memset(addr, 0, sizeof(mRosSockAddrInType));
+    mros_uint8 *paddr = addr_array;
+
+    addr->sin_family = AF_INET;
+    addr->sin_port = htons(port);
+    result = sscanf(ipaddrp, "%hhu.%hhu.%hhu.%hhu",
+    		(mros_uint8*)&addr_array[0],
+			(mros_uint8*)&addr_array[1],
+			(mros_uint8*)&addr_array[2],
+			(mros_uint8*)&addr_array[3]);
+
+    if (result != 4) {
+    	mRosHostEntType *host_address = mros_comm_gethostbyname(ipaddrp);
+        if (host_address == MROS_NULL) {
+    		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+        	return;
+        }
+        paddr = (mros_uint8*)host_address->h_addr_list[0];
+    }
+
+    memcpy((void*)&addr->sin_addr.s_addr, (void*)paddr, 4U);
+	return;
+}
+void mros_comm_inet_remote_sockaddr_ip32_init(mRosSockAddrInType *addr, mros_int32 port, mros_uint32 ipaddr)
+{
+    memset(addr, 0, sizeof(mRosSockAddrInType));
+
+    addr->sin_family = AF_INET;
+    addr->sin_port = htons(port);
+    memcpy((void*)&addr->sin_addr.s_addr, (void*)&ipaddr, 4U);
+	return;
+}
+
+void mros_comm_timeval_set(mros_uint32 sec, mros_uint32 usec, mRosTimeValType *tv)
+{
+	tv->tv_sec = sec;
+	tv->tv_usec = usec;
+	return;
+}
+
+#ifndef TARGET_ATHRILL
+#define USE_DHCP (0)
+#if(USE_DHCP == 0)
+	#define IP_ADDRESS  	("127.0.0.1")	/*IP address */
+	#define SUBNET_MASK		("255.0.0.0")	/*Subset mask */
+	#define DEFAULT_GATEWAY	("")	/*Default gateway */
+#endif
+
+static mros_boolean use_dhcp;
+static char mac_addr[19];
+static char ip_addr[17] = "\0";
+static char gateway[17] = "\0";
+static char networkmask[17] = "\0";
+/* TCP/IP and Network Interface Initialisation */
+static struct netif netif;
+
+
+static void tcpip_init_done(void *arg) {
+	//    tcpip_inited.release();
+	sig_sem(TCPIP_INITED);
+}
+
+static void netif_link_callback(struct netif *netif) {
+    if (netif_is_link_up(netif)) {
+        // netif_linked.release();
+		sig_sem(NETIF_LINKED);
+    }
+}
+
+static void netif_status_callback(struct netif *netif) {
+    if (netif_is_up(netif)) {
+        strcpy(ip_addr, inet_ntoa(netif->ip_addr));
+        strcpy(gateway, inet_ntoa(netif->gw));
+        strcpy(networkmask, inet_ntoa(netif->netmask));
+        // netif_up.release();
+		sig_sem(NETIF_UP);
+    }
+}
+
+static void init_netif(ip_addr_t *ipaddr, ip_addr_t *netmask, ip_addr_t *gw) {
+    tcpip_init(tcpip_init_done, NULL);
+	// tcpip_inited.wait();
+	wai_sem(TCPIP_INITED);
+
+    memset((void*) &netif, 0, sizeof(netif));
+    netif_add(&netif, ipaddr, netmask, gw, NULL, eth_arch_enetif_init, tcpip_input);
+    netif_set_default(&netif);
+
+    netif_set_link_callback  (&netif, netif_link_callback);
+    netif_set_status_callback(&netif, netif_status_callback);
+}
+
+static void set_mac_address(void) {
+#if (MBED_MAC_ADDRESS_SUM != MBED_MAC_ADDR_INTERFACE)
+    snprintf(mac_addr, 19, "%02x:%02x:%02x:%02x:%02x:%02x", MBED_MAC_ADDR_0, MBED_MAC_ADDR_1, MBED_MAC_ADDR_2,
+             MBED_MAC_ADDR_3, MBED_MAC_ADDR_4, MBED_MAC_ADDR_5);
+#else
+    char mac[6];
+    mbed_mac_address(mac);
+    snprintf(mac_addr, 19, "%02x:%02x:%02x:%02x:%02x:%02x", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+#endif
+}
+
+#if (USE_DHCP == 1)
+static int ethernet_init(void)
+{
+    use_dhcp = true;
+    set_mac_address();
+    init_netif(NULL, NULL, NULL);
+    return 0;
+}
+#endif
+
+static int ethernet_ip_init(const char* ip, const char* mask, const char* gateway)
+{
+    use_dhcp = false;
+
+    set_mac_address();
+    strcpy(ip_addr, ip);
+
+    ip_addr_t ip_n, mask_n, gateway_n;
+    inet_aton(ip, &ip_n);
+    inet_aton(mask, &mask_n);
+    inet_aton(gateway, &gateway_n);
+    init_netif(&ip_n, &mask_n, &gateway_n);
+
+    return 0;
+}
+
+static char* ethernet_getMACAddress() {
+    return mac_addr;
+}
+
+static char* ethernet_getIPAddress() {
+    return ip_addr;
+}
+
+static char* ethernet_getGateway() {
+    return gateway;
+}
+
+static char* ethernet_getNetworkMask() {
+    return networkmask;
+}
+static int ethernet_connect(unsigned int timeout_ms) {
+    eth_arch_enable_interrupts();
+
+    int inited;
+    if (use_dhcp) {
+        dhcp_start(&netif);
+        // Wait for an IP Address
+        // -1: error, 0: timeout
+		// inited = netif_up.wait(timeout_ms);
+		inited = twai_sem(NETIF_UP, timeout_ms);
+    } else {
+        netif_set_up(&netif);
+        // Wait for the link up
+        // inited = netif_linked.wait(timeout_ms);
+		inited = twai_sem(NETIF_LINKED, timeout_ms);
+    }
+	return (inited == E_OK) ? (0) : (-1);
+	//    return (inited > 0) ? (0) : (-1);
+}
+
+static void network_init(){
+#if (USE_DHCP == 1)
+	if(ethernet_init() != 0) {
+#else
+	if(ethernet_ip_init(IP_ADDRESS, SUBNET_MASK, DEFAULT_GATEWAY) != 0) {
+#endif
+		syslog(LOG_NOTICE, "Network Initialize Error\r\n");
+	return;
+	}
+		syslog(LOG_NOTICE, "Network Initialized successfully");
+	while (ethernet_connect(5000) != 0){
+		syslog(LOG_NOTICE, "LOG_NOTICE: Network Connect Error");
+	}
+	syslog(LOG_NOTICE,"MAC Address is %s\r\n", ethernet_getMACAddress());
+	syslog(LOG_NOTICE,"IP Address is %s\r\n", ethernet_getIPAddress());
+	syslog(LOG_NOTICE,"NetMask is %s\r\n", ethernet_getNetworkMask());
+	syslog(LOG_NOTICE,"Gateway Address is %s\r\n", ethernet_getGateway());
+	return;
+}
+#else
+static void network_init(void)
+{
+	lwip_init();
+	return;
+}
+#endif /* TARGET_ATHRILL */
+
+
+void mros_comm_init(void)
+{
+	network_init();
+	return;
+}
+mros_int32 mros_comm_accept(mros_int32 s, mRosSockAddrType *addr, mRosSizeType *addrlen)
+{
+	return lwip_accept(s, addr, (socklen_t*)addrlen);
+}
+mros_int32 mros_comm_bind(mros_int32 s, const mRosSockAddrType *name, mRosSizeType namelen)
+{
+	return lwip_bind(s, name, namelen);
+}
+mros_int32 mros_comm_shutdown(mros_int32 s, mros_int32 how)
+{
+	return lwip_shutdown(s, how);
+}
+mros_int32 mros_comm_getpeername (mros_int32 s, mRosSockAddrType *name, mRosSizeType *namelen)
+{
+	return lwip_getpeername(s, name, (socklen_t*)namelen);
+}
+mros_int32 mros_comm_getsockname (mros_int32 s, mRosSockAddrType *name, mRosSizeType *namelen)
+{
+	return lwip_getsockname(s, name, (socklen_t*)namelen);
+}
+mros_int32 mros_comm_getsockopt (mros_int32 s, mros_int32 level, mros_int32 optname, void *optval, mRosSizeType *optlen)
+{
+	return lwip_getsockopt(s, level, optname, optval, (socklen_t*)optlen);
+}
+mros_int32 mros_comm_setsockopt (mros_int32 s, mros_int32 level, mros_int32 optname, const void *optval, mRosSizeType optlen)
+{
+	return lwip_setsockopt(s, level, optname, optval, optlen);
+}
+mros_int32 mros_comm_close(mros_int32 s)
+{
+	return lwip_close(s);
+}
+mros_int32 mros_comm_connect(mros_int32 s, const mRosSockAddrType *name, mRosSizeType namelen)
+{
+	return lwip_connect(s, name, namelen);
+}
+mros_int32 mros_comm_listen(mros_int32 s, mros_int32 backlog)
+{
+	return lwip_listen(s, backlog);
+}
+mros_int32 mros_comm_recv(mros_int32 s, void *mem, mRosSizeType len, mros_int32 flags)
+{
+	return lwip_recv(s, mem, len, flags);
+}
+mros_int32 mros_comm_read(mros_int32 s, void *mem, mRosSizeType len)
+{
+	return lwip_read(s, mem, len);
+}
+mros_int32 mros_comm_recvfrom(mros_int32 s, void *mem, mRosSizeType len, mros_int32 flags, mRosSockAddrType *from, mRosSizeType *fromlen)
+{
+	return lwip_recvfrom(s, mem, len, flags, from, (socklen_t*)fromlen);
+}
+mros_int32 mros_comm_send(mros_int32 s, const void *dataptr, mRosSizeType size, mros_int32 flags)
+{
+	return lwip_send(s, dataptr, size, flags);
+}
+mros_int32 mros_comm_sendto(mros_int32 s, const void *dataptr, mRosSizeType size, mros_int32 flags, const mRosSockAddrType *to, mRosSizeType tolen)
+{
+	return lwip_sendto(s, dataptr, size, flags, to, tolen);
+}
+mros_int32 mros_comm_socket(mros_int32 domain, mros_int32 type, mros_int32 protocol)
+{
+	return lwip_socket(domain, type, protocol);
+}
+mros_int32 mros_comm_write(mros_int32 s, const void *dataptr, mRosSizeType size)
+{
+	return lwip_write(s, dataptr, size);
+}
+mros_int32 mros_comm_select(mros_int32 maxfdp1, mRosFdSetType *readset, mRosFdSetType *writeset, mRosFdSetType *exceptset, mRosTimeValType *timeout)
+{
+	return lwip_select(maxfdp1, readset, writeset, exceptset, timeout);
+}
+mros_int32 mros_comm_ioctl(mros_int32 s, mros_int32 cmd, void *argp)
+{
+	return lwip_ioctl(s, cmd, argp);
+}
+mros_int32 mros_comm_fcntl(mros_int32 s, mros_int32 cmd, int val)
+{
+	return lwip_fcntl(s, cmd, val);
+}
+mRosHostEntType *mros_comm_gethostbyname(const char *name)
+{
+	return lwip_gethostbyname(name);
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/comm/cimpl/target/lwip/mros_comm_target.h
@@ -0,0 +1,55 @@
+/* Copyright (C) 2012 mbed.org, MIT License
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ * and associated documentation files (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge, publish, distribute,
+ * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+ * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef _MROS_COMM_TARGET_H_
+#define _MROS_COMM_TARGET_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_types.h"
+#include "lwip/sockets.h"
+#include "lwip/init.h"
+#include "lwip/netdb.h"
+
+typedef struct sockaddr 	mRosSockAddrType;
+typedef struct sockaddr_in	mRosSockAddrInType;
+typedef struct hostent 		mRosHostEntType;
+typedef ip_addr_t 			mRosIpAaddrType;
+typedef fd_set				mRosFdSetType;
+typedef struct timeval		mRosTimeValType;
+
+#define MROS_FD_ZERO(arg)				FD_ZERO(arg)
+#define MROS_FD_SET(arg1, arg2)			FD_SET(arg1, arg2)
+#define MROS_FD_SETSIZE					FD_SETSIZE
+#define MROS_FD_ISSET(arg1, arg2)		FD_ISSET(arg1, arg2)
+
+#define MROS_SOCK_STREAM     SOCK_STREAM
+#define MROS_SOCK_DGRAM      SOCK_DGRAM
+#define MROS_SOCK_RAW        SOCK_RAW
+
+#define MROS_SOCK_UNSPEC	AF_UNSPEC
+#define MROS_SOCK_AF_INET	AF_INET
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* _MROS_COMM_TARGET_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/inc/mros_array_container.h
@@ -0,0 +1,36 @@
+#ifndef _MROS_ARRAY_CONTAINER_H_
+#define _MROS_ARRAY_CONTAINER_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_types.h"
+
+typedef struct {
+	mros_uint32 			count;
+	mros_uint32 			array_num;
+	mRosContainerObjType	*array;
+} mRosArrayContainerType;
+
+#define MROS_ARRAY_CONTAINER_CONFIG_DECLARE_MANAGER(manager_name, array_num)	\
+	static mRosContainerObjType manager_name##_array [(array_num)] MROS_MATTR_BSS_NOCLR;	\
+	static mRosArrayContainerType manager_name = {	\
+		(0),	\
+		(array_num),	\
+		manager_name##_array,	\
+	};
+
+static inline void mros_array_container_add(mRosArrayContainerType *mgrp, mRosContainerObjType obj)
+{
+	if (mgrp->count >= mgrp->array_num) {
+		return;
+	}
+	mgrp->array[mgrp->count] = obj;
+	mgrp->count++;
+}
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MROS_ARRAY_CONTAINER_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/inc/mros_exclusive_area.h
@@ -0,0 +1,20 @@
+#ifndef _MROS_EXCLUSIVE_AREA_H_
+#define _MROS_EXCLUSIVE_AREA_H_
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_exclusive_ops.h"
+#include "mros_wait_queue.h"
+
+extern mRosExclusiveObjectType mros_exclusive_area MROS_MATTR_BSS_NOCLR;
+extern mRosWaitQueueType mros_master_wait_queue MROS_MATTR_BSS_NOCLR;
+extern mRosWaitQueueType mros_subscribe_wait_queue MROS_MATTR_BSS_NOCLR;
+
+extern void mros_exclusive_area_init(mRosTaskIdType mas_task_id, mRosTaskIdType sub_task_id);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MROS_EXCLUSIVE_AREA_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/inc/mros_exclusive_ops.h
@@ -0,0 +1,32 @@
+#ifndef _MROS_EXCLUSIVE_OPS_H_
+#define _MROS_EXCLUSIVE_OPS_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_types.h"
+#include "mros_os.h"
+
+
+typedef struct {
+	/*
+	 * 排他エリアのプライオリティ
+	 * 排他エリア内では，タスクのプライオリティは本プライオリティに引き上げられる
+	 */
+	mRosTaskPriorityType	priority;
+} mRosExclusiveObjectType;
+
+typedef struct {
+	mRosTaskPriorityType	org_priority;
+} mROsExclusiveUnlockObjType;
+
+extern void mros_exclusive_init(mRosExclusiveObjectType *exobj, mRosTaskPriorityType priority);
+extern void mros_exclusive_lock(mRosExclusiveObjectType *exobj, mROsExclusiveUnlockObjType *unlock_obj);
+extern void mros_exclusive_unlock(mROsExclusiveUnlockObjType *unlock_objj);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MROS_EXCLUSIVE_OPS_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/inc/mros_list.h
@@ -0,0 +1,150 @@
+#ifndef _MROS_LIST_H_
+#define _MROS_LIST_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_types.h"
+
+/*
+ * PRIVATE
+ */
+#define ListEntry_Init(entry)	\
+do { \
+	(entry)->next = (entry);	\
+	(entry)->prev = (entry);	\
+} while (0)
+
+#define ListEntry_InsertHead(first, elm) \
+do { \
+	if ((first) != MROS_NULL) {	\
+		(elm)->next = (first);	\
+		(elm)->prev = (first)->prev;	\
+		(first)->prev->next = (elm); \
+		(first)->prev = (elm);	\
+	}	\
+	(first) = (elm);	\
+} while (0)
+
+#define List_IsEmpty(first)	((first)->next == (first))
+#define ListEntry_First(first)	(first)
+
+#define ListEntry_Remove(first, elm)	\
+do { \
+	if ((first) != MROS_NULL) { \
+		if ((first) == (elm)) { \
+			if (List_IsEmpty(first)) {	\
+				(first) = MROS_NULL;	\
+			}	\
+			else { \
+				(first) = (elm)->next; \
+			} \
+		} \
+		(elm)->next->prev = (elm)->prev;	\
+		(elm)->prev->next = (elm)->next;	\
+		ListEntry_Init(elm); \
+	} \
+} while (0)
+
+
+/*
+ * PUBLIC
+ */
+#define ListEntryType(name, dataTypeName)	\
+struct name {	\
+	struct name *next;	\
+	struct name *prev;	\
+	dataTypeName data;	\
+}
+
+#define ListHeadType(entry_type)	\
+struct {	\
+	mros_uint32 entry_size; \
+	mros_uint32 entry_num;	\
+	struct entry_type *entries;	\
+	struct entry_type *free;	\
+	mros_uint32 free_num;	\
+}
+
+#define List_Init(headp, entry_type, prealloc_size, memp)	\
+do {	\
+	mros_uint32 _i;\
+	(headp)->entry_size = sizeof(entry_type);	\
+	(headp)->entry_num = 0;	\
+	(headp)->entries = MROS_NULL;	\
+	(headp)->free = MROS_NULL;	\
+	(headp)->free_num = (prealloc_size);	\
+	for (_i = 0; _i < (prealloc_size); _i++) { \
+		entry_type *_tmp = &(((entry_type*)(memp))[_i]); \
+		ListEntry_Init(_tmp);	\
+		ListEntry_InsertHead((headp)->free, _tmp);	\
+	} \
+} while (0)
+
+#define List_InitEmpty(headp, entry_type)	\
+do { 	\
+	List_Init(headp, entry_type, 0, MROS_NULL);	\
+} while (0)
+
+#define ListEntry_Alloc(headp, entry_type, new_entrypp) \
+do { \
+	entry_type *_tmp;	\
+	if ((headp)->free_num > 0) {	\
+		_tmp = ListEntry_First((headp)->free);	\
+		ListEntry_Remove((headp)->free, _tmp); \
+		(headp)->free_num--;	\
+		*(new_entrypp) = _tmp;	\
+	} \
+	else { \
+		*(new_entrypp) = MROS_NULL;	\
+	} \
+} while (0)
+
+#define ListEntry_Free(headp, entryp) \
+do { \
+	ListEntry_Init(entryp);	\
+	ListEntry_InsertHead((headp)->free, entryp);	\
+	(headp)->free_num++;	\
+} while (0)
+
+
+#define ListEntry_AddEntry(headp, entryp)	\
+do { \
+	ListEntry_Init(entryp);	\
+	ListEntry_InsertHead((headp)->entries, entryp);	\
+	(headp)->entry_num++;	\
+} while (0)
+
+#define ListEntry_RemoveEntry(headp, entryp)	\
+do { \
+	ListEntry_Remove((headp)->entries, entryp); \
+	(headp)->entry_num--;	\
+} while (0)
+
+#define ListEntry_GetFirst(headp, entrypp)	\
+do { \
+	*(entrypp) = (headp)->entries;	\
+} while (0)
+
+
+#define ListEntry_RemoveAll(headp, entry_type) \
+do { \
+	while ((headp)->entry_num > 0) {	\
+		entry_type _tmp = ListEntry_First((headp)->entries);	\
+		ListEntry_RemoveEntry(headp, _tmp);	\
+	}	\
+} while (0)
+
+#define ListEntry_Foreach(headp, var)	\
+	mros_uint32 _i;	\
+	(var) = (headp)->entries;	\
+	for (_i = 0; \
+		_i < (headp)->entry_num; \
+		(var) = (var)->next, _i++)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MROS_LIST_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/inc/mros_memory.h
@@ -0,0 +1,114 @@
+#ifndef _MROS_MEMORY_H_
+#define _MROS_MEMORY_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_types.h"
+#include "mros_list.h"
+
+typedef mros_uint32 mRosMemorySizeIdType;
+
+struct mRosMemoryManagerType;
+typedef struct {
+	/*
+	 * manager
+	 */
+	struct mRosMemoryManagerType  *mgrp;
+	/*
+	 * id of memory_entries
+	 */
+	mRosIdType				memory_id;
+	/*
+	 * id of parent header
+	 */
+	mRosMemorySizeIdType	header_id;
+	/*
+	 * preallocation unit size
+	 */
+	mRosSizeType			memsize;
+	/*
+	 * real using size
+	 */
+	mRosSizeType			size;
+	char 					*memp;
+} mRosMemoryEntryType;
+
+typedef ListEntryType(mRosMemoryListEntryType, mRosMemoryEntryType) mRosMemoryListEntryType;
+typedef ListHeadType(mRosMemoryListEntryType) mRosMemoryListHeadType;
+
+typedef struct {
+	/*
+	 * memory list header
+	 */
+	mRosMemoryListHeadType 	head;
+	/*
+	 * num of preallocation memory
+	 */
+	mRosSizeType 			max_memory_num;
+	/*
+	 * preallocation unit size
+	 */
+	mRosSizeType			memsize;
+	/*
+	 * memory list entry
+	 */
+	mRosMemoryListEntryType *memory_entries;
+	/*
+	 * raw data
+	 */
+	char					*memory;
+} mRosMemoryHeaderType;
+
+typedef struct mRosMemoryManagerType {
+	/*
+	 * num of header
+	 */
+	mRosSizeType 			header_num;
+	/*
+	 * header array
+	 */
+	mRosMemoryHeaderType 	*header_array;
+} mRosMemoryManagerType;
+
+/*
+ * config memory
+ */
+typedef struct {
+	mRosSizeType 			max_memory_num;
+	mRosSizeType			memsize;
+	mRosMemoryListEntryType *memory_entries;
+	char					*memory;
+} mRosMemoryConfigType;
+
+extern mRosReturnType mros_mem_init(mRosSizeType config_num, mRosMemoryConfigType **config, mRosMemoryManagerType *mgrp);
+extern mRosReturnType mros_mem_alloc(mRosMemoryManagerType *mgrp, mRosSizeType size, mRosMemoryListEntryType **memory);
+extern mRosReturnType mros_mem_free(mRosMemoryManagerType *mgrp, mRosMemoryListEntryType *memory);
+
+/*
+ * Memory Config APIs
+ */
+#define MROS_MEMORY_CONFIG_DECLARE_ENTRY(entry_name, max_memory_num, memsize)	\
+	static mRosMemoryListEntryType entry_name##_entries [(max_memory_num)] MROS_MATTR_BSS_NOCLR;	\
+	static char entry_name##_memory [(max_memory_num) * (memsize)] MROS_MATTR_BSS_NOCLR;	\
+	static mRosMemoryConfigType entry_name##_config = {	\
+			(max_memory_num), \
+			(memsize), \
+			entry_name##_entries ,	\
+			entry_name##_memory ,	\
+	};
+
+#define MROS_MEMORY_CONFIG_DECLARE_MANAGER(mem_manager_name, config_num)	\
+	static mRosMemoryHeaderType mem_manager_name##_head_array [(config_num)] MROS_MATTR_BSS_NOCLR;	\
+	mRosMemoryManagerType mem_manager_name = {	\
+		(config_num),	\
+		mem_manager_name##_head_array,	\
+	};
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MROS_MEMORY_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/inc/mros_name.h
@@ -0,0 +1,17 @@
+#ifndef _MROS_NAME_H_
+#define _MROS_NAME_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_types.h"
+
+extern void mros_name_formalize(const char *src_name, mros_uint32 src_namelen, char *dst_name, mros_uint32 *dst_namelen);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MROS_NAME_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/inc/mros_os.h
@@ -0,0 +1,22 @@
+#ifndef _MROS_OS_H_
+#define _MROS_OS_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_types.h"
+
+extern mRosTaskIdType mros_get_taskid(void);
+extern mRosTaskPriorityType mros_get_taskpri(void);
+extern void mros_change_taskpri(mRosTaskPriorityType priority);
+extern void mros_sleep_task(void);
+extern void mros_sleep_task_msec(mRosTaskSleepIntervalType msec);
+extern void mros_wakeup_task(mRosTaskIdType task_id);
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* _MROS_OS_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/inc/mros_types.h
@@ -0,0 +1,69 @@
+#ifndef _MROS_TYPES_H_
+#define _MROS_TYPES_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef int mros_int32;
+typedef char mros_int8;
+typedef unsigned char mros_uint8;
+typedef unsigned short mros_uint16;
+typedef unsigned int mros_uint32;
+typedef unsigned char mros_boolean;
+#define MROS_FALSE		0
+#define MROS_TRUE		1
+
+#define MROS_ID_NONE	0
+#define MROS_ID(index)		((index) + 1U)
+#define MROS_INDEX(id)		((id) - 1U)
+
+typedef mros_uint32 mRosNodeIdType;
+typedef mros_uint32 mRosTopicIdType;
+typedef mros_uint32 mRosTopicConnectorIdType;
+typedef mros_uint32 mRosPacketIdType;
+typedef mros_uint32 mRosIdType;
+typedef mros_uint32* mRosFuncIdType;
+typedef mros_int8* mRosPtrType;
+
+
+typedef mros_uint32* mRosContainerObjType;
+#define MROS_NULL (0)
+#define MROS_COBJ_NULL	((mRosContainerObjType)MROS_NULL)
+
+typedef mros_uint32 mRosSizeType;
+
+#define MROS_E_OK			0
+#define MROS_E_NOENT		2
+#define MROS_E_NOMEM		12
+#define MROS_E_BUSY			13
+#define MROS_E_EXIST		17
+#define MROS_E_INVAL		22
+#define MROS_E_RANGE		34
+#define MROS_E_LIMIT		111
+#define MROS_E_NOTCONN		112
+#define MROS_E_SYSERR		-1
+typedef mros_int32 mRosReturnType;
+
+/*
+ * Os dependent data types
+ */
+#include "mros_os_target.h"
+#define MROS_TASKID_NONE	0U
+
+#ifdef OS_MAC
+#define MROS_MATTR_BSS_NOCLR
+#else
+#define MROS_MATTR_BSS_NOCLR __attribute__((section("NC_BSS")))
+#endif
+
+/*
+ * Comm dependent data types
+ */
+#include "mros_comm_target.h"
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MROS_TYPES_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/inc/mros_wait_queue.h
@@ -0,0 +1,36 @@
+#ifndef _MROS_WAIT_QUEUE_H_
+#define _MROS_WAIT_QUEUE_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_list.h"
+
+typedef struct {
+	mRosTaskIdType 			task_id;
+	mRosTaskPriorityType 	task_priority;
+	void 					*reqp;
+} mRosWaitEntryType;
+typedef ListEntryType(mRosWaitListEntryType, mRosWaitEntryType) mRosWaitListEntryType;
+typedef ListHeadType(mRosWaitListEntryType) mRosWaitListHeadType;
+
+typedef struct {
+	mRosTaskIdType 			task_id;
+	mRosWaitListHeadType	head;
+} mRosWaitQueueType;
+
+extern void mros_client_wait_entry_init(mRosWaitListEntryType *wait_entry, void *reqp);
+extern void mros_server_queue_init(mRosWaitQueueType *wait_queue, mRosTaskIdType task_id);
+
+extern void mros_client_wakeup(mRosWaitListEntryType *wait_entry);
+extern void mros_client_put_request(mRosWaitQueueType *wait_queue, mRosWaitListEntryType *wait_entry);
+extern void mros_client_wait_for_request_done(mRosWaitQueueType *wait_queue, mRosWaitListEntryType *wait_entry);
+extern mRosWaitListEntryType *mros_server_queue_wait(mRosWaitQueueType *wait_queue);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MROS_WAIT_QUEUE_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/lib/mros_memory.c
@@ -0,0 +1,46 @@
+#include "mros_memory.h"
+#define ASSERT(expr)	\
+do {	\
+	if (!(expr))	{	\
+		printf("ASSERTION FAILED:%s:%s:%d:%s\n", __FILE__, __FUNCTION__, __LINE__, #expr);	\
+		exit(1);	\
+	}	\
+} while (0)
+
+
+#define MEMORY_ID(index)		((index) + 1U)
+#define MEMORY_INDEX(id)		((id) - 1U)
+
+#define MEMORY_OBJ(mid, id)		memory_manager[(mid)].memory_entries[MEMORY_INDEX((id))]
+
+mRosReturnType mros_mem_init(mRosSizeType config_num, mRosMemoryConfigType **config, mRosMemoryManagerType *mgrp)
+{
+	return MROS_E_OK;
+}
+
+mRosReturnType mros_mem_alloc(mRosMemoryManagerType *mgrp, mRosSizeType size, mRosMemoryListEntryType **memory)
+{
+	mRosMemoryListEntryType *mp;
+	char *ptr;
+	mp = malloc(sizeof(mRosMemoryListEntryType));
+	ASSERT(mp != MROS_NULL);
+	ptr = malloc(size);
+	ASSERT(ptr != MROS_NULL);
+	mp->data.memp = ptr;
+	mp->data.memsize = size;
+	mp->data.size = size;
+	*memory = mp;
+	return MROS_E_OK;
+}
+
+mRosReturnType mros_mem_free(mRosMemoryManagerType *mgrp, mRosMemoryListEntryType *memory)
+{
+	if (memory != NULL) {
+		if (memory->data.memp != MROS_NULL) {
+			free(memory->data.memp);
+		}
+		free(memory);
+	}
+	return MROS_E_OK;
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/lib/mros_name.c
@@ -0,0 +1,26 @@
+#include "mros_name.h"
+#include <string.h>
+
+void mros_name_formalize(const char *src_name, mros_uint32 src_namelen, char *dst_name, mros_uint32 *dst_namelen)
+{
+	mros_uint32 i;
+	mros_uint32 slash_count = 0;
+	const char* src_copy_head = MROS_NULL;
+	mros_uint32 src_copy_len;
+
+	for (i = 0; i < src_namelen; i++) {
+		if (src_name[i] != '/') {
+			src_copy_head = &src_name[i];
+			break;
+		}
+		else {
+			slash_count++;
+		}
+	}
+	src_copy_len = src_namelen - slash_count;
+	dst_name[0] = '/';
+	memcpy(&dst_name[1], src_copy_head, src_copy_len);
+	dst_name[src_copy_len + 1] = '\0';
+	*dst_namelen = src_copy_len + 1;
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/lib/mros_wait_queue.c
@@ -0,0 +1,64 @@
+#include "mros_wait_queue.h"
+#include "mros_os.h"
+
+void mros_client_wait_entry_init(mRosWaitListEntryType *wait_entry, void *reqp)
+{
+	wait_entry->data.reqp = reqp;
+	wait_entry->data.task_id = mros_get_taskid();
+	wait_entry->data.task_priority = mros_get_taskpri();
+	return;
+}
+
+void mros_server_queue_init(mRosWaitQueueType *wait_queue, mRosTaskIdType task_id)
+{
+	wait_queue->task_id = task_id;
+	List_InitEmpty(&wait_queue->head, mRosWaitListEntryType);
+
+	return;
+}
+
+void mros_client_wakeup(mRosWaitListEntryType *wait_entry)
+{
+	mros_wakeup_task(wait_entry->data.task_id);
+	return;
+}
+
+
+void mros_client_put_request(mRosWaitQueueType *wait_queue, mRosWaitListEntryType *wait_entry)
+{
+	ListEntry_AddEntry(&wait_queue->head, wait_entry);
+	mros_wakeup_task(wait_queue->task_id);
+	return;
+}
+
+void mros_client_wait_for_request_done(mRosWaitQueueType *wait_queue, mRosWaitListEntryType *wait_entry)
+{
+	mros_client_put_request(wait_queue, wait_entry);
+	mros_sleep_task();
+	return;
+}
+static mRosWaitListEntryType *mros_server_queue_get(mRosWaitQueueType *wait_queue)
+{
+	mRosTaskPriorityType min_priority = MROS_TASK_MIN_PRIORITY;
+	mRosWaitListEntryType *entry;
+	mRosWaitListEntryType *target = MROS_NULL;
+
+	ListEntry_Foreach(&wait_queue->head, entry) {
+		if (entry->data.task_priority < min_priority) {
+			min_priority = entry->data.task_priority;
+			target = entry;
+		}
+	}
+	if (target != MROS_NULL) {
+		ListEntry_RemoveEntry(&wait_queue->head, target);
+	}
+	return target;
+}
+
+mRosWaitListEntryType *mros_server_queue_wait(mRosWaitQueueType *wait_queue)
+{
+	if (wait_queue->head.entry_num == 0) {
+		mros_sleep_task();
+	}
+	return mros_server_queue_get(wait_queue);
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/node/cimpl/mros_node_cimpl.c
@@ -0,0 +1,210 @@
+#include "mros_node_cimpl.h"
+#include "mros_usr_config.h"
+#include "mros_name.h"
+#include <string.h>
+
+typedef struct {
+	mRosNodeIdType				node_id;
+	mRosTaskIdType				task_id;
+	char						node_name[MROS_NODE_NAME_MAXLEN];
+	mros_uint32					namelen;
+} mRosNodeEntryType;
+
+#define MROS_TOPIC_NODE_ENTRY_INIT(entryp)	\
+do {	\
+	(entryp)->data.node_id = MROS_ID_NONE;	\
+	(entryp)->data.namelen = 0;	\
+} while (0)
+
+typedef ListEntryType(mRosNodeListEntryType, mRosNodeEntryType) mRosNodeListEntryType;
+typedef ListHeadType(mRosNodeListEntryType) mRosNodeEntryHeadType;
+
+typedef struct {
+	mRosNodeEntryHeadType	 	head;
+	mRosNodeListEntryType 		*node_entries;
+	mRosSizeType				max_node;
+} mRosNodeManagerType;
+
+/*
+ * Topic Node Config APIs
+ */
+#define MROS_TOPIC_NODE_CONFIG_DECLARE_MANAGER(tnode_instance_name, max_node)	\
+	static mRosNodeListEntryType tnode_instance_name##_array [(node_num)];	\
+	static mRosNodeManagerType tnode_instance_name##_mgr;	\
+	static mRosNodeConfigType  tnode_instance_name##_config = {	\
+		(max_node),	\
+		tnode_config_name##_array,	\
+	};
+
+
+static mRosNodeManagerType node_manager[MROS_NODE_TYPE_NUM] MROS_MATTR_BSS_NOCLR;
+#define NODE_OBJ(type, id)		( \
+									( type == MROS_NODE_TYPE_INNER) ? \
+											&node_manager[(type)].node_entries[MROS_INDEX((id))] :	\
+											&node_manager[(type)].node_entries[MROS_INDEX((id - node_manager[MROS_NODE_TYPE_INNER].max_node))] \
+								)
+
+#define NODE_TYPE(id)	( (id <= node_manager[MROS_NODE_TYPE_INNER].max_node) ? MROS_NODE_TYPE_INNER : MROS_NODE_TYPE_OUTER )
+
+static mRosNodeListEntryType node_entries[MROS_NODE_TYPE_NUM][MROS_NODE_MAX_NUM] MROS_MATTR_BSS_NOCLR;
+static char node_name_buffer[MROS_NODE_NAME_MAXLEN + 1] MROS_MATTR_BSS_NOCLR;
+
+#define NODE_MAX_ID(type)	( \
+	(type == MROS_NODE_TYPE_INNER) ? \
+			node_manager[MROS_NODE_TYPE_INNER].max_node :  \
+			(node_manager[MROS_NODE_TYPE_INNER].max_node + node_manager[MROS_NODE_TYPE_OUTER].max_node) \
+	)
+
+mRosReturnType mros_node_init(void)
+{
+	mros_uint32 i;
+	mros_uint32 j;
+	for (i = 0; i < MROS_NODE_TYPE_NUM; i++) {
+		node_manager[i].node_entries = node_entries[i];
+		for (j = 0; j < MROS_NODE_MAX_NUM; j++) {
+			mRosNodeListEntryType *entry = &(node_manager[i].node_entries[j]);
+			MROS_TOPIC_NODE_ENTRY_INIT(entry);
+			entry->data.node_id = MROS_ID(j) + (((mRosNodeIdType)i) * MROS_NODE_MAX_NUM);
+		}
+		List_Init(&node_manager[i].head, mRosNodeListEntryType, MROS_NODE_MAX_NUM, node_manager[i].node_entries);
+		node_manager[i].max_node = MROS_NODE_MAX_NUM;
+	}
+	return MROS_E_OK;
+}
+
+static mRosReturnType mros_node_get_node(const char *node_name, mros_uint32 len, mRosNodeEnumType type, mRosNodeIdType *id)
+{
+	mRosNodeListEntryType *p;
+	*id = MROS_ID_NONE;
+	ListEntry_Foreach(&node_manager[type].head, p) {
+		if (len != p->data.namelen) {
+			continue;
+		}
+		if (!strcmp(p->data.node_name, node_name)) {
+			*id = p->data.node_id;
+			break;
+		}
+	}
+	if (*id == MROS_ID_NONE) {
+		return MROS_E_NOENT;
+	}
+	return MROS_E_OK;
+}
+
+mRosReturnType mros_node_get_byname(const char *node_name, mRosNodeIdType *id)
+{
+	mros_uint32 len = strlen(node_name);
+
+	mRosReturnType ret = mros_node_get_node(node_name, len, MROS_NODE_TYPE_INNER, id);
+	if (ret != MROS_E_OK) {
+		ret = mros_node_get_node(node_name, len, MROS_NODE_TYPE_OUTER, id);
+	}
+
+	return ret;
+}
+
+mRosReturnType mros_node_get_bytid(mRosNodeIdType *id)
+{
+	mRosTaskIdType task_id;
+	task_id = mros_get_taskid();
+	mRosNodeListEntryType *p;
+
+	*id = MROS_ID_NONE;
+	ListEntry_Foreach(&node_manager[MROS_NODE_TYPE_INNER].head, p) {
+		if (task_id == p->data.task_id) {
+			*id = p->data.node_id;
+			break;
+		}
+	}
+	if (*id == MROS_ID_NONE) {
+		return MROS_E_NOENT;
+	}
+	return MROS_E_OK;
+}
+
+mRosNodeEnumType mros_node_type(mRosNodeIdType id)
+{
+	mRosNodeEnumType type = NODE_TYPE(id);
+	if (id > NODE_MAX_ID(type)) {
+		return MROS_NODE_TYPE_NUM;
+	}
+	return type;
+}
+const char* mros_node_name(mRosNodeIdType id)
+{
+	mRosNodeEnumType type = NODE_TYPE(id);
+	if (type != MROS_NODE_TYPE_INNER) {
+		return MROS_NULL;
+	}
+	return NODE_OBJ(type, id)->data.node_name;
+}
+static mRosReturnType mros_node_create(const char *node_name, mRosTaskIdType task_id, mRosNodeEnumType type, mRosNodeIdType *id)
+{
+	mRosNodeListEntryType *p;
+	mros_uint32 len = 0;
+	mRosReturnType ret;
+
+	if (type >= MROS_NODE_TYPE_NUM) {
+		return MROS_E_RANGE;
+	}
+
+	if (node_name != MROS_NULL) {
+		len = strlen(node_name);
+		if (len >= (MROS_NODE_NAME_MAXLEN + 1)) { /* for add slash on top */
+			ROS_ERROR("%s %u ret=%d", __FUNCTION__, __LINE__, MROS_E_NOMEM);
+			return MROS_E_NOMEM;
+		}
+		mros_name_formalize(node_name, len, node_name_buffer, &len);
+
+		ret = mros_node_get_byname(node_name_buffer, id);
+		if (ret == MROS_E_OK) {
+			return MROS_E_OK;
+		}
+	}
+	else {
+		/* outer node */
+	}
+
+	ListEntry_Alloc(&node_manager[type].head, mRosNodeListEntryType, &p);
+	if (p == MROS_NULL) {
+		ROS_ERROR("%s %u ret=%d", __FUNCTION__, __LINE__, MROS_E_NOMEM);
+		return MROS_E_NOMEM;
+	}
+	*id = p->data.node_id;
+	p->data.task_id = task_id;
+	if (node_name != MROS_NULL) {
+		p->data.namelen = len;
+		memcpy(p->data.node_name, node_name_buffer, len);
+	}
+	else {
+		p->data.namelen = 0;
+	}
+	ListEntry_AddEntry(&node_manager[type].head, p);
+	return MROS_E_OK;
+}
+
+mRosReturnType mros_node_create_inner(const char *node_name, mRosNodeIdType *id)
+{
+	mRosTaskIdType task_id;
+	task_id = mros_get_taskid();
+	return mros_node_create(node_name, task_id, MROS_NODE_TYPE_INNER, id);
+}
+
+mRosReturnType mros_node_create_outer(mRosNodeIdType *id)
+{
+	return mros_node_create(MROS_NULL, MROS_TASKID_NONE, MROS_NODE_TYPE_OUTER, id);
+}
+
+mRosReturnType mros_node_remove(mRosNodeIdType id)
+{
+	mRosNodeListEntryType *nodep;
+	mRosNodeEnumType type = NODE_TYPE(id);
+	if (id > NODE_MAX_ID(type)) {
+		ROS_ERROR("%s %u ret=%d", __FUNCTION__, __LINE__, MROS_E_RANGE);
+		return MROS_E_RANGE;
+	}
+	nodep = NODE_OBJ(type, id);
+	ListEntry_RemoveEntry(&node_manager[type].head, nodep);
+	ListEntry_Free(&node_manager[type].head, nodep);
+	return MROS_E_OK;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/node/cimpl/mros_node_cimpl.h
@@ -0,0 +1,31 @@
+#ifndef _MROS_NODE_CIMPL_H_
+#define _MROS_NODE_CIMPL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_types.h"
+
+typedef enum {
+	MROS_NODE_TYPE_INNER = 0,
+	MROS_NODE_TYPE_OUTER,
+	MROS_NODE_TYPE_NUM,
+} mRosNodeEnumType;
+
+
+extern mRosReturnType mros_node_init(void);
+extern mRosReturnType mros_node_get_byname(const char *node_name, mRosNodeIdType *id);
+extern mRosReturnType mros_node_get_bytid(mRosNodeIdType *id);
+extern mRosNodeEnumType mros_node_type(mRosNodeIdType id);
+extern const char* mros_node_name(mRosNodeIdType id);
+
+extern mRosReturnType mros_node_create_inner(const char *node_name, mRosNodeIdType *id);
+extern mRosReturnType mros_node_create_outer(mRosNodeIdType *id);
+
+extern mRosReturnType mros_node_remove(mRosNodeIdType id);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _MROS_NODE_CIMPL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/os/mros_exclusive_area.c
@@ -0,0 +1,17 @@
+#include "mros_exclusive_area.h"
+#include "mros_wait_queue.h"
+#include "mros_sys_config.h"
+
+mRosExclusiveObjectType mros_exclusive_area MROS_MATTR_BSS_NOCLR;
+mRosWaitQueueType mros_master_wait_queue MROS_MATTR_BSS_NOCLR;
+
+mRosWaitQueueType mros_subscribe_wait_queue MROS_MATTR_BSS_NOCLR;
+
+void mros_exclusive_area_init(mRosTaskIdType mas_task_id, mRosTaskIdType sub_task_id)
+{
+	mros_exclusive_init(&mros_exclusive_area, MROS_GIANT_EXCLUSIVE_AREA_PRIORITY);
+	mros_server_queue_init(&mros_master_wait_queue, mas_task_id);
+	mros_server_queue_init(&mros_subscribe_wait_queue, sub_task_id);
+
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/os/mros_exclusive_ops.c
@@ -0,0 +1,21 @@
+#include "mros_os.h"
+#include "mros_exclusive_ops.h"
+
+void mros_exclusive_init(mRosExclusiveObjectType *exobj, mRosTaskPriorityType priority)
+{
+	exobj->priority = priority;
+	return;
+}
+
+void mros_exclusive_lock(mRosExclusiveObjectType *exobj, mROsExclusiveUnlockObjType *unlock_obj)
+{
+	unlock_obj->org_priority = mros_get_taskpri();
+	mros_change_taskpri(exobj->priority);
+	return;
+}
+
+void mros_exclusive_unlock(mROsExclusiveUnlockObjType *unlock_obj)
+{
+	mros_change_taskpri(unlock_obj->org_priority);
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/os/target/os_asp/mros_log.h
@@ -0,0 +1,14 @@
+#ifndef _MROS_LOG_H_
+#define _MROS_LOG_H_
+
+#include <kernel.h>
+#include <t_syslog.h>
+
+#define ROS_DEBUG(...) 		syslog(LOG_DEBUG, __VA_ARGS__)
+#define ROS_INFO(...) 		syslog(LOG_NOTICE, __VA_ARGS__)
+#define ROS_WARN(...) 		syslog(LOG_WARNING, __VA_ARGS__)
+#define ROS_ERROR(...) 		syslog(LOG_ERROR, __VA_ARGS__)
+#define ROS_FATAL(...) 		syslog(LOG_EMERG, __VA_ARGS__)
+
+
+#endif /* _MROS_LOG_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/os/target/os_asp/mros_os.c
@@ -0,0 +1,44 @@
+#include "mros_os_target.h"
+
+mRosTaskIdType mros_get_taskid(void)
+{
+	mRosTaskIdType tid;
+	(void)get_tid(&tid);
+	return tid;
+}
+
+mRosTaskPriorityType mros_get_taskpri(void)
+{
+	mRosTaskIdType tid;
+	PRI pri;
+	(void)get_tid(&tid);
+	(void)get_pri(tid, &pri);
+	return pri;
+}
+
+void mros_change_taskpri(mRosTaskPriorityType priority)
+{
+	mRosTaskIdType tid;
+	(void)get_tid(&tid);
+	 chg_pri(tid, priority);
+	 return;
+}
+
+void mros_sleep_task(void)
+{
+	(void)slp_tsk();
+	return;
+}
+
+void mros_sleep_task_msec(mRosTaskSleepIntervalType msec)
+{
+	(void)dly_tsk(msec);
+	return;
+}
+
+void mros_wakeup_task(mRosTaskIdType task_id)
+{
+	(void)wup_tsk(task_id);
+	return;
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/os/target/os_asp/mros_os_target.h
@@ -0,0 +1,37 @@
+#ifndef _MROS_OS_TARGET_H_
+#define _MROS_OS_TARGET_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <kernel.h>
+#include <t_syslog.h>
+
+#include "mros_types.h"
+
+typedef ID	mRosTaskIdType;
+typedef PRI	mRosTaskPriorityType;
+typedef mros_uint32 mRosTaskSleepIntervalType;
+
+#define MROS_TASK_MAX_PRIORITY 	TMIN_TPRI
+#define MROS_TASK_MIN_PRIORITY 	TMAX_TPRI
+
+#define MROS_LOG_EMRG		LOG_EMERG
+#define MROS_LOG_ALERT		LOG_ALERT
+#define MROS_LOG_CRIT		LOG_CRIT
+#define MROS_LOG_ERROR		LOG_ERROR
+#define MROS_LOG_WARNING	LOG_WARNING
+#define MROS_LOG_NOTICE		LOG_NOTICE
+#define MROS_LOG_INFO		LOG_INFO
+#define MROS_LOG_DEBUG		LOG_DEBUG
+
+#include "mros_log.h"
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* _MROS_OS_TARGET_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/os/target/os_asp/mros_test.c
@@ -0,0 +1,274 @@
+#include "mros_protocol_client_rpc_cimpl.h"
+#include "mros_comm_tcp_server_cimpl.h"
+
+/*****************************************
+ * TASK CYCLE
+ *****************************************/
+#define MROS_SLAVE_TIMEOUT			100
+
+void do_test_server(void)
+{
+	mRosCommTcpServerType server;
+	mRosCommTcpClientType client;
+	mRosReturnType ret = mros_comm_tcp_server_init(&server);
+	if (ret != MROS_E_OK) {
+		syslog(LOG_NOTICE, "mros_comm_tcp_server_init()=%d", ret);
+		return;
+	}
+	(void)mros_comm_socket_set_blocking(&server.socket, MROS_FALSE, MROS_SLAVE_TIMEOUT);
+	ret =  mros_comm_tcp_server_bind(&server, mros_slave_port_no);
+	if (ret != MROS_E_OK) {
+		syslog(LOG_NOTICE, "mros_comm_tcp_server_bind()=%d", ret);
+		return;
+	}
+	ret = mros_comm_tcp_server_listen(&server, MROS_COMM_TCP_SERVER_LISTEN_MAX_DEFAULT_VALUE);
+	if (ret != MROS_E_OK) {
+		syslog(LOG_NOTICE, "mros_comm_tcp_server_bind()=%d", ret);
+		return;
+	}
+	while (MROS_TRUE) {
+		ret = mros_comm_tcp_server_accept(&server, &client);
+		if (ret != MROS_E_OK) {
+			syslog(LOG_NOTICE, "mros_comm_tcp_server_accept()=%d", ret);
+			continue;
+		}
+		syslog(LOG_NOTICE, "connected: ip=0x%x port=%u", client.remote.sin_addr, client.remote.sin_port);
+
+		mros_comm_tcp_client_close(&client);
+	}
+}
+
+void do_test_register_publisher(void)
+{
+	mRosPacketType packet;
+	mRosReturnType ret;
+	static char buffer[1024];
+	mRosCommTcpClientType client;
+	syslog(LOG_NOTICE, "START: TEST REGISTER PUBLISHER");
+
+	ret = mros_comm_tcp_client_init(&client, MROS_MASTER_IPADDR, MROS_MASTER_PORT_NO);
+	if (ret != MROS_E_OK) {
+		syslog(LOG_NOTICE, "mros_comm_tcp_client_init()=%d", ret);
+		return;
+	}
+	packet.data = buffer;
+	packet.total_size = sizeof(buffer);
+	packet.data_size = 0;
+
+	ret = mros_comm_tcp_client_connect(&client);
+	if (ret != MROS_E_OK) {
+		syslog(LOG_NOTICE, "mros_comm_tcp_client_connect()=%d", ret);
+		return;
+	}
+	mRosRegisterTopicReqType req;
+	mRosRegisterTopicResType res;
+	req.node_name = "node1";
+	req.req_packet = &packet;
+	req.topic_name = "/test_string";
+	req.topic_typename = "std_msgs/String";
+	res.reply_packet = &packet;
+
+	ret = mros_rpc_register_publisher(&client, &req, &res);
+	if (ret != MROS_E_OK) {
+		syslog(LOG_NOTICE, "mros_rpc_register_publisher()=%d", ret);
+		return;
+	}
+	mros_comm_tcp_client_close(&client);
+	syslog(LOG_NOTICE, "data_size=%d", packet.data_size);
+	syslog(LOG_NOTICE, "packet=%s", packet.data);
+	syslog(LOG_NOTICE, "END: TEST REGISTER PUBLISHER");
+
+	return;
+}
+
+void do_test_register_subscriber(void)
+{
+	mRosPacketType packet;
+	mRosReturnType ret;
+	static char buffer[1024];
+	mRosCommTcpClientType client;
+
+	syslog(LOG_NOTICE, "START: TEST REGISTER SUBSCRIBER");
+
+
+	ret = mros_comm_tcp_client_init(&client, MROS_MASTER_IPADDR, MROS_MASTER_PORT_NO);
+	if (ret != MROS_E_OK) {
+		syslog(LOG_NOTICE, "mros_comm_tcp_client_init()=%d", ret);
+		return;
+	}
+	packet.data = buffer;
+	packet.total_size = sizeof(buffer);
+	packet.data_size = 0;
+
+	ret = mros_comm_tcp_client_connect(&client);
+	if (ret != MROS_E_OK) {
+		syslog(LOG_NOTICE, "mros_comm_tcp_client_connect()=%d", ret);
+		return;
+	}
+	mRosRegisterTopicReqType req;
+	mRosRegisterTopicResType res;
+	req.node_name = "node1";
+	req.req_packet = &packet;
+	req.topic_name = "/test_string";
+	req.topic_typename = "std_msgs/String";
+	res.reply_packet = &packet;
+
+	ret = mros_rpc_register_subscriber(&client, &req, &res);
+	if (ret != MROS_E_OK) {
+		syslog(LOG_NOTICE, "mros_rpc_register_publisher()=%d", ret);
+		return;
+	}
+	syslog(LOG_NOTICE, "data_size=%d", packet.data_size);
+	syslog(LOG_NOTICE, "packet=%s", packet.data);
+
+	mros_uint32 ipaddr = -1;
+	mros_int32 port = -1;
+	mRosPtrType ptr = mros_xmlpacket_subres_get_first_uri(res.reply_packet, &ipaddr, &port);
+	syslog(LOG_NOTICE, "ptr=0x%x ipaddr=0x%x port=%d", ptr, ipaddr, port);
+
+	syslog(LOG_NOTICE, "END: TEST REGISTER SUBSCRIBER");
+
+	return;
+}
+
+static mros_uint32 test_request_topic_ipaddr;
+static mros_int32 test_request_topic_port;
+
+void do_test_request_topic(void)
+{
+	mRosPacketType packet;
+	mRosReturnType ret;
+	static char buffer[1024];
+	mRosCommTcpClientType client;
+
+	syslog(LOG_NOTICE, "START: TEST REQUEST TOPIC");
+
+
+	ret = mros_comm_tcp_client_init(&client, MROS_MASTER_IPADDR, MROS_MASTER_PORT_NO);
+	if (ret != MROS_E_OK) {
+		syslog(LOG_NOTICE, "mros_comm_tcp_client_init()=%d", ret);
+		return;
+	}
+	packet.data = buffer;
+	packet.total_size = sizeof(buffer);
+	packet.data_size = 0;
+
+	ret = mros_comm_tcp_client_connect(&client);
+	if (ret != MROS_E_OK) {
+		syslog(LOG_NOTICE, "mros_comm_tcp_client_connect()=%d", ret);
+		return;
+	}
+	mRosRegisterTopicReqType req;
+	mRosRegisterTopicResType res;
+	req.node_name = "node1";
+	req.req_packet = &packet;
+	req.topic_name = "/test_string";
+	req.topic_typename = "std_msgs/String";
+	res.reply_packet = &packet;
+	ret = mros_rpc_register_subscriber(&client, &req, &res);
+	if (ret != MROS_E_OK) {
+		syslog(LOG_NOTICE, "mros_rpc_register_publisher()=%d", ret);
+		return;
+	}
+	mros_comm_tcp_client_close(&client);
+	mros_uint32 ipaddr = -1;
+	mros_int32 port = -1;
+	mRosPtrType ptr = mros_xmlpacket_subres_get_first_uri(res.reply_packet, &ipaddr, &port);
+	syslog(LOG_NOTICE, "ptr=0x%x ipaddr=0x%x port=%d", ptr, ipaddr, port);
+	if (ptr == MROS_NULL) {
+		syslog(LOG_NOTICE, "no publisher");
+		return;
+	}
+	mRosRequestTopicReqType topic_req;
+	mRosRequestTopicResType topic_res;
+	topic_req.node_name = "node1";
+	topic_req.req_packet = &packet;
+	topic_req.topic_name = "/test_string";
+	topic_res.reply_packet = &packet;
+	if (ptr != MROS_NULL) {
+		ret = mros_comm_tcp_client_ip32_init(&client, ipaddr, port);
+		if (ret != MROS_E_OK) {
+			syslog(LOG_NOTICE, "mros_comm_tcp_client_connect()=%d", ret);
+			return;
+		}
+		ret = mros_comm_tcp_client_connect(&client);
+		if (ret != MROS_E_OK) {
+			syslog(LOG_NOTICE, "mros_comm_tcp_client_connect()=%d", ret);
+			return;
+		}
+		ret = mros_rpc_request_topic(&client, &topic_req, &topic_res);
+		mros_comm_tcp_client_close(&client);
+		if (ret != MROS_E_OK) {
+			syslog(LOG_NOTICE, "mros_protocol_master_request_topic()=%d", ret);
+			return;
+		}
+		ptr = mros_xmlpacket_reqtopicres_get_first_uri(topic_res.reply_packet, &test_request_topic_ipaddr, &test_request_topic_port);
+		syslog(LOG_NOTICE, "ptr=0x%x ipaddr=0x%x port=%d", ptr, test_request_topic_ipaddr, test_request_topic_port);
+	}
+	syslog(LOG_NOTICE, "data_size=%d", packet.data_size);
+	syslog(LOG_NOTICE, "packet=%s", packet.data);
+	mros_comm_tcp_client_close(&client);
+
+
+	syslog(LOG_NOTICE, "END: TEST REQUEST TOPIC");
+
+	return;
+}
+
+void do_test_tcpros_topic(void)
+{
+	mRosPacketType packet;
+	mRosReturnType ret;
+	static char buffer[1024];
+	mRosCommTcpClientType client;
+	mRosRcpRosReqType req;
+	mRosTcpRosResType res;
+
+
+	do_test_request_topic();
+
+	syslog(LOG_NOTICE, "START: TEST TCPROS TOPIC");
+	packet.data = buffer;
+	packet.total_size = sizeof(buffer);
+	packet.data_size = 0;
+
+	req.node_name = "node1";
+	req.req_packet = &packet;
+	req.topic_name = "/test_string";
+	req.topic_typename = "std_msgs/String";
+	res.reply_packet = &packet;
+
+	ret = mros_comm_tcp_client_ip32_init(&client, test_request_topic_ipaddr, test_request_topic_port);
+	if (ret != MROS_E_OK) {
+		syslog(LOG_NOTICE, "mros_comm_tcp_client_connect()=%d", ret);
+		return;
+	}
+	ret = mros_comm_tcp_client_connect(&client);
+	if (ret != MROS_E_OK) {
+		syslog(LOG_NOTICE, "mros_comm_tcp_client_connect()=%d", ret);
+		return;
+	}
+	syslog(LOG_NOTICE, "mros_comm_tcp_client_connect(): SUCCESS");
+
+	ret = mros_rpc_tcpros(&client, &req, &res);
+	if (ret != MROS_E_OK) {
+		syslog(LOG_NOTICE, "mros_rpc_tcpros()=%d", ret);
+		return;
+	}
+	syslog(LOG_NOTICE, "data_size=%d", packet.data_size);
+	mRosTcpRosPacketType tcpros_packet;
+	ret = mros_tcprospacket_decode(&packet, &tcpros_packet);
+	if (ret != MROS_E_OK) {
+		syslog(LOG_NOTICE, "mros_tcprospacket_decode()=%d", ret);
+		return;
+	}
+	syslog(LOG_NOTICE, "callerid=%s", tcpros_packet.callerid);
+	syslog(LOG_NOTICE, "tcp_nodely=%s", tcpros_packet.tcp_nodely);
+	syslog(LOG_NOTICE, "topic=%s", tcpros_packet.topic);
+	syslog(LOG_NOTICE, "type=%s", tcpros_packet.type);
+	syslog(LOG_NOTICE, "md5sum=%s", tcpros_packet.md5sum);
+	mros_comm_tcp_client_close(&client);
+	syslog(LOG_NOTICE, "END: TEST TCPROS TOPIC");
+
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/os/target/os_asp/mros_test.h
@@ -0,0 +1,20 @@
+#ifndef _MROS_TEST_H_
+#define _MROS_TEST_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern void do_test_register_publisher(void);
+extern void do_test_register_subscriber(void);
+extern void do_test_request_topic(void);
+extern void do_test_tcpros_topic(void);
+extern void do_test_server(void);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* _MROS_TEST_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/packet/cimpl/mros_packet_cimpl.h
@@ -0,0 +1,33 @@
+#ifndef _MROS_PACKET_CIMPL_H_
+#define _MROS_PACKET_CIMPL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_types.h"
+
+typedef enum {
+	MROS_PACKET_DATA_REGISTER_PUBLISHER_REQ = 0,
+	MROS_PACKET_DATA_REGISTER_SUBSCRIBER_REQ,
+	MROS_PACKET_DATA_REQUEST_TOPIC_REQ,
+	MROS_PACKET_DATA_REQUEST_TOPIC_RES,
+	MROS_PACKET_DATA_PUBLISHER_UPDATE_REQ,
+	MROS_PACKET_DATA_TCPROS_TOPIC_REQ,
+	MROS_PACKET_DATA_TCPROS_TOPIC_RES,
+	MROS_PACKET_DATA_TOPIC,
+	MROS_PACKET_DATA_NUM,
+} mRosPacketDataEnumType;
+#define MROS_PACKET_DATA_INVALID	MROS_PACKET_DATA_NUM
+
+typedef struct {
+	mRosSizeType						total_size;
+	mRosSizeType						data_size;
+	char							 	*data;
+} mRosPacketType;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MROS_PACKET_CIMPL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/packet/cimpl/mros_packet_decoder_cimpl.h
@@ -0,0 +1,117 @@
+#ifndef _MROS_PACKET_DECODER_CIMPL_H_
+#define _MROS_PACKET_DECODER_CIMPL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_packet_cimpl.h"
+
+extern mRosReturnType mros_packet_decoder_init(void);
+
+
+/************************************************
+ * XML RPC PACKET
+ ************************************************/
+/*
+ * XML request
+ */
+extern mros_boolean mros_xmlpacket_has_request_end(mRosPacketType *packet);
+/*
+ * XML response
+ */
+extern mros_boolean mros_xmlpacket_has_response_end(mRosPacketType *packet);
+
+//MASTER
+/*
+ * ReigsterPublish response
+ */
+extern mRosReturnType mros_xmlpacket_pubres_result(mRosPacketType *packet);
+
+/*
+ * ReigsterSubscribe response
+ */
+extern mRosReturnType mros_xmlpacket_subres_result(mRosPacketType *packet);
+extern mRosPtrType mros_xmlpacket_subres_get_first_uri(mRosPacketType *packet, mros_uint32 *ipaddr, mros_int32 *port);
+extern mRosPtrType mros_xmlpacket_subres_get_next_uri(mRosPtrType ptr, mRosPacketType *packet, mros_uint32 *ipaddr, mros_int32 *port);
+
+
+//SLAVE
+typedef struct {
+	struct {
+		char *start_key;
+		char *end_key;
+	} req;
+	struct {
+		char *head;
+		char *tail;
+		mRosSizeType len;
+	} res;
+} mRosPacketMemberInfoType;
+
+typedef struct {
+	mRosPacketDataEnumType		packet_type;
+	mRosPacketMemberInfoType method;
+	union {
+		struct {
+			mRosPacketMemberInfoType node_name;
+			mRosPacketMemberInfoType topic_name;
+		} topic;
+		struct {
+			mRosPacketMemberInfoType name;
+			mRosPacketMemberInfoType topic_name;
+		} publisher_update;
+	} request;
+} mRosPacketDecodedRequestType;
+extern mRosPacketDataEnumType mros_xmlpacket_slave_request_decode(mRosPacketType *packet, mRosPacketDecodedRequestType *decoded_infop);
+
+
+/*
+ * RequestTopic request
+ */
+extern mRosReturnType mros_xmlpacket_slave_reqtopic_get_topic_name(mRosPacketType *packet, char* topic_name, mros_uint32 len);
+
+/*
+ * RequestTopic response
+ */
+extern mRosReturnType mros_xmlpacket_reqtopicres_result(mRosPacketType *packet);
+extern mRosPtrType mros_xmlpacket_reqtopicres_get_first_uri(mRosPacketType *packet, mros_uint32 *ipaddr, mros_int32 *port);
+extern mRosPtrType mros_xmlpacket_reqtopicres_get_next_uri(mRosPtrType ptr, mRosPacketType *packet, mros_uint32 *ipaddr, mros_int32 *port);
+
+/*
+ * publisherUpdate request
+ */
+extern mRosPtrType mros_xmlpacket_pubupreq_get_first_uri(char *packet_data, mros_uint32 *ipaddr, mros_int32 *port);
+extern mRosPtrType mros_xmlpacket_pubupreq_get_next_uri(mRosPtrType ptr, mRosPacketType *packet, mros_uint32 *ipaddr, mros_int32 *port);
+
+/****************************************************
+ * TCPROS
+ ****************************************************/
+extern mRosReturnType mros_tcprospacket_get_body_size(mRosPacketType *packet, mRosSizeType *len);
+typedef struct {
+	mros_uint16 callerid_len;
+	mros_uint16 tcp_nodelay_len;
+	mros_uint16 topic_len;
+	mros_uint16 type_len;
+	mros_uint16 md5sum_len;
+	char *callerid;
+	char *tcp_nodely;
+	char *topic;
+	char* type;
+	char *md5sum;
+} mRosTcpRosPacketType;
+extern mRosReturnType mros_tcprospacket_decode(mRosPacketType *packet, mRosTcpRosPacketType *decoded_packet);
+
+
+/****************************************************
+ * TOPIC DATA
+ ****************************************************/
+extern mRosReturnType mros_topicpacket_get_body_size(mRosPacketType *packet, mRosSizeType *len);
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MROS_PACKET_DECODER_CIMPL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/packet/cimpl/mros_packet_encoder_cimpl.h
@@ -0,0 +1,59 @@
+#ifndef _MROS_PACKET_ENCODER_CIMPL_H_
+#define _MROS_PACKET_ENCODER_CIMPL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_packet_cimpl.h"
+
+/*************************************
+ * Encoder
+ *************************************/
+#define MROS_ENCODE_ARGS_MAX	5
+typedef struct {
+	mRosPacketDataEnumType type;
+	mRosSizeType	args_char;
+	const char* 	argv[MROS_ENCODE_ARGS_MAX];
+	mRosSizeType	args_int;
+	mros_uint32		argi[MROS_ENCODE_ARGS_MAX];
+} mRosEncodeArgType;
+
+extern mRosReturnType mros_packet_encoder_init(void);
+
+/*
+ * 	arg.type = MROS_PACKET_DATA_REGISTER_PUBLISHER_REQ;
+ *	arg.argv[0] = "registerPublisher";
+ *	arg.argv[1] = req->node_name;
+ *	arg.argv[2] = req->topic_name;
+ *	arg.argv[3] = req->topic_typename;
+ *	arg.argv[4] = MROS_URI_SLAVE;
+ */
+/*
+ *	arg.type = MROS_PACKET_DATA_REGISTER_SUBSCRIBER_REQ;
+ *	arg.argv[0] = "registerSubscriber";
+ *	arg.argv[1] = req->node_name;
+ *	arg.argv[2] = req->topic_name;
+ *	arg.argv[3] = req->topic_typename;
+ *	arg.argv[4] = MROS_URI_SLAVE;
+ */
+/*
+ *	arg.type = MROS_PACKET_DATA_REQUEST_TOPIC_REQ;
+ *	arg.argv[0] = "requestTopic";
+ *	arg.argv[1] = req->node_name;
+ *	arg.argv[2] = req->topic_name;
+ *	arg.argv[3] = "TCPROS";
+ */
+/*
+ *	arg.type = MROS_PACKET_DATA_REQUEST_TOPIC_RES;
+ *	arg.argi[0] = mros_publisher_port_no;
+ *	arg.argv[0] ="TCPROS";
+ *	arg.argv[1] = MROS_NODE_IPADDR;
+ */
+extern mRosReturnType mros_packet_encode(mRosEncodeArgType *arg, mRosPacketType *packet);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MROS_PACKET_ENCODER_CIMPL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/packet/cimpl/version/kinetic/mros_packet_config.h
@@ -0,0 +1,31 @@
+#ifndef _MROS_PACKET_CONFIG_H_
+#define _MROS_PACKET_CONFIG_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MROS_TOPIC_RAWDATA_HEADER_SIZE					4
+#define MROS_TCPROS_RAWDATA_HEADER_SIZE					4
+
+/**************************************
+ * PACKET
+ **************************************/
+#define MROS_PACKET_MAXSIZE_REQ_REGISTER_PUBLISHER		1024
+#define MROS_PACKET_MAXSIZE_RES_REGISTER_PUBLISHER		1024
+#define MROS_PACKET_MAXSIZE_REQ_REGISTER_SUBSCRIBER		1024
+#define MROS_PACKET_MAXSIZE_RES_REGISTER_SUBSCRIBER		1024
+#define MROS_PACKET_MAXSIZE_REQ_REQUEST_TOPIC			1024
+#define MROS_PACKET_MAXSIZE_RES_REQUEST_TOPIC			1024
+#define MROS_PACKET_MAXSIZE_REQ_PUBLISHER_UPDATE		1024
+
+
+#define MROS_PACKET_MAXSIZE_REQ_TCPROS					512
+#define MROS_PACKET_MAXSIZE_RES_TCPROS					512
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MROS_PACKET_CONFIG_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/packet/cimpl/version/kinetic/mros_packet_decoder_cimpl.c
@@ -0,0 +1,565 @@
+#include "mros_packet_decoder_cimpl.h"
+#include "mros_packet_fmt_xml.h"
+#include "mros_packet_fmt_http.h"
+#include "mros_comm_cimpl.h"
+#include "mros_packet_config.h"
+#include <string.h>
+
+static mros_int32 mros_packet_xmlrpc_req_end_str_len = 0;
+static mros_int32 mros_packet_xmlrpc_res_end_str_len = 0;
+
+mRosReturnType mros_packet_decoder_init(void)
+{
+	mros_packet_xmlrpc_req_end_str_len = strlen(MROS_PACKET_XMLRPC_REQ_END_STR);
+	mros_packet_xmlrpc_res_end_str_len = strlen(MROS_PACKET_XMLRPC_RES_END_STR);
+	return MROS_E_OK;
+}
+
+
+static char *find_string_after(const char* string1, const char* string2)
+{
+	char* str = strstr(string1, string2);
+	if (str == MROS_NULL) {
+		return MROS_NULL;
+	}
+	str += strlen(string2);
+	return str;
+}
+#define PORT_MAX_STR_LEN	6U /* 65536 */
+#define IP_MAX_STR_LEN	15U /* 255.255.255.255 */
+
+
+
+/************************************************
+ * XML RPC PACKET
+ ************************************************/
+/*
+ * XML request
+ */
+mros_boolean mros_xmlpacket_has_request_end(mRosPacketType *packet)
+{
+	mros_int32 off;
+	if (packet->data_size <= mros_packet_xmlrpc_req_end_str_len) {
+		return MROS_FALSE;
+	}
+	off = (mros_int32)packet->data_size - (mros_int32)mros_packet_xmlrpc_req_end_str_len;
+	while (off > 0) {
+		if (strncmp(&packet->data[off], MROS_PACKET_XMLRPC_REQ_END_STR, mros_packet_xmlrpc_req_end_str_len) == 0) {
+			return MROS_TRUE;
+		}
+		off--;
+	}
+	return MROS_FALSE;
+}
+
+/*
+ * XML response
+ */
+mros_boolean mros_xmlpacket_has_response_end(mRosPacketType *packet)
+{
+	mros_int32 off;
+	if (packet->data_size <= mros_packet_xmlrpc_res_end_str_len) {
+		return MROS_FALSE;
+	}
+	off = (mros_int32)packet->data_size - (mros_int32)mros_packet_xmlrpc_res_end_str_len;
+	while (off > 0) {
+		if (strncmp(&packet->data[off], MROS_PACKET_XMLRPC_RES_END_STR, mros_packet_xmlrpc_res_end_str_len) == 0) {
+			return MROS_TRUE;
+		}
+		off--;
+	}
+	return MROS_FALSE;
+}
+
+static mRosReturnType mros_xmlpacket_result(mRosPacketType *packet)
+{
+	//search HERE
+	//        |
+	//        V
+	//    HTTP/1.1 200 OK
+	const char* head = find_string_after((const char *)&packet->data[0], "HTTP/");
+	if (head == MROS_NULL) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return MROS_E_INVAL;
+	}
+	//    search HERE
+	//            |
+	//            V
+	//    HTTP/1.1 200 OK
+	head = find_string_after(head, " ");
+	if (head == MROS_NULL) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return MROS_E_INVAL;
+	}
+	//        search HERE
+	//                |
+	//                V
+	//    HTTP/1.1 200 OK
+	const char* tail = strstr(head, " ");
+	mros_uint32 len = (tail - head);
+	if (len != MROS_PACKET_HTT_OK_CODE_LEN) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return MROS_E_INVAL;
+	}
+	if (strncmp(head, MROS_PACKET_HTT_OK_CODE, MROS_PACKET_HTT_OK_CODE_LEN) != 0) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return MROS_E_INVAL;
+	}
+	return MROS_E_OK;
+}
+
+//MASTER
+/*
+ * ReigsterPublish response
+ */
+mRosReturnType mros_xmlpacket_pubres_result(mRosPacketType *packet)
+{
+	return mros_xmlpacket_result(packet);
+}
+
+/*
+ * ReigsterSubscribe response
+ */
+mRosReturnType mros_xmlpacket_subres_result(mRosPacketType *packet)
+{
+	return mros_xmlpacket_result(packet);
+}
+static mRosPtrType mros_xmlpacket_get_first_uri(char *packet_data, mros_uint32 *ipaddr, mros_int32 *port)
+{
+	//search HERE
+	//        |
+	//        V
+	//"http://xxx.xxx.xx:8080/"
+	char* head = find_string_after((const char *)packet_data, "http://");
+	if (head == MROS_NULL) {
+		//ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return MROS_NULL;
+	}
+
+	//           search HERE
+	//                   |
+	//                   V
+	//"http://xxx.xxx.xx:8080/"
+	char *tail = find_string_after(head, ":");
+	if (tail == MROS_NULL) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return MROS_NULL;
+	}
+	mros_uint32 len = (tail - head);
+	head[len - 1] = '\0';
+	//head[len] = '\0';
+	mRosReturnType ret = mros_comm_inet_get_ipaddr((const char *)head, ipaddr);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return MROS_NULL;
+	}
+
+	//               search HERE
+	//                       |
+	//                       V
+	//"http://xxx.xxx.xx:8080/"
+	//"http://xxx.xxx.xx:8080</"
+	head = tail;
+	tail = strstr(head, "/");
+	len = (tail - head) + 1;
+	if (head[len - 2] == '<') {
+		len--;
+	}
+	if (len > PORT_MAX_STR_LEN) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return MROS_NULL;
+	}
+	head[len - 1] = '\0';
+
+	*port = strtol(head, MROS_NULL, 10);
+	return (mRosPtrType)tail;
+}
+
+mRosPtrType mros_xmlpacket_subres_get_first_uri(mRosPacketType *packet, mros_uint32 *ipaddr, mros_int32 *port)
+{
+	return mros_xmlpacket_get_first_uri(&packet->data[0], ipaddr, port);
+}
+
+mRosPtrType mros_xmlpacket_subres_get_next_uri(mRosPtrType ptr, mRosPacketType *packet, mros_uint32 *ipaddr, mros_int32 *port)
+{
+	return mros_xmlpacket_get_first_uri(ptr, ipaddr, port);
+}
+
+
+static mRosReturnType mros_xmlpacket_get_member_info(const char*p, mRosPacketMemberInfoType *infop)
+{
+	infop->res.head = find_string_after(p, infop->req.start_key);
+	if (infop->res.head == MROS_NULL) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return MROS_E_INVAL;
+	}
+
+	infop->res.tail = strstr(infop->res.head, "<");
+	if (infop->res.tail == MROS_NULL) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return MROS_E_INVAL;
+	}
+	infop->res.len = (infop->res.tail - infop->res.head);
+	return MROS_E_OK;
+}
+
+//SLAVE
+/*
+ * RequestTopic request
+ */
+static mRosPacketDataEnumType mros_xmlpacket_slave_request_get_method(mRosPacketType *packet, mRosPacketMemberInfoType *minfop)
+{
+	mRosReturnType ret;
+	mRosSizeType reqtopic_len = strlen("requestTopic");
+	mRosSizeType pubup_len = strlen("publisherUpdate");
+
+	//"<methodName>requestTopic</methodName>"
+	minfop->req.start_key = "<methodName>";
+	minfop->req.end_key = "<";
+
+	ret = mros_xmlpacket_get_member_info(packet->data, minfop);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return MROS_PACKET_DATA_INVALID;
+	}
+	if (reqtopic_len == minfop->res.len) {
+		if (strncmp(minfop->res.head, "requestTopic", reqtopic_len) == 0) {
+			return MROS_PACKET_DATA_REQUEST_TOPIC_REQ;
+		}
+	}
+	if (pubup_len == minfop->res.len) {
+		if (strncmp(minfop->res.head, "publisherUpdate", pubup_len) == 0) {
+			return MROS_PACKET_DATA_PUBLISHER_UPDATE_REQ;
+		}
+	}
+	ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+	return MROS_PACKET_DATA_INVALID;
+}
+#define REQTOPIC_VALUE_TAG_START_NOSTRING "<value>"
+#define REQTOPIC_VALUE_TAG_END_NOSTRING "</value>"
+#define REQTOPIC_VALUE_TAG_START "<value><string>"
+#define REQTOPIC_VALUE_TAG_END "</string></value>"
+
+static mRosReturnType mros_xmlpacket_request_topic_req_decode(mRosPacketType *packet, mRosPacketDecodedRequestType *decoded_infop)
+{
+	mRosReturnType ret;
+	char *node_name_tail;
+	char *has_string;
+
+	has_string = find_string_after(packet->data, REQTOPIC_VALUE_TAG_START);
+	if (has_string != MROS_NULL) {
+		decoded_infop->request.topic.node_name.req.start_key = REQTOPIC_VALUE_TAG_START;
+	}
+	else {
+		decoded_infop->request.topic.node_name.req.start_key = REQTOPIC_VALUE_TAG_START_NOSTRING;
+	}
+	decoded_infop->request.topic.node_name.req.end_key = "<";
+	ret = mros_xmlpacket_get_member_info(decoded_infop->method.res.tail, &decoded_infop->request.topic.node_name);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return MROS_E_INVAL;
+	}
+	node_name_tail = decoded_infop->request.topic.node_name.res.tail;
+	if (has_string != MROS_NULL) {
+		decoded_infop->request.topic.topic_name.req.start_key = REQTOPIC_VALUE_TAG_START;
+	}
+	else {
+		decoded_infop->request.topic.topic_name.req.start_key = REQTOPIC_VALUE_TAG_START_NOSTRING;
+	}
+	decoded_infop->request.topic.topic_name.req.end_key = "<";
+	ret = mros_xmlpacket_get_member_info(node_name_tail, &decoded_infop->request.topic.topic_name);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return MROS_E_INVAL;
+	}
+
+	return MROS_E_OK;
+}
+
+static mRosReturnType mros_xmlpacket_publisher_update_req_decode(mRosPacketType *packet, mRosPacketDecodedRequestType *decoded_infop)
+{
+	mRosReturnType ret;
+	char *node_name_tail;
+	char *has_string;
+
+	has_string = find_string_after(packet->data, REQTOPIC_VALUE_TAG_START);
+	if (has_string != MROS_NULL) {
+		decoded_infop->request.topic.node_name.req.start_key = REQTOPIC_VALUE_TAG_START;
+	}
+	else {
+		decoded_infop->request.topic.node_name.req.start_key = REQTOPIC_VALUE_TAG_START_NOSTRING;
+	}
+	decoded_infop->request.publisher_update.name.req.end_key = "<";
+	ret = mros_xmlpacket_get_member_info(decoded_infop->method.res.tail, &decoded_infop->request.publisher_update.name);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return MROS_E_INVAL;
+	}
+	node_name_tail = decoded_infop->request.publisher_update.name.res.tail;
+	if (has_string != MROS_NULL) {
+		decoded_infop->request.topic.topic_name.req.start_key = REQTOPIC_VALUE_TAG_START;
+	}
+	else {
+		decoded_infop->request.topic.topic_name.req.start_key = REQTOPIC_VALUE_TAG_START_NOSTRING;
+	}
+	decoded_infop->request.publisher_update.topic_name.req.end_key = "<";
+	ret = mros_xmlpacket_get_member_info(node_name_tail, &decoded_infop->request.publisher_update.topic_name);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return MROS_E_INVAL;
+	}
+
+	return MROS_E_OK;
+}
+
+mRosPacketDataEnumType mros_xmlpacket_slave_request_decode(mRosPacketType *packet, mRosPacketDecodedRequestType *decoded_infop)
+{
+	mRosReturnType ret = MROS_E_INVAL;
+	decoded_infop->packet_type = mros_xmlpacket_slave_request_get_method(packet, &decoded_infop->method);
+	switch (decoded_infop->packet_type) {
+	case MROS_PACKET_DATA_REQUEST_TOPIC_REQ:
+		ret = mros_xmlpacket_request_topic_req_decode(packet, decoded_infop);
+		break;
+	case MROS_PACKET_DATA_PUBLISHER_UPDATE_REQ:
+		ret = mros_xmlpacket_publisher_update_req_decode(packet, decoded_infop);
+		break;
+	default:
+		break;
+	}
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return MROS_PACKET_DATA_INVALID;
+	}
+	return decoded_infop->packet_type;
+}
+
+/*
+ * RequestTopic response
+ */
+mRosReturnType mros_xmlpacket_reqtopicres_result(mRosPacketType *packet)
+{
+	return mros_xmlpacket_result(packet);
+}
+/*
+HTTP/1.0 200 OK
+Server: BaseHTTP/0.3 Python/2.7.12
+Date: Sat, 29 Jun 2019 01:07:58 GMT
+Content-type: text/xml
+Content-length: 377
+
+<?xml version='1.0'?>
+<methodResponse>
+<params>
+<param>
+<value><array><data>
+<value><int>1</int></value>
+<value><string>ready on Chagall:54894</string></value>
+<value><array><data>
+<value><string>TCPROS</string></value>
+<value><string>Chagall</string></value>
+<value><int>54894</int></value>
+</data></array></value>
+</data></array></value>
+</param>
+</params>
+</methodResponse>
+ */
+static mRosPtrType mros_xmlpacket_reqtopicres_get_uri(char *packet_data, mros_uint32 *ipaddr, mros_int32 *port)
+{
+	mRosReturnType ret;
+	char* tmp;
+	//      search HERE
+	//             |
+	//             V
+	//"<value><array><data>"
+	char* head = find_string_after((const char *)packet_data, "<array>");
+	if (head == MROS_NULL) {
+		//ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return MROS_NULL;
+	}
+
+	//      search HERE
+	//              |
+	//              V
+	//"<value><array><data>"
+	head = find_string_after(head, "<array>");
+	if (head == MROS_NULL) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return MROS_NULL;
+	}
+	//                             search HERE
+	//                                     |
+	//                                     V
+	//<value><string>TCPROS</string></value>
+	head = find_string_after(head, "</value>");
+	if (head == MROS_NULL) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return MROS_NULL;
+	}
+	//      search HERE
+	//              |
+	//              V
+	//<value><string>Chagall</string></value>
+	tmp = find_string_after(head, "<value><string>");
+	if (tmp == MROS_NULL) {
+		//<value>Chagall</value>
+		tmp = find_string_after(head, "<value>");
+		if (tmp == MROS_NULL) {
+			ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+			return MROS_NULL;
+		}
+	}
+	head = tmp;
+
+	//             search HERE
+	//                      |
+	//                      V
+	//<value><string>Chagall</string></value>
+	char* tail = strstr(head, "<");
+	mros_uint32 len = (tail - head);
+	//head[len - 1] = '\0';
+	head[len] = '\0';
+	ret = mros_comm_inet_get_ipaddr((const char *)head, ipaddr);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return MROS_NULL;
+	}
+	tail++;
+
+	//   search HERE
+	//           |
+	//           V
+	//<value><int>54894</int></value>
+	tmp = find_string_after(tail, "<value><int>");
+	if (tmp == MROS_NULL) {
+		//<value><i4>54894</i4></value>
+		tmp = find_string_after(tail, "<value><i4>");
+		if (tmp == MROS_NULL) {
+			ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+			return MROS_NULL;
+		}
+	}
+	head = tmp;
+
+	//         search HERE
+	//                 |
+	//                 V
+	//<value><int>54894</int></value>
+	tail = strstr(head, "<");
+	len = (tail - head) + 1;
+	if (len > PORT_MAX_STR_LEN) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return MROS_NULL;
+	}
+	head[len - 1] = '\0';
+	*port = strtol(head, MROS_NULL, 10);
+	return (mRosPtrType)tail;
+}
+mRosPtrType mros_xmlpacket_reqtopicres_get_first_uri(mRosPacketType *packet, mros_uint32 *ipaddr, mros_int32 *port)
+{
+	return mros_xmlpacket_reqtopicres_get_uri(packet->data, ipaddr, port);
+}
+mRosPtrType mros_xmlpacket_reqtopicres_get_next_uri(mRosPtrType ptr, mRosPacketType *packet, mros_uint32 *ipaddr, mros_int32 *port)
+{
+	return mros_xmlpacket_reqtopicres_get_uri(ptr, ipaddr, port);
+}
+
+mRosPtrType mros_xmlpacket_pubupreq_get_first_uri(char *packet_data, mros_uint32 *ipaddr, mros_int32 *port)
+{
+	return mros_xmlpacket_get_first_uri(packet_data, ipaddr, port);
+}
+
+mRosPtrType mros_xmlpacket_pubupreq_get_next_uri(mRosPtrType ptr, mRosPacketType *packet, mros_uint32 *ipaddr, mros_int32 *port)
+{
+	return mros_xmlpacket_get_first_uri(ptr, ipaddr, port);
+}
+
+
+/****************************************************
+ * TCPROS
+ ****************************************************/
+mRosReturnType mros_tcprospacket_get_body_size(mRosPacketType *packet, mRosSizeType *len)
+{
+	*len = *((mRosSizeType*)&packet->data[0]);
+	return MROS_E_OK;
+}
+
+mRosReturnType mros_tcprospacket_decode(mRosPacketType *packet, mRosTcpRosPacketType *decoded_packet)
+{
+	mros_uint32 len;
+	mros_uint32 off = 0;
+	mros_uint32 memlen;
+	mros_uint32 entrylen;
+
+	len = packet->data_size;
+
+	decoded_packet->callerid = MROS_NULL;
+	decoded_packet->md5sum = MROS_NULL;
+	decoded_packet->tcp_nodely = MROS_NULL;
+	decoded_packet->topic = MROS_NULL;
+	decoded_packet->type = MROS_NULL;
+
+
+	while (off < len) {
+		entrylen = *((mRosSizeType*)&packet->data[off]);
+		off += 4;
+		if (off >= len) {
+			break;
+		}
+
+		memlen = strlen("callerid=");
+		if (strncmp(&packet->data[off], "callerid=", memlen) == 0) {
+			decoded_packet->callerid_len = entrylen - memlen;
+			decoded_packet->callerid = (char*)&packet->data[off + memlen];
+		}
+		memlen = strlen("md5sum=");
+		if (strncmp(&packet->data[off], "md5sum=", memlen) == 0) {
+			decoded_packet->md5sum_len = entrylen - memlen;
+			decoded_packet->md5sum = (char*)&packet->data[off + memlen];
+		}
+		memlen = strlen("tcp_nodely=");
+		if (strncmp(&packet->data[off], "tcp_nodely=", memlen) == 0) {
+			decoded_packet->tcp_nodelay_len = entrylen - memlen;
+			decoded_packet->tcp_nodely = (char*)&packet->data[off + memlen];
+		}
+		memlen = strlen("topic=");
+		if (strncmp(&packet->data[off], "topic=", memlen) == 0) {
+			decoded_packet->topic_len = entrylen - memlen;
+			decoded_packet->topic = (char*)&packet->data[off + memlen];
+		}
+		memlen = strlen("type=");
+		if (strncmp(&packet->data[off], "type=", memlen) == 0) {
+			decoded_packet->type_len = entrylen - memlen;
+			decoded_packet->type = (char*)&packet->data[off + memlen];
+		}
+		off += entrylen;
+	}
+	if (decoded_packet->callerid != MROS_NULL) {
+		decoded_packet->callerid[decoded_packet->callerid_len] = '\0';
+	}
+	if (decoded_packet->md5sum != MROS_NULL) {
+		decoded_packet->md5sum[decoded_packet->md5sum_len] = '\0';
+	}
+	if (decoded_packet->tcp_nodely != MROS_NULL) {
+		decoded_packet->tcp_nodely[decoded_packet->tcp_nodelay_len] = '\0';
+	}
+	if (decoded_packet->topic != MROS_NULL) {
+		decoded_packet->topic[decoded_packet->topic_len] = '\0';
+	}
+	if (decoded_packet->type != MROS_NULL) {
+		decoded_packet->type[decoded_packet->type_len] = '\0';
+	}
+
+	return MROS_E_OK;
+}
+
+
+/****************************************************
+ * TOPIC DATA
+ ****************************************************/
+mRosReturnType mros_topicpacket_get_body_size(mRosPacketType *packet, mRosSizeType *len)
+{
+	*len = ( (*((mRosSizeType*)&packet->data[0])) );
+	return MROS_E_OK;
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/packet/cimpl/version/kinetic/mros_packet_encoder_cimpl.c
@@ -0,0 +1,374 @@
+#include "mros_packet_encoder_cimpl.h"
+#include "mros_packet_fmt_xml.h"
+#include "mros_packet_fmt_http.h"
+#include "mros_packet_fmt_tcpros.h"
+#include "mros_packet_config.h"
+#include <string.h>
+#include <stdio.h>
+
+static mRosReturnType encode_register_publisher_req(mRosEncodeArgType *arg, mRosPacketType *packet);
+static mRosReturnType encode_register_subscriber_req(mRosEncodeArgType *arg, mRosPacketType *packet);
+static mRosReturnType encode_request_topic_req(mRosEncodeArgType *arg, mRosPacketType *packet);
+static mRosReturnType encode_request_topic_res(mRosEncodeArgType *arg, mRosPacketType *packet);
+static mRosReturnType encode_tcpros_topic_req(mRosEncodeArgType *arg, mRosPacketType *packet);
+static mRosReturnType encode_tcpros_topic_res(mRosEncodeArgType *arg, mRosPacketType *packet);
+static mRosReturnType encode_topic_data(mRosEncodeArgType *arg, mRosPacketType *packet);
+typedef mRosReturnType (*encode_table_type) (mRosEncodeArgType*, mRosPacketType*);
+
+static encode_table_type encode_table[MROS_PACKET_DATA_NUM] = {
+		encode_register_publisher_req, 			//MROS_PACKET_DATA_REGISTER_PUBLISHER_REQ
+		encode_register_subscriber_req,			//MROS_PACKET_DATA_REGISTER_SUBSCRIBER_REQ
+		encode_request_topic_req,				//MROS_PACKET_DATA_REQUEST_TOPIC_REQ
+		encode_request_topic_res,				//MROS_PACKET_DATA_REQUEST_TOPIC_RES
+		MROS_NULL,								//MROS_PACKET_DATA_PUBLISHER_UPDATE_REQ
+		encode_tcpros_topic_req,				//MROS_PACKET_DATA_TCPROS_TOPIC_REQ
+		encode_tcpros_topic_res,				//MROS_PACKET_DATA_TCPROS_TOPIC_RES
+		encode_topic_data,						//MROS_PACKET_DATA_TOPIC
+};
+
+typedef struct {
+	const char* fmt;
+	mros_uint32 len;
+} mRosFmtType;
+
+
+static mRosFmtType mros_xml_fmt_table[MROS_PACKET_DATA_NUM] MROS_MATTR_BSS_NOCLR;
+static mRosFmtType mros_http_post_fmt MROS_MATTR_BSS_NOCLR;
+static mRosFmtType mros_http_ok_fmt MROS_MATTR_BSS_NOCLR;
+static mRosFmtType mros_tcpros_topic_req_fmt MROS_MATTR_BSS_NOCLR;
+static mRosFmtType mros_tcpros_topic_res_fmt MROS_MATTR_BSS_NOCLR;
+
+mRosReturnType mros_packet_encoder_init(void)
+{
+	mros_xml_fmt_table[MROS_PACKET_DATA_REGISTER_PUBLISHER_REQ].fmt = MROS_PACKET_FMT_XML_REGISTER_REQ;
+	mros_xml_fmt_table[MROS_PACKET_DATA_REGISTER_PUBLISHER_REQ].len = strlen(MROS_PACKET_FMT_XML_REGISTER_REQ) + 1;
+
+	mros_xml_fmt_table[MROS_PACKET_DATA_REGISTER_SUBSCRIBER_REQ].fmt = MROS_PACKET_FMT_XML_REGISTER_REQ;
+	mros_xml_fmt_table[MROS_PACKET_DATA_REGISTER_SUBSCRIBER_REQ].len = strlen(MROS_PACKET_FMT_XML_REGISTER_REQ) + 1;
+
+	mros_xml_fmt_table[MROS_PACKET_DATA_REQUEST_TOPIC_REQ].fmt = MROS_PACKET_FMT_XML_REQUEST_TOPIC_REQ;
+	mros_xml_fmt_table[MROS_PACKET_DATA_REQUEST_TOPIC_REQ].len = strlen(MROS_PACKET_FMT_XML_REQUEST_TOPIC_REQ) + 1;
+
+	mros_xml_fmt_table[MROS_PACKET_DATA_REQUEST_TOPIC_RES].fmt = MROS_NULL;
+	mros_xml_fmt_table[MROS_PACKET_DATA_REQUEST_TOPIC_RES].len = 0;
+
+	mros_xml_fmt_table[MROS_PACKET_DATA_TCPROS_TOPIC_REQ].fmt = MROS_NULL;
+	mros_xml_fmt_table[MROS_PACKET_DATA_TCPROS_TOPIC_REQ].len = 0;
+
+	mros_xml_fmt_table[MROS_PACKET_DATA_TCPROS_TOPIC_RES].fmt = MROS_NULL;
+	mros_xml_fmt_table[MROS_PACKET_DATA_TCPROS_TOPIC_RES].len = 0;
+
+	mros_http_post_fmt.fmt = MROS_PACKET_FMT_HTTP_POST;
+	mros_http_post_fmt.len = strlen(MROS_PACKET_FMT_HTTP_POST) + 1;
+
+	mros_http_ok_fmt.fmt = MROS_PACKET_FMT_HTTP_OK;
+	mros_http_ok_fmt.len = strlen(MROS_PACKET_FMT_HTTP_OK) + 1;
+
+	mros_tcpros_topic_req_fmt.fmt = MROS_PACKET_FMT_TCPROS_TOPIC_REQ;
+	mros_tcpros_topic_req_fmt.len = strlen(MROS_PACKET_FMT_TCPROS_TOPIC_REQ) + 1;
+
+	mros_tcpros_topic_res_fmt.fmt = MROS_PACKET_FMT_TCPROS_TOPIC_RES;
+	mros_tcpros_topic_res_fmt.len = strlen(MROS_PACKET_FMT_TCPROS_TOPIC_RES) + 1;
+
+
+	return MROS_E_OK;
+}
+
+static void add_len(unsigned char *buf, mros_uint32 len)
+{
+    buf[0] = (unsigned char) (len);
+    buf[1] = (unsigned char) (len >> 8);
+    buf[2] = (unsigned char) (len >> 16);
+    buf[3] = (unsigned char) (len >> 24);
+}
+static mros_uint32 get_digit(mros_uint32 value)
+{
+	mros_uint32 digit = 0;
+	while (value != 0) {
+		value = value / 10;
+		digit++;
+	}
+	return digit;
+}
+
+static mRosSizeType get_arglen(mRosEncodeArgType *arg)
+{
+	mRosSizeType len = 0;
+	mRosSizeType i;
+	for (i = 0; i < arg->args_char; i++) {
+		len += strlen(arg->argv[i]) + 1;
+	}
+	for (i = 0; i < arg->args_int; i++) {
+		len += get_digit(arg->argi[i]) + 1;
+	}
+	return len;
+}
+
+
+
+mRosReturnType mros_packet_encode(mRosEncodeArgType *arg, mRosPacketType *packet)
+{
+	if (arg->type >= MROS_PACKET_DATA_NUM) {
+		return MROS_E_RANGE;
+	}
+	if (encode_table[arg->type] == MROS_NULL) {
+		return MROS_E_INVAL;
+	}
+	return encode_table[arg->type](arg, packet);
+}
+
+
+static mRosReturnType encode_register_publisher_req(mRosEncodeArgType *arg, mRosPacketType *packet)
+{
+	mRosSizeType len;
+	mRosSizeType off = 0;
+	mRosSizeType xml_len;
+
+	len = get_arglen(arg);
+	len += mros_http_post_fmt.len;
+	len += mros_xml_fmt_table[arg->type].len;
+
+	if (len > packet->total_size) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_NOMEM);
+		return MROS_E_NOMEM;
+	}
+	xml_len = snprintf(&packet->data[off], packet->total_size,
+			MROS_PACKET_FMT_XML_REGISTER_REQ,
+			arg->argv[0],
+			arg->argv[1],
+			arg->argv[2],
+			arg->argv[3],
+			arg->argv[4]);
+
+	packet->data_size = snprintf(&packet->data[off], packet->total_size,
+			MROS_PACKET_FMT_HTTP_POST MROS_PACKET_FMT_XML_REGISTER_REQ,
+			xml_len,
+			arg->argv[0],
+			arg->argv[1],
+			arg->argv[2],
+			arg->argv[3],
+			arg->argv[4]);
+
+	return MROS_E_OK;
+}
+
+static mRosReturnType encode_register_subscriber_req(mRosEncodeArgType *arg, mRosPacketType *packet)
+{
+	mRosSizeType len;
+	mRosSizeType off = 0;
+	mRosSizeType xml_len;
+
+	len = get_arglen(arg);
+	len += mros_http_post_fmt.len;
+	len += mros_xml_fmt_table[arg->type].len;
+
+	if (len > packet->total_size) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_NOMEM);
+		return MROS_E_NOMEM;
+	}
+	xml_len = snprintf(&packet->data[off], packet->total_size,
+			MROS_PACKET_FMT_XML_REGISTER_REQ,
+			arg->argv[0],
+			arg->argv[1],
+			arg->argv[2],
+			arg->argv[3],
+			arg->argv[4]);
+
+	packet->data_size = snprintf(&packet->data[off], packet->total_size,
+			MROS_PACKET_FMT_HTTP_POST MROS_PACKET_FMT_XML_REGISTER_REQ,
+			xml_len,
+			arg->argv[0],
+			arg->argv[1],
+			arg->argv[2],
+			arg->argv[3],
+			arg->argv[4]);
+	return MROS_E_OK;
+}
+
+static mRosReturnType encode_request_topic_req(mRosEncodeArgType *arg, mRosPacketType *packet)
+{
+	mRosSizeType len;
+	mRosSizeType off = 0;
+	mRosSizeType xml_len;
+
+	len = get_arglen(arg);
+	len += mros_http_post_fmt.len;
+	len += mros_xml_fmt_table[arg->type].len;
+
+	if (len > packet->total_size) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_NOMEM);
+		return MROS_E_NOMEM;
+	}
+	xml_len = snprintf(&packet->data[off], packet->total_size,
+			MROS_PACKET_FMT_XML_REQUEST_TOPIC_REQ,
+			arg->argv[0],
+			arg->argv[1],
+			arg->argv[2],
+			arg->argv[3]);
+
+	packet->data_size = snprintf(&packet->data[off], packet->total_size,
+			MROS_PACKET_FMT_HTTP_POST MROS_PACKET_FMT_XML_REQUEST_TOPIC_REQ,
+			xml_len,
+			arg->argv[0],
+			arg->argv[1],
+			arg->argv[2],
+			arg->argv[3]);
+
+	return MROS_E_OK;
+}
+mRosReturnType encode_request_topic_res(mRosEncodeArgType *arg, mRosPacketType *packet)
+{
+	mRosSizeType len;
+	mRosSizeType off = 0;
+	mRosSizeType xml_len;
+
+	len = get_arglen(arg);
+	len += mros_http_post_fmt.len;
+	len += mros_xml_fmt_table[arg->type].len;
+
+	if (len > packet->total_size) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_NOMEM);
+		return MROS_E_NOMEM;
+	}
+	xml_len = snprintf(&packet->data[off], packet->total_size,
+			MROS_PACKET_FMT_XML_REQUEST_TOPIC_RES,
+			arg->argv[0],
+			arg->argv[1],
+			arg->argi[0]);
+
+	packet->data_size = snprintf(&packet->data[off], packet->total_size,
+			MROS_PACKET_FMT_HTTP_OK MROS_PACKET_FMT_XML_REQUEST_TOPIC_RES,
+			xml_len,
+			arg->argv[0],
+			arg->argv[1],
+			arg->argi[0]);
+
+	return MROS_E_OK;
+}
+
+static mRosReturnType encode_tcpros_topic_req(mRosEncodeArgType *arg, mRosPacketType *packet)
+{
+	mRosSizeType len;
+	mRosSizeType off = 0;
+	mRosSizeType len_callerid;
+	mRosSizeType len_tcpnodelay;
+	mRosSizeType len_topic;
+	mRosSizeType len_type;
+	mRosSizeType len_md5sum;
+
+	len = get_arglen(arg);
+	len += mros_tcpros_topic_req_fmt.len;
+
+	if (len > packet->total_size) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_NOMEM);
+		return MROS_E_NOMEM;
+	}
+
+	len_callerid = snprintf(&packet->data[off], packet->total_size,
+			MROS_PACKET_FMT_TCPROS_CALLER_ID, arg->argv[0]);
+
+	len_tcpnodelay = snprintf(&packet->data[off], packet->total_size,
+			MROS_PACKET_FMT_TCPROS_TCPNODELAY, "1");
+
+	len_topic = snprintf(&packet->data[off], packet->total_size,
+			MROS_PACKET_FMT_TCPROS_TOPIC, arg->argv[1]);
+
+	len_type = snprintf(&packet->data[off], packet->total_size,
+			MROS_PACKET_FMT_TCPROS_TYPE, arg->argv[2]);
+
+	len_md5sum = snprintf(&packet->data[off], packet->total_size,
+			MROS_PACKET_FMT_TCPROS_MD5SUM, arg->argv[3]);
+
+	packet->data_size = snprintf(&packet->data[off], packet->total_size,
+			MROS_PACKET_FMT_TCPROS_TOPIC_REQ,
+			arg->argv[0],
+			arg->argv[1],
+			arg->argv[2],
+			arg->argv[3]);
+
+	off = 0;
+	add_len((unsigned char*)&packet->data[off], packet->data_size - 4);
+
+	off += 4U;
+	add_len((unsigned char*)&packet->data[off], len_callerid);
+
+	off += (4U + len_callerid);
+	add_len((unsigned char*)&packet->data[off], len_tcpnodelay);
+
+	off += (4U + len_tcpnodelay);
+	add_len((unsigned char*)&packet->data[off], len_topic);
+
+	off += (4U + len_topic);
+	add_len((unsigned char*)&packet->data[off], len_type);
+
+	off += (4U + len_type);
+	add_len((unsigned char*)&packet->data[off], len_md5sum);
+
+	return MROS_E_OK;
+}
+
+static mRosReturnType encode_tcpros_topic_res(mRosEncodeArgType *arg, mRosPacketType *packet)
+{
+	mRosSizeType len;
+	mRosSizeType off = 0;
+	mRosSizeType len_callerid;
+	mRosSizeType len_topic;
+	mRosSizeType len_type;
+	mRosSizeType len_md5sum;
+
+	len = get_arglen(arg);
+	len += mros_tcpros_topic_res_fmt.len;
+
+	if (len > packet->total_size) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_NOMEM);
+		return MROS_E_NOMEM;
+	}
+
+	len_callerid = snprintf(&packet->data[off], packet->total_size,
+			MROS_PACKET_FMT_TCPROS_CALLER_ID, arg->argv[0]);
+
+	len_topic = snprintf(&packet->data[off], packet->total_size,
+			MROS_PACKET_FMT_TCPROS_TOPIC, arg->argv[1]);
+
+	len_type = snprintf(&packet->data[off], packet->total_size,
+			MROS_PACKET_FMT_TCPROS_TYPE, arg->argv[2]);
+
+	len_md5sum = snprintf(&packet->data[off], packet->total_size,
+			MROS_PACKET_FMT_TCPROS_MD5SUM, arg->argv[3]);
+
+	packet->data_size = snprintf(&packet->data[off], packet->total_size,
+			MROS_PACKET_FMT_TCPROS_TOPIC_RES,
+			arg->argv[0],
+			arg->argv[1],
+			arg->argv[2],
+			arg->argv[3]);
+
+	off = 0;
+	add_len((unsigned char*)&packet->data[off], packet->data_size - 4);
+
+	off += 4U;
+	add_len((unsigned char*)&packet->data[off], len_callerid);
+
+	off += (4U + len_callerid);
+	add_len((unsigned char*)&packet->data[off], len_topic);
+
+	off += (4U + len_topic);
+	add_len((unsigned char*)&packet->data[off], len_type);
+
+	off += (4U + len_type);
+	add_len((unsigned char*)&packet->data[off], len_md5sum);
+
+	return MROS_E_OK;
+}
+
+static mRosReturnType encode_topic_data(mRosEncodeArgType *arg, mRosPacketType *packet)
+{
+	if (packet->total_size < MROS_TOPIC_RAWDATA_HEADER_SIZE) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_NOMEM);
+		return MROS_E_NOMEM;
+	}
+    add_len((unsigned char*)&packet->data[0], arg->argi[0] - MROS_TOPIC_RAWDATA_HEADER_SIZE);
+    packet->data_size = MROS_TOPIC_RAWDATA_HEADER_SIZE;
+
+	return MROS_E_OK;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/packet/template/version/kinetic/mros_packet_fmt_http.h
@@ -0,0 +1,38 @@
+#ifndef _MROS_PACKET_FMT_HTTP_H_
+#define _MROS_PACKET_FMT_HTTP_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MROS_PACKET_HTT_OK_CODE_LEN		3
+#define MROS_PACKET_HTT_OK_CODE			"200"
+
+/*
+ * ARG1: xml size
+ */
+#define MROS_PACKET_FMT_HTTP_POST	\
+	"POST /RPC2 HTTP/1.1\n"	\
+	"Host: \n"				\
+	"Accept-Encoding: \n"	\
+	"User-Agent: \n"		\
+	"Content-Type: \n"		\
+	"Content-Length: %u\n\n"	\
+
+
+/*
+ * ARG1: xml size
+ */
+#define MROS_PACKET_FMT_HTTP_OK		\
+		"HTTP/1.1 200 OK\n"			\
+		"Host: \n"					\
+		"Accept-Encoding: \n"		\
+		"User-Agent: \n"			\
+		"Content-Type: \n"			\
+		"Content-Length: %u\n\n"		\
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MROS_PACKET_FMT_HTTP_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/packet/template/version/kinetic/mros_packet_fmt_tcpros.h
@@ -0,0 +1,57 @@
+#ifndef _MROS_PACKET_FMT_TCPROS_H_
+#define _MROS_PACKET_FMT_TCPROS_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MROS_PACKET_FMT_TCPROS_CALLER_ID	"callerid=%s"
+#define MROS_PACKET_FMT_TCPROS_TOPIC		"topic=%s"
+#define MROS_PACKET_FMT_TCPROS_TYPE			"type=%s"
+#define MROS_PACKET_FMT_TCPROS_MD5SUM		"md5sum=%s"
+#define MROS_PACKET_FMT_TCPROS_TCPNODELAY	"tcp_nodelay=%s"
+
+/*
+ * ARG1: callerid
+ * ARG2: topic
+ * ARG3: type
+ * ARG4: md5sum
+ */
+#define MROS_PACKET_FMT_TCPROS_TOPIC_REQ		\
+	"SIZE"	\
+	"SIZE"	\
+	"callerid=%s"	\
+	"SIZE"	\
+	"tcp_nodelay=1"	\
+	"SIZE"	\
+	"topic=%s"	\
+	"SIZE"	\
+	"type=%s"		\
+	"SIZE"	\
+	"md5sum=%s"
+
+
+/*
+ * ARG1: callerid
+ * ARG2: topic
+ * ARG3: type
+ * ARG4: md5sum
+ */
+#define MROS_PACKET_FMT_TCPROS_TOPIC_RES	\
+	"SIZE"	\
+	"SIZE"	\
+	"callerid=%s"	\
+	"SIZE"	\
+	"topic=%s"	\
+	"SIZE"	\
+	"type=%s"		\
+	"SIZE"	\
+	"md5sum=%s"
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* _MROS_PACKET_FMT_TCPROS_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/packet/template/version/kinetic/mros_packet_fmt_xml.h
@@ -0,0 +1,111 @@
+#ifndef _MROS_PACKET_FMT_XML_H_
+#define _MROS_PACKET_FMT_XML_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MROS_PACKET_XMLRPC_REQ_END_STR		"</methodCall>"
+#define MROS_PACKET_XMLRPC_RES_END_STR		"</methodResponse>"
+
+/*
+ * ARGS1: method name
+ * ARGS2: node name
+ * ARGS3: topic
+ * ARGS4: type
+ * ARGS5: uri
+ */
+#define MROS_PACKET_FMT_XML_REGISTER_REQ		\
+	"<?xml version='1.0'?>\n"					\
+	"<methodCall>\n"						\
+		"<methodName>%s</methodName>\n"		\
+		"<params>\n"						\
+			"<param>\n"						\
+				"<value>%s</value>\n"		\
+			"</param>\n"					\
+			"<param>\n"						\
+				"<value>%s</value>\n"		\
+			"</param>\n"					\
+			"<param>\n"						\
+				"<value>%s</value>\n"		\
+			"</param>\n"					\
+			"<param>\n"						\
+				"<value>%s</value>\n"		\
+			"</param>\n"					\
+		"</params>"							\
+	"</methodCall>\n"
+
+/*
+ * ARGS1: method name
+ * ARGS2: node name
+ * ARGS3: topic
+ * ARGS4: tcpros
+ */
+#define MROS_PACKET_FMT_XML_REQUEST_TOPIC_REQ				\
+	"<?xml version='1.0'?>\n"								\
+	"<methodCall>\n"										\
+		"<methodName>%s</methodName>\n"						\
+		"<params>\n"										\
+			"<param>\n"										\
+				"<value>%s</value>\n"						\
+			"</param>\n"									\
+			"<param>\n"										\
+				"<value>%s</value>\n"						\
+			"</param>\n"									\
+			"<param>\n"										\
+				"<value>"									\
+					"<array>\n"								\
+						"<data>"							\
+							"<value>"						\
+								"<array>\n"					\
+									"<data>"				\
+										"<value>%s</value>"	\
+									"</data>\n"				\
+								"</array>"					\
+							"</value>"						\
+						"</data>\n"							\
+					"</array>"								\
+				"</value>\n"								\
+			"</param>\n"									\
+		"</params>"											\
+	"</methodCall>\n"										\
+
+/*
+ * ARGS1: TCPROS
+ * ARGS2: ipaddr
+ * ARGS3: port
+ */
+#define MROS_PACKET_FMT_XML_REQUEST_TOPIC_RES		\
+	"<?xml version='1.0'?>\n"		\
+	"<methodResponse>\n"	\
+		"<params>\n"	\
+			"<param>\n"	\
+				"<value>" \
+					"<array>" \
+						"<data>" \
+							"<value>" \
+								"<i4>1</i4>"	\
+							"</value>\n"	\
+							"<value></value>\n"	\
+							"<value>"	\
+								"<array>\n"	\
+									"<data>" \
+										"<value>%s</value>\n"	\
+										"<value>%s</value>\n"	\
+										"<value><i4>%u</i4></value>\n"	\
+									"</data>"	\
+								"</array>"	\
+							"</value>\n"	\
+						"</data>"	\
+					"</array>"	\
+				"</value>"	\
+			"</param>\n"	\
+		"</params>\n"	\
+	"</methodResponse>\n"	\
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MROS_PACKET_FMT_XML_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_client_rpc_cimpl.c
@@ -0,0 +1,140 @@
+#include "mros_protocol_client_rpc_cimpl.h"
+#include "mros_packet_encoder_cimpl.h"
+#include "mros_packet_decoder_cimpl.h"
+#include "mros_sys_config.h"
+
+static mRosReturnType mros_rpc_sendreply_xmlpacket(mRosEncodeArgType *arg, mRosCommTcpClientType *client, mRosPacketType *req, mRosPacketType *res)
+{
+	mRosReturnType ret;
+	mros_boolean is_end;
+	mRosSizeType rlen;
+
+	ret = mros_packet_encode(arg, req);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	ret = mros_comm_tcp_client_send_all(client, req->data, req->data_size, &rlen);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	res->data_size = 0;
+	do {
+		ret = mros_comm_tcp_client_receive(client, &res->data[res->data_size], (res->total_size - res->data_size),  &rlen);
+		if (ret != MROS_E_OK) {
+			return ret;
+		}
+		res->data_size += rlen;
+		if ((res->data_size + 1) >= res->total_size) {
+			ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_NOMEM);
+			return MROS_E_NOMEM;
+		}
+		is_end = mros_xmlpacket_has_response_end(res);
+	} while (is_end == MROS_FALSE);
+	res->data[res->data_size] = '\0';
+	return MROS_E_OK;
+}
+
+mRosReturnType mros_rpc_register_publisher(mRosCommTcpClientType *client, mRosRegisterTopicReqType *req, mRosRegisterTopicResType *res)
+{
+	mRosEncodeArgType arg;
+
+	arg.type = MROS_PACKET_DATA_REGISTER_PUBLISHER_REQ;
+	arg.args_int = 0;
+	arg.args_char = 5;
+	arg.argv[0] = "registerPublisher";
+	arg.argv[1] = req->node_name;
+	arg.argv[2] = req->topic_name;
+	arg.argv[3] = req->topic_typename;
+	arg.argv[4] = mros_uri_slave;
+	return mros_rpc_sendreply_xmlpacket(&arg, client, req->req_packet, res->reply_packet);
+}
+
+mRosReturnType mros_rpc_register_subscriber(mRosCommTcpClientType *client, mRosRegisterTopicReqType *req, mRosRegisterTopicResType *res)
+{
+	mRosEncodeArgType arg;
+
+	arg.type = MROS_PACKET_DATA_REGISTER_SUBSCRIBER_REQ;
+	arg.args_int = 0;
+	arg.args_char = 5;
+	arg.argv[0] = "registerSubscriber";
+	arg.argv[1] = req->node_name;
+	arg.argv[2] = req->topic_name;
+	arg.argv[3] = req->topic_typename;
+	arg.argv[4] = mros_uri_slave;
+	return mros_rpc_sendreply_xmlpacket(&arg, client, req->req_packet, res->reply_packet);
+}
+
+mRosReturnType mros_rpc_request_topic(mRosCommTcpClientType *client, mRosRequestTopicReqType *req, mRosRequestTopicResType *res)
+{
+	mRosEncodeArgType arg;
+
+	arg.type = MROS_PACKET_DATA_REQUEST_TOPIC_REQ;
+	arg.args_int = 0;
+	arg.args_char = 4;
+	arg.argv[0] = "requestTopic";
+	arg.argv[1] = req->node_name;
+	arg.argv[2] = req->topic_name;
+	arg.argv[3] = "TCPROS";
+
+	return mros_rpc_sendreply_xmlpacket(&arg, client, req->req_packet, res->reply_packet);
+}
+
+static mRosReturnType mros_rpc_sendreply_tcpros(mRosEncodeArgType *arg, mRosCommTcpClientType *client, mRosRcpRosReqType *req, mRosTcpRosResType *res)
+{
+	mRosPacketType packet;
+	mRosReturnType ret;
+	mRosSizeType len;
+	mRosSizeType rlen;
+	mros_int8 rawdata[MROS_TCPROS_RAWDATA_HEADER_SIZE];
+
+	ret = mros_packet_encode(arg, req->req_packet);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+
+	ret = mros_comm_tcp_client_send_all(client, req->req_packet->data, req->req_packet->data_size, &rlen);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+
+	ret = mros_comm_tcp_client_receive_all(client, rawdata, MROS_TCPROS_RAWDATA_HEADER_SIZE, &rlen);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	packet.total_size = MROS_TCPROS_RAWDATA_HEADER_SIZE;
+	packet.data_size = MROS_TCPROS_RAWDATA_HEADER_SIZE;
+	packet.data = rawdata;
+	ret = mros_tcprospacket_get_body_size(&packet, &len);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	ret = mros_comm_tcp_client_receive_all(client, res->reply_packet->data, len, &rlen);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	res->reply_packet->data_size = len;
+	res->result = MROS_E_OK;
+	return MROS_E_OK;
+}
+
+mRosReturnType mros_rpc_tcpros(mRosCommTcpClientType *client, mRosRcpRosReqType *req, mRosTcpRosResType *res)
+{
+	mRosEncodeArgType arg;
+
+	arg.type = MROS_PACKET_DATA_TCPROS_TOPIC_REQ;
+	arg.args_int = 0;
+	arg.args_char = 4;
+	arg.argv[0] = req->node_name;
+	arg.argv[1] = req->topic_name;
+	arg.argv[2] = req->topic_typename;
+	arg.argv[3] = req->md5sum;
+
+	return mros_rpc_sendreply_tcpros(&arg, client, req, res);
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_client_rpc_cimpl.h
@@ -0,0 +1,56 @@
+#ifndef _MROS_PROTOCOL_CLIENT_RPC_CIMPL_H_
+#define _MROS_PROTOCOL_CLIENT_RPC_CIMPL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_types.h"
+#include "mros_packet_cimpl.h"
+#include "mros_comm_tcp_client_cimpl.h"
+
+typedef struct {
+	const char*					node_name;
+	const char*					topic_name;
+	const char*					topic_typename;
+	mRosPacketType 				*req_packet;
+} mRosRegisterTopicReqType;
+
+typedef struct {
+	mRosReturnType 		result;
+	mRosPacketType 		*reply_packet;
+} mRosRegisterTopicResType;
+extern mRosReturnType mros_rpc_register_publisher(mRosCommTcpClientType *client, mRosRegisterTopicReqType *req, mRosRegisterTopicResType *res);
+extern mRosReturnType mros_rpc_register_subscriber(mRosCommTcpClientType *client, mRosRegisterTopicReqType *req, mRosRegisterTopicResType *res);
+
+typedef struct {
+	const char*			node_name;
+	const char*			topic_name;
+	mRosPacketType 		*req_packet;
+} mRosRequestTopicReqType;
+
+typedef struct {
+	mRosReturnType 		result;
+	mRosPacketType 		*reply_packet;
+} mRosRequestTopicResType;
+extern mRosReturnType mros_rpc_request_topic(mRosCommTcpClientType *client, mRosRequestTopicReqType *req, mRosRequestTopicResType *res);
+
+typedef struct {
+	const char*			node_name;
+	const char*			topic_name;
+	const char*			topic_typename;
+	const char*			md5sum;
+	mRosPacketType 		*req_packet;
+} mRosRcpRosReqType;
+
+typedef struct {
+	mRosReturnType 		result;
+	mRosPacketType 		*reply_packet;
+} mRosTcpRosResType;
+extern mRosReturnType mros_rpc_tcpros(mRosCommTcpClientType *client, mRosRcpRosReqType *req, mRosTcpRosResType *res);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _MROS_PROTOCOL_CLIENT_RPC_CIMPL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_master_cimpl.c
@@ -0,0 +1,252 @@
+#include "mros_protocol_master_cimpl.h"
+#include "mros_protocol_client_rpc_cimpl.h"
+#include "mros_protocol_server_proc_cimpl.h"
+#include "mros_topic_cimpl.h"
+#include "mros_topic_connector_factory_cimpl.h"
+#include "mros_protocol_operation_cimpl.h"
+#include "mros_packet_decoder_cimpl.h"
+#include "mros_packet_config.h"
+#include "mros_exclusive_area.h"
+#include "mros_wait_queue.h"
+#include "mros_sys_config.h"
+
+typedef union {
+	char buffer;
+	char buffer1[MROS_PACKET_MAXSIZE_REQ_REGISTER_PUBLISHER];
+	char buffer2[MROS_PACKET_MAXSIZE_RES_REGISTER_PUBLISHER];
+	char buffer3[MROS_PACKET_MAXSIZE_REQ_REGISTER_SUBSCRIBER];
+	char buffer4[MROS_PACKET_MAXSIZE_RES_REGISTER_SUBSCRIBER];
+	char buffer5[MROS_PACKET_MAXSIZE_REQ_REQUEST_TOPIC];
+	char buffer6[MROS_PACKET_MAXSIZE_RES_REQUEST_TOPIC];
+} mRosMasterPacketBufferType;
+
+static mRosMasterPacketBufferType mros_master_packet_buffer;
+
+typedef struct {
+	mRosProtocolMasterStateEnumType 	state;
+	mRosPacketType						register_packet;
+	mRosPacketType						reqtopic_packet;
+	mRosCommTcpClientType				master_comm;
+	mRosWaitListEntryType				*api_reqp;
+	mros_uint32							self_ipaddr;
+} mRosProtocolMasterType;
+
+static mRosProtocolMasterType mros_protocol_master MROS_MATTR_BSS_NOCLR;
+static mRosReturnType mros_protocol_master_register_publisher(mRosProtocolMasterRequestType *pub_req);
+static mRosReturnType mros_protocol_master_register_subscriber(mRosProtocolMasterRequestType *sub_req);
+
+mRosReturnType mros_protocol_master_init(void)
+{
+	mRosReturnType ret = mros_comm_tcp_client_init(&mros_protocol_master.master_comm, mros_master_ipaddr, MROS_MASTER_PORT_NO);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	mros_protocol_master.register_packet.total_size = sizeof(mros_master_packet_buffer);
+	mros_protocol_master.register_packet.data = &mros_master_packet_buffer.buffer;
+	mros_protocol_master.reqtopic_packet.total_size = sizeof(mros_master_packet_buffer);
+	mros_protocol_master.reqtopic_packet.data = &mros_master_packet_buffer.buffer;
+	mros_protocol_master.state = MROS_PROTOCOL_MASTER_STATE_WAITING;
+	mros_protocol_master.api_reqp = NULL;
+	ret = mros_comm_inet_get_ipaddr((const char *)mros_node_ipaddr, &mros_protocol_master.self_ipaddr);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	return MROS_E_OK;
+}
+
+void mros_protocol_master_run(void)
+{
+	mROsExclusiveUnlockObjType unlck_obj;
+	mros_exclusive_lock(&mros_exclusive_area, &unlck_obj);
+	while (MROS_TRUE) {
+		mros_protocol_master.api_reqp = NULL;
+		mRosWaitListEntryType *wait_entry = mros_server_queue_wait(&mros_master_wait_queue);
+		if (wait_entry == MROS_NULL) {
+			continue;
+		}
+		mros_protocol_master.api_reqp = wait_entry;
+		mRosProtocolMasterRequestType *req = (mRosProtocolMasterRequestType*)wait_entry->data.reqp;
+		switch (req->req_type) {
+		case MROS_PROTOCOL_MASTER_REQ_REGISTER_PUBLISHER:
+			mros_protocol_master_register_publisher(req);
+			mros_client_wakeup(mros_protocol_master.api_reqp);
+			break;
+		case MROS_PROTOCOL_MASTER_REQ_REGISTER_SUBSCRIBER:
+			mros_protocol_master_register_subscriber(req);
+			//register subscriber api_reqp wakeup is done on subscriber_run.
+			break;
+		default:
+			mros_client_wakeup(mros_protocol_master.api_reqp);
+			break;
+		}
+	}
+	mros_exclusive_unlock(&unlck_obj);
+	return;
+}
+
+static mRosReturnType mros_protocol_master_register(mRosProtocolMasterRequestType *req, mRosTopicConnectorEnumType type, mRosRegisterTopicResType *rpc_response)
+{
+	mRosReturnType ret;
+	mRosTopicConnectorType connector;
+	mRosRegisterTopicReqType rpc_request;
+
+	ret = mros_topic_connector_get(req->connector_obj,  &connector);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return MROS_E_INVAL;
+	}
+
+	rpc_response->reply_packet =  &mros_protocol_master.register_packet;
+
+	rpc_request.node_name = mros_node_name(connector.node_id);
+	rpc_request.req_packet = &mros_protocol_master.register_packet;
+	rpc_request.topic_name = mros_topic_get_topic_name(connector.topic_id);
+	rpc_request.topic_typename = mros_topic_get_topic_typename(connector.topic_id);
+	if (type == MROS_TOPIC_CONNECTOR_PUB) {
+		ret = mros_rpc_register_publisher(&mros_protocol_master.master_comm, &rpc_request, rpc_response);
+	}
+	else {
+		ret = mros_rpc_register_subscriber(&mros_protocol_master.master_comm, &rpc_request, rpc_response);
+	}
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	return ret;
+}
+
+static mRosReturnType mros_protocol_master_request_topic(mRosCommTcpClientType *client, mRosProtocolMasterRequestType *req, mRosRequestTopicResType *rpc_response)
+{
+	mRosReturnType ret;
+	mRosTopicConnectorType connector;
+	mRosRequestTopicReqType rpc_request;
+
+	ret = mros_topic_connector_get(req->connector_obj,  &connector);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_INVAL);
+		return MROS_E_INVAL;
+	}
+
+	rpc_response->reply_packet =  &mros_protocol_master.reqtopic_packet;
+
+	rpc_request.node_name = mros_node_name(connector.node_id);
+	rpc_request.req_packet = &mros_protocol_master.reqtopic_packet;
+	rpc_request.topic_name = mros_topic_get_topic_name(connector.topic_id);
+	ret = mros_rpc_request_topic(client, &rpc_request, rpc_response);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	ret = mros_xmlpacket_reqtopicres_result(rpc_response->reply_packet);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+
+	return mros_proc_request_outer_node_addition(connector.topic_id, rpc_response, mros_protocol_master.api_reqp);
+}
+
+static mRosReturnType mros_protocol_master_register_publisher(mRosProtocolMasterRequestType *pub_req)
+{
+	mRosReturnType ret;
+	mRosRegisterTopicResType rpc_response;
+
+	mros_protocol_master.state = MROS_PROTOCOL_MASTER_STATE_REGISTER_PUBLISHER;
+
+	ret = mros_comm_tcp_client_connect(&mros_protocol_master.master_comm);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		ROS_ERROR("ERROR: Unable to communicate with master!");
+		goto done;
+	}
+	ret = mros_protocol_master_register(pub_req, MROS_TOPIC_CONNECTOR_PUB, &rpc_response);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		goto done;
+	}
+	ret = mros_xmlpacket_pubres_result(rpc_response.reply_packet);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		goto done;
+	}
+
+done:
+	mros_comm_tcp_client_close(&mros_protocol_master.master_comm);
+	mros_protocol_master.state = MROS_PROTOCOL_MASTER_STATE_WAITING;
+
+	return ret;
+}
+
+
+static mRosReturnType mros_protocol_master_register_subscriber(mRosProtocolMasterRequestType *sub_req)
+{
+	mRosReturnType ret;
+	mRosRegisterTopicResType rpc_regc_res;
+	mRosRequestTopicResType rpc_topic_res;
+	mros_uint32 ipaddr;
+	mros_int32 port;
+	mRosPtrType ptr;
+	mros_boolean is_outer_node = MROS_FALSE;
+
+	mros_protocol_master.state = MROS_PROTOCOL_MASTER_STATE_REGISTER_SUBSCRIBER;
+
+	ret = mros_comm_tcp_client_connect(&mros_protocol_master.master_comm);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		ROS_ERROR("ERROR: Unable to communicate with master!");
+		goto done;
+	}
+
+	ret = mros_protocol_master_register(sub_req, MROS_TOPIC_CONNECTOR_SUB, &rpc_regc_res);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		goto done;
+	}
+	mros_comm_tcp_client_close(&mros_protocol_master.master_comm);
+	ret = mros_xmlpacket_subres_result(rpc_regc_res.reply_packet);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		goto done;
+	}
+
+	mros_protocol_master.state = MROS_PROTOCOL_MASTER_STATE_REQUESTING_TOPIC;
+	//TODO まだ出版ノードが存在しない場合は，非同期でマスタから情報をもらう
+	ptr = mros_xmlpacket_subres_get_first_uri(rpc_regc_res.reply_packet, &ipaddr, &port);
+	if (ptr == MROS_NULL) {
+		mRosTopicConnectorType connector;
+		(void)mros_topic_connector_get(sub_req->connector_obj,  &connector);
+		ROS_WARN("WARNING: topic [%s] does not appear to be published yet", mros_topic_get_topic_name(connector.topic_id));
+	}
+	while (ptr != MROS_NULL) {
+		mRosCommTcpClientType client;
+		ret = mros_comm_tcp_client_ip32_init(&client, ipaddr, port);
+		if (ret != MROS_E_OK) {
+			ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+			goto done;
+		}
+		ret = mros_comm_tcp_client_connect(&client);
+		if (ret != MROS_E_OK) {
+			ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+			goto done;
+		}
+		ret = mros_protocol_master_request_topic(&client, sub_req, &rpc_topic_res);
+		mros_comm_tcp_client_close(&client);
+		if (ret != MROS_E_OK) {
+			ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+			goto done;
+		}
+		is_outer_node = MROS_TRUE;
+		ptr = mros_xmlpacket_subres_get_next_uri(ptr, rpc_regc_res.reply_packet, &ipaddr, &port);
+	}
+
+done:
+	if (is_outer_node == MROS_FALSE) {
+		mros_client_wakeup(mros_protocol_master.api_reqp);
+	}
+	mros_comm_tcp_client_close(&mros_protocol_master.master_comm);
+	mros_protocol_master.state = MROS_PROTOCOL_MASTER_STATE_WAITING;
+
+	return ret;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_master_cimpl.h
@@ -0,0 +1,33 @@
+#ifndef _MROS_PROTOCOL_MASTER_CIMPL_H_
+#define _MROS_PROTOCOL_MASTER_CIMPL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_types.h"
+
+typedef enum {
+	MROS_PROTOCOL_MASTER_STATE_WAITING = 0,
+	MROS_PROTOCOL_MASTER_STATE_REGISTER_PUBLISHER,
+	MROS_PROTOCOL_MASTER_STATE_REGISTER_SUBSCRIBER,
+	MROS_PROTOCOL_MASTER_STATE_REQUESTING_TOPIC,
+} mRosProtocolMasterStateEnumType;
+
+typedef enum {
+	MROS_PROTOCOL_MASTER_REQ_REGISTER_PUBLISHER = 0,
+	MROS_PROTOCOL_MASTER_REQ_REGISTER_SUBSCRIBER,
+} mRosProtocolMasterRequestEnumType;
+
+typedef struct {
+	mRosProtocolMasterRequestEnumType 	req_type;
+	mRosContainerObjType 				connector_obj;
+} mRosProtocolMasterRequestType;
+
+extern mRosReturnType mros_protocol_master_init(void);
+extern void mros_protocol_master_run(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _MROS_PROTOCOL_MASTER_CIMPL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_operation_cimpl.c
@@ -0,0 +1,96 @@
+#include "mros_protocol_operation_cimpl.h"
+#include "mros_comm_tcp_client_factory_cimpl.h"
+#include "mros_packet_decoder_cimpl.h"
+#include "mros_packet_encoder_cimpl.h"
+#include "mros_sys_config.h"
+#include <string.h>
+
+mRosSizeType mros_protocol_get_buffersize(mRosSizeType body_size)
+{
+	return (body_size + MROS_TOPIC_RAWDATA_HEADER_SIZE);
+}
+
+char* mros_protocol_get_body(char *buffer)
+{
+	return &buffer[MROS_TOPIC_RAWDATA_HEADER_SIZE];
+}
+
+
+mRosReturnType mros_protocol_topic_data_send(mRosCommTcpClientType *client, const char *data, mRosSizeType datalen)
+{
+	mRosReturnType ret;
+	mRosSizeType res;
+	mRosPacketType packet;
+	mRosEncodeArgType arg;
+
+	packet.total_size = MROS_TOPIC_RAWDATA_HEADER_SIZE;
+	packet.data_size = 0;
+
+	packet.data = (char*)data;
+	arg.type = MROS_PACKET_DATA_TOPIC;
+	arg.args_int = 1;
+	arg.argi[0] = datalen;
+	arg.args_char = 0;
+	ret = mros_packet_encode(&arg, &packet);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	//send header & body
+	return mros_comm_tcp_client_send_all(client, data, datalen, &res);
+}
+
+mRosReturnType mros_protocol_topic_data_receive(mRosCommTcpClientType *client, mRosMemoryManagerType *mempool, mRosMemoryListEntryType **retp)
+{
+	mRosPacketType packet;
+	mRosSizeType len;
+	mRosSizeType res;
+	mRosReturnType ret;
+	mRosMemoryListEntryType *mem_entryp;
+	mros_int8 rawdata[MROS_TOPIC_RAWDATA_HEADER_SIZE];
+	*retp = MROS_NULL;
+
+	ret = mros_comm_socket_wait_readable(&client->socket, 0);
+	if (ret != MROS_E_OK) {
+		//ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	//receive header
+	ret = mros_comm_tcp_client_receive_all(client, rawdata, MROS_TOPIC_RAWDATA_HEADER_SIZE, &res);
+	if (ret != MROS_E_OK) {
+		//ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	//decode header
+	packet.total_size = MROS_TOPIC_RAWDATA_HEADER_SIZE;
+	packet.data_size = MROS_TOPIC_RAWDATA_HEADER_SIZE;
+	packet.data = rawdata;
+	ret = mros_topicpacket_get_body_size(&packet, &len);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	//receive body
+	ret = mros_mem_alloc(mempool, len + MROS_TOPIC_RAWDATA_HEADER_SIZE, &mem_entryp);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	memcpy(&mem_entryp->data.memp[0], rawdata, MROS_TOPIC_RAWDATA_HEADER_SIZE);
+
+	ret = mros_comm_tcp_client_receive_all(client, &mem_entryp->data.memp[MROS_TOPIC_RAWDATA_HEADER_SIZE], len, &res);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	*retp = mem_entryp;
+	return MROS_E_OK;
+}
+
+void mros_protocol_client_obj_free(void* reqp)
+{
+	mros_comm_tcp_client_free((mRosCommTcpClientListReqEntryType *)reqp);
+	return;
+}
+
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_operation_cimpl.h
@@ -0,0 +1,26 @@
+#ifndef _MROS_PROTOCOL_OPERATION_CIMPL_H_
+#define _MROS_PROTOCOL_OPERATION_CIMPL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_memory.h"
+#include "mros_comm_tcp_client_cimpl.h"
+
+extern mRosReturnType mros_protocol_topic_data_send(mRosCommTcpClientType *client, const char *data, mRosSizeType datalen);
+extern mRosReturnType mros_protocol_topic_data_receive(mRosCommTcpClientType *client, mRosMemoryManagerType *mempool, mRosMemoryListEntryType **retp);
+
+extern mRosSizeType mros_protocol_get_buffersize(mRosSizeType body_size);
+extern char* mros_protocol_get_body(char *buffer);
+
+/*
+ * reqp: mRosCommTcpClientListReqEntryType
+ */
+extern void mros_protocol_client_obj_free(void* reqp);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _MROS_PROTOCOL_OPERATION_CIMPL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_publish_cimpl.c
@@ -0,0 +1,73 @@
+#include "mros_protocol_publish_cimpl.h"
+#include "mros_protocol_server_proc_cimpl.h"
+#include "mros_comm_tcp_client_cimpl.h"
+#include "mros_comm_tcp_server_cimpl.h"
+#include "mros_exclusive_area.h"
+#include "mros_sys_config.h"
+
+typedef union {
+	char buffer;
+	char buffer1[MROS_PACKET_MAXSIZE_REQ_TCPROS];
+	char buffer2[MROS_PACKET_MAXSIZE_RES_TCPROS];
+} mRosPublishPacketBufferType;
+static mRosPublishPacketBufferType mros_publish_packet_buffer MROS_MATTR_BSS_NOCLR;
+
+typedef struct {
+	mRosProtocolPublishStateEnumType 	state;
+	mRosPacketType						packet;
+	mRosCommTcpServerType				server_comm;
+	mRosCommTcpClientType				client_comm;
+} mRosProtocolPublishType;
+
+static mRosProtocolPublishType mros_protocol_publish MROS_MATTR_BSS_NOCLR;
+
+mRosReturnType mros_protocol_publish_init(void)
+{
+	mRosReturnType ret = mros_comm_tcp_server_init(&mros_protocol_publish.server_comm);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	mros_protocol_publish.packet.total_size = sizeof(mRosPublishPacketBufferType);
+	mros_protocol_publish.packet.data = &mros_publish_packet_buffer.buffer;
+	mros_protocol_publish.state = MROS_PROTOCOL_PUBLISH_STATE_WAITING;
+	ret =  mros_comm_tcp_server_bind(&mros_protocol_publish.server_comm, mros_publisher_port_no);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	ret = mros_comm_tcp_server_listen(&mros_protocol_publish.server_comm, MROS_COMM_TCP_SERVER_LISTEN_MAX_DEFAULT_VALUE);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	return MROS_E_OK;
+}
+
+void mros_protocol_publish_run(void)
+{
+	mRosReturnType ret;
+	mROsExclusiveUnlockObjType unlck_obj;
+
+	while (MROS_TRUE) {
+		mros_protocol_publish.state = MROS_PROTOCOL_PUBLISH_STATE_WAITING;
+		ret = mros_comm_tcp_server_accept(&mros_protocol_publish.server_comm, &mros_protocol_publish.client_comm);
+		if (ret != MROS_E_OK) {
+			continue;
+		}
+		mros_protocol_publish.state = MROS_PROTOCOL_PUBLISH_STATE_STARTING_PUBLISH_TOPIC;
+		ret = mros_proc_tcpros_receive(&mros_protocol_publish.client_comm, &mros_protocol_publish.packet);
+		if (ret != MROS_E_OK) {
+			ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+			mros_comm_tcp_client_close(&mros_protocol_publish.client_comm);
+			continue;
+		}
+		mros_exclusive_lock(&mros_exclusive_area, &unlck_obj);
+		ret = mros_proc_pub_tcpros(&mros_protocol_publish.client_comm, &mros_protocol_publish.packet);
+		mros_exclusive_unlock(&unlck_obj);
+		if (ret != MROS_E_OK) {
+			ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		}
+	}
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_publish_cimpl.h
@@ -0,0 +1,22 @@
+#ifndef _MROS_PROTOCOL_PUBLISH_CIMPL_H_
+#define _MROS_PROTOCOL_PUBLISH_CIMPL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_types.h"
+
+typedef enum {
+	MROS_PROTOCOL_PUBLISH_STATE_WAITING = 0,
+	MROS_PROTOCOL_PUBLISH_STATE_STARTING_PUBLISH_TOPIC,
+} mRosProtocolPublishStateEnumType;
+
+
+extern mRosReturnType mros_protocol_publish_init(void);
+extern void mros_protocol_publish_run(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _MROS_PROTOCOL_PUBLISH_CIMPL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_server_proc_cimpl.c
@@ -0,0 +1,384 @@
+#include "mros_protocol_server_proc_cimpl.h"
+#include "mros_protocol_operation_cimpl.h"
+#include "mros_comm_tcp_client_cimpl.h"
+#include "mros_topic_cimpl.h"
+#include "mros_topic_connector_factory_cimpl.h"
+#include "mros_packet_encoder_cimpl.h"
+#include "mros_packet_decoder_cimpl.h"
+#include "mros_exclusive_area.h"
+#include "mros_wait_queue.h"
+#include "mros_sys_config.h"
+#include <string.h>
+
+static mRosPacketDecodedRequestType mros_proc_slave_decoded_requst MROS_MATTR_BSS_NOCLR;
+
+mRosReturnType mros_proc_init(void)
+{
+	return MROS_E_OK;
+}
+
+mRosReturnType mros_proc_receive(mRosCommTcpClientType *client, mRosPacketType *packet)
+{
+	mRosReturnType ret;
+	mRosSizeType res;
+	mros_boolean is_end;
+
+	packet->data_size = 0;
+	do {
+		ret = mros_comm_tcp_client_receive(client, &packet->data[packet->data_size], (packet->total_size - packet->data_size),  &res);
+		if (ret != MROS_E_OK) {
+			ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+			break;
+		}
+		packet->data_size += res;
+		if ((packet->data_size + 1) >= packet->total_size) {
+			ret = MROS_E_NOMEM;
+			ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+			break;
+		}
+		is_end = mros_xmlpacket_has_request_end(packet);
+	} while (is_end == MROS_FALSE);
+	packet->data[packet->data_size] = '\0';
+	return ret;
+}
+mRosReturnType mros_proc_tcpros_receive(mRosCommTcpClientType *client, mRosPacketType *packet)
+{
+	mRosReturnType ret;
+	mRosSizeType res;
+	mRosPacketType header_packet;
+	mros_int8 rawdata[MROS_TCPROS_RAWDATA_HEADER_SIZE];
+
+	ret = mros_comm_tcp_client_receive_all(client, rawdata, MROS_TCPROS_RAWDATA_HEADER_SIZE, &res);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+
+	header_packet.total_size = MROS_TCPROS_RAWDATA_HEADER_SIZE;
+	header_packet.data_size = MROS_TCPROS_RAWDATA_HEADER_SIZE;
+	header_packet.data = rawdata;
+	ret = mros_tcprospacket_get_body_size(&header_packet, &res);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	packet->data_size = 0;
+	ret = mros_comm_tcp_client_receive_all(client, packet->data, res, &res);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	packet->data_size = res;
+	return ret;
+}
+
+mRosNodeIdType mros_proc_connector_get_first(mRosTopicIdType topic_id, mRosTopicConnectorEnumType type, mRosNodeEnumType nodeType, mRosTopicOuterTcpConnectionType *tcp_conn)
+{
+	mRosContainerObjType obj;
+	mRosContainerObjType topic_obj;
+	mRosTopicConnectorManagerType *mgrp;
+	mRosCommTcpClientListReqEntryType *connection;
+	mRosTopicConnectorType connector;
+
+	mgrp = mros_topic_connector_factory_get(type);
+	if (mgrp == MROS_NULL) {
+		return MROS_ID_NONE;
+	}
+	topic_obj = mros_topic_connector_get_topic_obj(mgrp, topic_id);
+	if (topic_obj == MROS_COBJ_NULL) {
+		return MROS_ID_NONE;
+	}
+	obj = mros_topic_connector_get_first(mgrp, nodeType, topic_obj);
+	while (obj != MROS_COBJ_NULL) {
+		(void)mros_topic_connector_get(obj,  &connector);
+		if (tcp_conn != MROS_NULL) {
+			 (void)mros_topic_connector_get_connection(obj, &connection);
+			 if (connection != MROS_NULL) {
+				 if ( (connection->data.client.remote.sin_port == tcp_conn->port) &&
+						 (connection->data.client.remote.sin_addr.s_addr == tcp_conn->ipaddr) ) {
+					return connector.node_id;
+				 }
+			 }
+		}
+		else {
+			return connector.node_id;
+		}
+		obj = mros_topic_connector_get_next(mgrp, topic_obj, obj);
+	}
+	return MROS_ID_NONE;
+}
+
+static mRosReturnType mros_proc_slave_request_topic(mRosCommTcpClientType *client, mRosPacketType *packet)
+{
+	mRosReturnType ret;
+	mRosNodeIdType node_id;
+	mRosTopicIdType topic_id;
+	mRosSizeType res;
+
+	if (mros_proc_slave_decoded_requst.request.topic.topic_name.res.len >= MROS_TOPIC_NAME_MAXLEN) {
+		return MROS_E_INVAL;
+	}
+	mros_proc_slave_decoded_requst.request.topic.topic_name.res.head[mros_proc_slave_decoded_requst.request.topic.topic_name.res.len] = '\0';
+	ret = mros_topic_get((const char*)&mros_proc_slave_decoded_requst.request.topic.topic_name.res.head[0], &topic_id);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	node_id = mros_proc_connector_get_first(topic_id, MROS_TOPIC_CONNECTOR_PUB, MROS_NODE_TYPE_INNER, NULL);
+	if (node_id == MROS_ID_NONE) {
+		//TODO error reply...
+		// original code does not support this case...
+	}
+	else {
+		mRosEncodeArgType arg;
+		arg.type = MROS_PACKET_DATA_REQUEST_TOPIC_RES;
+		arg.args_int = 1;
+		arg.argi[0] = mros_publisher_port_no;
+		arg.args_char = 2;
+		arg.argv[0] ="TCPROS";
+		arg.argv[1] = mros_node_ipaddr;
+		ret = mros_packet_encode(&arg, packet);
+		if (ret != MROS_E_OK) {
+			ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+			return ret;
+		}
+		ret = mros_comm_tcp_client_send_all(client, packet->data, packet->data_size, &res);
+	}
+
+	return ret;
+}
+
+mRosReturnType mros_proc_request_outer_node_addition(mRosTopicIdType topic_id, mRosRequestTopicResType *rpc_response, void *api_reqp)
+{
+	mRosReturnType ret = MROS_E_OK;
+	mRosPtrType ptr;
+	mRosTopicOuterTcpConnectionType tcp_conn;
+
+	ptr = mros_xmlpacket_reqtopicres_get_first_uri(rpc_response->reply_packet, &tcp_conn.ipaddr, &tcp_conn.port);
+	while (ptr != MROS_NULL) {
+		mRosCommTcpClientListReqEntryType *req = mros_comm_tcp_client_alloc();
+		if (req == MROS_NULL) {
+			ret = MROS_E_NOMEM;
+			ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+			goto done;
+		}
+		if (mros_proc_connector_get_first(topic_id, MROS_TOPIC_CONNECTOR_PUB, MROS_NODE_TYPE_OUTER, &tcp_conn) != MROS_ID_NONE) {
+			mros_comm_tcp_client_free(req);
+			ptr = mros_xmlpacket_reqtopicres_get_next_uri(ptr, rpc_response->reply_packet, &tcp_conn.ipaddr, &tcp_conn.port);
+			continue;
+		}
+		req->data.reqobj.ipaddr = tcp_conn.ipaddr;
+		req->data.reqobj.port = tcp_conn.port;
+		req->data.reqobj.topic_id = topic_id;
+		req->data.op.free = mros_protocol_client_obj_free;
+		req->data.op.topic_data_receive = mros_protocol_topic_data_receive;
+		req->data.op.topic_data_send = mros_protocol_topic_data_send;
+		mros_client_wait_entry_init(&req->data.reqobj.waitobj, req);
+		req->data.reqobj.api_reqp = api_reqp;
+
+		mros_client_put_request(&mros_subscribe_wait_queue, &req->data.reqobj.waitobj);
+
+		ptr = mros_xmlpacket_reqtopicres_get_next_uri(ptr, rpc_response->reply_packet, &tcp_conn.ipaddr, &tcp_conn.port);
+	}
+
+done:
+	return ret;
+}
+
+static mRosReturnType mros_proc_slave_publisher_update_do_request_topic(mRosTopicIdType topic_id, mRosTopicOuterTcpConnectionType *tcp_conn, mRosPacketType *packet)
+{
+	mRosReturnType ret;
+	mRosRequestTopicReqType rpc_request;
+	mRosRequestTopicResType rpc_response;
+	mRosCommTcpClientType slave_client;
+	mRosTopicConnectorType sub_connector;
+
+	sub_connector.topic_id = topic_id;
+	sub_connector.node_id = mros_proc_connector_get_first(topic_id, MROS_TOPIC_CONNECTOR_SUB, MROS_NODE_TYPE_INNER, MROS_NULL);
+	if (sub_connector.node_id == MROS_ID_NONE) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_NOENT);
+		return MROS_E_NOENT;
+	}
+
+	rpc_request.req_packet = packet;
+	rpc_response.reply_packet =  packet;
+
+	rpc_request.node_name = mros_node_name(sub_connector.node_id);
+	rpc_request.topic_name = mros_topic_get_topic_name(topic_id);
+
+	ret = mros_comm_tcp_client_ip32_init(&slave_client, tcp_conn->ipaddr, tcp_conn->port);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	ret = mros_comm_tcp_client_connect(&slave_client);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	ret = mros_rpc_request_topic(&slave_client, &rpc_request, &rpc_response);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	ret = mros_xmlpacket_reqtopicres_result(rpc_response.reply_packet);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	mros_comm_tcp_client_close(&slave_client);
+	ret = mros_proc_request_outer_node_addition(topic_id, &rpc_response, MROS_NULL);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	return MROS_E_OK;
+}
+
+static mRosReturnType mros_proc_slave_publisher_update(mRosCommTcpClientType *client, mRosPacketType *packet, mros_uint32 self_ipaddr)
+{
+	mRosReturnType ret;
+	mRosTopicIdType topic_id;
+	mRosPtrType ptr;
+	mRosTopicOuterTcpConnectionType tcp_conn;
+
+	if (mros_proc_slave_decoded_requst.request.topic.topic_name.res.len >= MROS_TOPIC_NAME_MAXLEN) {
+		return MROS_E_INVAL;
+	}
+	mros_proc_slave_decoded_requst.request.topic.topic_name.res.head[mros_proc_slave_decoded_requst.request.topic.topic_name.res.len] = '\0';
+	ret = mros_topic_get((const char*)&mros_proc_slave_decoded_requst.request.topic.topic_name.res.head[0], &topic_id);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+
+	ret = MROS_E_OK;
+	ptr = mros_xmlpacket_pubupreq_get_first_uri(&mros_proc_slave_decoded_requst.request.publisher_update.topic_name.res.tail[1], &tcp_conn.ipaddr, &tcp_conn.port);
+	while (ptr != MROS_NULL) {
+		if (mros_proc_connector_get_first(topic_id, MROS_TOPIC_CONNECTOR_PUB, MROS_NODE_TYPE_OUTER, &tcp_conn) != MROS_ID_NONE) {
+			ptr = mros_xmlpacket_pubupreq_get_next_uri(ptr, packet, &tcp_conn.ipaddr, &tcp_conn.port);
+			continue;
+		}
+		ret = mros_proc_slave_publisher_update_do_request_topic(topic_id, &tcp_conn, packet);
+		if (ret != MROS_E_OK) {
+			ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+			return ret;
+		}
+		ptr = mros_xmlpacket_pubupreq_get_next_uri(ptr, packet, &tcp_conn.ipaddr, &tcp_conn.port);
+	}
+
+	return ret;
+}
+
+mRosReturnType mros_proc_slave(mRosCommTcpClientType *client, mRosPacketType *packet, mros_uint32 self_ipaddr)
+{
+	mRosReturnType ret = MROS_E_INVAL;
+
+	mRosPacketDataEnumType type = mros_xmlpacket_slave_request_decode(packet, &mros_proc_slave_decoded_requst);
+	switch (type) {
+	case MROS_PACKET_DATA_REQUEST_TOPIC_REQ:
+		ret = mros_proc_slave_request_topic(client, packet);
+		break;
+	case MROS_PACKET_DATA_PUBLISHER_UPDATE_REQ:
+		ret = mros_proc_slave_publisher_update(client, packet, self_ipaddr);
+		break;
+	default:
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		break;
+	}
+
+	return ret;
+}
+
+static mRosReturnType mros_proc_add_outersub_connector(mRosCommTcpClientType *client, mRosTopicIdType topic_id)
+{
+	mRosReturnType ret = MROS_E_INVAL;
+	mRosTopicConnectorType connector;
+	mRosContainerObjType cobj;
+	mRosTopicConnectorManagerType *sub_mgrp = mros_topic_connector_factory_get(MROS_TOPIC_CONNECTOR_SUB);
+	if (sub_mgrp == MROS_NULL) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	connector.topic_id = topic_id;
+	connector.func_id = (mRosFuncIdType)MROS_ID_NONE;
+	ret = mros_node_create_outer(&connector.node_id);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return MROS_E_NOENT;
+	}
+	ret = mros_topic_connector_add(sub_mgrp, &connector, MROS_OUTER_CONNECTOR_QUEUE_MAXLEN, MROS_NULL);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	cobj = mros_topic_connector_get_obj(sub_mgrp, &connector);
+
+	mRosCommTcpClientListReqEntryType *client_entry = mros_comm_tcp_client_alloc_copy(client);
+	if (client_entry == MROS_NULL) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, MROS_E_NOENT);
+		return MROS_E_NOENT;
+	}
+	client_entry->data.op.free = mros_protocol_client_obj_free;
+	client_entry->data.op.topic_data_receive = mros_protocol_topic_data_receive;
+	client_entry->data.op.topic_data_send = mros_protocol_topic_data_send;
+	ret = mros_topic_connector_set_connection(cobj, client_entry);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	return MROS_E_OK;
+}
+
+
+mRosReturnType mros_proc_pub_tcpros(mRosCommTcpClientType *client, mRosPacketType *packet)
+{
+	mRosReturnType ret;
+	mRosNodeIdType node_id;
+	mRosTopicIdType topic_id;
+	mRosSizeType res;
+	mRosTcpRosPacketType tcpros_packet;
+
+	ret = mros_tcprospacket_decode(packet, &tcpros_packet);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	ret = mros_topic_get((const char*)&tcpros_packet.topic[0], &topic_id);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	node_id = mros_proc_connector_get_first(topic_id, MROS_TOPIC_CONNECTOR_PUB, MROS_NODE_TYPE_INNER, NULL);
+	if (node_id == MROS_ID_NONE) {
+		//TODO error reply...
+		// original code does not support this case...
+		ROS_ERROR("%s %u : not supported reply error", __FUNCTION__, __LINE__);
+	}
+	else {
+		mRosEncodeArgType arg;
+		const char* md5sum;
+		(void)mros_topic_get_md5sum(topic_id, &md5sum);
+		arg.type = MROS_PACKET_DATA_TCPROS_TOPIC_RES;
+		arg.args_int = 0;
+		arg.args_char = 4;
+		arg.argv[0] = mros_node_name(node_id);
+		arg.argv[1] = mros_topic_get_topic_name(topic_id);
+		arg.argv[2] = mros_topic_get_topic_typename(topic_id);
+		arg.argv[3] = md5sum;
+		ret = mros_packet_encode(&arg, packet);
+		if (ret != MROS_E_OK) {
+			ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+			return ret;
+		}
+		ret = mros_comm_tcp_client_send_all(client, packet->data, packet->data_size, &res);
+		if (ret != MROS_E_OK) {
+			ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+			return ret;
+		}
+		(void)mros_proc_add_outersub_connector(client, topic_id);
+	}
+
+	return ret;
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_server_proc_cimpl.h
@@ -0,0 +1,30 @@
+#ifndef _MROS_PROTOCOL_SERVER_PROC_CIMPL_H_
+#define _MROS_PROTOCOL_SERVER_PROC_CIMPL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_packet_cimpl.h"
+#include "mros_comm_tcp_client_cimpl.h"
+#include "mros_protocol_client_rpc_cimpl.h"
+#include "mros_node_cimpl.h"
+#include "mros_topic_connector_factory_cimpl.h"
+
+extern mRosReturnType mros_proc_init(void);
+extern mRosReturnType mros_proc_receive(mRosCommTcpClientType *client, mRosPacketType *packet);
+extern mRosReturnType mros_proc_tcpros_receive(mRosCommTcpClientType *client, mRosPacketType *packet);
+extern mRosReturnType mros_proc_slave(mRosCommTcpClientType *client, mRosPacketType *packet, mros_uint32 self_ipaddr);
+extern mRosReturnType mros_proc_pub_tcpros(mRosCommTcpClientType *client, mRosPacketType *packet);
+extern mRosReturnType mros_proc_request_outer_node_addition(mRosTopicIdType topic_id, mRosRequestTopicResType *rpc_response, void *api_reqp);
+typedef struct {
+	mros_uint32 ipaddr;
+	mros_int32	port;
+} mRosTopicOuterTcpConnectionType;
+extern mRosNodeIdType mros_proc_connector_get_first(mRosTopicIdType topic_id, mRosTopicConnectorEnumType type, mRosNodeEnumType nodeType, mRosTopicOuterTcpConnectionType *tcp_conn);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _MROS_PROTOCOL_SERVER_PROC_CIMPL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_slave_cimpl.c
@@ -0,0 +1,85 @@
+#include "mros_protocol_slave_cimpl.h"
+#include "mros_protocol_server_proc_cimpl.h"
+#include "mros_comm_tcp_client_cimpl.h"
+#include "mros_comm_tcp_server_cimpl.h"
+#include "mros_packet_encoder_cimpl.h"
+#include "mros_exclusive_area.h"
+#include "mros_sys_config.h"
+
+typedef union {
+	char buffer;
+	char buffer1[MROS_PACKET_MAXSIZE_REQ_REQUEST_TOPIC];
+	char buffer2[MROS_PACKET_MAXSIZE_RES_REQUEST_TOPIC];
+	char buffer3[MROS_PACKET_MAXSIZE_REQ_PUBLISHER_UPDATE];
+} mRosSlavePacketBufferType;
+static mRosSlavePacketBufferType mros_slave_packet_buffer MROS_MATTR_BSS_NOCLR;
+
+typedef struct {
+	mRosProtocolSlaveStateEnumType 		state;
+	mRosEncodeArgType 					arg;
+	mRosPacketType						packet;
+	mRosCommTcpServerType				server_comm;
+	mRosCommTcpClientType				client_comm;
+	mros_uint32							self_ipaddr;
+} mRosProtocolSlaveType;
+
+static mRosProtocolSlaveType mros_protocol_slave MROS_MATTR_BSS_NOCLR;
+
+mRosReturnType mros_protocol_slave_init(void)
+{
+	mRosReturnType ret = mros_comm_tcp_server_init(&mros_protocol_slave.server_comm);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+
+	mros_protocol_slave.packet.total_size = sizeof(mRosSlavePacketBufferType);
+	mros_protocol_slave.packet.data = &mros_slave_packet_buffer.buffer;
+	mros_protocol_slave.state = MROS_PROTOCOL_SLAVE_STATE_WAITING;
+	ret =  mros_comm_tcp_server_bind(&mros_protocol_slave.server_comm, mros_slave_port_no);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	ret = mros_comm_tcp_server_listen(&mros_protocol_slave.server_comm, MROS_COMM_TCP_SERVER_LISTEN_MAX_DEFAULT_VALUE);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	ret = mros_comm_inet_get_ipaddr((const char *)mros_node_ipaddr, &mros_protocol_slave.self_ipaddr);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	return MROS_E_OK;
+}
+
+void mros_protocol_slave_run(void)
+{
+	mRosReturnType ret;
+	mROsExclusiveUnlockObjType unlck_obj;
+
+	while (MROS_TRUE) {
+		mros_protocol_slave.state = MROS_PROTOCOL_SLAVE_STATE_WAITING;
+		ret = mros_comm_tcp_server_accept(&mros_protocol_slave.server_comm, &mros_protocol_slave.client_comm);
+		if (ret != MROS_E_OK) {
+			continue;
+		}
+		mros_protocol_slave.state = MROS_PROTOCOL_SLAVE_STATE_REPLYING_REQUEST_TOPIC;
+		ret = mros_proc_receive(&mros_protocol_slave.client_comm, &mros_protocol_slave.packet);
+		if (ret != MROS_E_OK) {
+			ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+			mros_comm_tcp_client_close(&mros_protocol_slave.client_comm);
+			continue;
+		}
+		mros_exclusive_lock(&mros_exclusive_area, &unlck_obj);
+		ret = mros_proc_slave(&mros_protocol_slave.client_comm, &mros_protocol_slave.packet, mros_protocol_slave.self_ipaddr);
+		mros_exclusive_unlock(&unlck_obj);
+		if (ret != MROS_E_OK) {
+			ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+			continue;
+		}
+		mros_comm_tcp_client_close(&mros_protocol_slave.client_comm);
+	}
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_slave_cimpl.h
@@ -0,0 +1,22 @@
+#ifndef _MROS_PROTOCOL_SLAVE_CIMPL_H_
+#define _MROS_PROTOCOL_SLAVE_CIMPL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_types.h"
+
+typedef enum {
+	MROS_PROTOCOL_SLAVE_STATE_WAITING = 0,
+	MROS_PROTOCOL_SLAVE_STATE_REPLYING_REQUEST_TOPIC,
+} mRosProtocolSlaveStateEnumType;
+
+
+extern mRosReturnType mros_protocol_slave_init(void);
+extern void mros_protocol_slave_run(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _MROS_PROTOCOL_SLAVE_CIMPL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_subscribe_cimpl.c
@@ -0,0 +1,126 @@
+#include "mros_protocol_subscribe_cimpl.h"
+#include "mros_protocol_client_rpc_cimpl.h"
+#include "mros_protocol_server_proc_cimpl.h"
+#include "mros_topic_cimpl.h"
+#include "mros_topic_connector_factory_cimpl.h"
+#include "mros_topic_runner_cimpl.h"
+#include "mros_node_cimpl.h"
+#include "mros_comm_tcp_client_factory_cimpl.h"
+#include "mros_packet_config.h"
+#include "mros_exclusive_area.h"
+#include "mros_wait_queue.h"
+#include "mros_sys_config.h"
+
+typedef union {
+	char buffer;
+	char buffer1[MROS_PACKET_MAXSIZE_REQ_TCPROS];
+	char buffer2[MROS_PACKET_MAXSIZE_RES_TCPROS];
+} mRosSubscribePacketTcpRosBufferType;
+
+
+typedef struct {
+	mRosProtocolSubscribeStateEnumType 	state;
+	mRosPacketType						tcpros_packet;
+	mRosTopicConnectorManagerType 		*pub_mgrp;// for outer pub
+} mRosProtocolSubscribeType;
+
+static mRosProtocolSubscribeType mros_protocol_subscribe MROS_MATTR_BSS_NOCLR;
+static mRosSubscribePacketTcpRosBufferType mros_subscribe_packet_tcpros_buffer MROS_MATTR_BSS_NOCLR;
+
+mRosReturnType mros_protocol_subscribe_init(void)
+{
+	mros_protocol_subscribe.tcpros_packet.total_size = sizeof(mRosSubscribePacketTcpRosBufferType);
+	mros_protocol_subscribe.tcpros_packet.data = &mros_subscribe_packet_tcpros_buffer.buffer;
+	mros_protocol_subscribe.state = MROS_PROTOCOL_SUBSCRIBE_STATE_WAITING;
+	mros_protocol_subscribe.pub_mgrp = mros_topic_connector_factory_get(MROS_TOPIC_CONNECTOR_PUB);
+	return MROS_E_OK;
+}
+
+void mros_protocol_subscribe_run(void)
+{
+	mRosReturnType ret;
+	mRosTopicConnectorType connector;
+	mRosCommTcpClientListReqEntryType *client_req;
+	mRosRcpRosReqType req;
+	mRosTcpRosResType res;
+	mRosContainerObjType cobj;
+	mROsExclusiveUnlockObjType unlck_obj;
+	mRosTopicConnectorType sub_connector;
+
+	req.req_packet = &mros_protocol_subscribe.tcpros_packet;
+	res.reply_packet = &mros_protocol_subscribe.tcpros_packet;
+
+	mros_exclusive_lock(&mros_exclusive_area, &unlck_obj);
+	while (MROS_TRUE) {
+		mros_protocol_subscribe.state = MROS_PROTOCOL_SUBSCRIBE_STATE_WAITING;
+		mRosWaitListEntryType *wait_entry = mros_server_queue_wait(&mros_subscribe_wait_queue);
+		if (wait_entry == MROS_NULL) {
+			mros_topic_data_publisher_run();
+			mros_topic_data_subscriber_run();
+			continue;
+		}
+		mros_protocol_subscribe.state = MROS_PROTOCOL_SUBSCRIBE_STATE_PUB_CONNECTING;
+		client_req = (mRosCommTcpClientListReqEntryType*)wait_entry->data.reqp;
+
+		ret = mros_comm_tcp_client_ip32_init(&client_req->data.client, client_req->data.reqobj.ipaddr, client_req->data.reqobj.port);
+		if (ret != MROS_E_OK) {
+			ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+			mros_comm_tcp_client_free(client_req);
+			continue;
+		}
+		ret = mros_comm_tcp_client_connect(&client_req->data.client);
+		if (ret != MROS_E_OK) {
+			ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+			mros_comm_tcp_client_free(client_req);
+			continue;
+		}
+
+		connector.topic_id = client_req->data.reqobj.topic_id;
+		connector.func_id = (mRosFuncIdType)MROS_ID_NONE;
+		ret = mros_node_create_outer(&connector.node_id);
+		if (ret != MROS_E_OK) {
+			ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+			mros_comm_tcp_client_free(client_req);
+			continue;
+		}
+		ret = mros_topic_connector_add(mros_protocol_subscribe.pub_mgrp, &connector, MROS_OUTER_CONNECTOR_QUEUE_MAXLEN, &ros_outer_topic_publisher_mempool);
+		if (ret != MROS_E_OK) {
+			ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+			(void)mros_node_remove(connector.node_id);
+			mros_comm_tcp_client_free(client_req);
+			continue;
+		}
+
+		mros_protocol_subscribe.state = MROS_PROTOCOL_SUBSCRIBE_STATE_PUB_REQUESTING;
+		sub_connector.node_id = mros_proc_connector_get_first(connector.topic_id, MROS_TOPIC_CONNECTOR_SUB, MROS_NODE_TYPE_INNER, MROS_NULL);
+		if (sub_connector.node_id == MROS_ID_NONE) {
+			ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+			(void)mros_node_remove(connector.node_id);
+			mros_comm_tcp_client_free(client_req);
+			continue;
+		}
+
+		req.node_name = mros_node_name(sub_connector.node_id);
+		req.topic_name = mros_topic_get_topic_name(connector.topic_id);
+		req.topic_typename = mros_topic_get_topic_typename(connector.topic_id);
+		(void)mros_topic_get_md5sum(connector.topic_id, &req.md5sum);
+		ret = mros_rpc_tcpros(&client_req->data.client, &req, &res);
+		if (ret != MROS_E_OK) {
+			ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+			mros_topic_connector_remove(mros_protocol_subscribe.pub_mgrp, &connector);
+			(void)mros_node_remove(connector.node_id);
+			mros_comm_tcp_client_free(client_req);
+			continue;
+		}
+
+		cobj = mros_topic_connector_get_obj(mros_protocol_subscribe.pub_mgrp, &connector);
+		(void)mros_topic_connector_set_connection(cobj, client_req);
+		//wakeup api requester
+		if (client_req->data.reqobj.api_reqp != MROS_NULL) {
+			mros_client_wakeup((mRosWaitListEntryType*)client_req->data.reqobj.api_reqp);
+			client_req->data.reqobj.api_reqp = NULL;
+		}
+	}
+	mros_exclusive_unlock(&unlck_obj);
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/protocol/cimpl/mros_protocol_subscribe_cimpl.h
@@ -0,0 +1,22 @@
+#ifndef _MROS_PROTOCOL_SUBSCRIBE_CIMPL_H_
+#define _MROS_PROTOCOL_SUBSCRIBE_CIMPL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_types.h"
+
+typedef enum {
+	MROS_PROTOCOL_SUBSCRIBE_STATE_WAITING = 0,
+	MROS_PROTOCOL_SUBSCRIBE_STATE_PUB_CONNECTING,
+	MROS_PROTOCOL_SUBSCRIBE_STATE_PUB_REQUESTING,
+} mRosProtocolSubscribeStateEnumType;
+
+extern mRosReturnType mros_protocol_subscribe_init(void);
+extern void mros_protocol_subscribe_run(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _MROS_PROTOCOL_SUBSCRIBE_CIMPL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/topic/cimpl/mros_topic_cimpl.c
@@ -0,0 +1,285 @@
+#include "mros_topic_cimpl.h"
+#include "mros_usr_config.h"
+#include "mros_name.h"
+#include <string.h>
+
+typedef struct {
+	mRosTopicIdType				topic_id;
+	mros_uint32					namelen;
+	char						topic_name[MROS_TOPIC_NAME_MAXLEN];
+	mros_uint32					typenamelen;
+	char						topic_typename[MROS_TOPIC_TYPENAME_MAXLEN];
+	const char*					md5sum;
+	const char*					definition;
+	mros_uint32					type_id;
+
+	/*
+	 * トピックデータ格納用キュー
+	 */
+	mRosSizeType				queue_maxsize;
+	mRosMemoryListHeadType 		queue_head;
+} mRosTopicEntryType;
+
+typedef ListEntryType(mRosTopicListEntryType, mRosTopicEntryType) mRosTopicListEntryType;
+typedef ListHeadType(mRosTopicListEntryType) mRosTopicEntryHeadType;
+
+#define MROS_TOPIC_ENTRY_INIT(entryp)	\
+do {	\
+	(entryp)->data.namelen = 0;	\
+	(entryp)->data.typenamelen = 0;	\
+	(entryp)->data.queue_maxsize = 1; \
+} while (0)
+
+typedef struct {
+	mRosTopicEntryHeadType	 	head;
+	mRosTopicListEntryType 		*topic_entries;
+	mRosTopicIdType				max_topic;
+} mRosTopicManagerType;
+
+static mRosTopicManagerType 	topic_manager;
+#define TOPIC_OBJ(id)		topic_manager.topic_entries[MROS_INDEX((id))]
+
+static mRosTopicListEntryType topic_entries[MROS_TOPIC_MAX_NUM] MROS_MATTR_BSS_NOCLR;
+static char topic_name_buffer[MROS_TOPIC_NAME_MAXLEN + 1] MROS_MATTR_BSS_NOCLR;
+
+mRosReturnType mros_topic_init(void)
+{
+	mros_uint32 i;
+	topic_manager.topic_entries = topic_entries;
+	topic_manager.max_topic = MROS_TOPIC_MAX_NUM;
+	for (i = 0; i < topic_manager.max_topic; i++) {
+		mRosTopicListEntryType *entry = &(topic_manager.topic_entries[i]);
+		MROS_TOPIC_ENTRY_INIT(entry);
+		entry->data.topic_id = MROS_ID(i);
+		List_InitEmpty(&(entry->data.queue_head), mRosMemoryListEntryType);
+	}
+	List_Init(&topic_manager.head, mRosTopicListEntryType, topic_manager.max_topic, topic_manager.topic_entries);
+
+	return MROS_E_OK;
+}
+
+mRosContainerObjType mros_topic_get_first(void)
+{
+	mRosTopicListEntryType *p;
+
+	if (topic_manager.head.entry_num == 0) {
+		return MROS_COBJ_NULL;
+	}
+	ListEntry_GetFirst(&topic_manager.head, &p);
+	return (mRosContainerObjType)p;
+}
+
+mRosContainerObjType mros_topic_get_next(mRosContainerObjType obj)
+{
+	mRosTopicListEntryType *first;
+	mRosTopicListEntryType *entry = (mRosTopicListEntryType*)obj;
+	ListEntry_GetFirst(&topic_manager.head, &first);
+	if (first == MROS_NULL) {
+		return MROS_COBJ_NULL;
+	}
+	if (entry->next == first) {
+		return MROS_COBJ_NULL;
+	}
+	return (mRosContainerObjType)entry->next;
+}
+
+mRosTopicIdType mros_topic_get_id(mRosContainerObjType obj)
+{
+	mRosTopicListEntryType *entry = (mRosTopicListEntryType*)obj;
+	return entry->data.topic_id;
+}
+
+mRosReturnType mros_topic_get(const char *topic_name, mRosTopicIdType *id)
+{
+	mRosTopicListEntryType *p;
+	mros_uint32 len = strlen(topic_name);
+
+	*id = MROS_ID_NONE;
+	ListEntry_Foreach(&topic_manager.head, p) {
+		if (len != p->data.namelen) {
+			continue;
+		}
+		if (!strcmp(p->data.topic_name, topic_name)) {
+			*id = p->data.topic_id;
+			break;
+		}
+	}
+	if (*id == MROS_ID_NONE) {
+		return MROS_E_NOENT;
+	}
+	return MROS_E_OK;
+}
+
+mRosReturnType mros_topic_create(const char *topic_name, const char *topic_typename, mRosTopicIdType *id)
+{
+	mRosTopicListEntryType *p;
+	mros_uint32 len = strlen(topic_name);
+	mros_uint32 typelen = strlen(topic_typename);
+	mRosReturnType ret;
+
+	if (len >= (MROS_TOPIC_NAME_MAXLEN + 1)) { /* for add slash on top */
+		return MROS_E_NOMEM;
+	}
+	if (typelen >= MROS_TOPIC_NAME_MAXLEN) {
+		return MROS_E_NOMEM;
+	}
+	mros_name_formalize(topic_name, len, topic_name_buffer, &len);
+	ret = mros_topic_get(topic_name_buffer, id);
+	if (ret == MROS_E_OK) {
+		return MROS_E_OK;
+	}
+
+	ListEntry_Alloc(&topic_manager.head, mRosTopicListEntryType, &p);
+	if (p == MROS_NULL) {
+		return MROS_E_NOMEM;
+	}
+	*id = p->data.topic_id;
+	p->data.namelen = len;
+	memcpy(p->data.topic_name, topic_name_buffer, len);
+	p->data.typenamelen = typelen;
+	memcpy(p->data.topic_typename, topic_typename, typelen);
+	p->data.topic_typename[typelen] = '\0';
+	ListEntry_AddEntry(&topic_manager.head, p);
+	return MROS_E_OK;
+}
+
+mRosReturnType mros_topic_set_quesize_byname(const char *topic_name, mRosSizeType size)
+{
+	mRosTopicIdType id;
+
+	mRosReturnType ret = mros_topic_get(topic_name, &id);
+	if (ret != MROS_E_OK) {
+		return ret;
+	}
+	TOPIC_OBJ(id).data.queue_maxsize = size;
+	return MROS_E_OK;
+}
+mRosReturnType mros_topic_set_quesize_byid(mRosTopicIdType id, mRosSizeType size)
+{
+	if (id > topic_manager.max_topic) {
+		return MROS_E_RANGE;
+	}
+	TOPIC_OBJ(id).data.queue_maxsize = size;
+	return MROS_E_OK;
+}
+mRosReturnType mros_topic_set_typeid(mRosTopicIdType topic_id, mros_uint32 type_id)
+{
+	if (topic_id > topic_manager.max_topic) {
+		return MROS_E_RANGE;
+	}
+	TOPIC_OBJ(topic_id).data.type_id = type_id;
+	return MROS_E_OK;
+}
+mRosReturnType mros_topic_get_typeid(mRosTopicIdType topic_id, mros_uint32 *type_id)
+{
+	if (topic_id > topic_manager.max_topic) {
+		return MROS_E_RANGE;
+	}
+	*type_id = TOPIC_OBJ(topic_id).data.type_id;
+	return MROS_E_OK;
+}
+
+mRosReturnType mros_topic_set_definition(mRosTopicIdType topic_id, const char* definition)
+{
+	if (topic_id > topic_manager.max_topic) {
+		return MROS_E_RANGE;
+	}
+	TOPIC_OBJ(topic_id).data.definition = definition;
+	return MROS_E_OK;
+}
+
+mRosReturnType mros_topic_get_definition(mRosTopicIdType topic_id, const char **definition)
+{
+	if (topic_id > topic_manager.max_topic) {
+		return MROS_E_RANGE;
+	}
+	*definition = TOPIC_OBJ(topic_id).data.definition;
+	return MROS_E_OK;
+}
+
+
+mRosReturnType mros_topic_set_md5sum(mRosTopicIdType topic_id, const char* md5sum)
+{
+	if (topic_id > topic_manager.max_topic) {
+		return MROS_E_RANGE;
+	}
+	TOPIC_OBJ(topic_id).data.md5sum = md5sum;
+	return MROS_E_OK;
+}
+
+mRosReturnType mros_topic_get_md5sum(mRosTopicIdType topic_id, const char **md5sum)
+{
+	if (topic_id > topic_manager.max_topic) {
+		return MROS_E_RANGE;
+	}
+	*md5sum = TOPIC_OBJ(topic_id).data.md5sum;
+	return MROS_E_OK;
+}
+
+const char *mros_topic_get_topic_name(mRosTopicIdType id)
+{
+	if (id > topic_manager.max_topic) {
+		return MROS_NULL;
+	}
+	return TOPIC_OBJ(id).data.topic_name;
+}
+const char *mros_topic_get_topic_typename(mRosTopicIdType id)
+{
+	if (id > topic_manager.max_topic) {
+		return MROS_NULL;
+	}
+	return TOPIC_OBJ(id).data.topic_typename;
+}
+
+mRosReturnType mros_topic_remove_byname(const char *topic_name)
+{
+	mRosTopicIdType id;
+
+	mRosReturnType ret = mros_topic_get(topic_name, &id);
+	if (ret != MROS_E_OK) {
+		return ret;
+	}
+	ListEntry_RemoveEntry(&topic_manager.head, &TOPIC_OBJ(id));
+	ListEntry_Free(&topic_manager.head, &TOPIC_OBJ(id));
+	return MROS_E_OK;
+}
+mRosReturnType mros_topic_remove_byid(mRosTopicIdType id)
+{
+	if (id > topic_manager.max_topic) {
+		return MROS_E_RANGE;
+	}
+	ListEntry_RemoveEntry(&topic_manager.head, &TOPIC_OBJ(id));
+	ListEntry_Free(&topic_manager.head, &TOPIC_OBJ(id));
+	return MROS_E_OK;
+}
+
+mRosReturnType mros_topic_add_data(mRosTopicIdType id, mRosMemoryListEntryType *data)
+{
+	mRosMemoryListEntryType *datap;
+	if (id > topic_manager.max_topic) {
+		return MROS_E_RANGE;
+	}
+	if (TOPIC_OBJ(id).data.queue_head.entry_num >= TOPIC_OBJ(id).data.queue_maxsize) {
+		//ROS_WARN("%s %s() %u :WARNING: Removed topic data for queufull(%u).", __FILE__, __FUNCTION__, __LINE__, TOPIC_OBJ(id).data.queue_maxsize);
+		datap = ListEntry_First(TOPIC_OBJ(id).data.queue_head.entries);
+		ListEntry_RemoveEntry(&TOPIC_OBJ(id).data.queue_head, datap);
+		(void)mros_mem_free(datap->data.mgrp, datap);
+	}
+	ListEntry_AddEntry(&TOPIC_OBJ(id).data.queue_head, data);
+	return MROS_E_OK;
+}
+
+mRosReturnType mros_topic_get_data(mRosTopicIdType id, mRosMemoryListEntryType **data)
+{
+	mRosMemoryListEntryType *datap;
+	if (id > topic_manager.max_topic) {
+		return MROS_E_RANGE;
+	}
+	if (TOPIC_OBJ(id).data.queue_head.entry_num <= 0) {
+		return MROS_E_NOENT;
+	}
+	datap = ListEntry_First(TOPIC_OBJ(id).data.queue_head.entries);
+	ListEntry_RemoveEntry(&TOPIC_OBJ(id).data.queue_head, datap);
+	*data = datap;
+	return MROS_E_OK;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/topic/cimpl/mros_topic_cimpl.h
@@ -0,0 +1,38 @@
+#ifndef _MROS_TOPIC_CIMPL_H_
+#define _MROS_TOPIC_CIMPL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_memory.h"
+
+extern mRosReturnType mros_topic_init(void);
+extern mRosContainerObjType mros_topic_get_first(void);
+extern mRosContainerObjType mros_topic_get_next(mRosContainerObjType obj);
+extern const char *mros_topic_get_topic_name(mRosTopicIdType id);
+extern const char *mros_topic_get_topic_typename(mRosTopicIdType id);
+extern mRosTopicIdType mros_topic_get_id(mRosContainerObjType obj);
+extern mRosReturnType mros_topic_get(const char *topic_name, mRosTopicIdType *id);
+extern mRosReturnType mros_topic_create(const char *topic_name, const char *topic_typename, mRosTopicIdType *id);
+extern mRosReturnType mros_topic_set_quesize_byname(const char *topic_name, mRosSizeType size);
+extern mRosReturnType mros_topic_set_quesize_byid(mRosTopicIdType id, mRosSizeType size);
+extern mRosReturnType mros_topic_remove_byname(const char *topic_name);
+extern mRosReturnType mros_topic_remove_byid(mRosTopicIdType id);
+extern mRosReturnType mros_topic_add_data(mRosTopicIdType id, mRosMemoryListEntryType *data);
+extern mRosReturnType mros_topic_get_data(mRosTopicIdType id, mRosMemoryListEntryType **data);
+
+
+extern mRosReturnType mros_topic_set_typeid(mRosTopicIdType topic_id, mros_uint32 type_id);
+extern mRosReturnType mros_topic_get_typeid(mRosTopicIdType topic_id, mros_uint32 *type_id);
+
+extern mRosReturnType mros_topic_set_definition(mRosTopicIdType topic_id, const char* definition);
+extern mRosReturnType mros_topic_get_definition(mRosTopicIdType topic_id, const char **definition);
+
+extern mRosReturnType mros_topic_set_md5sum(mRosTopicIdType topic_id, const char* md5sum);
+extern mRosReturnType mros_topic_get_md5sum(mRosTopicIdType topic_id, const char **md5sum);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _MROS_TOPIC_CIMPL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/topic/cimpl/mros_topic_connector_cimpl.c
@@ -0,0 +1,426 @@
+#include "mros_topic_connector_cimpl.h"
+#include "mros_topic_callback.h"
+#include "mros_node_cimpl.h"
+#include "mros_topic_cimpl.h"
+#include "mros_usr_config.h"
+#include <string.h>
+
+#define MROS_TOPIC_CONNECTOR_ENTRY_INIT(entryp)	\
+do {	\
+	(entryp)->data.queue_maxsize = 1U;		\
+	(entryp)->data.value.topic_id = MROS_ID_NONE;		\
+	(entryp)->data.value.node_id = MROS_ID_NONE;		\
+	(entryp)->data.value.func_id = MROS_ID_NONE;	\
+} while (0)
+
+mRosReturnType mros_topic_connector_init(mRosTopicConnectorConfigType *config, mRosTopicConnectorManagerType *mgrp)
+{
+	mros_uint32 i;
+	mgrp->is_error = MROS_FALSE;
+	mgrp->conn_entries = config->conn_entries;
+	mgrp->topic_entries = config->topic_entries;
+	mgrp->max_connector = config->max_connector;
+	for (i = 0; i < mgrp->max_connector; i++) {
+		mRosTopicConnectorListEntryType *entry = &(mgrp->conn_entries[i]);
+		MROS_TOPIC_CONNECTOR_ENTRY_INIT(entry);
+		List_InitEmpty(&entry->data.queue_head, mRosMemoryListEntryType);
+	}
+
+	for (i = 0; i < MROS_TOPIC_MAX_NUM; i++) {
+		mRosTopicConnectorListEntryRootType *topic_entry = &(mgrp->topic_entries[i]);
+		topic_entry->data.topic_id = MROS_ID_NONE;
+		List_Init(&topic_entry->data.head[MROS_NODE_TYPE_INNER], mRosTopicConnectorListEntryType, 0, MROS_NULL);
+		List_Init(&topic_entry->data.head[MROS_NODE_TYPE_OUTER], mRosTopicConnectorListEntryType, 0, MROS_NULL);
+	}
+	List_Init(&mgrp->topic_head, mRosTopicConnectorListEntryRootType, MROS_TOPIC_MAX_NUM, mgrp->topic_entries);
+	List_Init(&mgrp->conn_head, mRosTopicConnectorListEntryType, mgrp->max_connector, mgrp->conn_entries);
+	return MROS_E_OK;
+}
+
+mRosContainerObjType mros_topic_connector_get_topic_first(mRosTopicConnectorManagerType *mgrp)
+{
+	mRosTopicConnectorListEntryRootType *p;
+
+	if (mgrp->topic_head.entry_num == 0) {
+		return MROS_COBJ_NULL;
+	}
+	ListEntry_GetFirst(&mgrp->topic_head, &p);
+	return (mRosContainerObjType)p;
+}
+mRosContainerObjType mros_topic_connector_get_topic_next(mRosTopicConnectorManagerType *mgrp, mRosContainerObjType obj)
+{
+	mRosTopicConnectorListEntryRootType *first;
+	mRosTopicConnectorListEntryRootType *entry = (mRosTopicConnectorListEntryRootType*)obj;
+	ListEntry_GetFirst(&mgrp->topic_head, &first);
+	if (first == MROS_NULL) {
+		return MROS_COBJ_NULL;
+	}
+	if (entry->next == first) {
+		return MROS_COBJ_NULL;
+	}
+	return (mRosContainerObjType)entry->next;
+}
+
+mRosContainerObjType mros_topic_connector_get_first(mRosTopicConnectorManagerType *mgrp, mRosNodeEnumType type, mRosContainerObjType topic_obj)
+{
+	mRosTopicConnectorListEntryRootType *topic_entry = (mRosTopicConnectorListEntryRootType*)topic_obj;
+	mRosTopicConnectorListEntryType *p;
+
+	if (topic_entry->data.head[type].entry_num == 0) {
+		return MROS_COBJ_NULL;
+	}
+	ListEntry_GetFirst(&topic_entry->data.head[type], &p);
+
+	return (mRosContainerObjType)p;
+}
+
+
+mRosContainerObjType mros_topic_connector_get_next(mRosTopicConnectorManagerType *mgrp, mRosContainerObjType topic_obj, mRosContainerObjType obj)
+{
+	mRosTopicConnectorListEntryRootType *topic_entry = (mRosTopicConnectorListEntryRootType*)topic_obj;
+	mRosTopicConnectorListEntryType *entry = (mRosTopicConnectorListEntryType*)obj;
+	mRosTopicConnectorListEntryType *first;
+
+	mRosNodeEnumType type = mros_node_type(entry->data.value.node_id);
+	ListEntry_GetFirst(&topic_entry->data.head[type], &first);
+	if (first == MROS_NULL) {
+		return MROS_COBJ_NULL;
+	}
+	if (entry->next == first) {
+		return MROS_COBJ_NULL;
+	}
+	return (mRosContainerObjType)entry->next;
+}
+
+static mRosTopicConnectorListEntryRootType *mros_topic_connector_get_topic_head(mRosTopicConnectorManagerType *mgrp, mRosTopicIdType topic_id)
+{
+	mRosTopicConnectorListEntryRootType *topic_p;
+
+	ListEntry_Foreach(&mgrp->topic_head, topic_p) {
+		if (topic_p->data.topic_id == topic_id) {
+			return topic_p;
+		}
+	}
+	return MROS_NULL;
+}
+mRosContainerObjType mros_topic_connector_get_topic_obj(mRosTopicConnectorManagerType *mgrp, mRosTopicIdType topic_id)
+{
+	mRosTopicConnectorListEntryRootType *root = mros_topic_connector_get_topic_head(mgrp, topic_id);
+	if (root == MROS_NULL) {
+		return MROS_COBJ_NULL;
+	}
+	return (mRosContainerObjType)root;
+}
+
+static mRosTopicConnectorListEntryRootType *mros_topic_connector_create_topic_head(mRosTopicConnectorManagerType *mgrp, mRosTopicIdType topic_id)
+{
+	mRosTopicConnectorListEntryRootType *topic_p;
+
+	ListEntry_Alloc(&mgrp->topic_head, mRosTopicConnectorListEntryRootType, &topic_p);
+	if (topic_p == MROS_NULL) {
+		return MROS_NULL;
+	}
+	topic_p->data.topic_id = topic_id;
+	List_InitEmpty(&topic_p->data.head[MROS_NODE_TYPE_INNER], mRosTopicConnectorListEntryType);
+	List_InitEmpty(&topic_p->data.head[MROS_NODE_TYPE_OUTER], mRosTopicConnectorListEntryType);
+	ListEntry_AddEntry(&mgrp->topic_head, topic_p);
+	return topic_p;
+}
+
+static mRosTopicConnectorListEntryType *mros_topic_connector_get_node(mRosTopicConnectorListEntryRootType *topic_p, mRosNodeIdType node_id)
+{
+	mRosTopicConnectorListEntryType *entry;
+	mRosNodeEnumType type = mros_node_type(node_id);
+
+	ListEntry_Foreach(&topic_p->data.head[type], entry) {
+		if (entry->data.value.node_id == node_id) {
+			return entry;
+		}
+	}
+	return MROS_NULL;
+}
+
+mRosReturnType mros_topic_connector_add(mRosTopicConnectorManagerType *mgrp, mRosTopicConnectorType *connector, mRosSizeType queue_length, mRosMemoryManagerType *mempool)
+{
+	mRosTopicConnectorListEntryRootType *topic_p;
+	mRosTopicConnectorListEntryRootType *org_topic_p;
+	mRosTopicConnectorListEntryType *entry;
+
+	org_topic_p = mros_topic_connector_get_topic_head(mgrp, connector->topic_id);
+	if (org_topic_p == MROS_NULL) {
+		topic_p = mros_topic_connector_create_topic_head(mgrp, connector->topic_id);
+	}
+	else {
+		topic_p = org_topic_p;
+	}
+	if (topic_p == MROS_NULL) {
+		(void)mros_topic_connector_remove(mgrp, connector);
+		return MROS_E_NOMEM;
+	}
+
+	entry = mros_topic_connector_get_node(topic_p, connector->node_id);
+	mRosNodeEnumType type = mros_node_type(connector->node_id);
+	if (entry == MROS_NULL) {
+		ListEntry_Alloc(&mgrp->conn_head, mRosTopicConnectorListEntryType, &entry);
+		if (entry != MROS_NULL) {
+			entry->data.value.topic_id = connector->topic_id;
+			entry->data.value.node_id = connector->node_id;
+			entry->data.value.func_id = connector->func_id;
+			entry->data.queue_maxsize = queue_length;
+			entry->data.mempool = mempool;
+			entry->data.commp = MROS_NULL;
+			ListEntry_AddEntry(&topic_p->data.head[type], entry);
+			List_InitEmpty(&entry->data.queue_head, mRosMemoryListEntryType);
+		}
+		else {
+			(void)mros_topic_connector_remove(mgrp, connector);
+			return MROS_E_NOMEM;
+		}
+	}
+	return MROS_E_OK;
+}
+
+mRosReturnType mros_topic_connector_remove(mRosTopicConnectorManagerType *mgrp, mRosTopicConnectorType *connector)
+{
+	mRosTopicConnectorListEntryRootType *topic_entryp;
+	mRosTopicConnectorListEntryType *entryp;
+
+	topic_entryp = mros_topic_connector_get_topic_head(mgrp, connector->topic_id);
+	if (topic_entryp == MROS_NULL) {
+		return MROS_E_NOENT;
+	}
+	entryp = mros_topic_connector_get_node(topic_entryp, connector->node_id);
+	if (entryp == MROS_NULL) {
+		return MROS_E_NOENT;
+	}
+	mRosNodeEnumType type = mros_node_type(connector->node_id);
+	{
+		ListEntry_RemoveEntry(&topic_entryp->data.head[type], entryp);
+		if (topic_entryp->data.head[type].entry_num == 0) {
+			ListEntry_RemoveEntry(&mgrp->topic_head, topic_entryp);
+		}
+	}
+	if (entryp->data.commp != MROS_NULL) {
+		entryp->data.commp->data.op.free(entryp->data.commp);
+		entryp->data.commp = MROS_NULL;
+	}
+	ListEntry_Free(&mgrp->conn_head, entryp);
+	return MROS_E_OK;
+}
+
+mRosReturnType mros_topic_connector_get(mRosContainerObjType obj, mRosTopicConnectorType *connector)
+{
+	mRosTopicConnectorListEntryType *entry = (mRosTopicConnectorListEntryType*)obj;
+	*connector = entry->data.value;
+	return MROS_E_OK;
+}
+
+mRosReturnType mros_topic_connector_get_connection(mRosContainerObjType obj, mRosCommTcpClientListReqEntryType **connection)
+{
+	mRosTopicConnectorListEntryType *entry = (mRosTopicConnectorListEntryType*)obj;
+	*connection = entry->data.commp;
+	return MROS_E_OK;
+}
+
+mRosReturnType mros_topic_connector_set_connection(mRosContainerObjType obj, mRosCommTcpClientListReqEntryType *connection)
+{
+	mRosTopicConnectorListEntryType *entry = (mRosTopicConnectorListEntryType*)obj;
+	entry->data.commp = connection;
+	return MROS_E_OK;
+}
+
+
+mRosContainerObjType mros_topic_connector_get_obj(mRosTopicConnectorManagerType *mgrp, mRosTopicConnectorType *connector)
+{
+	mRosTopicConnectorListEntryRootType *tp;
+	mRosTopicConnectorListEntryRootType *topic_p = MROS_NULL;
+	mRosTopicConnectorListEntryType *p;
+	mRosTopicConnectorListEntryType *entry = MROS_NULL;
+
+	{
+		ListEntry_Foreach(&mgrp->topic_head, tp) {
+			if (tp->data.topic_id == connector->topic_id) {
+				topic_p = tp;
+				break;
+			}
+		}
+		if (tp == MROS_NULL) {
+			return MROS_COBJ_NULL;
+		}
+
+	}
+	mRosNodeEnumType type = mros_node_type(connector->node_id);
+	{
+		ListEntry_Foreach(&topic_p->data.head[type], p) {
+			if (p->data.value.node_id == connector->node_id) {
+				entry = p;
+				break;
+			}
+		}
+	}
+	if (entry == MROS_NULL) {
+		return MROS_COBJ_NULL;
+	}
+	return (mRosContainerObjType)entry;
+}
+
+mRosReturnType mros_topic_connector_get_topic(mRosContainerObjType topic_obj, mRosTopicIdType *topic_id)
+{
+	mRosTopicConnectorListEntryRootType *topic_p = (mRosTopicConnectorListEntryRootType*)topic_obj;
+	*topic_id = topic_p->data.topic_id;
+	return MROS_E_OK;
+}
+
+
+mRosReturnType mros_topic_connector_put_data(mRosContainerObjType obj, const char* data, mRosSizeType len)
+{
+	mRosReturnType ret;
+	mRosMemoryListEntryType *mem_entryp;
+	mRosTopicConnectorListEntryType *entry = (mRosTopicConnectorListEntryType*)obj;
+	mRosNodeEnumType type = mros_node_type(entry->data.value.node_id);
+	if (type != MROS_NODE_TYPE_INNER) {
+		return MROS_E_INVAL;
+	}
+	if (entry->data.queue_head.entry_num >= entry->data.queue_maxsize) {
+		ROS_WARN("%s %s() %u :WARNING: Removed topic data for queufull(%u).", __FILE__, __FUNCTION__, __LINE__, entry->data.queue_maxsize);
+		ListEntry_GetFirst(&entry->data.queue_head, &mem_entryp);
+		ListEntry_RemoveEntry(&entry->data.queue_head, mem_entryp);
+		(void)mros_mem_free(entry->data.mempool, mem_entryp);
+	}
+	ret = mros_mem_alloc(entry->data.mempool, len, &mem_entryp);
+	if (ret != MROS_E_OK) {
+		return ret;
+	}
+	mem_entryp->data.size = len;
+	memcpy(mem_entryp->data.memp, data, mem_entryp->data.size);
+	ListEntry_AddEntry(&entry->data.queue_head, mem_entryp);
+	return MROS_E_OK;
+}
+mRosReturnType mros_topic_connector_alloc_data(mRosContainerObjType obj, char **data, mRosSizeType len)
+{
+	mRosReturnType ret;
+	mRosMemoryListEntryType *mem_entryp;
+	mRosTopicConnectorListEntryType *entry = (mRosTopicConnectorListEntryType*)obj;
+	mRosNodeEnumType type = mros_node_type(entry->data.value.node_id);
+	if (type != MROS_NODE_TYPE_INNER) {
+		return MROS_E_INVAL;
+	}
+	if (entry->data.queue_head.entry_num >= entry->data.queue_maxsize) {
+		ROS_WARN("%s %s() %u :WARNING: Removed topic data for queufull(%u).", __FILE__, __FUNCTION__, __LINE__, entry->data.queue_maxsize);
+		ListEntry_GetFirst(&entry->data.queue_head, &mem_entryp);
+		ListEntry_RemoveEntry(&entry->data.queue_head, mem_entryp);
+		(void)mros_mem_free(entry->data.mempool, mem_entryp);
+	}
+	ret = mros_mem_alloc(entry->data.mempool, len, &mem_entryp);
+	if (ret != MROS_E_OK) {
+		return ret;
+	}
+	mem_entryp->data.size = len;
+	*data = mem_entryp->data.memp;
+	ListEntry_AddEntry(&entry->data.queue_head, mem_entryp);
+	return MROS_E_OK;
+}
+
+
+mRosReturnType mros_topic_connector_send_data(mRosTopicConnectorManagerType *mgrp, mRosContainerObjType obj, const char* data, mRosSizeType len)
+{
+	mRosReturnType ret;
+	mRosTopicConnectorListEntryType *entry = (mRosTopicConnectorListEntryType*)obj;
+
+	mRosNodeEnumType type = mros_node_type(entry->data.value.node_id);
+	if (type == MROS_NODE_TYPE_INNER) {
+		//TOPIC ==> inner node callback
+		mros_uint32 type_id;
+		(void)mros_topic_get_typeid(entry->data.value.topic_id, &type_id);
+		mros_topic_callback(entry->data.value.topic_id, type_id, entry->data.value.func_id, data, len);
+		return MROS_E_OK;
+	}
+	//TOPIC ==> outer node
+	if (entry->data.commp == MROS_NULL) {
+		return MROS_E_NOTCONN;
+	}
+	ret = entry->data.commp->data.op.topic_data_send(&entry->data.commp->data.client, data, len);
+	if (ret != MROS_E_OK) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		mgrp->is_error = MROS_TRUE;
+		mros_comm_tcp_client_close(&entry->data.commp->data.client);
+	}
+	return ret;
+}
+
+mRosReturnType mros_topic_connector_receive_data(mRosTopicConnectorManagerType *mgrp, mRosContainerObjType obj, mRosMemoryListEntryType **memp)
+{
+	mRosReturnType ret;
+	mRosMemoryListEntryType *data;
+	mRosTopicConnectorListEntryType *entry = (mRosTopicConnectorListEntryType*)obj;
+
+	*memp = MROS_NULL;
+	mRosNodeEnumType type = mros_node_type(entry->data.value.node_id);
+	if (type == MROS_NODE_TYPE_INNER) {
+		if (entry->data.queue_head.entry_num == 0) {
+			return MROS_E_NOENT;
+		}
+		ListEntry_GetFirst(&entry->data.queue_head, &data);
+		ListEntry_RemoveEntry(&entry->data.queue_head, data);
+		*memp = data;
+		return MROS_E_OK;
+	}
+	//outer node
+	if (entry->data.commp == MROS_NULL) {
+		return MROS_NULL;
+	}
+	ret = entry->data.commp->data.op.topic_data_receive(&entry->data.commp->data.client, entry->data.mempool, memp);
+	if ((ret != MROS_E_OK) && (ret != MROS_E_NOENT)) {
+		ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		mgrp->is_error = MROS_TRUE;
+		mros_comm_tcp_client_close(&entry->data.commp->data.client);
+	}
+
+	return ret;
+}
+
+static mros_boolean mros_topic_connector_purge_one(mRosTopicConnectorManagerType *mgrp, mRosTopicConnectorListEntryRootType *topic_root)
+{
+	mRosTopicConnectorListEntryType *entryp;
+
+	ListEntry_Foreach(&topic_root->data.head[MROS_NODE_TYPE_OUTER], entryp) {
+		if (entryp->data.commp != MROS_NULL) {
+			if (mros_comm_tcp_client_is_connected(&entryp->data.commp->data.client) == MROS_FALSE) {
+				entryp->data.commp->data.op.free(entryp->data.commp);
+				entryp->data.commp = MROS_NULL;
+				mros_node_remove(entryp->data.value.node_id);
+				ListEntry_RemoveEntry(&topic_root->data.head[MROS_NODE_TYPE_OUTER], entryp);
+				ListEntry_Free(&mgrp->conn_head, entryp);
+				ROS_ERROR("removed connector topic_id=%d node_id=%d", entryp->data.value.topic_id, entryp->data.value.node_id);
+				return MROS_TRUE;
+			}
+		}
+	}
+	return MROS_FALSE;
+}
+
+void mros_topic_connector_purge(mRosTopicConnectorManagerType *mgrp)
+{
+	mros_boolean is_removed = MROS_FALSE;
+	mRosTopicConnectorListEntryRootType *topic_first = MROS_NULL;
+	mRosTopicConnectorListEntryRootType *topic_root = MROS_NULL;
+
+	if (mgrp->is_error == MROS_FALSE) {
+		return;
+	}
+	if (mgrp->topic_head.entry_num == 0) {
+		return;
+	}
+
+	ListEntry_GetFirst(&mgrp->topic_head, &topic_first);
+	topic_root = topic_first;
+	do {
+		do {
+			is_removed = mros_topic_connector_purge_one(mgrp, topic_root);
+		} while (is_removed == MROS_TRUE);
+		topic_root = topic_root->next;
+	} while (topic_root != topic_first);
+
+	mgrp->is_error = MROS_FALSE;
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/topic/cimpl/mros_topic_connector_cimpl.h
@@ -0,0 +1,93 @@
+#ifndef _MROS_TOPIC_CONNECTOR_CIMPL_H_
+#define _MROS_TOPIC_CONNECTOR_CIMPL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_node_cimpl.h"
+#include "mros_memory.h"
+#include "mros_comm_tcp_client_factory_cimpl.h"
+
+typedef struct {
+	mRosTopicIdType				topic_id;
+	mRosNodeIdType				node_id;
+	mRosFuncIdType				func_id;
+} mRosTopicConnectorType;
+
+/******************************************************
+ * START: do not use these data types
+ ******************************************************/
+typedef struct {
+	mRosTopicConnectorType				value;
+	mRosSizeType						queue_maxsize;
+	mRosMemoryListHeadType 				queue_head;
+	mRosMemoryManagerType				*mempool;
+	mRosCommTcpClientListReqEntryType	*commp;
+} mRosTopicConnectorEntryType;
+typedef ListEntryType(mRosTopicConnectorListEntryType, mRosTopicConnectorEntryType) mRosTopicConnectorListEntryType;
+typedef ListHeadType(mRosTopicConnectorListEntryType) mRosTopicConnectorListHeadType;
+
+
+
+typedef struct {
+	mRosTopicIdType						topic_id;
+	mRosTopicConnectorListHeadType		head[MROS_NODE_TYPE_NUM];
+} mRosTopicConnectorEntryRootType;
+typedef ListEntryType(mRosTopicConnectorListEntryRootType, mRosTopicConnectorEntryRootType) mRosTopicConnectorListEntryRootType;
+typedef ListHeadType(mRosTopicConnectorListEntryRootType) mRosTopicConnectorListEntryRootHeadType;
+
+typedef struct {
+	mros_boolean								is_error;
+	mRosSizeType								max_connector;
+
+	mRosTopicConnectorListHeadType			 	conn_head;
+	mRosTopicConnectorListEntryType				*conn_entries;
+
+	mRosTopicConnectorListEntryRootHeadType		topic_head;
+	mRosTopicConnectorListEntryRootType			*topic_entries;
+} mRosTopicConnectorManagerType;
+
+typedef struct {
+	mRosSizeType								max_connector;
+	mRosTopicConnectorListEntryType				*conn_entries;
+	mRosTopicConnectorListEntryRootType			*topic_entries;
+} mRosTopicConnectorConfigType;
+/******************************************************
+ * END: do not use these data types
+ ******************************************************/
+
+extern mRosReturnType mros_topic_connector_init(mRosTopicConnectorConfigType *config, mRosTopicConnectorManagerType *mgrp);
+
+extern mRosContainerObjType mros_topic_connector_get_topic_first(mRosTopicConnectorManagerType *mgrp);
+extern mRosContainerObjType mros_topic_connector_get_topic_next(mRosTopicConnectorManagerType *mgrp, mRosContainerObjType obj);
+extern mRosContainerObjType mros_topic_connector_get_topic_obj(mRosTopicConnectorManagerType *mgrp, mRosTopicIdType topic_id);
+
+extern mRosContainerObjType mros_topic_connector_get_first(mRosTopicConnectorManagerType *mgrp, mRosNodeEnumType type, mRosContainerObjType topic_obj);
+extern mRosContainerObjType mros_topic_connector_get_next(mRosTopicConnectorManagerType *mgrp, mRosContainerObjType topic_obj, mRosContainerObjType obj);
+
+
+extern mRosReturnType mros_topic_connector_get_topic(mRosContainerObjType topic_obj, mRosTopicIdType *topic_id);
+extern mRosReturnType mros_topic_connector_get(mRosContainerObjType obj, mRosTopicConnectorType *connector);
+extern mRosContainerObjType mros_topic_connector_get_obj(mRosTopicConnectorManagerType *mgrp, mRosTopicConnectorType *connector);
+
+extern mRosReturnType mros_topic_connector_get_connection(mRosContainerObjType obj, mRosCommTcpClientListReqEntryType **connection);
+extern mRosReturnType mros_topic_connector_set_connection(mRosContainerObjType obj, mRosCommTcpClientListReqEntryType *connection);
+
+extern mRosReturnType mros_topic_connector_add(mRosTopicConnectorManagerType *mgrp, mRosTopicConnectorType *connector, mRosSizeType queue_length, mRosMemoryManagerType *mempool);
+extern mRosReturnType mros_topic_connector_remove(mRosTopicConnectorManagerType *mgrp, mRosTopicConnectorType *connector);
+
+
+extern mRosReturnType mros_topic_connector_put_data(mRosContainerObjType obj, const char *data, mRosSizeType len);
+extern mRosReturnType mros_topic_connector_send_data(mRosTopicConnectorManagerType *mgrp, mRosContainerObjType obj, const char *data, mRosSizeType len);
+extern mRosReturnType mros_topic_connector_receive_data(mRosTopicConnectorManagerType *mgrp, mRosContainerObjType obj, mRosMemoryListEntryType **memp);
+
+extern void mros_topic_connector_purge(mRosTopicConnectorManagerType *mgrp);
+
+extern mRosReturnType mros_topic_connector_alloc_data(mRosContainerObjType obj, char **data, mRosSizeType len);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _MROS_TOPIC_CONNECTOR_CIMPL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/topic/cimpl/mros_topic_connector_factory_cimpl.c
@@ -0,0 +1,77 @@
+#include "mros_topic_connector_factory_cimpl.h"
+#include "mros_sys_config.h"
+
+static mros_boolean mros_topic_connector_is_inialized[MROS_TOPIC_CONNECTOR_NUM] = {
+	MROS_FALSE,
+	MROS_FALSE,
+};
+/*
+ * topic connector Config APIs
+ */
+#define MROS_TOPIC_CONNECTOR_CONFIG_DECLARE_MANAGER(manager_name, conn_entry_num)	\
+	static mRosTopicConnectorListEntryType manager_name##_conn_array [(conn_entry_num)] MROS_MATTR_BSS_NOCLR;	\
+	static mRosTopicConnectorListEntryRootType manager_name##_topic_array [MROS_TOPIC_MAX_NUM] MROS_MATTR_BSS_NOCLR;	\
+	static mRosTopicConnectorManagerType manager_name MROS_MATTR_BSS_NOCLR;	\
+	static mRosTopicConnectorConfigType manager_name##_config = {	\
+		(conn_entry_num),	\
+		manager_name##_conn_array,	\
+		manager_name##_topic_array,	\
+	};
+
+MROS_TOPIC_CONNECTOR_CONFIG_DECLARE_MANAGER(pub_connector_mgr, (MROS_PUB_TOPIC_CONNECTOR_MAX_NUM) );
+MROS_TOPIC_CONNECTOR_CONFIG_DECLARE_MANAGER(sub_connector_mgr, (MROS_SUB_TOPIC_CONNECTOR_MAX_NUM) );
+
+mRosTopicConnectorManagerType *mros_topic_connector_factory_create(mRosTopicConnectorEnumType type)
+{
+	mRosTopicConnectorManagerType *mgrp = MROS_NULL;
+	mRosTopicConnectorConfigType *cfgp = MROS_NULL;
+	mRosReturnType ret;
+
+	switch (type) {
+	case MROS_TOPIC_CONNECTOR_PUB:
+		mgrp = &pub_connector_mgr;
+		cfgp = &pub_connector_mgr_config;
+		break;
+	case MROS_TOPIC_CONNECTOR_SUB:
+		mgrp = &sub_connector_mgr;
+		cfgp = &sub_connector_mgr_config;
+		break;
+	default:
+		break;
+	}
+	if (mgrp == MROS_NULL) {
+		return MROS_NULL;
+	}
+	if (mros_topic_connector_is_inialized[type] == MROS_TRUE) {
+		return mgrp;
+	}
+	ret = mros_topic_connector_init(cfgp, mgrp);
+	if (ret != MROS_E_OK) {
+		return MROS_NULL;
+	}
+	mros_topic_connector_is_inialized[type] = MROS_TRUE;
+	return mgrp;
+}
+
+mRosTopicConnectorManagerType *mros_topic_connector_factory_get(mRosTopicConnectorEnumType type)
+{
+	mRosTopicConnectorManagerType *mgrp = MROS_NULL;
+
+	switch (type) {
+	case MROS_TOPIC_CONNECTOR_PUB:
+		mgrp = &pub_connector_mgr;
+		break;
+	case MROS_TOPIC_CONNECTOR_SUB:
+		mgrp = &sub_connector_mgr;
+		break;
+	default:
+		break;
+	}
+	if (mgrp == MROS_NULL) {
+		return MROS_NULL;
+	}
+	if (mros_topic_connector_is_inialized[type] == MROS_FALSE) {
+		return MROS_NULL;
+	}
+	return mgrp;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/topic/cimpl/mros_topic_connector_factory_cimpl.h
@@ -0,0 +1,22 @@
+#ifndef _MROS_TOPIC_CONNECTOR_FACTORY_CIMPL_H_
+#define _MROS_TOPIC_CONNECTOR_FACTORY_CIMPL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_topic_connector_cimpl.h"
+
+typedef enum {
+	MROS_TOPIC_CONNECTOR_PUB = 0,
+	MROS_TOPIC_CONNECTOR_SUB,
+	MROS_TOPIC_CONNECTOR_NUM,
+} mRosTopicConnectorEnumType;
+
+extern mRosTopicConnectorManagerType *mros_topic_connector_factory_create(mRosTopicConnectorEnumType type);
+extern mRosTopicConnectorManagerType *mros_topic_connector_factory_get(mRosTopicConnectorEnumType type);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _MROS_TOPIC_CONNECTOR_FACTORY_CIMPL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/topic/cimpl/mros_topic_runner_cimpl.h
@@ -0,0 +1,16 @@
+#ifndef _MROS_TOPIC_RUNNER_CIMPL_H_
+#define _MROS_TOPIC_RUNNER_CIMPL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_types.h"
+
+extern void mros_topic_data_publisher_run(void);
+extern void mros_topic_data_subscriber_run(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _MROS_TOPIC_RUNNER_CIMPL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/transfer/cimpl/mros_topic_data_publisher_cimpl.c
@@ -0,0 +1,79 @@
+#include "mros_topic_data_publisher_cimpl.h"
+#include "mros_topic_connector_factory_cimpl.h"
+#include "mros_topic_cimpl.h"
+#include "mros_array_container.h"
+#include "mros_usr_config.h"
+
+MROS_ARRAY_CONTAINER_CONFIG_DECLARE_MANAGER(mros_topic_pub_mgr, MROS_TOPIC_MAX_NUM);
+
+static void mros_topic_publish(mRosTopicConnectorManagerType *mgrp, mRosNodeEnumType type, mRosContainerObjType topic_obj)
+{
+	mRosReturnType ret;
+	mRosContainerObjType obj;
+	mRosMemoryListEntryType *topic_data;
+	mRosTopicIdType topic_id;
+
+	ret = mros_topic_connector_get_topic(topic_obj, &topic_id);
+	if (ret != MROS_E_OK) {
+		return;
+	}
+
+	obj = mros_topic_connector_get_first(mgrp, type, topic_obj);
+	if (obj == MROS_COBJ_NULL) {
+		return;
+	}
+	while (obj != MROS_COBJ_NULL) {
+		ret = mros_topic_connector_receive_data(mgrp, obj, &topic_data);
+		if (ret != MROS_E_OK) {
+			obj = mros_topic_connector_get_next(mgrp, topic_obj, obj);
+			continue;
+		}
+		ret = mros_topic_add_data(topic_id, topic_data);
+		if (ret != MROS_E_OK) {
+			ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+			(void)mros_mem_free(topic_data->data.mgrp, topic_data);
+		}
+		obj = mros_topic_connector_get_next(mgrp, topic_obj, obj);
+	}
+
+	return;
+}
+
+mRosReturnType mros_topic_data_publisher_init(void)
+{
+	return MROS_E_OK;
+}
+
+void mros_topic_data_publisher_run(void)
+{
+	mRosContainerObjType topic_obj;
+	mRosTopicConnectorManagerType *mgrp;
+
+	mgrp = mros_topic_connector_factory_get(MROS_TOPIC_CONNECTOR_PUB);
+	if (mgrp == MROS_NULL) {
+		return;
+	}
+	mros_topic_pub_mgr.count = 0;
+
+	/**************************
+	 * INNER NODE
+	 **************************/
+	topic_obj = mros_topic_connector_get_topic_first(mgrp);
+	while (topic_obj != MROS_COBJ_NULL) {
+		mros_array_container_add(&mros_topic_pub_mgr, topic_obj);
+
+		mros_topic_publish(mgrp, MROS_NODE_TYPE_INNER, topic_obj);
+		topic_obj = mros_topic_connector_get_topic_next(mgrp, topic_obj);
+	}
+
+	/**************************
+	 * OUTER NODE
+	 **************************/
+	mros_uint32 i;
+	for (i = 0; i < mros_topic_pub_mgr.count; i++) {
+		mros_topic_publish(mgrp, MROS_NODE_TYPE_OUTER, mros_topic_pub_mgr.array[i]);
+	}
+
+	mros_topic_connector_purge(mgrp);
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/transfer/cimpl/mros_topic_data_publisher_cimpl.h
@@ -0,0 +1,15 @@
+#ifndef _MROS_TOPIC_DATA_PUBLISHER_CIMPL_H_
+#define _MROS_TOPIC_DATA_PUBLISHER_CIMPL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_types.h"
+
+extern mRosReturnType mros_topic_data_publisher_init(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _MROS_TOPIC_DATA_PUBLISHER_CIMPL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/transfer/cimpl/mros_topic_data_subscriber_cimpl.c
@@ -0,0 +1,70 @@
+#include "mros_topic_data_subscriber_cimpl.h"
+#include "mros_topic_connector_factory_cimpl.h"
+#include "mros_topic_cimpl.h"
+#include "mros_array_container.h"
+#include "mros_usr_config.h"
+
+MROS_ARRAY_CONTAINER_CONFIG_DECLARE_MANAGER(mros_topic_sub_mgr, MROS_TOPIC_MAX_NUM);
+
+static void mros_topic_subscribe(mRosTopicConnectorManagerType *mgrp, mRosNodeEnumType type, mRosContainerObjType topic_obj, mRosMemoryListEntryType *topic_data)
+{
+	mRosReturnType ret;
+	mRosContainerObjType obj;
+
+	obj = mros_topic_connector_get_first(mgrp, type, topic_obj);
+	if (obj == MROS_COBJ_NULL) {
+		return;
+	}
+
+	while (obj != MROS_COBJ_NULL) {
+		ret = mros_topic_connector_send_data(mgrp, obj, topic_data->data.memp, topic_data->data.size);
+		if (ret != MROS_E_OK) {
+			ROS_ERROR("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, ret);
+		}
+		obj = mros_topic_connector_get_next(mgrp, topic_obj, obj);
+	}
+
+	return;
+}
+
+mRosReturnType mros_topic_data_subscriber_init(void)
+{
+	return MROS_E_OK;
+}
+
+void mros_topic_data_subscriber_run(void)
+{
+	mRosContainerObjType topic_obj;
+	mRosTopicConnectorManagerType *mgrp;
+	mRosMemoryListEntryType *topic_data;
+	mRosTopicIdType topic_id;
+	mRosReturnType ret;
+	mros_uint32 i;
+
+	mgrp = mros_topic_connector_factory_get(MROS_TOPIC_CONNECTOR_SUB);
+	if (mgrp == MROS_NULL) {
+		return;
+	}
+	mros_topic_sub_mgr.count = 0;
+
+	topic_obj = mros_topic_connector_get_topic_first(mgrp);
+	while (topic_obj != MROS_COBJ_NULL) {
+		mros_array_container_add(&mros_topic_sub_mgr, topic_obj);
+		topic_obj = mros_topic_connector_get_topic_next(mgrp, topic_obj);
+	}
+	for (i = 0; i < mros_topic_sub_mgr.count; i++) {
+		ret = mros_topic_connector_get_topic(mros_topic_sub_mgr.array[i], &topic_id);
+		if (ret != MROS_E_OK) {
+			continue;
+		}
+		ret = mros_topic_get_data(topic_id, &topic_data);
+		if (ret == MROS_E_OK) {
+			mros_topic_subscribe(mgrp, MROS_NODE_TYPE_INNER, mros_topic_sub_mgr.array[i], topic_data);
+			mros_topic_subscribe(mgrp, MROS_NODE_TYPE_OUTER, mros_topic_sub_mgr.array[i], topic_data);
+			(void)mros_mem_free(topic_data->data.mgrp, topic_data);
+		}
+	}
+
+	mros_topic_connector_purge(mgrp);
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/mros-dev/mros-src/transfer/cimpl/mros_topic_data_subscriber_cimpl.h
@@ -0,0 +1,15 @@
+#ifndef _MROS_TOPIC_DATA_SUBSCRIBER_CIMPL_H_
+#define _MROS_TOPIC_DATA_SUBSCRIBER_CIMPL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mros_types.h"
+
+extern mRosReturnType mros_topic_data_subscriber_init(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _MROS_TOPIC_DATA_SUBSCRIBER_CIMPL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/serial/fifo/serial_fifo.c
@@ -0,0 +1,424 @@
+#include "cpu.h"
+#include "serial_fifo.h"
+#include "assert.h"
+#include "mpu_ops.h"
+#include "cpuemu_ops.h"
+#include "device.h"
+#include "athrill_mpthread.h"
+#include "target/target_os_api.h"
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+static AthrillSerialFifoType athrill_serial_fifo[SERIAL_FIFO_MAX_CHANNEL_NUM];
+static uint32 serial_fifo_base_addr = 0x0;
+static void serial_fifo_thread_start(uint32 channel);
+
+static char serial_fifo_param_buffer[256];
+
+typedef struct {
+	uint32 fd;
+} AthrillSerialFifoCounterType;
+static AthrillSerialFifoCounterType serial_fifo_counter = {
+	.fd = 1024,
+};
+
+void athrill_device_init_serial_fifo(void)
+{
+	uint32 i;
+	uint32 buffer_size;
+	Std_ReturnType ret;
+
+	ret = cpuemu_get_devcfg_value_hex("DEVICE_CONFIG_SERIAL_FILFO_BASE_ADDR", &serial_fifo_base_addr);
+	if (ret != STD_E_OK) {
+		return;
+	}
+	printf("DEVICE_CONFIG_SERIAL_FILFO_BASE_ADDR=0x%x\n", serial_fifo_base_addr);
+	(void)cpuemu_get_devcfg_value("DEVICE_CONFIG_SERIAL_FIFO_FD", &serial_fifo_counter.fd);
+	printf("DEVICE_CONFIG_SERIAL_FIFO_FD=%u\n", serial_fifo_counter.fd);
+
+	for (i = 0; i < SERIAL_FIFO_MAX_CHANNEL_NUM; i++) {
+		memset(serial_fifo_param_buffer, 0, sizeof(serial_fifo_param_buffer));
+		snprintf(serial_fifo_param_buffer, sizeof(serial_fifo_param_buffer), "DEVICE_CONFIG_SERIAL_FILFO_%d_SIZE", i);
+		ret = cpuemu_get_devcfg_value(serial_fifo_param_buffer, &buffer_size);
+		if (ret == STD_E_OK) {
+			uint32 enable_external_device = FALSE;
+			uint32 disable_cpuio = FALSE;
+			athrill_serial_fifo[i].rd_raise_delay_count = 0;
+			athrill_serial_fifo[i].rd_raise_intr = FALSE;
+			athrill_serial_fifo[i].wr_raise_delay_count = 0;
+			athrill_serial_fifo[i].wr_raise_intr = FALSE;
+			printf("%s=%u\n", serial_fifo_param_buffer, buffer_size);
+			ret = comm_fifo_buffer_create(buffer_size, &athrill_serial_fifo[i].rd);
+			ASSERT(ret == STD_E_OK);
+			ret = comm_fifo_buffer_create(SERIAL_FIFO_RD_BUFFER_LEN, &athrill_serial_fifo[i].rd_dev_buffer);
+			ASSERT(ret == STD_E_OK);
+
+			ret = comm_fifo_buffer_create(buffer_size, &athrill_serial_fifo[i].wr);
+			ASSERT(ret == STD_E_OK);
+			ret = comm_fifo_buffer_create(SERIAL_FIFO_WR_BUFFER_LEN, &athrill_serial_fifo[i].wr_dev_buffer);
+			ASSERT(ret == STD_E_OK);
+
+			snprintf(serial_fifo_param_buffer, sizeof(serial_fifo_param_buffer), "DEVICE_CONFIG_SERIAL_FILFO_%d_RD_INTNO", i);
+			ret = cpuemu_get_devcfg_value(serial_fifo_param_buffer, &athrill_serial_fifo[i].rd_intno);
+			ASSERT(ret == STD_E_OK);
+			printf("%s=%u\n", serial_fifo_param_buffer, athrill_serial_fifo[i].rd_intno);
+			snprintf(serial_fifo_param_buffer, sizeof(serial_fifo_param_buffer), "DEVICE_CONFIG_SERIAL_FILFO_%d_WR_INTNO", i);
+			ret = cpuemu_get_devcfg_value(serial_fifo_param_buffer, &athrill_serial_fifo[i].wr_intno);
+			ASSERT(ret == STD_E_OK);
+			printf("%s=%u\n", serial_fifo_param_buffer, athrill_serial_fifo[i].wr_intno);
+			snprintf(serial_fifo_param_buffer, sizeof(serial_fifo_param_buffer), "DEVICE_CONFIG_SERIAL_FILFO_%d_RD_INTOFF", i);
+			ret = cpuemu_get_devcfg_value(serial_fifo_param_buffer, &athrill_serial_fifo[i].rd_intoff);
+			ASSERT(ret == STD_E_OK);
+			printf("%s=%u\n", serial_fifo_param_buffer, athrill_serial_fifo[i].rd_intoff);
+			snprintf(serial_fifo_param_buffer, sizeof(serial_fifo_param_buffer), "DEVICE_CONFIG_SERIAL_FILFO_%d_WR_INTOFF", i);
+			ret = cpuemu_get_devcfg_value(serial_fifo_param_buffer, &athrill_serial_fifo[i].wr_intoff);
+			ASSERT(ret == STD_E_OK);
+			printf("%s=%u\n", serial_fifo_param_buffer, athrill_serial_fifo[i].wr_intoff);
+
+
+			snprintf(serial_fifo_param_buffer, sizeof(serial_fifo_param_buffer), "DEVICE_CONFIG_SERIAL_FILFO_%d_DISABLE_CPUIO", i);
+			(void)cpuemu_get_devcfg_value(serial_fifo_param_buffer, &disable_cpuio);
+			printf("%s=%u\n", serial_fifo_param_buffer, disable_cpuio);
+			athrill_serial_fifo[i].disable_cpu_io = disable_cpuio;
+
+			snprintf(serial_fifo_param_buffer, sizeof(serial_fifo_param_buffer), "DEVICE_CONFIG_SERIAL_FILFO_%d_EXDEV_ENABLE", i);
+			(void)cpuemu_get_devcfg_value(serial_fifo_param_buffer, &enable_external_device);
+			printf("%s=%u\n", serial_fifo_param_buffer, enable_external_device);
+			athrill_serial_fifo[i].is_extdev = enable_external_device;
+			if (enable_external_device == FALSE) {
+				printf("start default serial thread:%d\n", i);
+				serial_fifo_thread_start(i);
+			}
+		}
+		else {
+			athrill_serial_fifo[i].rd.data = NULL;
+			athrill_serial_fifo[i].wr.data = NULL;
+		}
+	}
+	return;
+}
+
+static void do_serial_fifo_cpu_read(uint32 channel)
+{
+	Std_ReturnType err;
+	uint8 data;
+	uint8 cmd;
+	uint32 res;
+
+	/*
+	 * status
+	 */
+	if (COMM_FIFO_IS_EMPTY(&athrill_serial_fifo[channel].rd)) {
+		//no data found
+		mpu_put_data8(0U, SERIAL_FIFO_READ_STATUS_ADDR(serial_fifo_base_addr, channel), SERIAL_FIFO_READ_STATUS_NO_DATA);
+	}
+	else {
+		//found data
+		mpu_put_data8(0U, SERIAL_FIFO_READ_STATUS_ADDR(serial_fifo_base_addr, channel), SERIAL_FIFO_READ_STATUS_DATA_IN);
+		if (athrill_serial_fifo[channel].rd.count >= athrill_serial_fifo[channel].rd_intoff) {
+			//device_raise_int(athrill_serial_fifo[channel].rd_intno);
+			if (athrill_serial_fifo[channel].rd_raise_intr == FALSE) {
+				athrill_serial_fifo[channel].rd_raise_delay_count = serial_fifo_counter.fd;
+				athrill_serial_fifo[channel].rd_raise_intr = TRUE;
+			}
+		}
+	}
+	/*
+	 * check command and move data
+	 */
+	mpu_get_data8(0U, SERIAL_FIFO_READ_CMD_ADDR(serial_fifo_base_addr, channel), &cmd);
+	if (cmd == SERIAL_FIFO_READ_CMD_MOVE) {
+		mpthread_lock(athrill_serial_fifo[channel].rx_thread);
+		err = comm_fifo_buffer_get(&athrill_serial_fifo[channel].rd, (char*)&data, 1, &res);
+		mpthread_unlock(athrill_serial_fifo[channel].rx_thread);
+		if (err == STD_E_OK) {
+			mpu_put_data8(0U, SERIAL_FIFO_READ_PTR_ADDR(serial_fifo_base_addr, channel), data);
+		}
+		mpu_put_data8(0U, SERIAL_FIFO_READ_CMD_ADDR(serial_fifo_base_addr, channel), SERIAL_FIFO_READ_CMD_NONE);
+	}
+
+	return;
+}
+static void do_serial_fifo_cpu_write_tx(uint32 channel)
+{
+	Std_ReturnType err;
+	uint32 i;
+	uint8 data;
+	uint32 res;
+	uint32 count;
+
+	mpthread_lock(athrill_serial_fifo[channel].tx_thread);
+	count = athrill_serial_fifo[channel].wr_dev_buffer.count;
+	//printf("do_serial_fifo_cpu_write_tx:B:wr_dev_buffer.count=%d\n", athrill_serial_fifo[channel].wr_dev_buffer.count);
+	for (i = 0; i < count; i++) {
+		//printf("do_serial_fifo_cpu_write_tx:wr.count=%d cond=%d\n", athrill_serial_fifo[channel].wr.count, COMM_FIFO_IS_FULL(&athrill_serial_fifo[channel].wr));
+		if (COMM_FIFO_IS_FULL(&athrill_serial_fifo[channel].wr)) {
+			break;
+		}
+		err = comm_fifo_buffer_get(&athrill_serial_fifo[channel].wr_dev_buffer, (char*)&data, 1, &res);
+		//printf("comm_fifo_buffer_get:err=%d\n", err);
+		if (err == STD_E_OK) {
+			//printf("do_serial_fifo_cpu_write_tx:%d:%c\n", i, data);
+			(void)comm_fifo_buffer_add(&athrill_serial_fifo[channel].wr, (const char*)&data, 1, &res);
+		}
+		else {
+			break;
+		}
+	}
+
+	//printf("do_serial_fifo_cpu_write_tx:err=%d\n", err);
+	//printf("do_serial_fifo_cpu_write_tx:wr.count=%d\n", athrill_serial_fifo[channel].wr.count);
+	//printf("do_serial_fifo_cpu_write_tx:A:wr_dev_buffer.count=%d\n", athrill_serial_fifo[channel].wr_dev_buffer.count);
+	mpthread_unlock(athrill_serial_fifo[channel].tx_thread);
+	if (athrill_serial_fifo[channel].wr_dev_buffer.count <= athrill_serial_fifo[channel].wr_intoff) {
+		//printf("do_serial_fifo_cpu_write_tx:raise interrupt\n");
+		//device_raise_int(athrill_serial_fifo[channel].wr_intno);
+		athrill_serial_fifo[channel].wr_raise_delay_count = serial_fifo_counter.fd;
+		athrill_serial_fifo[channel].wr_raise_intr = TRUE;
+	}
+	if (athrill_serial_fifo[channel].wr_dev_buffer.count == 0) {
+		mpu_put_data8(0U, SERIAL_FIFO_WRITE_CMD_ADDR(serial_fifo_base_addr, channel), SERIAL_FIFO_WRITE_CMD_NONE);
+	}
+	return;
+}
+
+static void do_serial_fifo_cpu_write(uint32 channel)
+{
+	uint8 data;
+	uint8 cmd;
+	uint32 res;
+	/*
+	 * status
+	 */
+	if (!COMM_FIFO_IS_FULL(&athrill_serial_fifo[channel].wr_dev_buffer)) {
+		mpu_put_data8(0U, SERIAL_FIFO_WRITE_STATUS_ADDR(serial_fifo_base_addr, channel), SERIAL_FIFO_WRITE_STATUS_CAN_DATA);
+	}
+	else {
+		mpu_put_data8(0U, SERIAL_FIFO_WRITE_STATUS_ADDR(serial_fifo_base_addr, channel), SERIAL_FIFO_WRITE_STATUS_DATA_FULL);
+	}
+	/*
+	 * check command and move data
+	 */
+	mpu_get_data8(0U, SERIAL_FIFO_WRITE_CMD_ADDR(serial_fifo_base_addr, channel), &cmd);
+	if (cmd == SERIAL_FIFO_WRITE_CMD_MOVE) {
+		mpu_get_data8(0U, SERIAL_FIFO_WRITE_PTR_ADDR(serial_fifo_base_addr, channel), &data);
+		//printf("do_serial_fifo_cpu_write:%c\n", data);
+		(void)comm_fifo_buffer_add(&athrill_serial_fifo[channel].wr_dev_buffer, (const char*)&data, 1, &res);
+		mpu_put_data8(0U, SERIAL_FIFO_WRITE_CMD_ADDR(serial_fifo_base_addr, channel), SERIAL_FIFO_WRITE_CMD_NONE);
+	}
+	else if (cmd == SERIAL_FIFO_WRITE_CMD_TX) {
+		do_serial_fifo_cpu_write_tx(channel);
+	}
+	return;
+}
+static void do_serial_fifo_cpu_intr(uint32 channel)
+{
+	if (athrill_serial_fifo[channel].rd_raise_intr == TRUE) {
+		if (athrill_serial_fifo[channel].rd_raise_delay_count == 0) {
+			device_raise_int(athrill_serial_fifo[channel].rd_intno);
+			athrill_serial_fifo[channel].rd_raise_intr = FALSE;
+			//printf("do_serial_fifo_cpu_intr:RX raise interrupt(%d)\n", athrill_serial_fifo[channel].rd_intno);
+		}
+		else {
+			athrill_serial_fifo[channel].rd_raise_delay_count--;
+			//printf("do_serial_fifo_cpu_intr:RX rd_raise_delay_count(%d)\n", athrill_serial_fifo[channel].rd_raise_delay_count);
+		}
+	}
+	if (athrill_serial_fifo[channel].wr_raise_intr == TRUE) {
+		if (athrill_serial_fifo[channel].wr_raise_delay_count == 0) {
+			device_raise_int(athrill_serial_fifo[channel].wr_intno);
+			athrill_serial_fifo[channel].wr_raise_intr = FALSE;
+			//printf("do_serial_fifo_cpu_intr:TX raise interrupt(%d)\n", athrill_serial_fifo[channel].wr_intno);
+		}
+		else {
+			athrill_serial_fifo[channel].wr_raise_delay_count--;
+		}
+	}
+	return;
+}
+void athrill_device_supply_clock_serial_fifo(DeviceClockType *dev_clock)
+{
+	uint32 i;
+	if (serial_fifo_base_addr == 0x0) {
+		return;
+	}
+	for (i = 0; i < SERIAL_FIFO_MAX_CHANNEL_NUM; i++) {
+		if (athrill_serial_fifo[i].rd.data == NULL) {
+			continue;
+		}
+		else if (athrill_serial_fifo[i].disable_cpu_io == TRUE) {
+			continue;
+		}
+		do_serial_fifo_cpu_read(i);
+		do_serial_fifo_cpu_write(i);
+		do_serial_fifo_cpu_intr(i);
+	}
+	return;
+}
+
+void athrill_device_get_serial_fifo_buffer(uint32 channel, AthrillSerialFifoType **serial_fifop)
+{
+	*serial_fifop = NULL;
+	if (serial_fifo_base_addr == 0x0) {
+		return;
+	}
+	if (channel >= SERIAL_FIFO_MAX_CHANNEL_NUM) {
+		return;
+	}
+	if (athrill_serial_fifo[channel].rd.data == NULL) {
+		return;
+	}
+	*serial_fifop = &athrill_serial_fifo[channel];
+	return;
+}
+
+/*
+ * Thread Common
+ */
+
+static Std_ReturnType serial_fifo_thread_do_init(MpthrIdType id)
+{
+	return STD_E_OK;
+}
+
+static Std_ReturnType serial_fifo_tx_thread_do_proc(MpthrIdType id)
+{
+	uint32 ch;
+	uint32 res;
+	uint8 data;
+	int fd;
+	ssize_t ret;
+	Std_ReturnType err;
+
+	mpthread_lock(id);
+	for (ch = 0; ch < SERIAL_FIFO_MAX_CHANNEL_NUM; ch++) {
+		if (athrill_serial_fifo[ch].wr.data == NULL) {
+			continue;
+		}
+		if (athrill_serial_fifo[ch].is_extdev == TRUE) {
+			continue;
+		}
+		if (athrill_serial_fifo[ch].tx_thread == id) {
+			break;
+		}
+	}
+	mpthread_unlock(id);
+	ASSERT(ch != SERIAL_FIFO_MAX_CHANNEL_NUM);
+
+	fd = -1;
+	while (fd < 0) {
+		fd = open(athrill_serial_fifo[ch].tx_serial_fifopath, O_WRONLY);
+		if (fd < 0) {
+			target_os_api_sleep(1000);// 1000msec
+			printf("ERROR: can not open fifo(%s)\n", athrill_serial_fifo[ch].tx_serial_fifopath);
+		}
+	}
+	ASSERT(fd >= 0);
+	printf("id=%d OK: open ch=%d tx_fifo(%s)\n", id, ch, athrill_serial_fifo[ch].tx_serial_fifopath);
+	while (TRUE) {
+		if (athrill_serial_fifo[ch].wr.count == 0) {
+			target_os_api_sleep(100);// 100msec
+			continue;
+		}
+		mpthread_lock(athrill_serial_fifo[ch].tx_thread);
+		err = comm_fifo_buffer_get(&athrill_serial_fifo[ch].wr, (char*)&data, 1, &res);
+		ASSERT(err == STD_E_OK);
+		mpthread_unlock(athrill_serial_fifo[ch].tx_thread);
+
+		ret = write(fd, (void*)&data, 1);
+		if (ret <= 0) {
+			printf("ERROR: can not put data on fifo(%s)\n", athrill_serial_fifo[ch].tx_serial_fifopath);
+		}
+	}
+	return STD_E_OK;
+}
+static Std_ReturnType serial_fifo_rx_thread_do_proc(MpthrIdType id)
+{
+	uint32 ch;
+	uint32 res;
+	uint8 data;
+	int fd;
+	ssize_t ret;
+	Std_ReturnType err;
+
+	mpthread_lock(id);
+	for (ch = 0; ch < SERIAL_FIFO_MAX_CHANNEL_NUM; ch++) {
+		if (athrill_serial_fifo[ch].rd.data == NULL) {
+			continue;
+		}
+		if (athrill_serial_fifo[ch].is_extdev == TRUE) {
+			continue;
+		}
+		if (athrill_serial_fifo[ch].rx_thread == id) {
+			break;
+		}
+	}
+	mpthread_unlock(id);
+	ASSERT(ch != SERIAL_FIFO_MAX_CHANNEL_NUM);
+	printf("id=%d OK: open ch=%d rx_fifo(%s)\n", id, ch, athrill_serial_fifo[ch].rx_serial_fifopath);
+
+	fd = -1;
+	while (fd < 0) {
+		fd = open(athrill_serial_fifo[ch].rx_serial_fifopath, O_RDONLY);
+		if (fd < 0) {
+			target_os_api_sleep(1000);// 1000msec
+			printf("ERROR: serial can not open fifo(%s)\n", athrill_serial_fifo[ch].rx_serial_fifopath);
+		}
+	}
+	ASSERT(fd >= 0);
+
+	while (TRUE) {
+		if (COMM_FIFO_IS_FULL(&athrill_serial_fifo[ch].rd)) {
+			target_os_api_sleep(500);// 500msec
+			continue;
+		}
+		ret = read(fd, (void*)&data, 1);
+		if (ret <= 0) {
+			target_os_api_sleep(500);// 500msec
+			//printf("ERROR: can not get data from fifo(%s)\n", athrill_serial_fifo[ch].rx_serial_fifopath);
+			continue;
+		}
+		mpthread_lock(athrill_serial_fifo[ch].rx_thread);
+		err = comm_fifo_buffer_add(&athrill_serial_fifo[ch].rd, (const char*)&data, 1, &res);
+		ASSERT(err == STD_E_OK);
+		mpthread_unlock(athrill_serial_fifo[ch].rx_thread);
+	}
+	return STD_E_OK;
+}
+static MpthrOperationType	rx_thread_ops = {
+	.do_init = serial_fifo_thread_do_init,
+	.do_proc = serial_fifo_rx_thread_do_proc,
+};
+static MpthrOperationType	tx_thread_ops = {
+	.do_init = serial_fifo_thread_do_init,
+	.do_proc = serial_fifo_tx_thread_do_proc,
+};
+
+static void serial_fifo_thread_start(uint32 channel)
+{
+	Std_ReturnType err;
+
+	snprintf(serial_fifo_param_buffer, sizeof(serial_fifo_param_buffer), "DEVICE_CONFIG_SERIAL_FILFO_%d_RD_FIFO", channel);
+	err = cpuemu_get_devcfg_string(serial_fifo_param_buffer, &athrill_serial_fifo[channel].rx_serial_fifopath);
+	ASSERT(err == STD_E_OK);
+
+	snprintf(serial_fifo_param_buffer, sizeof(serial_fifo_param_buffer), "DEVICE_CONFIG_SERIAL_FILFO_%d_WR_FIFO", channel);
+	err = cpuemu_get_devcfg_string(serial_fifo_param_buffer, &athrill_serial_fifo[channel].tx_serial_fifopath);
+	ASSERT(err == STD_E_OK);
+
+	err = mpthread_register(&athrill_serial_fifo[channel].rx_thread, &rx_thread_ops);
+	ASSERT(err == STD_E_OK);
+	err = mpthread_register(&athrill_serial_fifo[channel].tx_thread, &tx_thread_ops);
+	ASSERT(err == STD_E_OK);
+	//printf("ch=%d tx_thr_id=%d\n", channel, athrill_serial_fifo[channel].tx_thread);
+	//printf("ch=%d rx_thr_id=%d\n", channel, athrill_serial_fifo[channel].rx_thread);
+
+	err = mpthread_start_proc(athrill_serial_fifo[channel].rx_thread);
+	ASSERT(err == STD_E_OK);
+	err = mpthread_start_proc(athrill_serial_fifo[channel].tx_thread);
+	ASSERT(err == STD_E_OK);
+	return;
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/serial/fifo/serial_fifo.h
@@ -0,0 +1,127 @@
+#ifndef _SERIAL_FIFO_H_
+#define _SERIAL_FIFO_H_
+
+#include "std_types.h"
+#include "std_device_ops.h"
+#include "comm_buffer.h"
+#include "athrill_mpthread.h"
+
+#define SERIAL_FIFO_MAX_CHANNEL_NUM					8U
+
+#define SERIAL_FIFO_WRITE_STATUS_OFF				(SERIAL_FIFO_MAX_CHANNEL_NUM * 0U)
+#define SERIAL_FIFO_WRITE_CMD_OFF					(SERIAL_FIFO_MAX_CHANNEL_NUM * 1U)
+#define SERIAL_FIFO_WRITE_PTR_OFF					(SERIAL_FIFO_MAX_CHANNEL_NUM * 2U)
+#define SERIAL_FIFO_READ_STATUS_OFF					(SERIAL_FIFO_MAX_CHANNEL_NUM * 3U)
+#define SERIAL_FIFO_READ_CMD_OFF					(SERIAL_FIFO_MAX_CHANNEL_NUM * 4U)
+#define SERIAL_FIFO_READ_PTR_OFF					(SERIAL_FIFO_MAX_CHANNEL_NUM * 5U)
+
+/*
+ * status:
+ *  0x0: can write
+ *  0x1: can not write(busy)
+ */
+#define SERIAL_FIFO_WRITE_STATUS_ADDR(base, ch)		((base) + SERIAL_FIFO_WRITE_STATUS_OFF + (ch))
+/*
+ * cmd:
+ *  0x0: no cmd
+ *  0x1: move one char data from fifo buffer
+ */
+#define SERIAL_FIFO_WRITE_CMD_ADDR(base, ch)		((base) + SERIAL_FIFO_WRITE_CMD_OFF + (ch))
+#define SERIAL_FIFO_WRITE_PTR_ADDR(base, ch)		((base) + SERIAL_FIFO_WRITE_PTR_OFF    + (ch))
+
+#define SERIAL_FIFO_WRITE_STATUS_CAN_DATA		0x0
+#define SERIAL_FIFO_WRITE_STATUS_DATA_FULL		0x1
+
+#define SERIAL_FIFO_WRITE_CMD_NONE				0x0
+#define SERIAL_FIFO_WRITE_CMD_MOVE				0x1
+#define SERIAL_FIFO_WRITE_CMD_TX				0x2
+
+/*
+ *  cpu write example:
+ *  	while (res > 0) {
+ *  		status = dev_read(status_addr);
+ *  		if (status == 0x0) {
+ *	 			dev_write(ptr_addr, data);
+ *	 			dev_write(cmd_addr, 0x1);
+ *	 			res--;
+ * 			}
+ * 			else { busy..
+ * 				break;
+ * 			}
+ * 		}
+ * 		dev_write(cmd_addr, 0x2);
+ */
+
+
+/*
+ * status:
+ *  0x0: can not read(no data)
+ *  0x1: can read
+ */
+#define SERIAL_FIFO_READ_STATUS_ADDR(base, ch)		((base) + SERIAL_FIFO_READ_STATUS_OFF + (ch))
+/*
+ * cmd:
+ *  0x0: no cmd
+ *  0x1: move one char data from fifo buffer
+ */
+#define SERIAL_FIFO_READ_CMD_ADDR(base, ch)			((base) + SERIAL_FIFO_READ_CMD_OFF + (ch))
+#define SERIAL_FIFO_READ_PTR_ADDR(base, ch)			((base) + SERIAL_FIFO_READ_PTR_OFF    + (ch))
+#define SERIAL_FIFO_READ_STATUS_NO_DATA			0x0
+#define SERIAL_FIFO_READ_STATUS_DATA_IN			0x1
+
+#define SERIAL_FIFO_READ_CMD_NONE				0x0
+#define SERIAL_FIFO_READ_CMD_MOVE				0x1
+
+/*
+ *  cpu read example:
+ *  	while (1) {
+ *  		status = dev_read(status_addr);
+ *  		if (status == 0x1) {
+ *	 			dev_write(cmd_addr, 0x1);
+ *  			data = dev_read(ptr_addr);
+ * 			}
+ * 			else { no data..
+ * 				break;
+ * 			}
+ * 		}
+ */
+
+extern void athrill_device_init_serial_fifo(void);
+extern void athrill_device_supply_clock_serial_fifo(DeviceClockType *dev_clock);
+#define SERIAL_FIFO_RD_BUFFER_LEN	16U
+#define SERIAL_FIFO_WR_BUFFER_LEN	16U
+typedef struct {
+	std_bool			is_extdev;
+	std_bool			disable_cpu_io;
+	/*
+	 * read: cpu
+	 * write: external device
+	 */
+	CommFifoBufferType 	rd;
+	CommFifoBufferType	rd_dev_buffer;
+	uint32				rd_intno;
+	uint32				rd_intoff;
+	uint32				rd_raise_delay_count;
+	std_bool			rd_raise_intr;
+	/*
+	 * read: external device
+	 * write: cpu
+	 */
+	CommFifoBufferType 	wr;
+	CommFifoBufferType	wr_dev_buffer;
+	uint32				wr_intno;
+	uint32				wr_intoff;
+	uint32				wr_raise_delay_count;
+	std_bool			wr_raise_intr;
+
+	/*
+	 * for serial ext thread info
+	 */
+	MpthrIdType			rx_thread;
+	char				*rx_serial_fifopath;
+	MpthrIdType			tx_thread;
+	char				*tx_serial_fifopath;
+} AthrillSerialFifoType;
+extern void athrill_device_get_serial_fifo_buffer(uint32 channel, AthrillSerialFifoType **serial_fifop);
+
+#endif /* _SERIAL_FIFO_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/device/peripheral/target/device_ex_serial_ops.h
@@ -0,0 +1,18 @@
+#ifndef _DEVICE_EX_SERIAL_OPS_H_
+#define _DEVICE_EX_SERIAL_OPS_H_
+
+typedef struct {
+	/*
+	 * シリアル出力をCPUエミュレータから外部に出力する．
+	 */
+	bool (*putchar) (uint8 channel, uint8 data);
+	/*
+	 * シリアル入力をCPUエミュレータの外部から入力する．
+	 */
+	bool (*getchar) (uint8 channel, uint8 *data);
+
+	void (*flush) (uint8 channel);
+} DeviceExSerialOpType;
+extern void device_ex_serial_register_ops(uint8 channel, DeviceExSerialOpType *ops);
+
+#endif /* _DEVICE_EX_SERIAL_OPS_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/inc/athrill_device.h
@@ -0,0 +1,26 @@
+#ifndef _ATHRILL_DEVICE_H_
+#define _ATHRILL_DEVICE_H_
+
+#include "std_types.h"
+#include "cpu.h"
+#include "std_device_ops.h"
+#include "cpu.h"
+
+extern void device_init_athrill_device(void);
+extern void device_init_athrill_exdev(void);
+extern void device_add_athrill_exdev(void *devp, void *region);
+
+extern void device_supply_clock_athrill_device(void);
+extern void device_supply_clock_exdev(DeviceClockType *dev_clock);
+extern void athrill_device_cleanup(void);
+
+
+typedef struct {
+	int fd;
+	void *addr;
+} AthrillDeviceMmapInfoType;
+extern void athrill_device_set_mmap_info(AthrillDeviceMmapInfoType *info);
+
+extern void athrill_syscall_device(uint32 addr);
+
+#endif /* _ATHRILL_DEVICE_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/inc/athrill_exdev.h
@@ -0,0 +1,109 @@
+#ifndef _ATHRILL_EXDEV_H_
+#define _ATHRILL_EXDEV_H_
+
+#include "std_errno.h"
+#include "mpu_types.h"
+#include "std_device_ops.h"
+#include "comm_buffer.h"
+#include "tcp/tcp_client.h"
+#include "tcp/tcp_server.h"
+#include "udp/udp_comm.h"
+#include "athrill_mpthread.h"
+#include "serial_fifo.h"
+
+typedef struct {
+	Std_ReturnType (*get_devcfg_value) (const char* key, uint32 *value);
+	Std_ReturnType (*get_devcfg_value_hex) (const char* key, uint32 *value);
+	Std_ReturnType (*get_devcfg_string) (const char* key, char **value);
+} AthrillExDevParamOperationType;
+
+typedef struct {
+	Std_ReturnType (*add_intr) (const char* name, uint32 intno, uint32 priority); //TODO target dependent function
+	void (*raise_intr) (uint32 intno);
+} AthrillExDevIntrOperationType;
+
+typedef struct {
+	/*
+	 * fifo
+	 */
+	struct {
+		Std_ReturnType (*create) (uint32 size, CommFifoBufferType *fifop);
+		Std_ReturnType (*add) (CommFifoBufferType *fifop, const char* datap, uint32 datalen, uint32 *res);
+		Std_ReturnType (*get) (CommFifoBufferType *fifop, char* datap, uint32 datalen, uint32 *res);
+		void (*close) (CommFifoBufferType *fifop);
+		void (*destroy) (CommFifoBufferType *fifop);
+	} fifo;
+
+	/*
+	 * tcp
+	 */
+	struct {
+		Std_ReturnType (*client_create) (const TcpClientConfigType *config, TcpClientType *client);
+		Std_ReturnType (*client_connect) (TcpClientType *client);
+
+		Std_ReturnType (*send) (TcpConnectionType *connection, const char *data, uint32 size, uint32 *res);
+		Std_ReturnType (*receive) (TcpConnectionType *connection, char *data, uint32 size, uint32 *res);
+		Std_ReturnType (*send_nblk) (TcpConnectionType *connection, const char *data, uint32 size, uint32 *res);
+		Std_ReturnType (*receive_nblk) (TcpConnectionType *connection, char *data, uint32 size, uint32 *res);
+		void (*client_close) (TcpConnectionType *connection);
+
+		Std_ReturnType (*server_create) (const TcpServerConfigType *config, TcpServerType *server);
+		Std_ReturnType (*server_accept) (const TcpServerType *server, TcpConnectionType *connection);
+		void (*server_close) (TcpServerType *server);
+	} tcp;
+
+	/*
+	 * udp
+	 */
+	struct {
+		Std_ReturnType (*create) (const UdpCommConfigType *config, UdpCommType *comm);
+		Std_ReturnType (*create_ipaddr) (const UdpCommConfigType *config, UdpCommType *comm, const char* my_ipaddr);
+
+		Std_ReturnType (*read) (UdpCommType *comm);
+		Std_ReturnType (*write) (UdpCommType *comm);
+		Std_ReturnType (*remote_write) (UdpCommType *comm, const char *remote_ipaddr);
+		void (*delete) (UdpCommType *comm);
+	} udp;
+	/*
+	 * thread
+	 */
+	struct {
+		Std_ReturnType (*init) (void);
+		Std_ReturnType (*thr_register) (MpthrIdType *id, MpthrOperationType *op);
+		void (*lock) (MpthrIdType id);
+		void (*unlock) (MpthrIdType id);
+		MpthrStatusType (*get_status) (MpthrIdType id);
+		Std_ReturnType (*start_proc) (MpthrIdType id);
+		Std_ReturnType (*wait_proc) (MpthrIdType id);
+		Std_ReturnType (*timedwait_proc) (MpthrIdType id, sint32 timeout);
+	} thread;
+} AthrillExDevLibOperationType;
+
+typedef struct {
+	Std_ReturnType (*get_memory) (uint32 addr, uint8 **data);
+	void (*get_serial_fifo) (uint32 channel, AthrillSerialFifoType **serial_fifop);
+} AthrillExDevDeviceOperationType;
+
+typedef struct {
+	AthrillExDevParamOperationType	param;
+	AthrillExDevIntrOperationType	intr;
+	AthrillExDevDeviceOperationType	dev;
+	AthrillExDevLibOperationType	libs;
+} AthrillExDevOperationType;
+
+extern AthrillExDevOperationType athrill_exdev_operation;
+
+#include "athrill_exdev_header.h"
+/*
+ * dynamic symbol name: "athrill_ex_device"
+ */
+typedef struct {
+	AthrillExDeviceHeaderType header;
+	char *datap;
+	MpuAddressRegionOperationType *ops;
+	void (*devinit) (MpuAddressRegionType *, AthrillExDevOperationType *);
+	void (*supply_clock) (DeviceClockType *);
+	void (*cleanup) (void);
+} AthrillExDeviceType;
+
+#endif /* _ATHRILL_EXDEV_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/inc/athrill_exdev_header.h
@@ -0,0 +1,13 @@
+#ifndef _ATHRILL_EXDEV_HEADER_H_
+#define _ATHRILL_EXDEV_HEADER_H_
+
+#define ATHRILL_EXTERNAL_DEVICE_MAGICNO		0xBEEFDEAD
+#define ATHRILL_EXTERNAL_DEVICE_VERSION		0x00000004
+typedef struct {
+	unsigned int magicno; /* ATHRILL_EXTERNAL_DEVICE_MAGICNO */
+	unsigned int version; /* ATHRILL_EXTERNAL_DEVICE_VERSION */
+	int memory_size; /* Bytes */
+} AthrillExDeviceHeaderType;
+
+
+#endif /* _ATHRILL_EXDEV_HEADER_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/inc/athrill_mpthread.h
@@ -0,0 +1,34 @@
+#ifndef _ATHRILL_MPTHREAD_H_
+#define _ATHRILL_MPTHREAD_H_
+
+#include "std_types.h"
+#include "std_errno.h"
+
+typedef uint32 MpthrIdType;
+typedef struct {
+    Std_ReturnType (*do_init) (MpthrIdType id);
+    Std_ReturnType (*do_proc) (MpthrIdType id);
+} MpthrOperationType;
+
+/*
+ * Manager api
+ */
+extern Std_ReturnType mpthread_init(void);
+extern Std_ReturnType mpthread_register(MpthrIdType *id, MpthrOperationType *op);
+
+/*
+ * Thread api
+ */
+typedef enum {
+    MPTHR_STATUS_INITIALIZING = 0,
+    MPTHR_STATUS_RUNNING,
+    MPTHR_STATUS_WAITING,
+} MpthrStatusType;
+extern void mpthread_lock(MpthrIdType id);
+extern void mpthread_unlock(MpthrIdType id);
+extern MpthrStatusType mpthread_get_status(MpthrIdType id);
+extern Std_ReturnType mpthread_start_proc(MpthrIdType id);
+extern Std_ReturnType mpthread_wait_proc(MpthrIdType id);
+extern Std_ReturnType mpthread_timedwait_proc(MpthrIdType id, sint32 timeout);
+
+#endif /* _ATHRILL_MPTHREAD_H_ */
\ No newline at end of file
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/inc/cpu_config_ops.h
@@ -0,0 +1,6 @@
+#ifndef _CPU_CONFIG_OPS_H_
+#define _CPU_CONFIG_OPS_H_
+
+extern int cpu_config_get_core_id_num(void);
+
+#endif /* _CPU_CONFIG_OPS_H_ */
\ No newline at end of file
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/inc/cpuemu_ops.h
@@ -0,0 +1,81 @@
+#ifndef _CPUEMU_OPS_H_
+#define _CPUEMU_OPS_H_
+
+#include "std_types.h"
+#include "cpu_config.h"
+#include "target_cpu.h"
+#include "cpu_config_ops.h"
+#ifdef OS_LINUX
+#include <sys/time.h>
+#endif /* OS_LINUX */
+
+typedef struct {
+	uint64	total_clocks;
+	uint64	intr_clocks;
+	int     core_id_num;
+	uint64  cpu_clocks[CPU_CONFIG_CORE_NUM];
+#ifdef OS_LINUX
+	struct timeval elaps_tv;
+#endif /* OS_LINUX */
+} CpuEmuElapsType;
+extern void cpuemu_init(void *(*cpu_run)(void *), void *opt);
+extern void cpuemu_get_elaps(CpuEmuElapsType *elaps);
+#ifdef OS_LINUX
+extern void cpuemu_start_elaps(void);
+extern void cpuemu_end_elaps(void);
+#endif /* OS_LINUX */
+extern uint32 cpuemu_get_retaddr(CoreIdType core_id);
+extern Std_ReturnType cpuemu_get_addr_pointer(uint32 addr, uint8 **data);
+extern void cpuemu_get_register(CoreIdType core_id, TargetCoreType *cpu);
+
+extern void *cpuemu_thread_run(void* arg);
+extern uint64 cpuemu_get_cpu_end_clock(void);
+extern void cpuemu_set_cpu_end_clock(uint64 clock);
+
+
+extern Std_ReturnType cpuemu_set_comm_fifocfg(const char* fifocfg);
+extern const char* cpuemu_get_comm_rx_fifo(void);
+extern const char* cpuemu_get_comm_tx_fifo(void);
+
+extern Std_ReturnType cpuemu_symbol_set(void);
+
+extern void cpuemu_raise_intr(uint32 intno);
+
+
+/*
+ * the following enum values must be equal MpuAddressGetType(mpu_ops.h).
+ */
+typedef enum {
+	MemoryAddressImplType_ROM = 0,
+	MemoryAddressImplType_RAM,
+	MemoryAddressImplType_MMAP,
+	MemoryAddressImplType_MALLOC,
+	MemoryAddressImplType_DEV,
+} MemoryAddressImplType;
+
+typedef struct {
+	MemoryAddressImplType type;
+	uint32	start;						/* unit:byte */
+	uint32	size;						/* unit:KB */
+	void *mmap_addr;
+	void *extdev_handle;
+	bool region_executable;				/* X */
+	bool region_elf_load_from_vaddr;	/* V */
+} MemoryAddressType;
+
+typedef struct {
+	uint32				rom_num;
+	MemoryAddressType	*rom;
+	uint32				ram_num;
+	MemoryAddressType	*ram;
+	uint32				dev_num;
+	MemoryAddressType	*dev;
+} MemoryAddressMapType;
+extern Std_ReturnType cpuemu_load_memmap(const char *path, MemoryAddressMapType *map);
+
+extern Std_ReturnType cpuemu_load_devcfg(const char *path);
+extern Std_ReturnType cpuemu_get_devcfg_value(const char* key, uint32 *value);
+extern Std_ReturnType cpuemu_get_devcfg_value_hex(const char* key, uint32 *value);
+extern Std_ReturnType cpuemu_get_devcfg_string(const char* key, char **value);
+
+#endif /* _CPUEMU_OPS_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/inc/std_cpu_ops.h
@@ -0,0 +1,18 @@
+#ifndef _STD_CPU_OPS_H_
+#define _STD_CPU_OPS_H_
+
+#include "std_types.h"
+#include "std_errno.h"
+#include "cpu_config_ops.h"
+
+extern void cpu_init(void);
+extern void cpu_reset(CoreIdType core_id);
+extern void cpu_illegal_opcode_trap(CoreIdType core_id);
+extern void cpu_set_current_core(CoreIdType core_id);
+extern Std_ReturnType cpu_supply_clock(CoreIdType core_id);
+extern bool cpu_is_halt(CoreIdType core_id);
+extern bool cpu_is_halt_all(void);
+extern void cpu_mpu_construct_containers(CoreIdType core_id);
+extern bool cpu_illegal_access(CoreIdType core_id);
+
+#endif /* _STD_CPU_OPS_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/inc/std_device_ops.h
@@ -0,0 +1,159 @@
+#ifndef _STD_DEVICE_OPS_H_
+#define _STD_DEVICE_OPS_H_
+
+#include "cpu_config_ops.h"
+#ifdef OS_LINUX
+#include <sys/time.h>
+#include <time.h>
+
+static inline uint64 cpuemu_timeval2usec(struct timeval *tv)
+{
+	return ( (tv->tv_sec * 1000000LU) + tv->tv_usec );
+}
+
+static inline void cpuemu_timeval_sub(struct timeval *tv1, struct timeval *tv2, struct timeval *tv_result)
+{
+	tv_result->tv_sec = tv1->tv_sec - tv2->tv_sec;
+	if (tv1->tv_usec >= tv2->tv_usec) {
+		tv_result->tv_usec = tv1->tv_usec - tv2->tv_usec;
+	}
+	else {
+		tv_result->tv_usec = (1000000 + tv1->tv_usec) - tv2->tv_usec;
+		tv_result->tv_sec--;
+	}
+	return;
+}
+static inline void cpuemu_timeval_add(struct timeval *tv1, struct timeval *tv2, struct timeval *tv_result)
+{
+	tv_result->tv_sec = tv1->tv_sec + tv2->tv_sec;
+	tv_result->tv_usec = tv1->tv_usec + tv2->tv_usec;
+	if (tv_result->tv_usec >= 1000000) {
+		tv_result->tv_usec -= 1000000;
+		tv_result->tv_sec++;
+	}
+	return;
+}
+static inline void cpuemu_timespec_sub(struct timespec *tv1, struct timespec *tv2, struct timespec *tv_result)
+{
+	tv_result->tv_sec = tv1->tv_sec - tv2->tv_sec;
+	if (tv1->tv_nsec >= tv2->tv_nsec) {
+		tv_result->tv_nsec = tv1->tv_nsec - tv2->tv_nsec;
+	}
+	else {
+		tv_result->tv_nsec = (1000000000 + tv1->tv_nsec) - tv2->tv_nsec;
+		tv_result->tv_sec--;
+	}
+	return;
+}
+
+#define PROF_STAT_LOOP_MAX	1
+typedef struct {
+	uint64 max; /* nsec */
+	uint64 total; /* nsec */
+	uint64 count;
+	struct timespec start_ts;
+	struct timespec end_ts;
+	struct timespec elaps_ts;
+} ProfStatType;
+
+static inline void profstat_start(ProfStatType *prof)
+{
+	clock_gettime(CLOCK_REALTIME, &prof->start_ts);
+	return;
+}
+static inline void profstat_end(ProfStatType *prof)
+{
+	if (prof->start_ts.tv_sec == 0) {
+		return;
+	}
+	clock_gettime(CLOCK_REALTIME, &prof->end_ts);
+	cpuemu_timespec_sub(&prof->end_ts, &prof->start_ts, &prof->elaps_ts);
+	/* set max */
+	uint64 elaps = ((uint64)(prof->elaps_ts.tv_sec) * ((uint64)1000000000)) + (uint64)(prof->elaps_ts.tv_nsec);
+	//uint64 elaps =  (uint64)(prof->elaps.tv_usec);
+	//printf("%llu start=%lu end=%lu loop=%u\n", elaps, prof->start_time.tv_sec, prof->end_time.tv_sec, prof->loop);
+	if (prof->max < elaps) {
+		prof->max = elaps;
+	}
+	/* set average */
+	prof->count++;
+	prof->total += elaps;
+	return;
+}
+#ifdef CONFIG_STAT_PERF
+#define DEBUG_STAT_NUM	5
+extern ProfStatType cpuemu_cpu_total_prof;
+extern ProfStatType cpuemu_dev_total_prof;
+extern ProfStatType cpuemu_dbg_total_prof[DEBUG_STAT_NUM];
+extern ProfStatType cpuemu_dev_timer_prof;
+extern ProfStatType cpuemu_dev_serial_prof;
+extern ProfStatType cpuemu_dev_intr_prof;
+extern ProfStatType cpuemu_dev_adev1_prof;
+extern ProfStatType cpuemu_dev_adev2_prof;
+extern ProfStatType cpuemu_tool1_prof;
+extern ProfStatType cpuemu_tool2_prof;
+
+#define PROFSTAT_START(arg)	profstat_start(arg)
+#define PROFSTAT_END(arg)	profstat_end(arg)
+#else
+#define PROFSTAT_START(arg)
+#define PROFSTAT_END(arg)
+#endif
+#endif /* OS_LINUX */
+
+/*
+ * スキップ可能な最大クロック数
+ */
+#ifndef CPUEMU_CLOCK_BUG_FIX
+#define DEVICE_CLOCK_MAX_INTERVAL	-1
+#else
+#define DEVICE_CLOCK_MAX_INTERVAL	-1ULL
+#endif /* CPUEMU_CLOCK_BUG_FIX */
+
+typedef struct {
+	uint64 clock;
+	uint64 intclock;//割込み処理で消費している時間
+#ifdef OS_LINUX
+	struct timeval elaps_tv;
+	struct timeval start_tv;
+#endif /* OS_LINUX */
+
+
+	/**************************************
+	 * CPUがHALT状態になった場合，タイマ割り込みの
+	 * 発生する時間まで時間を飛ばす機能
+	 *
+	 * 本機能はまだ検討中のものであるため，注意して
+	 * 使用する．
+	 *
+	 **************************************/
+	/*
+	 * 本機能のON/OFFをする
+	 */
+	std_bool	enable_skip;
+	/*
+	 * デバイスが時間飛ばし可能かどうかを判断した結果を格納する
+	 */
+	std_bool	can_skip_clock;
+	/*
+	 * 全デバイス中で次の割り込みが発生するまでの時間の最小値
+	 */
+	uint64 	min_intr_interval;
+	std_bool	is_halt;
+} DeviceClockType;
+
+#ifndef ATHRILL_EXT_DEVICE
+extern void device_init(CpuType *cpu, DeviceClockType *dev_clock);
+extern void device_supply_clock(DeviceClockType *dev_clock);
+/*
+ * デバイスクロック参照
+ */
+extern void device_get_clock(DeviceClockType *dev_clock);
+
+/*
+ * 割込みコントローラ制御
+ */
+extern int intc_raise_intr(uint32 intno);
+
+#endif /* ATHRILL_EXT_DEVICE */
+#endif /* _STD_DEVICE_OPS_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/inc/std_errno.h
@@ -0,0 +1,13 @@
+#ifndef _STD_ERRNO_H_
+#define _STD_ERRNO_H_
+
+#define	STD_E_OK		0U
+#define STD_E_DECODE	1U
+#define STD_E_EXEC		2U
+#define STD_E_SEGV		3U
+#define STD_E_INVALID	4U
+#define STD_E_NOENT		5U
+#define STD_E_LIMIT		6U
+#define STD_E_PERM		7U
+
+#endif /* _STD_ERRNO_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/inc/std_types.h
@@ -0,0 +1,51 @@
+﻿#ifndef _STD_TYPES_H_
+#define _STD_TYPES_H_
+
+typedef signed char sint8;
+typedef signed short sint16;
+typedef signed int sint32;
+typedef signed long long sint64;
+
+typedef unsigned char uint8;
+typedef unsigned short uint16;
+typedef unsigned int uint32;
+typedef unsigned long long uint64;
+typedef int	bool;
+typedef int std_bool;
+#define DEFINE_FLOAT_TYPEDEF
+typedef float float32;
+typedef double float64;
+
+typedef uint32 Std_ReturnType;
+
+typedef uint32 CoreIdType;
+
+
+#ifndef NULL
+#define NULL	((void*)0)
+#endif
+
+#ifndef TRUE
+#define TRUE	(1U)
+#endif
+
+#ifndef FALSE
+#define FALSE	(0U)
+#endif
+
+#ifndef UINT_C
+#define UINT_C(val)		(val ## U)
+#endif /* UINT_C */
+
+
+#ifdef __i386__
+#define CAST_UINT32_TO_ADDR(uint32_data) ( (void*)((uint32)(uint32_data)) )
+#elif __x86_64__
+#define CAST_UINT32_TO_ADDR(uint32_data) ( (void*)((uint64)(uint32_data)) )
+#elif __arm64
+#define CAST_UINT32_TO_ADDR(uint32_data) ( (void*)((uint64)(uint32_data)) )
+#else
+#error "unknown arch."
+#endif
+
+#endif /* _STD_TYPES_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/assert.h
@@ -0,0 +1,15 @@
+#ifndef _ASSERT_H_
+#define _ASSERT_H_
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#define ASSERT(expr)	\
+do {	\
+	if (!(expr))	{	\
+		printf("ASSERTION FAILED:%s:%s:%d:%s\n", __FILE__, __FUNCTION__, __LINE__, #expr);	\
+		exit(1);	\
+	}	\
+} while (0)
+
+#endif /* _ASSERT_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/athrill_memory.h
@@ -0,0 +1,62 @@
+#ifndef _ATHRLL_MEMORY_H_
+#define _ATHRLL_MEMORY_H_
+
+#include "std_types.h"
+#include "assert.h"
+#include <string.h>
+
+#define ATHRILL_MEM_ENTRY_SIZE	(10240 * 1024 * 4)
+typedef struct {
+	uint32 free_start;
+	uint32 freesize;
+	void *next;
+	uint8 data[ATHRILL_MEM_ENTRY_SIZE];
+} AthrillMemEntryType;
+
+typedef struct {
+	AthrillMemEntryType *headp;
+	AthrillMemEntryType *currp;
+} AthrillMemHeadType;
+
+extern AthrillMemHeadType athrill_mem_head;
+
+static inline void athrill_mem_init(AthrillMemEntryType *entryp)
+{
+	entryp->next = NULL;
+	entryp->free_start = 0U;
+	entryp->freesize = ATHRILL_MEM_ENTRY_SIZE;
+	return;
+}
+
+static inline void *athrill_mem_alloc(uint32 size)
+{
+	static int alloc_count = 0;
+	ASSERT(size <= ATHRILL_MEM_ENTRY_SIZE);
+	if (athrill_mem_head.headp == NULL) {
+		athrill_mem_head.headp = malloc(sizeof(AthrillMemEntryType));
+		alloc_count++;
+		ASSERT(athrill_mem_head.headp != NULL);
+		athrill_mem_head.currp = athrill_mem_head.headp;
+		athrill_mem_init(athrill_mem_head.headp);
+	}
+	if (size > athrill_mem_head.currp->freesize) {
+		AthrillMemEntryType *new_entryp = malloc(sizeof(AthrillMemEntryType));
+		alloc_count++;
+		ASSERT(new_entryp != NULL);
+		athrill_mem_init(new_entryp);
+		new_entryp->next = athrill_mem_head.currp;
+		athrill_mem_head.currp = new_entryp;
+	}
+	void *retp =  &athrill_mem_head.currp->data[athrill_mem_head.currp->free_start];
+	athrill_mem_head.currp->free_start += size;
+	athrill_mem_head.currp->freesize -= size;
+	return retp;
+}
+static inline void *athrill_mem_calloc(uint32 memsz, uint32 size)
+{
+	void *p = athrill_mem_alloc(memsz * size);
+	memset(p, 0, size);
+	return p;
+}
+
+#endif /* _ATHRLL_MEMORY_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/comm_buffer.c
@@ -0,0 +1,133 @@
+#include "comm_buffer.h"
+#include <stdlib.h>
+
+Std_ReturnType comm_fifo_buffer_create(uint32 size, CommFifoBufferType *fifop)
+{
+	if (fifop == NULL) {
+		return STD_E_INVALID;
+	}
+	fifop->data = malloc(size);
+	if (fifop->data == NULL) {
+		return STD_E_LIMIT;
+	}
+	fifop->max_size = size;
+	fifop->count = 0;
+	fifop->rx_off = 0;
+	fifop->tx_off = 0;
+	return STD_E_OK;
+}
+
+static Std_ReturnType fifo_buffer_add(CommFifoBufferType *fifop, char data)
+{
+	if (fifop->count >= fifop->max_size) {
+		return STD_E_LIMIT;
+	}
+	fifop->data[fifop->tx_off] = data;
+	fifop->tx_off++;
+	if (fifop->tx_off >= fifop->max_size) {
+		fifop->tx_off = 0;
+	}
+	fifop->count++;
+	return STD_E_OK;
+}
+
+Std_ReturnType comm_fifo_buffer_add(CommFifoBufferType *fifop, const char* datap, uint32 datalen, uint32 *res)
+{
+	uint32 i;
+	Std_ReturnType err;
+
+	*res = 0;
+	if (fifop->count >= fifop->max_size) {
+		return STD_E_LIMIT;
+	}
+	for (i = 0; i < datalen; i++) {
+		err = fifo_buffer_add(fifop, datap[i]);
+		if (err != STD_E_OK) {
+			return err;
+		}
+		(*res) = (*res) + 1;
+	}
+	return STD_E_OK;
+}
+static Std_ReturnType fifo_buffer_get(CommFifoBufferType *fifop, char* datap)
+{
+	if (fifop->count == 0) {
+		return STD_E_NOENT;
+	}
+	*datap = fifop->data[fifop->rx_off];
+	fifop->rx_off++;
+	if (fifop->rx_off >= fifop->max_size) {
+		fifop->rx_off = 0;
+	}
+	fifop->count--;
+	return STD_E_OK;
+}
+
+Std_ReturnType comm_fifo_buffer_get(CommFifoBufferType *fifop, char* datap, uint32 datalen, uint32 *res)
+{
+	uint32 i;
+	Std_ReturnType err;
+
+	*res = 0;
+	if (fifop->count == 0) {
+		return STD_E_NOENT;
+	}
+	for (i = 0; i < datalen; i++) {
+		err = fifo_buffer_get(fifop, &datap[i]);
+		if (err != STD_E_OK) {
+			return err;
+		}
+		(*res) = (*res) + 1;
+	}
+	return STD_E_OK;
+}
+
+void comm_fifo_buffer_close(CommFifoBufferType *fifop)
+{
+	if (fifop != NULL) {
+		fifop->count = 0;
+		fifop->rx_off = 0;
+		fifop->tx_off = 0;
+	}
+	return;
+}
+
+void comm_fifo_buffer_destroy(CommFifoBufferType *fifop)
+{
+	if (fifop != NULL) {
+		if (fifop->data != NULL) {
+			free(fifop->data);
+			fifop->data = NULL;
+		}
+		fifop->max_size = 0;
+		fifop->count = 0;
+		fifop->rx_off = 0;
+		fifop->tx_off = 0;
+	}
+	return;
+}
+
+
+Std_ReturnType comm_buffer_create(uint32 size, CommBufferType *bufferp)
+{
+	if (bufferp == NULL) {
+		return STD_E_INVALID;
+	}
+	bufferp->data = malloc(size);
+	if (bufferp->data == NULL) {
+		return STD_E_LIMIT;
+	}
+	bufferp->max_size = size;
+	return STD_E_OK;
+}
+void comm_buffer_destroy(CommBufferType *bufferp)
+{
+	if (bufferp != NULL) {
+		if (bufferp->data != NULL) {
+			free(bufferp->data);
+			bufferp->data = NULL;
+		}
+		bufferp->max_size = 0;
+	}
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/comm_buffer.h
@@ -0,0 +1,31 @@
+#ifndef _COMM_BUFFER_H_
+#define _COMM_BUFFER_H_
+
+#include "std_types.h"
+#include "std_errno.h"
+
+typedef struct {
+	uint32	max_size;
+	uint32	count;
+	uint32	rx_off;
+	uint32	tx_off;
+	char*	data;
+} CommFifoBufferType;
+extern Std_ReturnType comm_fifo_buffer_create(uint32 size, CommFifoBufferType *fifop);
+extern Std_ReturnType comm_fifo_buffer_add(CommFifoBufferType *fifop, const char* datap, uint32 datalen, uint32 *res);
+extern Std_ReturnType comm_fifo_buffer_get(CommFifoBufferType *fifop, char* datap, uint32 datalen, uint32 *res);
+extern void comm_fifo_buffer_close(CommFifoBufferType *fifop);
+extern void comm_fifo_buffer_destroy(CommFifoBufferType *fifop);
+
+#define COMM_FIFO_IS_EMPTY(fifop)	((fifop)->count == 0)
+#define COMM_FIFO_IS_FULL(fifop)	((fifop)->count >= (fifop)->max_size)
+
+typedef struct {
+	uint32	max_size;
+	char*	data;
+} CommBufferType;
+extern Std_ReturnType comm_buffer_create(uint32 size, CommBufferType *bufferp);
+extern void comm_buffer_destroy(CommBufferType *bufferp);
+
+
+#endif /* _COMM_BUFFER_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/cui/cui_ops.c
@@ -0,0 +1,24 @@
+#include "cui/cui_ops.h"
+
+static FileOpType *cui_fileop;
+CuiPrintBufferType CuiPrintBuffer;
+
+int	cui_fileop_register(FileOpType *fileop)
+{
+	cui_fileop = fileop;
+	return 0;
+}
+
+int  cui_getline(char *line, int size)
+{
+	return cui_fileop->cui_getline(line, size);
+}
+void cui_write(char *line, int size)
+{
+	return cui_fileop->cui_write(line, size);
+}
+
+void cui_close(void)
+{
+	return cui_fileop->cui_close();
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/cui/cui_ops.h
@@ -0,0 +1,32 @@
+#ifndef _CUI_OPS_H_
+#define _CUI_OPS_H_
+
+#include "std_types.h"
+
+typedef struct {
+	int  (*cui_getline) (char *line, int size);
+	void (*cui_write) (char *line, int size);
+	void (*cui_close) (void);
+} FileOpType;
+extern int	cui_fileop_register(FileOpType *fileop);
+
+extern int  cui_getline(char *line, int size);
+extern void cui_write(char *line, int size);
+extern void cui_close(void);
+
+#define CUI_BUFP_LEN		(1024U)
+typedef struct {
+	uint32 write_len;
+	char p[CUI_BUFP_LEN];
+} CuiPrintBufferType;
+
+extern CuiPrintBufferType CuiPrintBuffer;
+#define CPU_PRINT_BUF()		((CuiPrintBuffer.p))
+#define CPU_PRINT_BUF_LEN()	(CUI_BUFP_LEN)
+
+#define CUI_PRINTF(arg)	\
+do { \
+	CuiPrintBuffer.write_len = snprintf	arg;	\
+	cui_write(CPU_PRINT_BUF(), CuiPrintBuffer.write_len);	\
+} while (0)
+#endif /* _CUI_OPS_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/cui/stdio/cui_ops_stdio.c
@@ -0,0 +1,67 @@
+#include "cui/stdio/cui_ops_stdio.h"
+#include "cui/cui_ops.h"
+#include <unistd.h>
+#include <stdio.h>
+
+typedef struct {
+	int read_fd;
+	int write_fd;
+	FileOpType op;
+} StdioFileOpType;
+
+static void cui_close_stdio(void);
+static int  cui_getline_stdio(char *line, int size);
+static void cui_write_stdio(char *line, int size);
+
+static StdioFileOpType cui_fileop_stdio = {
+	.read_fd  = 0,
+	.write_fd = 1,
+	.op = {
+			.cui_getline = cui_getline_stdio,
+			.cui_write = cui_write_stdio,
+			.cui_close = cui_close_stdio,
+	},
+};
+
+
+void cui_ops_stdio_init(void)
+{
+	(void)cui_fileop_register(&cui_fileop_stdio.op);
+	return;
+}
+
+static void cui_close_stdio(void)
+{
+	//nothing to do
+	return;
+}
+
+static int  cui_getline_stdio(char *line, int size)
+{
+	int n = 0;
+	char c;
+	int rc;
+
+	while (TRUE) {
+		if (n >= size) {
+			printf("ERROR:input is too long\n");
+			return -1;
+		}
+		rc = read(cui_fileop_stdio.read_fd, &c, 1);
+		if (rc <= 0) {
+			return -1;
+		}
+		if (c < 0 || c == '\n') {
+			break;
+		}
+		line[n] = c;
+		n++;
+	}
+	return n;
+}
+
+static void cui_write_stdio(char *line, int size)
+{
+	//nothing to do
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/cui/stdio/cui_ops_stdio.h
@@ -0,0 +1,6 @@
+#ifndef _CUI_OPS_STDIO_H_
+#define _CUI_OPS_STDIO_H_
+
+extern void cui_ops_stdio_init(void);
+
+#endif /* _CUI_OPS_STDIO_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/cui/tcp/cui_ops_tcp.c
@@ -0,0 +1,44 @@
+#include "cui/tcp/cui_ops_tcp.h"
+#include "tcp/tcp_server.h"
+
+static TcpServerConfigType tcp_server_config;
+static TcpServerType tcp_server;
+static TcpConnectionType tcp_connection;
+
+static FileOpType cui_fileop_tcp;
+
+void cui_ops_tcp_init(void)
+{
+	Std_ReturnType err;
+
+	err = tcp_server_create(&tcp_server_config, &tcp_server);
+	if (err != STD_E_OK) {
+		printf("ERROR:internal error: tcp_server_create()\n");
+		exit(1);
+	}
+
+	err = tcp_server_poll(&tcp_server, &tcp_connection);
+	if (err != STD_E_OK) {
+		printf("ERROR:internal error: tcp_server_poll()\n");
+		exit(1);
+	}
+	cui_fileop_tcp.write_fd = tcp_connection.client_socket;
+	cui_fileop_tcp.read_fd = tcp_connection.client_socket;
+	cui_fileop_register(&cui_fileop_tcp);
+	return;
+}
+
+void cui_close(void)
+{
+	Std_ReturnType err;
+	tcp_connection_close(&tcp_connection);
+
+	err = tcp_server_poll(&tcp_server, &tcp_connection);
+	if (err != STD_E_OK) {
+		printf("ERROR:internal error: tcp_server_poll()\n");
+		exit(1);
+	}
+	cui_fileop_tcp.write_fd = tcp_connection.client_socket;
+	cui_fileop_tcp.read_fd = tcp_connection.client_socket;
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/cui/tcp/cui_ops_tcp.h
@@ -0,0 +1,6 @@
+#ifndef _CUI_OPS_TCP_H_
+#define _CUI_OPS_TCP_H_
+
+extern void cui_ops_tcp_init(void);
+
+#endif /* _CUI_OPS_TCP_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/cui/udp/cui_ops_udp.c
@@ -0,0 +1,102 @@
+#include "cui/cui_ops.h"
+#include "cui/udp/cui_ops_udp.h"
+#include "udp/udp_comm.h"
+#include "cpuemu_config.h"
+#include <stdio.h>
+
+typedef struct {
+	UdpCommConfigType	config;
+	UdpCommType			comm;
+	FileOpType 			op;
+} UdpFileOpType;
+
+static void cui_close_udp(void);
+static int  cui_getline_udp(char *line, int size);
+static void cui_write_udp(char *line, int size);
+
+static UdpFileOpType cui_fileop_udp;
+
+void cui_ops_udp_init(uint16 server_port, uint16 client_port)
+{
+	Std_ReturnType err;
+
+	UdpFileOpType cui_fileop_udp_tmp = {
+		.config = {
+				.server_port = server_port,
+				.client_port = client_port,
+				.is_wait = TRUE,
+		},
+		.op = {
+				.cui_getline = cui_getline_udp,
+				.cui_write = cui_write_udp,
+				.cui_close = cui_close_udp,
+		},
+
+	};
+
+	cui_fileop_udp = cui_fileop_udp_tmp;
+
+	printf("REMOTE:athrill listen port %u\n", cui_fileop_udp.config.server_port);
+	printf("REMOTE:client listen port %u\n", cui_fileop_udp.config.client_port);
+
+	err = udp_comm_create(&cui_fileop_udp.config, &cui_fileop_udp.comm);
+	if (err != STD_E_OK) {
+		printf("ERROR:internal error:udp_server_create()\n");
+		exit(1);
+	}
+
+	(void)cui_fileop_register(&cui_fileop_udp.op);
+	return;
+}
+
+static void cui_close_udp(void)
+{
+	Std_ReturnType err;
+
+	udp_server_delete(&cui_fileop_udp.comm);
+
+	err = udp_comm_create(&cui_fileop_udp.config, &cui_fileop_udp.comm);
+	if (err != STD_E_OK) {
+		printf("ERROR:internal error:udp_server_create()\n");
+		exit(1);
+	}
+	return;
+}
+
+static int  cui_getline_udp(char *line, int size)
+{
+	Std_ReturnType err;
+
+	//printf("cui_getline_udp:enter\n");
+	err = udp_comm_read(&cui_fileop_udp.comm);
+	if (err != STD_E_OK) {
+		printf("ERROR:internal error:udp_server_read()\n");
+		return -1;
+	}
+	if (cui_fileop_udp.comm.read_data.len > size) {
+		printf("ERROR:internal error:cui_getline_udp():recv size is too large\n");
+		return -1;
+	}
+	memcpy(line, cui_fileop_udp.comm.read_data.buffer, cui_fileop_udp.comm.read_data.len);
+	line[cui_fileop_udp.comm.read_data.len] = '\0';
+	//printf("cui_getline_udp:exit:%s\n", line);
+	return cui_fileop_udp.comm.read_data.len;
+}
+
+static void cui_write_udp(char *line, int size)
+{
+	Std_ReturnType err;
+
+	if (size > UDP_BUFFER_LEN) {
+		return;
+	}
+	cui_fileop_udp.comm.write_data.len = size;
+	memcpy(cui_fileop_udp.comm.write_data.buffer, line, size);
+
+	err = udp_comm_write(&cui_fileop_udp.comm);
+	if (err != STD_E_OK) {
+		printf("ERROR:internal error:udp_server_write()\n");
+		return;
+	}
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/cui/udp/cui_ops_udp.h
@@ -0,0 +1,6 @@
+#ifndef _CUI_OPS_UDP_H_
+#define _CUI_OPS_UDP_H_
+
+extern void cui_ops_udp_init(uint16 server_port, uint16 client_port);
+
+#endif /* _CUI_OPS_UDP_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dbg_log.c
@@ -0,0 +1,60 @@
+#include "dbg_log.h"
+#include <stdlib.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include "target/target_os_api.h"
+
+DbgExecOpBufferType DbgExecOpBuffer;
+char dbg_tmp_logbuf[DBG_BUFP_LEN];
+uint32 dbg_tmp_logbuflen;
+
+void dbg_log_init(char *filepath)
+{
+	int fd;
+	fd = target_os_api_open_ctw(filepath, 0777);
+	if (fd < 0) {
+		printf("debugger_exec_op_bufinit:open err=%d\n", errno);
+		fflush(stdout);
+		exit(1);
+	}
+	DbgExecOpBuffer.is_view_mode = FALSE;
+	DbgExecOpBuffer.fd = fd;
+	DbgExecOpBuffer.filepath = filepath;
+	DbgExecOpBuffer.count = 0;
+	return;
+}
+
+void dbg_log_sync(void)
+{
+	int i;
+	int err;
+	for (i = 0; i < DbgExecOpBuffer.count; i++) {
+		err = write(DbgExecOpBuffer.fd, DbgExecOpBuffer.buf[i].p, DbgExecOpBuffer.buf[i].write_len);
+		if (err <= 0) {
+			printf("debugger_exec_op_bufsync:write err=%d\n", errno);
+			fflush(stdout);
+			exit(1);
+		}
+	}
+	err = close(DbgExecOpBuffer.fd);
+	if (err < 0) {
+		printf("debugger_exec_op_bufsync:close err=%d\n", errno);
+		fflush(stdout);
+		exit(1);
+	}
+	int fd;
+	fd = target_os_api_open_aw(DbgExecOpBuffer.filepath);
+	if (fd < 0) {
+		printf("debugger_exec_op_bufsync:open err=%d\n", errno);
+		fflush(stdout);
+		exit(1);
+	}
+	DbgExecOpBuffer.fd = fd;
+	DbgExecOpBuffer.count = 0;
+	return;
+}
+
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dbg_log.h
@@ -0,0 +1,111 @@
+#ifndef _DBG_LOG_H_
+#define _DBG_LOG_H_
+
+#define DEBUG_EMU
+#ifdef DEBUG_EMU
+#include "symbol_ops.h"
+#include "cpu.h"
+#include <stdio.h>
+#include "std_types.h"
+
+#define DBG_BUFP_LEN		(2048U)
+#define DBG_BUFP_MAX_CNT	(8192U)
+
+typedef struct {
+	int fd;
+	uint32 pc;
+	char *funcname;
+	uint32 funcid;
+	uint32 funcaddr;
+	uint32 funcoff;
+	bool is_view_mode;
+	bool can_print;
+	char *filepath;
+	int count;
+	struct {
+		uint32 write_len;
+		char p[DBG_BUFP_LEN];
+	} buf[DBG_BUFP_MAX_CNT];
+} DbgExecOpBufferType;
+
+extern DbgExecOpBufferType DbgExecOpBuffer;
+extern uint32 dbg_tmp_logbuflen;
+extern char dbg_tmp_logbuf[DBG_BUFP_LEN];
+#define DBG_EXEC_OP_BUF()		(dbg_tmp_logbuf)
+#define DBG_EXEC_OP_BUF_LEN()	(DBG_BUFP_LEN)
+extern void dbg_log_init(char *filepath);
+extern void dbg_log_sync(void);
+
+static inline void dbg_log_set_view_mode(bool on)
+{
+	DbgExecOpBuffer.is_view_mode = on;
+}
+
+static inline bool dbg_log_is_view_mode(void)
+{
+	return DbgExecOpBuffer.is_view_mode;
+}
+static inline void dbg_log_set_print_mode(bool on)
+{
+	DbgExecOpBuffer.can_print = on;
+}
+
+static inline bool dbg_log_can_print(void)
+{
+	return DbgExecOpBuffer.can_print;
+}
+static inline void dbg_print_log(void)
+{
+	int err;
+	err = symbol_pc2funcid(cpu_get_current_core_pc(), &DbgExecOpBuffer.funcaddr);
+	if (err >= 0) {
+		DbgExecOpBuffer.funcid = err;
+		DbgExecOpBuffer.funcname = symbol_funcid2funcname(DbgExecOpBuffer.funcid);
+		DbgExecOpBuffer.funcoff = cpu_get_current_core_pc() - DbgExecOpBuffer.funcaddr;
+		DbgExecOpBuffer.buf[DbgExecOpBuffer.count].write_len = snprintf(
+				DbgExecOpBuffer.buf[DbgExecOpBuffer.count].p,
+				DBG_BUFP_LEN,
+				"[DONE> core%u pc=0x%x %s(+%x) %s",
+				cpu_get_current_core_id(),
+				cpu_get_current_core_pc(),
+				DbgExecOpBuffer.funcname,
+				DbgExecOpBuffer.funcoff,
+				dbg_tmp_logbuf);
+	}
+	else {
+		DbgExecOpBuffer.buf[DbgExecOpBuffer.count].write_len = snprintf(
+				DbgExecOpBuffer.buf[DbgExecOpBuffer.count].p,
+				DBG_BUFP_LEN,
+				"[DONE> core%u pc=0x%x null(null) %s",
+				cpu_get_current_core_id(),
+				cpu_get_current_core_pc(),
+				dbg_tmp_logbuf);
+	}
+	if (dbg_log_can_print() == TRUE) {
+		printf("%s", DbgExecOpBuffer.buf[DbgExecOpBuffer.count].p);
+	}
+	DbgExecOpBuffer.count++;
+	if (DbgExecOpBuffer.count >= DBG_BUFP_MAX_CNT) {
+		dbg_log_sync();
+	}
+	return;
+}
+
+
+#define DBG_PRINT(arg)	\
+do { \
+	if (dbg_log_is_view_mode() == TRUE) {	\
+		dbg_tmp_logbuflen = snprintf	arg;	\
+		dbg_print_log();	\
+	}	\
+} while (0)
+#define DBG_LOG_SET_VIEW(on)	dbg_log_set_view_mode(on)
+#define DBG_LOG_IS_VIEW_MODE()	dbg_log_is_view_mode()
+#else
+#define DBG_PRINT(arg)
+#define DBG_LOG_SET_VIEW(on)
+#define DBG_LOG_IS_VIEW_MODE()
+#endif
+
+
+#endif /* _DBG_LOG_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/data_type/elf_dwarf_array_type.c
@@ -0,0 +1,118 @@
+#include "elf_dwarf_array_type.h"
+#include "assert.h"
+
+static void elf_dwarf_build_array_dimension(DwarfDataArrayType *obj, ElfDwarfDieType *member)
+{
+	uint32 size;
+	int j;
+	uint32 array_size;
+	ElfDwarfAttributeType *attr;
+	ElfDwarfAbbrevType *abbrev;
+	DwAtType attr_type;
+
+	abbrev = (ElfDwarfAbbrevType *)member->abbrev_info;
+	for (j = 0; j < member->attribute->current_array_size; j++) {
+		attr = (ElfDwarfAttributeType*)member->attribute->data[j];
+		attr_type = abbrev->attribute_name->data[j];
+		//printf("dimension name=0x%x form=%s\n", attr_type, attr->typename);
+		switch (attr_type) {
+		case DW_AT_upper_bound:
+			array_size = elf_dwarf_info_get_value(abbrev->attribute_form->data[j], attr, &size);
+			dwarf_uint32_array_add_entry(obj->dimension, (array_size + 1));
+			//printf("array_size=%u\n", array_size);
+			break;
+		case DW_AT_abstract_origin:
+		case DW_AT_accessibility:
+		case DW_AT_byte_size:
+		case DW_AT_count:
+		case DW_AT_declaration:
+		case DW_AT_lower_bound:
+		case DW_AT_name:
+		case DW_AT_sibling:
+		case DW_AT_type:
+			break;
+		default:
+			ASSERT(0);
+		}
+	}
+
+	return;
+}
+void elf_dwarf_build_array_type(ElfDwarfDieType *die)
+{
+	int i;
+	uint32 size;
+	DwarfDataArrayType *obj = dwarf_alloc_data_type(DATA_TYPE_ARRAY);
+	ElfDwarfAttributeType *attr;
+	ElfDwarfAbbrevType *abbrev;
+	DwAtType attr_type;
+	uint32 offset;
+	Std_ReturnType err;
+
+	obj->dimension = dwarf_uint32_array_alloc();
+
+	//printf("elf_dwarf_build_typedef_type:off=0x%x\n", die->offset);
+	//printf("typedef_type\n");
+	for (i = 0; i < die->attribute->current_array_size; i++) {
+		abbrev = (ElfDwarfAbbrevType *)die->abbrev_info;
+		attr = (ElfDwarfAttributeType*)die->attribute->data[i];
+		attr_type = abbrev->attribute_name->data[i];
+		//printf("name=0x%x form=%s\n", attr_type, attr->typename);
+		switch (attr_type) {
+		case DW_AT_type:
+			offset = elf_dwarf_info_get_value(abbrev->attribute_form->data[i], attr, &size);
+			 err = dwarf_get_real_type_offset(offset, &obj->ref_debug_info_offset);
+			 if (err == STD_E_OK) {
+				 obj->is_valid_ref_debug_info_offset = TRUE;
+			 }
+			break;
+		case DW_AT_sibling:
+			break;
+		default:
+			ASSERT(0);
+		}
+	}
+	//配列サイズ
+	for (i = 0; i < die->children->current_array_size; i++) {
+		ElfDwarfDieType *member = (ElfDwarfDieType*)die->children->data[i];
+		if (member->abbrev_info->tag != DW_TAG_subrange_type) {
+			continue;
+		}
+		elf_dwarf_build_array_dimension(obj, member);
+	}
+
+
+	obj->info.die = die;
+	//printf("typedef=%s ref_offset=0x%x\n", obj->info.typename, obj->ref_debug_info_offset);
+
+	dwarf_register_data_type(&obj->info);
+
+	return;
+}
+
+void elf_dwarf_resolve_array_type(void)
+{
+	int i;
+	ElfPointerArrayType	*my_types = dwarf_get_data_types(DATA_TYPE_ARRAY);
+	DwarfDataTypedefType *obj;
+	if (my_types == NULL) {
+		return;
+	}
+	for (i = 0; i < my_types->current_array_size; i++) {
+		obj = (DwarfDataTypedefType *)my_types->data[i];
+		if (obj->ref != NULL) {
+			continue;
+		}
+		if (obj->is_valid_ref_debug_info_offset == FALSE) {
+			continue;
+		}
+		obj->ref = elf_dwarf_get_data_type(obj->ref_debug_info_offset);
+		if (obj->ref == NULL) {
+			//printf("Not supported:unknown typeref(%s) debug_offset=0x%x\n", obj->info.typename, obj->ref_debug_info_offset);
+		}
+		else {
+			//printf("array %s %s\n", obj->ref->typename, obj->info.typename);
+		}
+	}
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/data_type/elf_dwarf_array_type.h
@@ -0,0 +1,10 @@
+#ifndef _ELF_DWARF_ARRAY_TYPE_H_
+#define _ELF_DWARF_ARRAY_TYPE_H_
+
+#include "elf_dwarf_data_type.h"
+#include "elf_dwarf_info.h"
+
+extern void elf_dwarf_build_array_type(ElfDwarfDieType *die);
+extern void elf_dwarf_resolve_array_type(void);
+
+#endif /* _ELF_DWARF_ARRAY_TYPE_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/data_type/elf_dwarf_base_type.c
@@ -0,0 +1,37 @@
+#include "elf_dwarf_base_type.h"
+#include "assert.h"
+
+void elf_dwarf_build_base_type(ElfDwarfDieType *die)
+{
+	int i;
+	uint32 size;
+	DwarfDataBaseType *obj = dwarf_alloc_data_type(DATA_TYPE_BASE);
+	ElfDwarfAttributeType *attr;
+	ElfDwarfAbbrevType *abbrev;
+	DwAtType attr_type;
+
+	for (i = 0; i < die->attribute->current_array_size; i++) {
+		abbrev = (ElfDwarfAbbrevType *)die->abbrev_info;
+		attr = (ElfDwarfAttributeType*)die->attribute->data[i];
+		attr_type = abbrev->attribute_name->data[i];
+
+		switch (attr_type) {
+		case DW_AT_byte_size:
+			obj->info.size = elf_dwarf_info_get_value(abbrev->attribute_form->data[i], attr, &size);
+			break;
+		case DW_AT_name:
+			obj->info.typename = attr->encoded.string;
+			break;
+		case DW_AT_encoding:
+			obj->encoding = elf_dwarf_info_get_value(abbrev->attribute_form->data[i], attr, &size);
+			//printf("encoding=0x%x\n", obj->encoding);
+			break;
+		default:
+			ASSERT(0);
+		}
+	}
+	obj->info.die = die;
+
+	dwarf_register_data_type(&obj->info);
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/data_type/elf_dwarf_base_type.h
@@ -0,0 +1,9 @@
+#ifndef _ELF_DWARF_BASE_TYPE_H_
+#define _ELF_DWARF_BASE_TYPE_H_
+
+#include "elf_dwarf_data_type.h"
+#include "elf_dwarf_info.h"
+
+extern void elf_dwarf_build_base_type(ElfDwarfDieType *die);
+
+#endif /* _ELF_DWARF_BASE_TYPE_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/data_type/elf_dwarf_data_type.c
@@ -0,0 +1,468 @@
+#include "elf_dwarf_data_type.h"
+#include "elf_dwarf_info.h"
+#include "elf_dwarf_base_type.h"
+#include "elf_dwarf_struct_type.h"
+#include "elf_dwarf_typedef_type.h"
+#include "elf_dwarf_pointer_type.h"
+#include "elf_dwarf_array_type.h"
+#include "elf_dwarf_enum_type.h"
+#include "elf_dwarf_variable_type.h"
+#include "elf_dwarf_subprogram_type.h"
+#include "assert.h"
+#include <string.h>
+
+static ElfPointerArrayType	*dwarf_data_type_set[DATA_TYPE_NUM] = {
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+};
+ElfPointerArrayType	*dwarf_get_data_types(DwarfDataEnumType type)
+{
+	return dwarf_data_type_set[type];
+}
+
+
+typedef  void (*parse_func_table_t)(ElfDwarfDieType *die);
+
+static parse_func_table_t parse_func_table[DATA_TYPE_NUM] = {
+		elf_dwarf_build_base_type,
+		elf_dwarf_build_struct_type,
+		elf_dwarf_build_struct_type,
+		elf_dwarf_build_array_type,
+		elf_dwarf_build_pointer_type,
+		elf_dwarf_build_typedef_type,
+		elf_dwarf_build_enum_type,
+		elf_dwarf_build_variable_type,
+		elf_dwarf_build_subprogram_type,
+		elf_dwarf_build_struct_type,
+};
+
+static DwarfDataEnumType get_dataType(DwTagType tag)
+{
+	DwarfDataEnumType ret = DATA_TYPE_NUM;
+	switch (tag) {
+	case DW_TAG_array_type:
+		ret = DATA_TYPE_ARRAY;
+		break;
+	case DW_TAG_pointer_type:
+		ret = DATA_TYPE_POINTER;
+		break;
+	case DW_TAG_base_type:
+		ret = DATA_TYPE_BASE;
+		break;
+	case DW_TAG_structure_type:
+		ret = DATA_TYPE_STRUCT;
+		break;
+	case DW_TAG_union_type:
+		ret = DATA_TYPE_UNION;
+		break;
+	case DW_TAG_typedef:
+		ret = DATA_TYPE_TYPEDEF;
+		break;
+	case DW_TAG_enumeration_type:
+		ret = DATA_TYPE_ENUM;
+		break;
+	case DW_TAG_variable:
+		ret = DATA_TYPE_VARIABLE;
+		break;
+	case DW_TAG_subprogram:
+		ret = DATA_TYPE_SUBPROGRAM;
+		break;
+	case DW_TAG_class_type:
+		ret = DATA_TYPE_CLASS;
+		break;
+	//case DW_TAG_const_type:
+	//	printf("Unknown DW_TAG_const_type\n");
+	//	break;
+	default:
+		break;
+	}
+	return ret;
+}
+
+static void dwarf_search_die_recursive(ElfDwarfDieType *die)
+{
+	int i_childs;
+	ElfDwarfDieType *child;
+	DwarfDataEnumType type;
+
+	if (die->attribute == NULL) {
+		return;
+	}
+	type = get_dataType(die->abbrev_info->tag);
+	if ((type != DATA_TYPE_NUM) && (parse_func_table[type] != NULL)) {
+		//printf("die(%u)=0x%x\n", die->level, die->abbrev_info->tag);
+		parse_func_table[type](die);
+	}
+	if (die->children == NULL) {
+		return;
+	}
+	for (i_childs = 0; i_childs < die->children->current_array_size; i_childs++) {
+		child = die->children->data[i_childs];
+		dwarf_search_die_recursive(child);
+	}
+	return;
+}
+static ElfDwarfCompilationUnitHeaderType *current_cu = NULL;
+static void build_types(void)
+{
+	int i_cu;
+	int i_die;
+	ElfDwarfCompilationUnitHeaderType	*cu;
+	ElfDwarfDieType						*die;
+
+	ElfPointerArrayType *compilation_unit_set = elf_dwarf_info_get();
+
+	for (i_cu = 0; i_cu < compilation_unit_set->current_array_size; i_cu++) {
+		cu = (ElfDwarfCompilationUnitHeaderType *)compilation_unit_set->data[i_cu];
+		//printf("cu->offset=0x%x\n", cu->offset);
+		current_cu = cu;
+		if (cu->dies == NULL) {
+			continue;
+		}
+		for (i_die = 0; i_die < cu->dies->current_array_size; i_die++) {
+			die = (ElfDwarfDieType *)cu->dies->data[i_die];
+			if (die->parent != NULL) {
+				continue;
+			}
+			//printf("die->abbrev_code=%u\n", die->abbrev_code);
+			//printf("die->children=0x%p\n", die->children);
+			dwarf_search_die_recursive(die);
+		}
+	}
+	current_cu = NULL;
+	return;
+}
+ElfDwarfDieType *dwarf_get_die(uint32 offset)
+{
+	int i_die;
+	ElfDwarfCompilationUnitHeaderType	*cu = current_cu;
+	ElfDwarfDieType						*die;
+	if (cu == NULL) {
+		return NULL;
+	}
+	for (i_die = 0; i_die < cu->dies->current_array_size; i_die++) {
+		die = (ElfDwarfDieType *)cu->dies->data[i_die];
+		if (die->offset == offset) {
+			return die;
+		}
+	}
+	return NULL;
+}
+
+static Std_ReturnType get_DW_AT_type_value(ElfDwarfDieType *die, uint32 *retp)
+{
+	int i;
+	uint32 size;
+	ElfDwarfAttributeType *attr;
+	ElfDwarfAbbrevType *abbrev;
+	DwAtType attr_type;
+
+	if (die->attribute->current_array_size == 0) {
+		//printf("get_DW_AT_type_value:not supported:off=0x%x die->attribute->current_array_size=%u\n", die->offset, die->attribute->current_array_size);
+		//ASSERT(0);
+		return STD_E_NOENT;
+	}
+
+	for (i = 0; i < die->attribute->current_array_size; i++) {
+		abbrev = (ElfDwarfAbbrevType *)die->abbrev_info;
+		attr = (ElfDwarfAttributeType*)die->attribute->data[i];
+		attr_type = abbrev->attribute_name->data[i];
+		//printf("get_DW_AT_type_value:off=0x%x 0x%x\n", die->offset, attr_type);
+		switch (attr_type) {
+		case DW_AT_type:
+			*retp = elf_dwarf_info_get_value(abbrev->attribute_form->data[i], attr, &size);
+			return STD_E_OK;
+		case DW_AT_prototyped:
+		case DW_AT_byte_size:
+		case DW_AT_name:
+			//printf("Not Supported:get_DW_AT_type_value:off=0x%x 0x%x\n", die->offset, attr_type);
+			return STD_E_NOENT;
+		default:
+			printf("get_DW_AT_type_value:not supported attr=0x%x\n", attr_type);
+			break;
+		}
+	}
+	printf("get_DW_AT_type_value:not supported:off=0x%x die->attribute->current_array_size=%u\n", die->offset, die->attribute->current_array_size);
+	ASSERT(0);
+	return STD_E_NOENT;
+}
+
+
+Std_ReturnType dwarf_get_real_type_offset(uint32 offset, uint32 *retp)
+{
+	uint32 ret_offset;
+	int i_cu;
+	int i_die;
+	ElfDwarfCompilationUnitHeaderType	*cu;
+	ElfDwarfDieType						*die;
+	DwarfDataEnumType					type;
+	Std_ReturnType err;
+
+	ElfPointerArrayType *compilation_unit_set = elf_dwarf_info_get();
+
+retry:
+	for (i_cu = 0; i_cu < compilation_unit_set->current_array_size; i_cu++) {
+		cu = (ElfDwarfCompilationUnitHeaderType *)compilation_unit_set->data[i_cu];
+		//printf("cu->offset=0x%x\n", cu->offset);
+		if (cu->dies == NULL) {
+			continue;
+		}
+		for (i_die = 0; i_die < cu->dies->current_array_size; i_die++) {
+			die = (ElfDwarfDieType *)cu->dies->data[i_die];
+			if (die->offset != offset) {
+				continue;
+			}
+			if (die->abbrev_info->tag == DW_TAG_subroutine_type) {
+				//printf("Not supported:dwarf_get_real_type_offset(0x%x) DW_TAG_subroutine_type\n", die->offset);
+				return STD_E_NOENT;
+			}
+			type = get_dataType(die->abbrev_info->tag);
+			if (type == DATA_TYPE_NUM) {
+				//printf("tag=0x%x\n", die->abbrev_info->tag);
+				err = get_DW_AT_type_value(die, &ret_offset);
+				if (err != STD_E_OK) {
+					//printf("err = %d\n", err);
+					return err;
+				}
+				offset = ret_offset;
+				goto retry;
+			}
+			*retp = die->offset;
+			return STD_E_OK;
+		}
+	}
+	ASSERT(0);
+	return ret_offset;
+}
+
+
+DwarfDataType *elf_dwarf_get_data_type(uint32 debug_info_offset)
+{
+	int i;
+	int j;
+	for (i = 0; i < DATA_TYPE_NUM; i++) {
+		if (dwarf_data_type_set[i] == NULL) {
+			continue;
+		}
+		for (j = 0; j < dwarf_data_type_set[i]->current_array_size; j++) {
+			DwarfDataType *dtype = (DwarfDataType*)dwarf_data_type_set[i]->data[j];
+			if (dtype->die->offset == debug_info_offset) {
+				//printf("debug_info_offset=0x%x\n", debug_info_offset);
+				//printf("type=0x%x %s\n", dtype->type, dtype->typename);
+				return dtype;
+			}
+		}
+	}
+	return NULL;
+}
+
+static void resolve_reference(void)
+{
+	elf_dwarf_resolve_typedef_type();
+	elf_dwarf_resolve_pointer_type();
+	elf_dwarf_resolve_array_type();
+	elf_dwarf_resolve_struct_type();
+	elf_dwarf_resolve_variable_type();
+	elf_dwarf_resolve_subprogram_type();
+	return;
+}
+
+/*
+ * 1) build definition
+ * 2) resolve reference
+ */
+void dwarf_build_data_type_set(void)
+{
+	build_types();
+	resolve_reference();
+}
+
+void *dwarf_alloc_data_type(DwarfDataEnumType type)
+{
+	uint32 size;
+	DwarfDataType *obj;
+
+	switch (type) {
+	case DATA_TYPE_BASE:
+		size = sizeof(DwarfDataBaseType);
+		break;
+	case DATA_TYPE_STRUCT:
+		size = sizeof(DwarfDataStructType);
+		break;
+	case DATA_TYPE_CLASS:
+		size = sizeof(DwarfDataStructType);
+		break;
+	case DATA_TYPE_UNION:
+		size = sizeof(DwarfDataStructType);
+		break;
+	case DATA_TYPE_ARRAY:
+		size = sizeof(DwarfDataArrayType);
+		break;
+	case DATA_TYPE_POINTER:
+		size = sizeof(DwarfDataPointerType);
+		break;
+	case DATA_TYPE_TYPEDEF:
+		size = sizeof(DwarfDataTypedefType);
+		break;
+	case DATA_TYPE_ENUM:
+		size = sizeof(DwarfDataEnumulatorType);
+		break;
+	case DATA_TYPE_VARIABLE:
+		size = sizeof(DwarfDataVariableType);
+		break;
+	case DATA_TYPE_SUBPROGRAM:
+		size = sizeof(DwarfDataSubprogramType);
+		break;
+	default:
+		ASSERT(0);
+		break;
+	}
+	obj = (DwarfDataType *)elf_obj_alloc(size);
+	obj->type = type;
+	return obj;
+}
+
+void *dwarf_search_data_type(DwarfDataEnumType type, char *dirname, char *filename, char *typename)
+{
+	int i;
+#if 0
+	int dirlen = strlen(dirname);
+	int filelen = strlen(filename);
+#endif
+	int typelen = strlen(typename);
+
+	//printf("type=%u name=%s\n", type, typename);
+	if (type >= DATA_TYPE_NUM) {
+		return NULL;
+	}
+	if (dwarf_data_type_set[type] == NULL) {
+		return NULL;
+	}
+
+	for (i = 0; i < dwarf_data_type_set[type]->current_array_size; i++) {
+		int len;
+		DwarfDataType *entry = (DwarfDataType *)dwarf_data_type_set[type]->data[i];
+
+		//printf("entry(0x%p\n", entry);
+		if (entry->typename == NULL) {
+			continue;
+		}
+		len = strlen(entry->typename);
+		//printf("in_len=%u chk_len=%u in_name=%s chk_name=%s\n", typelen, len, typename, entry->typename);
+		if (typelen != len) {
+			continue;
+		}
+		if (strncmp(typename, entry->typename, len) != 0) {
+			continue;
+		}
+#if 0
+		len = strlen(entry->dirname);
+		if (dirlen != len) {
+			continue;
+		}
+		if (strncmp(dirname, entry->dirname, len) == 0) {
+			continue;
+		}
+		len = strlen(entry->filename);
+		if (filelen != len) {
+			continue;
+		}
+		if (strncmp(filename, entry->filename, len) == 0) {
+			continue;
+		}
+#endif
+
+		return entry;
+	}
+	return NULL;
+}
+void *dwarf_search_data_type_from_die(DwarfDataEnumType type, uint32 die_off)
+{
+	int i;
+
+	if (type >= DATA_TYPE_NUM) {
+		return NULL;
+	}
+	if (dwarf_data_type_set[type] == NULL) {
+		return NULL;
+	}
+
+	for (i = 0; i < dwarf_data_type_set[type]->current_array_size; i++) {
+		DwarfDataType *entry = (DwarfDataType *)dwarf_data_type_set[type]->data[i];
+		if (entry->die->offset == die_off) {
+			return entry;
+		}
+	}
+	return NULL;
+}
+
+void dwarf_register_data_type(DwarfDataType *entry)
+{
+	if (entry->type >= DATA_TYPE_NUM) {
+		return;
+	}
+	if (dwarf_data_type_set[entry->type] == NULL) {
+		dwarf_data_type_set[entry->type] = elf_array_alloc();
+	}
+	//printf("type=%u reg data=%s\n", entry->type, entry->typename);
+
+	elf_array_add_entry(dwarf_data_type_set[entry->type], entry);
+	return;
+}
+
+
+void dwarf_add_struct_member(DwarfDataStructType *obj, DwarfDataStructMember *org_mem)
+{
+	DwarfDataStructMember *member;
+
+	member = (DwarfDataStructMember*)elf_obj_alloc(sizeof(DwarfDataStructMember));
+	*member = *org_mem;
+	if (obj->members == NULL) {
+		obj->members = elf_array_alloc();
+	}
+
+	elf_array_add_entry(obj->members, member);
+
+	return;
+}
+
+
+void dwarf_add_subprogram_variable(DwarfDataSubprogramType *obj, DwarfLocalVariableType *org_val)
+{
+	DwarfLocalVariableType *val;
+
+	val = (DwarfLocalVariableType*)elf_obj_alloc(sizeof(DwarfLocalVariableType));
+	*val = *org_val;
+	if (obj->variables == NULL) {
+		obj->variables = elf_array_alloc();
+	}
+
+	elf_array_add_entry(obj->variables, val);
+
+	return;
+}
+
+void dwarf_add_enum_member(DwarfDataEnumulatorType *obj, char *name, uint32 const_value)
+{
+	DwarfDataEnumMember *member;
+
+	member = (DwarfDataEnumMember*)elf_obj_alloc(sizeof(DwarfDataEnumMember));
+	member->name = name;
+	member->const_value = const_value;
+	if (obj->members == NULL) {
+		obj->members = elf_array_alloc();
+	}
+
+	elf_array_add_entry(obj->members, member);
+
+	return;
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/data_type/elf_dwarf_data_type.h
@@ -0,0 +1,151 @@
+#ifndef _ELF_DWARF_DATA_TYPE_H_
+#define _ELF_DWARF_DATA_TYPE_H_
+
+#include "std_types.h"
+#include "elf_dwarf_util.h"
+#include "elf_dwarf_info.h"
+
+typedef enum {
+	DATA_TYPE_BASE = 0,
+	DATA_TYPE_STRUCT,
+	DATA_TYPE_UNION,
+	DATA_TYPE_ARRAY,
+	DATA_TYPE_POINTER,
+	DATA_TYPE_TYPEDEF,
+	DATA_TYPE_ENUM,
+	DATA_TYPE_VARIABLE,
+	DATA_TYPE_SUBPROGRAM,
+	DATA_TYPE_CLASS,
+	DATA_TYPE_NUM,
+} DwarfDataEnumType;
+
+extern void *dwarf_alloc_data_type(DwarfDataEnumType type);
+extern void *dwarf_search_data_type(DwarfDataEnumType type, char *dirname, char *filename, char *typename);
+extern void *dwarf_search_data_type_from_die(DwarfDataEnumType type, uint32 die_off);
+typedef struct {
+	ElfDwarfDieType		*die;
+	DwarfDataEnumType	type;
+	char				*dirname;
+	char				*filename;
+	char				*typename;
+	uint32				size;
+} DwarfDataType;
+extern void dwarf_register_data_type(DwarfDataType *entry);
+extern ElfPointerArrayType	*dwarf_get_data_types(DwarfDataEnumType type);
+extern void dwarf_build_data_type_set(void);
+extern DwarfDataType *elf_dwarf_get_data_type(uint32 debug_info_offset);
+
+extern Std_ReturnType dwarf_get_real_type_offset(uint32 offset, uint32 *retp);
+
+/*
+ * ex. uint32
+ *
+ * info.type = DATA_TYPE_BASE
+ * info.name = "uint32"
+ * info.size = 4
+ */
+typedef struct {
+	DwarfDataType	info;
+	DwAteType		encoding;
+} DwarfDataBaseType;
+
+/*
+ * ex. uint32 *
+ *
+ * info.type = DATA_TYPE_POINTER
+ * info.name = NULL
+ * info.size = 4
+ * info.ref = (ref of uint32)
+ */
+typedef struct {
+	DwarfDataType	info;
+	DwarfDataType	*ref;
+	bool			is_valid_ref_debug_info_offset;
+	uint32			ref_debug_info_offset;
+} DwarfDataPointerType;
+
+
+/*
+ * ex. typedef struct a a_t;
+ *
+ * info.type = DATA_TYPE_TYPEDEF
+ * info.name = "a_t"
+ * info.size = sizeof (struct a)
+ * info.ref = (ref of struct a )
+ */
+typedef struct {
+	DwarfDataType	info;
+	DwarfDataType	*ref;
+	bool			is_valid_ref_debug_info_offset;
+	uint32			ref_debug_info_offset;
+} DwarfDataTypedefType;
+
+
+typedef struct {
+	DwarfDataType		info;
+	ElfPointerArrayType	*members;
+} DwarfDataStructType;
+
+typedef struct {
+	char				*name;
+	char				*linkage_name;
+	uint32				off;
+	DwarfDataType		*ref;
+	bool				is_valid_ref_debug_info_offset;
+	uint32				ref_debug_info_offset;
+} DwarfDataStructMember;
+extern void dwarf_add_struct_member(DwarfDataStructType *obj, DwarfDataStructMember *member);
+
+
+typedef struct {
+	DwarfDataType		info;
+	ElfPointerArrayType	*members;
+} DwarfDataEnumulatorType;
+typedef struct {
+	char				*name;
+	uint32				const_value;
+} DwarfDataEnumMember;
+extern void dwarf_add_enum_member(DwarfDataEnumulatorType *obj, char *name, uint32 const_value);
+
+
+typedef struct {
+	DwarfDataType			info;
+	DwarfDataType			*ref;
+	bool					is_valid_ref_debug_info_offset;
+	uint32					ref_debug_info_offset;
+	DwarfUint32ArrayType	*dimension;
+} DwarfDataArrayType;
+
+typedef struct {
+	DwarfDataType			info;
+	DwarfDataType			*ref;
+	bool					is_valid_ref_debug_info_offset;
+	uint32					ref_debug_info_offset;
+} DwarfDataVariableType;
+
+typedef struct {
+	char					*name;
+	bool					isSupported;
+	sint32					stackLocOff;
+	ElfDwarfAttributeType	*DW_AT_location;
+	bool					is_valid_ref_debug_info_offset;
+	uint32					ref_debug_info_offset;
+	DwarfDataType			*ref;
+	uint8					location_op;
+} DwarfLocalVariableType;
+
+typedef struct {
+	DwarfDataType			info;
+	uint32					frame_loc_offset;
+	ElfPointerArrayType		*variables;
+} DwarfDataSubprogramType;
+extern void dwarf_add_subprogram_variable(DwarfDataSubprogramType *obj, DwarfLocalVariableType *org_val);
+
+extern DwarfDataSubprogramType *elf_dwarf_search_subprogram(char *funcname);
+extern DwarfLocalVariableType *elf_dwarf_search_local_variable(DwarfDataSubprogramType *subprogram, char *local_variable);
+
+extern ElfDwarfDieType *dwarf_get_die(uint32 offset);
+
+extern char *elf_dwarf_get_class_method_linkagename(char *classname, char *methodname);
+
+#endif /* _ELF_DWARF_DATA_TYPE_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/data_type/elf_dwarf_enum_type.c
@@ -0,0 +1,75 @@
+#include "elf_dwarf_enum_type.h"
+#include "assert.h"
+
+void elf_dwarf_build_enum_type(ElfDwarfDieType *die)
+{
+	uint32 size;
+	int i;
+	int j;
+	DwarfDataEnumulatorType *obj = dwarf_alloc_data_type(DATA_TYPE_ENUM);
+	ElfDwarfAttributeType *attr;
+	ElfDwarfAbbrevType *abbrev;
+	DwAtType attr_type;
+	ElfDwarfDieType *member;
+
+	for (i = 0; i < die->attribute->current_array_size; i++) {
+		abbrev = (ElfDwarfAbbrevType *)die->abbrev_info;
+		attr = (ElfDwarfAttributeType*)die->attribute->data[i];
+		attr_type = abbrev->attribute_name->data[i];
+		//printf("name=0x%x form=%s\n", attr_type, attr->typename);
+		switch (attr_type) {
+		case DW_AT_name:
+			obj->info.typename = attr->encoded.string;
+			break;
+		case DW_AT_byte_size:
+			obj->info.size = elf_dwarf_info_get_value(abbrev->attribute_form->data[i], attr, &size);
+			break;
+		case DW_AT_sibling:
+		case DW_AT_decl_file:
+		case DW_AT_decl_line:
+		case DW_AT_decl_column:
+		case DW_AT_MIPS_linkage_name:
+		case DW_AT_encoding:
+		case DW_AT_type:
+		case DW_AT_accessibility:
+		case DW_AT_virtuality:
+		case DW_AT_linkage_name:
+		case DW_AT_enum_class:
+			break;
+		default:
+			printf("name=0x%x form=%s\n", attr_type, attr->typename);
+			ASSERT(0);
+		}
+	}
+
+	for (i = 0; i < die->children->current_array_size; i++) {
+		DwarfDataEnumMember mem;
+		mem.name = NULL;
+		mem.const_value = 0;
+		member = (ElfDwarfDieType*)die->children->data[i];
+		abbrev = (ElfDwarfAbbrevType *)member->abbrev_info;
+		if (member->abbrev_info->tag != DW_TAG_enumerator) {
+			continue;
+		}
+		for (j = 0; j < member->attribute->current_array_size; j++) {
+			attr = (ElfDwarfAttributeType*)member->attribute->data[j];
+			attr_type = abbrev->attribute_name->data[j];
+			//printf("member name=0x%x form=%s\n", attr_type, attr->typename);
+			switch (attr_type) {
+			case DW_AT_name:
+				mem.name = attr->encoded.string;
+				//printf("enum mem=%s\n", mem.name);
+				break;
+			case DW_AT_const_value:
+				mem.const_value = elf_dwarf_info_get_value(abbrev->attribute_form->data[j], attr, &size);
+				break;
+			default:
+				ASSERT(0);
+			}
+		}
+		dwarf_add_enum_member(obj, mem.name, mem.const_value);
+	}
+
+	obj->info.die = die;
+	dwarf_register_data_type(&obj->info);
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/data_type/elf_dwarf_enum_type.h
@@ -0,0 +1,9 @@
+#ifndef _ELF_DWARF_ENUM_TYPE_H_
+#define _ELF_DWARF_ENUM_TYPE_H_
+
+#include "elf_dwarf_data_type.h"
+#include "elf_dwarf_info.h"
+
+extern void elf_dwarf_build_enum_type(ElfDwarfDieType *die);
+
+#endif /* _ELF_DWARF_ENUM_TYPE_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/data_type/elf_dwarf_pointer_type.c
@@ -0,0 +1,76 @@
+#include "elf_dwarf_pointer_type.h"
+#include "assert.h"
+
+void elf_dwarf_build_pointer_type(ElfDwarfDieType *die)
+{
+	int i;
+	uint32 size;
+	DwarfDataPointerType *obj = dwarf_alloc_data_type(DATA_TYPE_POINTER);
+	ElfDwarfAttributeType *attr;
+	ElfDwarfAbbrevType *abbrev;
+	DwAtType attr_type;
+	uint32 offset;
+	Std_ReturnType err;
+
+	obj->info.typename = "*";
+	 obj->is_valid_ref_debug_info_offset = FALSE;
+
+	//printf("elf_dwarf_build_pointer_type:off=0x%x\n", die->offset);
+	for (i = 0; i < die->attribute->current_array_size; i++) {
+		abbrev = (ElfDwarfAbbrevType *)die->abbrev_info;
+		attr = (ElfDwarfAttributeType*)die->attribute->data[i];
+		attr_type = abbrev->attribute_name->data[i];
+		switch (attr_type) {
+		case DW_AT_name:
+			obj->info.typename = attr->typename;
+			break;
+		case DW_AT_byte_size:
+			obj->info.size = elf_dwarf_info_get_value(abbrev->attribute_form->data[i], attr, &size);
+			break;
+		case DW_AT_type:
+			offset = elf_dwarf_info_get_value(abbrev->attribute_form->data[i], attr, &size);
+			 err = dwarf_get_real_type_offset(offset, &obj->ref_debug_info_offset);
+			 if (err == STD_E_OK) {
+				 obj->is_valid_ref_debug_info_offset = TRUE;
+			 }
+			//printf("ref_debug_info_offset:off=0x%x\n", obj->ref_debug_info_offset);
+			break;
+		default:
+			printf("die=0x%x attr=0x%x\n", die->offset, attr_type);
+			ASSERT(0);
+		}
+	}
+	obj->info.die = die;
+
+	dwarf_register_data_type(&obj->info);
+
+	return;
+}
+
+void elf_dwarf_resolve_pointer_type(void)
+{
+	int i;
+	ElfPointerArrayType	*my_types = dwarf_get_data_types(DATA_TYPE_POINTER);
+	DwarfDataPointerType *obj;
+	if (my_types == NULL) {
+		return;
+	}
+	for (i = 0; i < my_types->current_array_size; i++) {
+		obj = (DwarfDataPointerType *)my_types->data[i];
+		if (obj->ref != NULL) {
+			continue;
+		}
+		if (obj->is_valid_ref_debug_info_offset == FALSE) {
+			continue;
+		}
+		obj->ref = elf_dwarf_get_data_type(obj->ref_debug_info_offset);
+		//printf("pointer(0x%x):off=0x%x ref_off=0x%x\n", obj->info.die->offset, obj->ref_debug_info_offset, obj->ref->die->offset);
+		if (obj->ref == NULL) {
+			//printf("Not supported:unknown typeref(%s) debug_offset=0x%x\n", obj->info.typename, obj->ref_debug_info_offset);
+		}
+		else {
+			//printf("pointer %s %s\n", obj->ref->typename, obj->info.typename);
+		}
+	}
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/data_type/elf_dwarf_pointer_type.h
@@ -0,0 +1,10 @@
+#ifndef _ELF_DWARF_POINTER_TYPE_H_
+#define _ELF_DWARF_POINTER_TYPE_H_
+
+#include "elf_dwarf_data_type.h"
+#include "elf_dwarf_info.h"
+
+extern void elf_dwarf_build_pointer_type(ElfDwarfDieType *die);
+extern void elf_dwarf_resolve_pointer_type(void);
+
+#endif /* _ELF_DWARF_POINTER_TYPE_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/data_type/elf_dwarf_struct_type.c
@@ -0,0 +1,329 @@
+#include "elf_dwarf_struct_type.h"
+#include "assert.h"
+#include <string.h>
+
+static void elf_dwarf_build_struct_member(DwarfDataStructType *obj, ElfDwarfDieType *member)
+{
+	uint32 size;
+	int j;
+	DwarfDataStructMember mem;
+	ElfDwarfAttributeType *attr;
+	ElfDwarfAbbrevType *abbrev;
+	DwAtType attr_type;
+	uint32 offset;
+	Std_ReturnType err;
+
+	abbrev = (ElfDwarfAbbrevType *)member->abbrev_info;
+	memset(&mem, 0, sizeof(mem));
+	for (j = 0; j < member->attribute->current_array_size; j++) {
+		attr = (ElfDwarfAttributeType*)member->attribute->data[j];
+		attr_type = abbrev->attribute_name->data[j];
+		//printf("member name=0x%x form=%s\n", attr_type, attr->typename);
+		switch (attr_type) {
+		case DW_AT_name:
+			mem.name = attr->encoded.string;
+			//printf("mem.name=%s\n", mem.name);
+			break;
+		case DW_AT_type:
+			//value = elf_dwarf_info_get_value(abbrev->attribute_form->data[j], attr, &size);
+			offset = elf_dwarf_info_get_value(abbrev->attribute_form->data[j], attr, &size);
+			err = dwarf_get_real_type_offset(offset, &mem.ref_debug_info_offset);
+			if (err == STD_E_OK) {
+				mem.is_valid_ref_debug_info_offset = TRUE;
+				//printf("struct location off=0x%x\n", mem.ref_debug_info_offset);
+			}
+			else {
+				//printf("struct location type not found err=%u\n", err);
+			}
+			break;
+		case DW_AT_data_member_location:
+			mem.off = elf_dwarf_info_get_value(abbrev->attribute_form->data[j], attr, &size);
+			//printf("struct location from=0x%x off=%u\n", abbrev->attribute_form->data[j], mem.off);
+			break;
+		case DW_AT_accessibility:
+		case DW_AT_byte_size:
+		case DW_AT_bit_offset:
+		case DW_AT_bit_size:
+		case DW_AT_declaration:
+		case DW_AT_visibility:
+		case DW_AT_decl_file:
+		case DW_AT_decl_line:
+		case DW_AT_decl_column:
+		case DW_AT_artificial:
+		case DW_AT_const_value:
+		case DW_AT_external:
+			break;
+		default:
+			printf("attr_type=0x%x\n", attr_type);
+			ASSERT(0);
+		}
+	}
+	dwarf_add_struct_member(obj, &mem);
+	return;
+}
+
+static void elf_dwarf_build_struct_method(DwarfDataStructType *obj, ElfDwarfDieType *member)
+{
+	uint32 size;
+	int j;
+	DwarfDataStructMember mem;
+	ElfDwarfAttributeType *attr;
+	ElfDwarfAbbrevType *abbrev;
+	DwAtType attr_type;
+	uint32 offset;
+	ElfDwarfDieType *sibling = NULL;
+
+	abbrev = (ElfDwarfAbbrevType *)member->abbrev_info;
+	memset(&mem, 0, sizeof(mem));
+	for (j = 0; j < member->attribute->current_array_size; j++) {
+		attr = (ElfDwarfAttributeType*)member->attribute->data[j];
+		attr_type = abbrev->attribute_name->data[j];
+		//printf("member name=0x%x form=%s\n", attr_type, attr->typename);
+		switch (attr_type) {
+		case DW_AT_name:
+			mem.name = attr->encoded.string;
+			//printf("mem.name=%s\n", mem.name);
+			break;
+		case DW_AT_sibling:
+			offset = elf_dwarf_info_get_value(abbrev->attribute_form->data[j], attr, &size);
+			sibling = dwarf_get_die(offset);
+			//printf("sibling=%p offset=0x%x\n", sibling, offset);
+			break;
+		case DW_AT_MIPS_linkage_name:
+			mem.linkage_name = attr->encoded.string;
+			//printf("mem.linkage_name=%s\n", mem.linkage_name);
+			break;
+		case DW_AT_type:
+		case DW_AT_data_member_location:
+		case DW_AT_accessibility:
+		case DW_AT_byte_size:
+		case DW_AT_bit_offset:
+		case DW_AT_bit_size:
+		case DW_AT_declaration:
+		case DW_AT_visibility:
+		case DW_AT_decl_file:
+		case DW_AT_decl_line:
+		case DW_AT_decl_column:
+		case DW_AT_external:
+		case DW_AT_object_pointer:
+		case DW_AT_inline:
+		case DW_AT_low_pc:
+		case DW_AT_high_pc:
+		case DW_AT_frame_base:
+		case DW_AT_prototyped:
+		case DW_AT_explicit:
+		case DW_AT_linkage_name:
+		case DW_AT_artificial:
+		case DW_AT_virtuality:
+		case DW_AT_containing_type:
+		case DW_AT_vtable_elem_location:
+		case DW_AT_const_value:
+		case DW_AT_encoding:
+		case DW_AT_unknown_0x2116:
+		case DW_AT_unknown_0x2117:
+		case DW_AT_unknown_0x211a:
+			break;
+		default:
+			printf("attr_type=0x%x\n", attr_type);
+			ASSERT(0);
+		}
+	}
+	dwarf_add_struct_member(obj, &mem);
+	if (sibling != NULL) {
+		elf_dwarf_build_struct_method(obj, sibling);
+	}
+	return;
+}
+
+void elf_dwarf_build_struct_type(ElfDwarfDieType *die)
+{
+	uint32 size;
+	int i;
+	DwarfDataStructType *obj;
+	ElfDwarfAttributeType *attr;
+	ElfDwarfAbbrevType *abbrev;
+	DwAtType attr_type;
+	ElfDwarfDieType *member;
+
+	if (die->children == NULL) {
+		// no member;
+		return;
+	}
+
+	if (die->abbrev_info->tag == DW_TAG_structure_type) {
+		obj = dwarf_alloc_data_type(DATA_TYPE_STRUCT);
+	}
+	else if (die->abbrev_info->tag == DW_TAG_class_type) {
+		obj = dwarf_alloc_data_type(DATA_TYPE_CLASS);
+	}
+	else {
+		obj = dwarf_alloc_data_type(DATA_TYPE_UNION);
+	}
+
+
+	//printf("struct_type\n");
+	for (i = 0; i < die->attribute->current_array_size; i++) {
+		abbrev = (ElfDwarfAbbrevType *)die->abbrev_info;
+		attr = (ElfDwarfAttributeType*)die->attribute->data[i];
+		attr_type = abbrev->attribute_name->data[i];
+		//printf("name=0x%x form=%s\n", attr_type, attr->typename);
+		switch (attr_type) {
+		case DW_AT_name:
+			obj->info.typename = attr->encoded.string;
+			//printf("0x%p struct typename=%s\n", obj, obj->info.typename);
+			break;
+		case DW_AT_byte_size:
+			obj->info.size = elf_dwarf_info_get_value(abbrev->attribute_form->data[i], attr, &size);
+			//printf("0x%p struct size=%u\n", obj, obj->info.size);
+			break;
+		case DW_AT_sibling:
+		case DW_AT_decl_file:
+		case DW_AT_decl_line:
+		case DW_AT_decl_column:
+		case DW_AT_declaration:
+		case DW_AT_accessibility:
+		case DW_AT_linkage_name:
+		case DW_AT_containing_type:
+		case DW_AT_MIPS_linkage_name:
+			break;
+		default:
+			printf("attr_type=0x%x\n", attr_type);
+			ASSERT(0);
+		}
+	}
+
+	/*
+	 * members
+	 */
+	for (i = 0; i < die->children->current_array_size; i++) {
+		member = (ElfDwarfDieType*)die->children->data[i];
+		if (member->abbrev_info->tag == DW_TAG_member) {
+			elf_dwarf_build_struct_member(obj, member);
+		}
+		else if(member->abbrev_info->tag == DW_TAG_subprogram) {
+			if (die->abbrev_info->tag == DW_TAG_class_type) {
+				elf_dwarf_build_struct_method(obj, member);
+			}
+		}
+	}
+
+	obj->info.die = die;
+	dwarf_register_data_type(&obj->info);
+	return;
+}
+
+char *elf_dwarf_get_class_method_linkagename(char *classname, char *methodname)
+{
+	int i;
+	int j;
+	ElfPointerArrayType	*my_types = dwarf_get_data_types(DATA_TYPE_CLASS);
+	DwarfDataStructType *obj;
+	DwarfDataStructMember *member;
+
+	if (my_types == NULL) {
+		return NULL;
+	}
+
+	for (i = 0; i < my_types->current_array_size; i++) {
+		obj = (DwarfDataStructType *)my_types->data[i];
+		if (strcmp(obj->info.typename, classname) != 0) {
+			continue;
+		}
+		for (j = 0; j < obj->members->current_array_size; j++) {
+			member = (DwarfDataStructMember *)obj->members->data[j];
+			if (strcmp(member->name, methodname) != 0) {
+				continue;
+			}
+			return member->linkage_name;
+		}
+	}
+	return NULL;
+}
+
+static void elf_dwarf_resolve_struct_union_member(DwarfDataStructType *struct_obj)
+{
+	int i;
+	DwarfDataStructMember *obj;
+
+	//printf("struct or union:%s\n", struct_obj->info.typename);
+	if (struct_obj->members == NULL) {
+		return;
+	}
+	for (i = 0; i < struct_obj->members->current_array_size; i++) {
+		obj = (DwarfDataStructMember *)struct_obj->members->data[i];
+		//printf("member %s ref=%p flag=%u;\n", obj->name, obj->ref, obj->is_valid_ref_debug_info_offset);
+		if (obj->ref != NULL) {
+			continue;
+		}
+		if (obj->is_valid_ref_debug_info_offset == FALSE) {
+			continue;
+		}
+		obj->ref = elf_dwarf_get_data_type(obj->ref_debug_info_offset);
+		if (obj->ref == NULL) {
+			//printf("Not supported:unknown typeref(%s) debug_offset=0x%x\n", obj->ref->typename, obj->ref_debug_info_offset);
+		}
+		else {
+			//printf("member %s %s;\n", obj->ref->typename, obj->name);
+		}
+
+	}
+}
+
+static void elf_dwarf_resolve_union(void)
+{
+	int i;
+	ElfPointerArrayType	*my_types = dwarf_get_data_types(DATA_TYPE_UNION);
+	DwarfDataStructType *obj;
+
+	if (my_types == NULL) {
+		return;
+	}
+
+	for (i = 0; i < my_types->current_array_size; i++) {
+		obj = (DwarfDataStructType *)my_types->data[i];
+		elf_dwarf_resolve_struct_union_member(obj);
+	}
+	return;
+}
+static void elf_dwarf_resolve_struct(void)
+{
+	int i;
+	ElfPointerArrayType	*my_types = dwarf_get_data_types(DATA_TYPE_STRUCT);
+	DwarfDataStructType *obj;
+
+	if (my_types == NULL) {
+		return;
+	}
+
+	for (i = 0; i < my_types->current_array_size; i++) {
+		obj = (DwarfDataStructType *)my_types->data[i];
+		elf_dwarf_resolve_struct_union_member(obj);
+	}
+	return;
+}
+
+static void elf_dwarf_resolve_class(void)
+{
+	int i;
+	ElfPointerArrayType	*my_types = dwarf_get_data_types(DATA_TYPE_CLASS);
+	DwarfDataStructType *obj;
+
+	if (my_types == NULL) {
+		return;
+	}
+
+	for (i = 0; i < my_types->current_array_size; i++) {
+		obj = (DwarfDataStructType *)my_types->data[i];
+		elf_dwarf_resolve_struct_union_member(obj);
+	}
+	return;
+}
+
+void elf_dwarf_resolve_struct_type(void)
+{
+	elf_dwarf_resolve_struct();
+	elf_dwarf_resolve_union();
+	elf_dwarf_resolve_class();
+	return;
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/data_type/elf_dwarf_struct_type.h
@@ -0,0 +1,10 @@
+#ifndef _ELF_DWARF_STRUCT_TYPE_H_
+#define _ELF_DWARF_STRUCT_TYPE_H_
+
+#include "elf_dwarf_data_type.h"
+#include "elf_dwarf_info.h"
+
+extern void elf_dwarf_build_struct_type(ElfDwarfDieType *die);
+extern void elf_dwarf_resolve_struct_type(void);
+
+#endif /* _ELF_DWARF_STRUCT_TYPE_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/data_type/elf_dwarf_subprogram_type.c
@@ -0,0 +1,282 @@
+#include "elf_dwarf_subprogram_type.h"
+#include "elf_dwarf_info_ops.h"
+#include "elf_dwarf_data_type.h"
+#include "assert.h"
+#include <string.h>
+
+static void elf_dwarf_build_subprogram_variable(DwarfDataSubprogramType *obj, ElfDwarfDieType *variable)
+{
+	uint32 size;
+	int j;
+	ElfDwarfAttributeType *attr;
+	ElfDwarfAbbrevType *abbrev;
+	DwAtType attr_type;
+	uint32 offset;
+	Std_ReturnType err;
+	DwarfLocalVariableType localVariable;
+
+	localVariable.is_valid_ref_debug_info_offset = FALSE;
+
+	abbrev = (ElfDwarfAbbrevType *)variable->abbrev_info;
+	memset(&localVariable, 0, sizeof(DwarfLocalVariableType));
+	for (j = 0; j < variable->attribute->current_array_size; j++) {
+		attr = (ElfDwarfAttributeType*)variable->attribute->data[j];
+		attr_type = abbrev->attribute_name->data[j];
+		//printf("variable name=0x%x form=%s\n", attr_type, attr->typename);
+		switch (attr_type) {
+		case DW_AT_name:
+			//printf("=>%s\n", attr->encoded.string);
+			localVariable.name = attr->encoded.string;
+			break;
+		case DW_AT_location:
+			//printf("location:%d\n", attr->encoded.op.len);
+			localVariable.DW_AT_location = attr;
+			break;
+		case DW_AT_type:
+			offset = elf_dwarf_info_get_value(abbrev->attribute_form->data[j], attr, &size);
+			err = dwarf_get_real_type_offset(offset, &localVariable.ref_debug_info_offset);
+			if (err == STD_E_OK) {
+				localVariable.is_valid_ref_debug_info_offset = TRUE;
+			}
+			break;
+		case DW_AT_decl_file:
+		case DW_AT_decl_line:
+		case DW_AT_decl_column:
+		case DW_AT_external:
+		case DW_AT_abstract_origin:
+		case DW_AT_declaration:
+		case DW_AT_const_value:
+		case DW_AT_artificial:
+		case DW_AT_specification:
+		case DW_AT_MIPS_linkage_name:
+		case DW_AT_linkage_name:
+		case DW_AT_unknown_0x2137:
+			break;
+		default:
+			printf("attr_type=0x%x\n", attr_type);
+			ASSERT(0);
+		}
+	}
+	dwarf_add_subprogram_variable(obj, &localVariable);
+	return;
+}
+void elf_dwarf_build_subprogram_type(ElfDwarfDieType *die)
+{
+	int i;
+	DwarfDataSubprogramType *obj = dwarf_alloc_data_type(DATA_TYPE_SUBPROGRAM);
+	ElfDwarfAttributeType *attr;
+	ElfDwarfAbbrevType *abbrev;
+	DwAtType attr_type;
+	ElfDwarfDieType *entry;
+
+	//printf("elf_dwarf_build_subprogram_type:off=0x%x\n", die->offset);
+	//printf("subprogram_type\n");
+	for (i = 0; i < die->attribute->current_array_size; i++) {
+		abbrev = (ElfDwarfAbbrevType *)die->abbrev_info;
+		attr = (ElfDwarfAttributeType*)die->attribute->data[i];
+		attr_type = abbrev->attribute_name->data[i];
+		//printf("name=0x%x form=%s\n", attr_type, attr->typename);
+		switch (attr_type) {
+		case DW_AT_name:
+			obj->info.typename = attr->encoded.string;
+			//printf("typename=%s\n", obj->info.typename);
+			break;
+		case DW_AT_frame_base:
+			//printf("elf_dwarf_build_subprogram_type:off=0x%x\n", die->offset);
+			if (attr->type == DW_FORM_data4) {
+				obj->frame_loc_offset = attr->encoded.const32;
+				//printf("name=0x%x form=%s off=0x%x\n", attr_type, attr->typename, obj->frame_loc_offset);
+			}
+			else if (attr->type == DW_FORM_exprloc) {
+				//printf("ERROR: not supported elf_dwarf_build_subprogram_type:off=0x%x", die->offset);
+			}
+			else {
+				//printf("ERROR: not supported elf_dwarf_build_subprogram_type:off=0x%x", die->offset);
+				//printf("name=0x%x form=%s\n", attr_type, attr->typename);
+			}
+			break;
+		case DW_AT_abstract_origin:
+		case DW_AT_accessibility:
+		case DW_AT_address_class:
+		case DW_AT_artificial:
+		case DW_AT_calling_convention:
+		case DW_AT_declaration:
+		case DW_AT_external:
+		case DW_AT_high_pc:
+		case DW_AT_inline:
+		case DW_AT_low_pc:
+		case DW_AT_prototyped:
+		case DW_AT_return_addr:
+		case DW_AT_segment:
+		case DW_AT_sibling:
+		case DW_AT_specification:
+		case DW_AT_start_scope:
+		case DW_AT_static_link:
+		case DW_AT_type:
+		case DW_AT_visibility:
+		case DW_AT_virtuality:
+		case DW_AT_vtable_elem_location:
+		case DW_AT_decl_file:
+		case DW_AT_decl_line:
+		case DW_AT_decl_column:
+		case DW_AT_linkage_name:
+		case DW_AT_object_pointer:
+		case DW_AT_explicit:
+		case DW_AT_pure:
+		case DW_AT_containing_type:
+		case DW_AT_MIPS_linkage_name:
+		case DW_AT_unknown_0x2116:
+		case DW_AT_unknown_0x2117:
+		case DW_AT_noreturn:
+		case DW_AT_unknown_0x211a:
+#if 0
+		case DW_AT_linkage_name:
+		case DW_AT_main_subprogram:
+		case DW_AT_object_pointer:
+		case DW_AT_pure:
+		case DW_AT_ranges:
+		case DW_AT_recursive:
+		case DW_AT_trampoline:
+		case DW_AT_description:
+		case DW_AT_elemental:
+		case DW_AT_entry_pc:
+		case DW_AT_explicit:
+#endif
+			break;
+		default:
+			printf("die=0x%x attr_type=0x%x\n", die->offset, attr_type);
+			ASSERT(0);
+		}
+	}
+
+	/*
+	 * entries
+	 */
+	if (die->children != NULL) {
+		for (i = 0; i < die->children->current_array_size; i++) {
+			entry = (ElfDwarfDieType*)die->children->data[i];
+			if (entry->abbrev_info->tag == DW_TAG_variable) {
+				elf_dwarf_build_subprogram_variable(obj, entry);
+			}
+			else if (entry->abbrev_info->tag == DW_TAG_formal_parameter) {
+				elf_dwarf_build_subprogram_variable(obj, entry);
+			}
+
+		}
+
+	}
+
+	obj->info.die = die;
+	//printf("variable=%s ref_offset=0x%x\n", obj->info.typename, obj->ref_debug_info_offset);
+
+	dwarf_register_data_type(&obj->info);
+
+	return;
+}
+
+
+static void elf_dwarf_resolve_local_variable(DwarfDataSubprogramType *obj)
+{
+	int i;
+	DwarfLocalVariableType *localVariable;
+
+	if (obj->variables == NULL) {
+		return;
+	}
+
+	//printf("struct or union:%s\n", struct_obj->info.typename);
+	for (i = 0; i < obj->variables->current_array_size; i++) {
+		localVariable = (DwarfLocalVariableType *)obj->variables->data[i];
+
+		if (localVariable->is_valid_ref_debug_info_offset == FALSE) {
+			continue;
+		}
+		localVariable->ref = elf_dwarf_get_data_type(localVariable->ref_debug_info_offset);
+		if (localVariable->ref == NULL) {
+			//printf("Not supported:unknown typeref(%s) debug_offset=0x%x\n", localVariable->ref->typename, localVariable->ref_debug_info_offset);
+		}
+		else {
+			//printf("func %s: %s %s;\n", obj->info.typename, localVariable->ref->typename, localVariable->name);
+		}
+
+	}
+}
+
+void elf_dwarf_resolve_subprogram_type(void)
+{
+	int i;
+	ElfPointerArrayType	*my_types = dwarf_get_data_types(DATA_TYPE_SUBPROGRAM);
+	DwarfDataSubprogramType *obj;
+
+	if (my_types == NULL) {
+		return;
+	}
+
+	for (i = 0; i < my_types->current_array_size; i++) {
+		obj = (DwarfDataSubprogramType *)my_types->data[i];
+		elf_dwarf_resolve_local_variable(obj);
+	}
+	return;
+}
+
+DwarfDataSubprogramType *elf_dwarf_search_subprogram(char *funcname)
+{
+	int namelen = strlen(funcname);
+	int i;
+	ElfPointerArrayType	*my_types = dwarf_get_data_types(DATA_TYPE_SUBPROGRAM);
+	DwarfDataSubprogramType *obj = NULL;
+
+	if (my_types == NULL) {
+		return NULL;
+	}
+
+	for (i = 0; i < my_types->current_array_size; i++) {
+		int len;
+		obj = (DwarfDataSubprogramType *)my_types->data[i];
+		if (obj->info.typename == NULL) {
+			continue;
+		}
+		len = strlen(obj->info.typename);
+		if (len != namelen) {
+			continue;
+		}
+		if (strncmp(funcname, obj->info.typename, len) != 0) {
+			continue;
+		}
+		return obj;
+	}
+	return NULL;
+}
+
+DwarfLocalVariableType *elf_dwarf_search_local_variable(DwarfDataSubprogramType *subprogram, char *local_variable)
+{
+	int namelen = strlen(local_variable);
+	int i;
+
+	DwarfLocalVariableType *localVariable;
+
+	if (subprogram->variables == NULL) {
+		return NULL;
+	}
+
+	for (i = 0; i < subprogram->variables->current_array_size; i++) {
+		int len;
+		localVariable = (DwarfLocalVariableType *)subprogram->variables->data[i];
+
+		if (localVariable->ref == NULL) {
+			continue;
+		}
+		if (localVariable->name == NULL) {
+			continue;
+		}
+		len = strlen(localVariable->name);
+		if (namelen != len) {
+			continue;
+		}
+		if (strncmp(local_variable, localVariable->name, len) != 0) {
+			continue;
+		}
+		return localVariable;
+	}
+	return NULL;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/data_type/elf_dwarf_subprogram_type.h
@@ -0,0 +1,10 @@
+#ifndef _ELF_DWARF_SUBPROGRAM_TYPE_H_
+#define _ELF_DWARF_SUBPROGRAM_TYPE_H_
+
+#include "elf_dwarf_data_type.h"
+#include "elf_dwarf_info.h"
+
+extern void elf_dwarf_build_subprogram_type(ElfDwarfDieType *die);
+extern void elf_dwarf_resolve_subprogram_type(void);
+
+#endif /* _ELF_DWARF_SUBPROGRAM_TYPE_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/data_type/elf_dwarf_typedef_type.c
@@ -0,0 +1,78 @@
+#include "elf_dwarf_typedef_type.h"
+#include "assert.h"
+
+void elf_dwarf_build_typedef_type(ElfDwarfDieType *die)
+{
+	int i;
+	uint32 size;
+	DwarfDataTypedefType *obj = dwarf_alloc_data_type(DATA_TYPE_TYPEDEF);
+	ElfDwarfAttributeType *attr;
+	ElfDwarfAbbrevType *abbrev;
+	DwAtType attr_type;
+	uint32 offset;
+	Std_ReturnType err;
+
+	//printf("elf_dwarf_build_typedef_type:off=0x%x\n", die->offset);
+	//printf("typedef_type\n");
+	for (i = 0; i < die->attribute->current_array_size; i++) {
+		abbrev = (ElfDwarfAbbrevType *)die->abbrev_info;
+		attr = (ElfDwarfAttributeType*)die->attribute->data[i];
+		attr_type = abbrev->attribute_name->data[i];
+		//printf("name=0x%x form=%s\n", attr_type, attr->typename);
+		switch (attr_type) {
+		case DW_AT_name:
+			obj->info.typename = attr->encoded.string;
+			break;
+		case DW_AT_type:
+			offset = elf_dwarf_info_get_value(abbrev->attribute_form->data[i], attr, &size);
+			 err = dwarf_get_real_type_offset(offset, &obj->ref_debug_info_offset);
+			 if (err == STD_E_OK) {
+				 obj->is_valid_ref_debug_info_offset = TRUE;
+			 }
+			break;
+		case DW_AT_accessibility:
+		case DW_AT_decl_file:
+		case DW_AT_decl_line:
+		case DW_AT_decl_column:
+			break;
+		default:
+			printf("name=0x%x form=%s\n", attr_type, attr->typename);
+			ASSERT(0);
+		}
+	}
+	obj->info.die = die;
+	//printf("typedef=%s ref_offset=0x%x\n", obj->info.typename, obj->ref_debug_info_offset);
+
+	dwarf_register_data_type(&obj->info);
+
+	return;
+}
+void elf_dwarf_resolve_typedef_type(void)
+{
+	int i;
+	ElfPointerArrayType	*my_types = dwarf_get_data_types(DATA_TYPE_TYPEDEF);
+	DwarfDataTypedefType *obj;
+
+	if (my_types == NULL) {
+		return;
+	}
+
+	for (i = 0; i < my_types->current_array_size; i++) {
+		obj = (DwarfDataTypedefType *)my_types->data[i];
+		if (obj->ref != NULL) {
+			continue;
+		}
+		if (obj->is_valid_ref_debug_info_offset == FALSE) {
+			continue;
+		}
+		obj->ref = elf_dwarf_get_data_type(obj->ref_debug_info_offset);
+		if (obj->ref == NULL) {
+			//printf("Not supported:unknown typeref(%s) debug_offset=0x%x\n", obj->info.typename, obj->ref_debug_info_offset);
+		}
+		else {
+			//printf("typedef %s %s\n", obj->ref->typename, obj->info.typename);
+		}
+	}
+
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/data_type/elf_dwarf_typedef_type.h
@@ -0,0 +1,10 @@
+#ifndef _ELF_DWARF_TYPEDEF_TYPE_H_
+#define _ELF_DWARF_TYPEDEF_TYPE_H_
+
+#include "elf_dwarf_data_type.h"
+#include "elf_dwarf_info.h"
+
+extern void elf_dwarf_build_typedef_type(ElfDwarfDieType *die);
+extern void elf_dwarf_resolve_typedef_type(void);
+
+#endif /* _ELF_DWARF_TYPEDEF_TYPE_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/data_type/elf_dwarf_variable_type.c
@@ -0,0 +1,89 @@
+#include "elf_dwarf_variable_type.h"
+#include "assert.h"
+
+void elf_dwarf_build_variable_type(ElfDwarfDieType *die)
+{
+	int i;
+	uint32 size;
+	DwarfDataVariableType *obj = dwarf_alloc_data_type(DATA_TYPE_VARIABLE);
+	ElfDwarfAttributeType *attr;
+	ElfDwarfAbbrevType *abbrev;
+	DwAtType attr_type;
+	uint32 offset;
+	Std_ReturnType err;
+
+	//printf("elf_dwarf_build_variable_type:off=0x%x\n", die->offset);
+	//printf("variable_type\n");
+	for (i = 0; i < die->attribute->current_array_size; i++) {
+		abbrev = (ElfDwarfAbbrevType *)die->abbrev_info;
+		attr = (ElfDwarfAttributeType*)die->attribute->data[i];
+		attr_type = abbrev->attribute_name->data[i];
+		//printf("name=0x%x form=%s\n", attr_type, attr->typename);
+		switch (attr_type) {
+		case DW_AT_name:
+			obj->info.typename = attr->encoded.string;
+			//printf("typename=%s\n", obj->info.typename);
+			break;
+		case DW_AT_type:
+			offset = elf_dwarf_info_get_value(abbrev->attribute_form->data[i], attr, &size);
+			 err = dwarf_get_real_type_offset(offset, &obj->ref_debug_info_offset);
+			 if (err == STD_E_OK) {
+				 obj->is_valid_ref_debug_info_offset = TRUE;
+			 }
+			break;
+		case DW_AT_decl_file:
+		case DW_AT_decl_line:
+		case DW_AT_decl_column:
+		case DW_AT_location:
+		case DW_AT_external:
+		case DW_AT_abstract_origin:
+		case DW_AT_declaration:
+		case DW_AT_const_value:
+		case DW_AT_artificial:
+		case DW_AT_specification:
+		case DW_AT_linkage_name:
+		case DW_AT_MIPS_linkage_name:
+		case DW_AT_alignment:
+		case DW_AT_unknown_0x2137:
+			break;
+		default:
+			printf("die=0x%x attr_type=0x%x\n", die->offset, attr_type);
+			ASSERT(0);
+		}
+	}
+	obj->info.die = die;
+	//printf("variable=%s ref_offset=0x%x\n", obj->info.typename, obj->ref_debug_info_offset);
+
+	dwarf_register_data_type(&obj->info);
+
+	return;
+}
+void elf_dwarf_resolve_variable_type(void)
+{
+	int i;
+	ElfPointerArrayType	*my_types = dwarf_get_data_types(DATA_TYPE_VARIABLE);
+	DwarfDataVariableType *obj;
+	if (my_types == NULL) {
+		return;
+	}
+	for (i = 0; i < my_types->current_array_size; i++) {
+		obj = (DwarfDataVariableType *)my_types->data[i];
+		if (obj->ref != NULL) {
+			continue;
+		}
+		if (obj->is_valid_ref_debug_info_offset == FALSE) {
+			continue;
+		}
+		obj->ref = elf_dwarf_get_data_type(obj->ref_debug_info_offset);
+		//printf("variable =%s type=0x%x ref_off=0x%x\n", obj->info.typename, obj->ref_debug_info_offset, obj->ref->die->offset);
+		if (obj->ref == NULL) {
+			//printf("Not supported:unknown typeref(%s) debug_offset=0x%x\n", obj->info.typename, obj->ref_debug_info_offset);
+		}
+		else {
+			//if (strcmp("test_class_data", obj->info.typename) == 0)
+			//	printf("variable(0x%p) %s %s\n", obj, obj->ref->typename, obj->info.typename);
+		}
+	}
+
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/data_type/elf_dwarf_variable_type.h
@@ -0,0 +1,10 @@
+#ifndef _ELF_DWARF_VARIABLE_TYPE_H_
+#define _ELF_DWARF_VARIABLE_TYPE_H_
+
+#include "elf_dwarf_data_type.h"
+#include "elf_dwarf_info.h"
+
+extern void elf_dwarf_build_variable_type(ElfDwarfDieType *die);
+extern void elf_dwarf_resolve_variable_type(void);
+
+#endif /* _ELF_DWARF_VARIABLE_TYPE_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/elf_dwarf_abbrev.c
@@ -0,0 +1,155 @@
+#include "elf_dwarf_abbrev.h"
+#include "elf_section.h"
+#include <stdio.h>
+
+#if 0
+#define DBG_PRINTF(arg)	printf arg
+static void print_ElfDwarfAbbrev(ElfDwarfAbbrevType *entry)
+{
+	int i;
+
+	printf("******************\n");
+	printf("code=0x%x\n", entry->code);
+	printf("tag=0x%x\n", entry->tag);
+	printf("childs=0x%x\n", entry->child);
+
+	for (i = 0; i < entry->attribute_name->current_array_size; i++) {
+		printf("%u : name=0x%x form=0x%x\n", i, entry->attribute_name->data[i], entry->attribute_form->data[i]);
+	}
+
+	return;
+}
+#else
+#define DBG_PRINTF(arg)
+#define	print_ElfDwarfAbbrev(arg)
+#endif
+
+static ElfPointerArrayType *elf_dwarf_abbrev_array = NULL;
+
+
+Std_ReturnType elf_dwarf_abbrev_load(uint8 *elf_data)
+{
+	uint8 *section_data;
+	Std_ReturnType err;
+	uint32 section_size;
+	uint32 current_size = 0;
+	uint32 entry_size;
+	uint32 attr_name;
+	uint32 attr_form;
+	uint32 code;
+	ElfDwarfAbbrevType *entry;
+	uint32 index = 0;
+
+	err = elf_section_get(elf_data, SECTION_DWARF_ABBREV_NAME, &section_data, &section_size);
+	if (err != STD_E_OK) {
+		return err;
+	}
+	DBG_PRINTF(("**section_size=%u\n", section_size));
+
+	elf_dwarf_abbrev_array = elf_array_alloc();
+
+	while (current_size < section_size) {
+		code = elf_dwarf_decode_uleb128(&section_data[current_size], &entry_size);
+		DBG_PRINTF(("**current_size=0x%x code=0x%x******\n", current_size, code));
+		if (code == 0) {
+			current_size += entry_size;
+			continue;
+		}
+		/*
+		 * header
+		 */
+		entry = elf_dwarf_abbrev_alloc_empty_ElfDwarfAbbrev();
+		entry->offset = current_size;
+		entry->index = index++;
+		current_size += entry_size;
+
+		/*
+		 * set abbrev code
+		 */
+		entry->code = code;
+		/*
+		 * set tag
+		 */
+		entry->tag = elf_dwarf_decode_uleb128(&section_data[current_size], &entry_size);
+		current_size += entry_size;
+
+		/*
+		 * childs
+		 */
+		entry->child = section_data[current_size];
+		current_size += 1;
+
+		/*
+		 * set attribute
+		 */
+		do {
+			attr_name = elf_dwarf_decode_uleb128(&section_data[current_size], &entry_size);
+			current_size += entry_size;
+			attr_form = elf_dwarf_decode_uleb128(&section_data[current_size], &entry_size);
+			current_size += entry_size;
+
+			dwarf_uint32_array_add_entry(entry->attribute_name, attr_name);
+			dwarf_uint32_array_add_entry(entry->attribute_form, attr_form);
+		} while (attr_name != 0);
+
+		//print_ElfDwarfAbbrev(entry);
+		elf_array_add_entry(elf_dwarf_abbrev_array, entry);
+	}
+	DBG_PRINTF(("END\n"));
+
+	return STD_E_OK;
+}
+
+ElfDwarfAbbrevType *elf_dwarf_abbrev_get(uint32 offset)
+{
+	ElfDwarfAbbrevType *entry;
+	int i;
+
+	for (i = 0; i < elf_dwarf_abbrev_array->current_array_size; i++) {
+		entry = (ElfDwarfAbbrevType *)elf_dwarf_abbrev_array->data[i];
+		if (entry->offset == offset) {
+			return entry;
+		}
+	}
+	return NULL;
+}
+
+ElfDwarfAbbrevType *elf_dwarf_abbrev_get_from_code(ElfDwarfAbbrevType *top, uint32 code)
+{
+	ElfDwarfAbbrevType *entry;
+	int i;
+	uint32 last_code = 0x0;
+
+	for (i = top->index; i < elf_dwarf_abbrev_array->current_array_size; i++) {
+		entry = (ElfDwarfAbbrevType *)elf_dwarf_abbrev_array->data[i];
+		if (entry->code <= last_code) {
+			break;
+		}
+		if (entry->code == code) {
+			return entry;
+		}
+		last_code = entry->code;
+	}
+	return NULL;
+}
+
+ElfDwarfAbbrevType *elf_dwarf_abbrev_next(ElfDwarfAbbrevType *current)
+{
+	uint32 index = current->index;
+
+	if (index >= (elf_dwarf_abbrev_array->current_array_size - 1)) {
+		return NULL;
+	}
+	return (ElfDwarfAbbrevType *)elf_dwarf_abbrev_array->data[index + 1];
+}
+
+
+ElfDwarfAbbrevType *elf_dwarf_abbrev_alloc_empty_ElfDwarfAbbrev(void)
+{
+	ElfDwarfAbbrevType *obj;
+
+	obj = elf_obj_alloc(sizeof(ElfDwarfAbbrevType));
+	obj->attribute_name = dwarf_uint32_array_alloc();
+	obj->attribute_form = dwarf_uint32_array_alloc();
+	return obj;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/elf_dwarf_abbrev.h
@@ -0,0 +1,254 @@
+#ifndef _ELF_DWARF_ABBREV_H_
+#define _ELF_DWARF_ABBREV_H_
+
+#include "std_types.h"
+#include "std_errno.h"
+#include "elf_dwarf_util.h"
+
+typedef enum {
+	DW_TAG_array_type = 0x01,
+	DW_TAG_class_type = 0x02,
+	DW_TAG_entry_point = 0x03,
+	DW_TAG_enumeration_type = 0x04,
+	DW_TAG_formal_parameter = 0x05,
+	DW_TAG_imported_declaration = 0x08,
+	DW_TAG_label = 0x0a,
+	DW_TAG_lexical_block = 0x0b,
+	DW_TAG_member = 0x0d,
+	DW_TAG_pointer_type = 0x0f,
+	DW_TAG_reference_type = 0x10,
+	DW_TAG_compile_unit = 0x11,
+	DW_TAG_string_type = 0x12,
+	DW_TAG_structure_type = 0x13,
+	DW_TAG_subroutine_type = 0x15,
+	DW_TAG_typedef = 0x16,
+	DW_TAG_union_type = 0x17,
+	DW_TAG_unspecified_parameters = 0x18,
+	DW_TAG_variant = 0x19,
+	DW_TAG_common_block = 0x1a,
+	DW_TAG_common_inclusion = 0x1b,
+	DW_TAG_inheritance = 0x1c,
+	DW_TAG_inlined_subroutine = 0x1d,
+	DW_TAG_module = 0x1e,
+	DW_TAG_ptr_to_member_type = 0x1f,
+	DW_TAG_set_type = 0x20,
+	DW_TAG_subrange_type = 0x21,
+	DW_TAG_with_stmt = 0x22,
+	DW_TAG_access_declaration = 0x23,
+	DW_TAG_base_type = 0x24,
+	DW_TAG_catch_block = 0x25,
+	DW_TAG_const_type = 0x26,
+	DW_TAG_constant = 0x27,
+	DW_TAG_enumerator = 0x28,
+	DW_TAG_file_type = 0x29,
+	DW_TAG_friend = 0x2a,
+	DW_TAG_namelist = 0x2b,
+	DW_TAG_namelist_item = 0x2c,
+	DW_TAG_packed_type = 0x2d,
+	DW_TAG_subprogram = 0x2e,
+	DW_TAG_template_type_param = 0x2f,
+	DW_TAG_template_value_param = 0x30,
+	DW_TAG_thrown_type = 0x31,
+	DW_TAG_try_block = 0x32,
+	DW_TAG_variant_part = 0x33,
+	DW_TAG_variable = 0x34,
+	DW_TAG_volatile_type = 0x35,
+	DW_TAG_lo_user = 0x4080,
+	DW_TAG_hi_user = 0xffff,
+} DwTagType;
+
+typedef enum {
+	DW_AT_sibling = 0x01, //reference
+	DW_AT_location = 0x02, //block, constant
+	DW_AT_name = 0x03, //string
+	DW_AT_ordering = 0x09, //constant
+	DW_AT_byte_size = 0x0b, //constant
+	DW_AT_bit_offset = 0x0c, //constant
+	DW_AT_bit_size = 0x0d, //constant
+	DW_AT_stmt_list = 0x10, //constant
+	DW_AT_low_pc = 0x11, //address
+	DW_AT_high_pc = 0x12, //address
+	DW_AT_language = 0x13, //constant
+	DW_AT_discr = 0x15, //reference
+	DW_AT_discr_value = 0x16, //constant
+	DW_AT_visibility = 0x17, //constant
+	DW_AT_import = 0x18, //reference
+	DW_AT_string_length = 0x19, //block, constant
+	DW_AT_common_reference = 0x1a, //reference
+	DW_AT_comp_dir = 0x1b, //string
+	DW_AT_const_value = 0x1c, //string, constant, block
+	DW_AT_containing_type = 0x1d, //reference
+	DW_AT_default_value = 0x1e, //reference
+	DW_AT_inline = 0x20, //constant
+	DW_AT_is_optional = 0x21, //flag
+	DW_AT_lower_bound = 0x22, //constant, reference
+	DW_AT_producer = 0x25, //string
+	DW_AT_prototyped = 0x27, //flag
+	DW_AT_return_addr = 0x2a, //block, constant
+	DW_AT_start_scope = 0x2c, //constant
+	DW_AT_stride_size = 0x2e, //constant
+	DW_AT_upper_bound = 0x2f, //constant, reference
+	DW_AT_abstract_origin = 0x31, //reference
+	DW_AT_accessibility = 0x32, //constant
+	DW_AT_address_class = 0x33, //constant
+	DW_AT_artificial = 0x34, //flag
+	DW_AT_base_types = 0x35, //reference
+	DW_AT_calling_convention = 0x36, //constant
+	DW_AT_count = 0x37, //constant, reference
+	DW_AT_data_member_location = 0x38, //block, reference
+	DW_AT_decl_column = 0x39, //constant
+	DW_AT_decl_file = 0x3a, //constant
+	DW_AT_decl_line = 0x3b, //constant
+	DW_AT_declaration = 0x3c, //flag
+	DW_AT_discr_list = 0x3d, //block
+	DW_AT_encoding = 0x3e, //constant
+	DW_AT_external = 0x3f, //flag
+	DW_AT_frame_base = 0x40, //block, constant
+	DW_AT_friend = 0x41, //reference
+	DW_AT_identifier_case = 0x42, //constant
+	DW_AT_macro_info = 0x43, //constant
+	DW_AT_namelist_item = 0x44, //block
+	DW_AT_priority = 0x45, //reference
+	DW_AT_segment = 0x46, //block, constant
+	DW_AT_specification = 0x47, //reference
+	DW_AT_static_link = 0x48, //block, constant
+	DW_AT_type = 0x49, //reference
+	DW_AT_use_location = 0x4a, //block, constant
+	DW_AT_variable_parameter = 0x4b, //flag
+	DW_AT_virtuality = 0x4c, //constant
+	DW_AT_vtable_elem_location = 0x4d, //block, reference
+
+	DW_AT_allocated = 0x4e, //constant, exprloc, reference
+	DW_AT_associated = 0x4f, // constant, exprloc, reference
+	DW_AT_data_location = 0x50, // exprloc
+	DW_AT_byte_stride = 0x51, // constant, exprloc, reference
+	DW_AT_entry_pc = 0x52, // address
+	DW_AT_use_UTF8 = 0x53, // flag
+	DW_AT_extension = 0x54, // reference
+	DW_AT_ranges = 0x55, // rangelistptr
+	DW_AT_trampoline = 0x56, // address, flag, reference, string
+	DW_AT_call_column = 0x57, // constant
+	DW_AT_call_file = 0x58, // constant
+	DW_AT_call_line = 0x59, // constant
+	DW_AT_description = 0x5a, // string
+	DW_AT_binary_scale = 0x5b, // constant
+	DW_AT_decimal_scale = 0x5c, // constant
+	DW_AT_small = 0x5d, // reference
+	DW_AT_decimal_sign = 0x5e, // constant
+	DW_AT_digit_count = 0x5f, // constant
+	DW_AT_picture_string = 0x60, // string
+	DW_AT_mutable = 0x61, // flag
+
+	DW_AT_threads_scaled = 0x62, // flag
+	DW_AT_explicit = 0x63, // flag
+	DW_AT_object_pointer = 0x64, // reference
+	DW_AT_endianity = 0x65, // constant
+	DW_AT_elemental = 0x66, // flag
+	DW_AT_pure = 0x67, // flag
+	DW_AT_recursive = 0x68, // flag
+	DW_AT_signature = 0x69, // reference
+	DW_AT_main_subprogram = 0x6a, // flag
+	DW_AT_data_bit_offset = 0x6b, // constant
+	DW_AT_const_expr = 0x6c, // flag
+	DW_AT_enum_class = 0x6d, // flag
+	DW_AT_linkage_name = 0x6e, // string
+
+	DW_AT_noreturn = 0x87,	// flag
+	DW_AT_alignment = 0x88, // constant
+	DW_AT_lo_user = 0x2000,
+	DW_AT_MIPS_linkage_name = 0x2007,
+	DW_AT_unknown_0x2116 = 0x2116,
+	DW_AT_unknown_0x2117 = 0x2117,
+	DW_AT_unknown_0x2137 = 0x2137,
+	DW_AT_unknown_0x211a = 0x211a,
+	DW_AT_hi_user = 0x3fff,
+} DwAtType;
+
+typedef enum {
+	DW_CHILDREN_no = 0,
+	DW_CHILDREN_yes = 1,
+} DwChildrenType;
+
+typedef enum {
+	DW_FORM_none = 0x0,
+	DW_FORM_addr = 0x01, //address
+	DW_FORM_block2 = 0x03, //block
+	DW_FORM_block4 = 0x04, //block
+	DW_FORM_data2 = 0x05, //constant
+	DW_FORM_data4 = 0x06, //constant
+	DW_FORM_data8 = 0x07, //constant
+	DW_FORM_string = 0x08, //string
+	DW_FORM_block = 0x09, //block
+	DW_FORM_block1 = 0x0a, //block
+	DW_FORM_data1 = 0x0b, //constant
+	DW_FORM_flag = 0x0c, //flag
+	DW_FORM_sdata = 0x0d, //constant
+	DW_FORM_strp = 0x0e, //string
+	DW_FORM_udata = 0x0f, //constant
+	DW_FORM_ref_addr = 0x10, //reference
+	DW_FORM_ref1 = 0x11, //reference
+	DW_FORM_ref2 = 0x12, //reference
+	DW_FORM_ref4 = 0x13, //reference
+	DW_FORM_ref8 = 0x14, //reference
+	DW_FORM_ref_udata = 0x15, //reference
+	DW_FORM_indirect = 0x16, //(see section 7.5.3)
+	DW_FORM_sec_offset = 0x17,
+	DW_FORM_exprloc = 0x18,
+	DW_FORM_flag_present = 0x19,
+	DW_FORM_ref_sig8 = 0x20,
+} DwFormType;
+
+typedef enum {
+	DW_FORM_ENC_ADDRESS = 0,
+	DW_FORM_ENC_BLOCK,
+	DW_FORM_ENC_CONSTANT,
+	DW_FORM_ENC_FLAG,
+	DW_FORM_ENC_REFERENCE,
+	DW_FORM_ENC_STRING,
+	DW_FORM_ENC_INDIRECT,
+	DW_FORM_ENC_UNKNOWN,
+} DwFormEncodingType;
+
+
+typedef enum {
+	DW_ATE_address = 0x1, //linear machine address
+	DW_ATE_boolean = 0x2, //true or false
+	DW_ATE_complex_float = 0x3, //complex floating-point number
+	DW_ATE_float = 0x4, //floating-point number
+	DW_ATE_signed = 0x5, //signed binary integer
+	DW_ATE_signed_char = 0x6, // signed character
+	DW_ATE_unsigned = 0x7, //unsigned binary integer
+	DW_ATE_unsigned_char = 0x8,
+	DW_ATE_unknown = 0xFF,
+} DwAteType;
+
+typedef struct {
+	uint32	index;
+	uint32	offset;
+	/*
+	 * abbreviation code(uleb128)
+	 */
+	uint32	code;
+	/*
+	 * entry’s tag(uleb128)
+	 */
+	DwTagType	tag;
+	/*
+	 * this abbreviation has child entries or not(uint8)
+	 */
+	DwChildrenType	child;
+
+	/*
+	 * series of attribute specifications
+	 */
+	DwarfUint32ArrayType	*attribute_name;
+	DwarfUint32ArrayType	*attribute_form;
+} ElfDwarfAbbrevType;
+
+extern Std_ReturnType elf_dwarf_abbrev_load(uint8 *elf_data);
+extern ElfDwarfAbbrevType *elf_dwarf_abbrev_get(uint32 offset);
+extern ElfDwarfAbbrevType *elf_dwarf_abbrev_next(ElfDwarfAbbrevType *current);
+extern ElfDwarfAbbrevType *elf_dwarf_abbrev_get_from_code(ElfDwarfAbbrevType *top, uint32 code);
+extern ElfDwarfAbbrevType *elf_dwarf_abbrev_alloc_empty_ElfDwarfAbbrev(void);
+
+#endif /* _ELF_DWARF_ABBREV_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/elf_dwarf_info.c
@@ -0,0 +1,521 @@
+#include "elf_dwarf_info.h"
+#include "elf_dwarf_info_ops.h"
+#include "elf_section.h"
+#include "assert.h"
+#include <string.h>
+
+#if 0
+#include <stdio.h>
+#define DBG_PRINTF_DEFINED
+#define DBG_PRINTF(arg)	printf arg
+static void printCompilationUnitHeader(ElfDwarfCompilationUnitHeaderType *cu);
+static void printAll(void);
+#else
+#define DBG_PRINTF(arg)
+#endif
+
+
+static char *debug_str = NULL;
+static ElfPointerArrayType *compilation_unit_headers = NULL;
+
+
+static ElfDwarfAttributeType *elf_dwarf_alloc_empty_ElfDwarfAttribute(void)
+{
+	return (ElfDwarfAttributeType *)elf_obj_alloc(sizeof(ElfDwarfAttributeType));
+}
+static ElfDwarfCompilationUnitHeaderType *elf_dwarf_alloc_empty_ElfDwarfCompilationUnitHeader(void)
+{
+	ElfDwarfCompilationUnitHeaderType *obj;
+
+	obj = (ElfDwarfCompilationUnitHeaderType *)elf_obj_alloc(sizeof(ElfDwarfCompilationUnitHeaderType));
+
+	obj->dies = elf_array_alloc();
+	return obj;
+}
+static ElfDwarfDieType *elf_dwarf_alloc_empty_ElfDwarfDie(void)
+{
+	ElfDwarfDieType *obj;
+
+	obj = (ElfDwarfDieType *)elf_obj_alloc(sizeof(ElfDwarfDieType));
+
+	obj->attribute = elf_array_alloc();
+	return obj;
+}
+
+uint32 elf_dwarf_info_get_value(DwFormType form, ElfDwarfAttributeType *obj, uint32 *size)
+{
+	uint32 value = -1;
+	*size = 0;
+	switch (form) {
+	case DW_FORM_none:
+		break;
+	case DW_FORM_addr:
+		value = obj->encoded.addr;
+		*size = 4;
+		break;
+	case DW_FORM_data1:
+		value = obj->encoded.const8;
+		*size = 1;
+		break;
+	case DW_FORM_data2:
+		value = obj->encoded.const16;
+		*size = 2;
+		break;
+	case DW_FORM_data4:
+		value = obj->encoded.const32;
+		*size = 4;
+		break;
+	case DW_FORM_ref1:
+		value = obj->encoded.ref8;
+		*size = 1;
+		break;
+	case DW_FORM_ref2:
+		value = obj->encoded.ref16;
+		*size = 2;
+		break;
+	case DW_FORM_ref4:
+		value = obj->encoded.ref32;
+		*size = 4;
+		break;
+	case DW_FORM_sec_offset:
+		value = obj->encoded.sec_offset;
+		*size = 4;
+		break;
+	case DW_FORM_sdata:
+		value = (uint32)obj->encoded.scont64;
+		*size = 4;
+		break;
+	case DW_FORM_block1:
+		//printf("block1:len=%u op[0]=%x, op[1]=%x\n", obj->encoded.op.len,
+		//		obj->encoded.op.ops[0], obj->encoded.op.ops[1]);
+		elf_dwarf_info_ops_push(0);
+		elf_dwarf_info_ops_DW_OP(obj->encoded.op.ops[0], &obj->encoded.op.ops[1]);
+		value = elf_dwarf_info_ops_pop();
+		break;
+	default:
+		printf("invalid form=0x%x\n", form);
+		ASSERT(0);
+		break;
+	}
+	return value;
+}
+
+static ElfDwarfAttributeType *elf_dwarf_info_parse_attr(ElfDwarfCompilationUnitHeaderType *cu, ElfDwarfDieType *die, uint8 *addr, DwFormType form, uint32 *size)
+{
+	ElfDwarfAttributeType *obj = NULL;
+
+	*size = 0;
+	switch (form) {
+	case DW_FORM_none:
+		break;
+	case DW_FORM_addr:
+		*size = cu->pointer_size;
+		obj = elf_dwarf_alloc_empty_ElfDwarfAttribute();
+		obj->encoded.addr = elf_get_data32(addr, 0);
+		obj->typename = "DW_FORM_addr";
+		break;
+	case DW_FORM_block:
+		ASSERT(0);
+		break;
+	case DW_FORM_block1:
+		obj = elf_dwarf_alloc_empty_ElfDwarfAttribute();
+		obj->encoded.op.len = elf_get_data8(addr, 0);
+		obj->encoded.op.ops = &addr[1];
+		*size = obj->encoded.op.len + 1;
+		obj->typename = "DW_FORM_block1";
+		break;
+	case DW_FORM_block2:
+		obj = elf_dwarf_alloc_empty_ElfDwarfAttribute();
+		obj->encoded.op.len = elf_get_data16(addr, 0);
+		obj->encoded.op.ops = &addr[2];
+		*size = obj->encoded.op.len + 2;
+		obj->typename = "DW_FORM_block2";
+		break;
+	case DW_FORM_block4:
+		obj = elf_dwarf_alloc_empty_ElfDwarfAttribute();
+		obj->encoded.op.len = elf_get_data32(addr, 0);
+		obj->encoded.op.ops = &addr[4];
+		obj->typename = "DW_FORM_block4";
+		*size = obj->encoded.op.len + 4;
+		break;
+	case DW_FORM_data1:
+		obj = elf_dwarf_alloc_empty_ElfDwarfAttribute();
+		obj->encoded.const8 = elf_get_data8(addr, 0);
+		obj->typename = "DW_FORM_data1";
+		*size = 1;
+		break;
+	case DW_FORM_data2:
+		obj = elf_dwarf_alloc_empty_ElfDwarfAttribute();
+		obj->encoded.const16 = elf_get_data16(addr, 0);
+		obj->typename = "DW_FORM_data2";
+		*size = 2;
+		break;
+	case DW_FORM_data4:
+		obj = elf_dwarf_alloc_empty_ElfDwarfAttribute();
+		obj->encoded.const32 = elf_get_data32(addr, 0);
+		obj->typename = "DW_FORM_data4";
+		*size = 4;
+		break;
+	case DW_FORM_data8:
+		obj = elf_dwarf_alloc_empty_ElfDwarfAttribute();
+		obj->encoded.const64 = elf_get_data64(addr, 0);
+		obj->typename = "DW_FORM_data8";
+		*size = 8;
+		break;
+	case DW_FORM_sdata:
+		obj = elf_dwarf_alloc_empty_ElfDwarfAttribute();
+		obj->encoded.scont64 = elf_dwarf_decode_sleb128(addr, size);
+		obj->typename = "DW_FORM_sdata";
+		break;
+	case DW_FORM_udata:
+		obj = elf_dwarf_alloc_empty_ElfDwarfAttribute();
+		obj->encoded.const64 = elf_dwarf_decode_uleb128(addr, size);
+		obj->typename = "DW_FORM_udata";
+		break;
+	case DW_FORM_string:
+		obj = elf_dwarf_alloc_empty_ElfDwarfAttribute();
+		obj->encoded.string = (char*)addr;
+		*size = strlen((char*)addr) + 1;
+		obj->typename = "DW_FORM_string";
+		break;
+	case DW_FORM_strp:
+	{
+		uint32 off = elf_get_data32(addr, 0);
+		obj = elf_dwarf_alloc_empty_ElfDwarfAttribute();
+		obj->encoded.string = &debug_str[off];
+		obj->typename = "DW_FORM_strp";
+		*size = 4;
+	}
+		break;
+	case DW_FORM_flag:
+		obj = elf_dwarf_alloc_empty_ElfDwarfAttribute();
+		obj->encoded.flag = *addr;
+		obj->typename = "DW_FORM_flag";
+		*size = 1;
+		break;
+	case DW_FORM_ref_addr:
+		ASSERT(0);
+		break;
+	case DW_FORM_ref1:
+		obj = elf_dwarf_alloc_empty_ElfDwarfAttribute();
+		obj->encoded.ref8 = elf_get_data8(addr, 0) + cu->offset;
+		obj->typename = "DW_FORM_ref1";
+		*size = 1;
+		break;
+	case DW_FORM_ref2:
+		obj = elf_dwarf_alloc_empty_ElfDwarfAttribute();
+		obj->encoded.ref16 = elf_get_data16(addr, 0) + cu->offset;
+		obj->typename = "DW_FORM_ref2";
+		*size = 2;
+		break;
+	case DW_FORM_ref4:
+		obj = elf_dwarf_alloc_empty_ElfDwarfAttribute();
+		obj->encoded.ref32 = elf_get_data32(addr, 0) + cu->offset;
+		obj->typename = "DW_FORM_ref4";
+		*size = 4;
+		break;
+	case DW_FORM_ref8:
+		obj = elf_dwarf_alloc_empty_ElfDwarfAttribute();
+		obj->encoded.ref64 = elf_get_data64(addr, 0) + cu->offset;
+		obj->typename = "DW_FORM_ref8";
+		*size = 8;
+		break;
+	case DW_FORM_ref_udata:
+		ASSERT(0);
+		break;
+	case DW_FORM_indirect:
+		ASSERT(0);
+		break;
+	case DW_FORM_sec_offset:
+		obj = elf_dwarf_alloc_empty_ElfDwarfAttribute();
+		obj->encoded.sec_offset = elf_get_data32(addr, 0);
+		obj->typename = "DW_FORM_sec_offset";
+		*size = 4;
+		break;
+	case DW_FORM_exprloc:
+		obj = elf_dwarf_alloc_empty_ElfDwarfAttribute();
+		obj->encoded.op.len = elf_dwarf_decode_uleb128(addr, size);
+		obj->encoded.op.ops = &addr[*size];
+		obj->typename = "DW_FORM_exprloc";
+		*size += obj->encoded.op.len;
+		break;
+	case DW_FORM_flag_present:
+		obj = elf_dwarf_alloc_empty_ElfDwarfAttribute();
+		obj->encoded.flag = TRUE;
+		obj->typename = "DW_FORM_flag_present";
+		*size = 0;
+		break;
+	case DW_FORM_ref_sig8:
+		ASSERT(0);
+		break;
+	default:
+		ASSERT(0);
+		break;
+	}
+
+	return obj;
+}
+
+ElfPointerArrayType *elf_dwarf_info_get(void)
+{
+	return compilation_unit_headers;
+}
+
+Std_ReturnType elf_dwarf_info_load(uint8 *elf_data)
+{
+	uint8 *section_data;
+	Std_ReturnType err;
+	uint32 section_size;
+	uint32 current_size = 0;
+	uint32	header_size;
+	ElfDwarfCompilationUnitHeaderType	*cu;
+	ElfDwarfAbbrevType *entry;
+	ElfDwarfAbbrevType *top;
+	uint32 size;
+	uint32 entry_size;
+	uint8 *addr;
+	uint32 code;
+	ElfDwarfDieType *die = NULL;
+	int i;
+	uint32 level;
+	ElfDwarfDieType *parent = NULL;
+
+	elf_dwarf_info_ops_init();
+
+	compilation_unit_headers = elf_array_alloc();
+
+	err = elf_section_get(elf_data, SECTION_DWARF_STR_NAME, (uint8**)&debug_str, &section_size);
+	if (err != STD_E_OK) {
+		return err;
+	}
+
+	err = elf_section_get(elf_data, SECTION_DWARF_INFO_NAME, &section_data, &section_size);
+	if (err != STD_E_OK) {
+		return err;
+	}
+	DBG_PRINTF(("**section_size=%u\n", section_size));
+
+	header_size = (4 + 2 + 4 + 1);
+	while (current_size < section_size) {
+		DBG_PRINTF(("**current_size=0x%x ******\n", current_size));
+
+		cu = elf_dwarf_alloc_empty_ElfDwarfCompilationUnitHeader();
+
+		cu->offset = current_size;
+		cu->length = elf_get_data32(&section_data[current_size], 0);
+		cu->version = elf_get_data16(&section_data[current_size], 4);
+		cu->abbrev_offset = elf_get_data32(&section_data[current_size], 6);
+		cu->pointer_size = elf_get_data8(&section_data[current_size], 10);
+
+		top = elf_dwarf_abbrev_get(cu->abbrev_offset);
+		ASSERT(top != NULL);
+		level = 0;
+		parent = NULL;
+
+		entry_size = header_size;
+		while (entry_size < (cu->length + 4)) {
+			code = elf_dwarf_decode_uleb128(&section_data[current_size + entry_size], &size);
+			DBG_PRINTF(("<%x>    entry_code=0x%x\n", current_size + entry_size, code));
+			entry_size += size;
+			if (code == 0x00) {
+				level--;
+				if (die != NULL) {
+					parent = die->parent;
+				}
+				continue;
+			}
+			entry = elf_dwarf_abbrev_get_from_code(top, code);
+			ASSERT(entry != NULL);
+			die = elf_dwarf_alloc_empty_ElfDwarfDie();
+			die->abbrev_code = code;
+			die->abbrev_info = entry;
+			die->offset = current_size + entry_size - size;
+			die->level = level;
+			if (parent != NULL) {
+				die->parent = parent;
+				elf_array_add_entry(parent->children, die);
+			}
+			if (entry->child == TRUE) {
+				die->children = elf_array_alloc();
+				parent = die;
+				level++;
+			}
+
+			DBG_PRINTF(("    code=0x%x tag=0x%x\n", entry->code, entry->tag));
+			for (i = 0; i < entry->attribute_name->current_array_size; i++) {
+				ElfDwarfAttributeType *obj;
+				addr = &section_data[current_size + entry_size];
+				obj = elf_dwarf_info_parse_attr(cu, die, addr, entry->attribute_form->data[i], &size);
+
+				if (obj != NULL) {
+					obj->type = entry->attribute_form->data[i];
+					obj->size = size;
+					obj->offset = current_size + entry_size;
+					elf_array_add_entry(die->attribute, obj);
+				}
+
+				DBG_PRINTF(("<%x>    name=0x%x form=0x%x\n",
+						current_size + entry_size,
+						entry->attribute_name->data[i],
+						entry->attribute_form->data[i]));
+				entry_size += size;
+			}
+
+			elf_array_add_entry(cu->dies, die);
+			DBG_PRINTF(("    entry_size=0x%x\n", entry_size));
+		}
+		ASSERT(entry_size == (cu->length + 4));
+		current_size += entry_size;
+
+		elf_array_add_entry(compilation_unit_headers, cu);
+	}
+	//printAll();
+	return STD_E_OK;
+}
+#ifdef DBG_PRINTF_DEFINED
+
+static void printOps(ElfDwarfAttributeType *obj)
+{
+	int i;
+	printf("size=%u",
+			obj->encoded.op.len);
+	for (i = 0; i < obj->encoded.op.len; i++) {
+		printf(" 0x%x ", obj->encoded.op.ops[i]);
+	}
+	printf("\n");
+	return;
+}
+
+static void printAttr(ElfDwarfAttributeType *obj)
+{
+	switch (obj->type) {
+	case DW_FORM_none:
+		break;
+	case DW_FORM_addr:
+		printf("0x%x\n", obj->encoded.addr);
+		break;
+	case DW_FORM_block:
+		ASSERT(0);
+		break;
+	case DW_FORM_block1:
+	case DW_FORM_block2:
+	case DW_FORM_block4:
+	case DW_FORM_exprloc:
+		printOps(obj);
+		break;
+	case DW_FORM_data1:
+		printf("0x%x\n", obj->encoded.const8);
+		break;
+	case DW_FORM_data2:
+		printf("0x%x\n", obj->encoded.const16);
+		break;
+	case DW_FORM_data4:
+		printf("0x%x\n", obj->encoded.const32);
+		break;
+	case DW_FORM_data8:
+		printf("0x%I64x\n", obj->encoded.const64);
+		break;
+	case DW_FORM_sdata:
+		printf("0x%I64x\n", obj->encoded.scont64);
+		break;
+	case DW_FORM_udata:
+		printf("0x%I64x\n", obj->encoded.const64);
+		break;
+	case DW_FORM_string:
+	case DW_FORM_strp:
+		printf("%s\n", obj->encoded.string);
+		break;
+	case DW_FORM_flag:
+		if (obj->encoded.flag == TRUE) {
+			printf("true\n");
+		}
+		else {
+			printf("false\n");
+		}
+		break;
+	case DW_FORM_ref_addr:
+		ASSERT(0);
+		break;
+	case DW_FORM_ref1:
+		printf("0x%x\n", obj->encoded.ref8);
+		break;
+	case DW_FORM_ref2:
+		printf("0x%x\n", obj->encoded.ref16);
+		break;
+	case DW_FORM_ref4:
+		printf("0x%x\n", obj->encoded.ref32);
+		break;
+	case DW_FORM_ref8:
+		printf("0x%I64x\n", obj->encoded.ref64);
+		break;
+	case DW_FORM_ref_udata:
+		ASSERT(0);
+		break;
+	case DW_FORM_indirect:
+		ASSERT(0);
+		break;
+	case DW_FORM_sec_offset:
+		printf("0x%x\n", obj->encoded.sec_offset);
+		break;
+	case DW_FORM_flag_present:
+		printf("true\n");
+		break;
+	case DW_FORM_ref_sig8:
+		ASSERT(0);
+		break;
+	default:
+		ASSERT(0);
+		break;
+	}
+	return;
+}
+
+static void printDie(ElfDwarfDieType *die)
+{
+	int i;
+	ElfDwarfAttributeType *obj;
+	uint32 parent_offset = 0x0;
+	uint32 children = 0;
+
+	if (die->parent != NULL) {
+		parent_offset = die->parent->offset;
+	}
+	if (die->children != NULL) {
+		children = die->children->current_array_size;
+	}
+
+	printf("<%u><%x>: Abbrev Number: %u (TAG=0x%x) die=0x%x parent=0x%x children=%u\n",
+			die->level, die->offset, die->abbrev_code, die->abbrev_info->tag,
+			die->offset, parent_offset, children);
+	for (i = 0; i < die->attribute->current_array_size; i++) {
+		obj = (ElfDwarfAttributeType *)die->attribute->data[i];
+		printf("	<%x> AT=0x%x %s(0x%x): ",
+				obj->offset, die->abbrev_info->attribute_name->data[i], obj->typename, obj->type);
+		printAttr(obj);
+	}
+	return;
+}
+
+static void printCompilationUnitHeader(ElfDwarfCompilationUnitHeaderType *cu)
+{
+	int i;
+	printf("Compilation Unit @ offset 0x%x\n", cu->offset);
+	printf(" Length:	0x%x\n", cu->length);
+	printf(" Version:	%u\n", cu->version);
+	printf(" Abbrev Offset:	0x%x\n", cu->abbrev_offset);
+	printf(" Pointer Size:	%u\n", cu->pointer_size);
+
+	for (i = 0; i < cu->dies->current_array_size; i++) {
+		printDie(cu->dies->data[i]);
+	}
+	return;
+}
+
+static void printAll(void)
+{
+	int i;
+	for (i = 0; i < compilation_unit_headers->current_array_size; i++) {
+		printCompilationUnitHeader(compilation_unit_headers->data[i]);
+	}
+}
+#endif
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/elf_dwarf_info.h
@@ -0,0 +1,64 @@
+#ifndef _ELF_DWARF_INFO_H_
+#define _ELF_DWARF_INFO_H_
+#include "std_types.h"
+#include "std_errno.h"
+#include "elf_dwarf_util.h"
+#include "elf_dwarf_abbrev.h"
+
+
+typedef struct {
+	DwFormType	type;
+	uint32		offset;
+	uint32		size;
+	char		*typename;
+	union {
+		uint32	addr;
+		uint8	const8;
+		uint16	const16;
+		uint32	const32;
+		uint64	const64;
+		sint64	scont64;
+		uint8	ref8;
+		uint16	ref16;
+		uint32	ref32;
+		uint64	ref64;
+		uint32	sec_offset;
+		bool	flag;
+		char 	*string;
+		struct {
+			uint32 len;
+			uint8 *ops;
+		} op;
+	} encoded;
+} ElfDwarfAttributeType;
+
+struct ElfDwarfDie;
+typedef struct ElfDwarfDie {
+	uint32				offset;
+	uint32				abbrev_code;
+	ElfDwarfAbbrevType	*abbrev_info;
+	ElfPointerArrayType	*attribute;
+	uint32				level;
+	struct ElfDwarfDie	*parent;
+	ElfPointerArrayType	*children;
+} ElfDwarfDieType;
+
+typedef struct {
+	uint32				offset;
+	uint32				length;
+	uint16				version;
+	uint32				abbrev_offset;
+	uint8				pointer_size;
+	ElfPointerArrayType	*dies;
+} ElfDwarfCompilationUnitHeaderType;
+
+extern Std_ReturnType elf_dwarf_info_load(uint8 *elf_data);
+extern ElfDwarfCompilationUnitHeaderType *elf_dwarf_info_alloc_empty_ElfDwarfCompilationUnitHeader(void);
+
+extern ElfPointerArrayType *elf_dwarf_info_get(void);
+
+extern uint32 elf_dwarf_info_get_value(DwFormType form, ElfDwarfAttributeType *obj, uint32 *size);
+
+
+
+#endif /* _ELF_DWARF_INFO_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/elf_dwarf_info_ops.c
@@ -0,0 +1,55 @@
+#include "elf_dwarf_info_ops.h"
+#include "elf_dwarf_util.h"
+#include "assert.h"
+#include <stdio.h>
+
+static ElfDwarfStackType elf_dwaf_info_ops;
+
+void elf_dwarf_info_ops_init(void)
+{
+	elf_dwaf_info_ops.stack_size = 0;
+	elf_dwaf_info_ops.stack = dwarf_uint32_array_alloc();
+	return;
+}
+uint32 elf_dwarf_info_ops_pop(void)
+{
+	if (elf_dwaf_info_ops.stack_size > 0) {
+		elf_dwaf_info_ops.stack_size--;
+		return elf_dwaf_info_ops.stack->data[elf_dwaf_info_ops.stack_size];
+	}
+	return 0;
+}
+void elf_dwarf_info_ops_push(uint32 data)
+{
+	if (elf_dwaf_info_ops.stack->current_array_size > elf_dwaf_info_ops.stack_size) {
+		elf_dwaf_info_ops.stack->data[elf_dwaf_info_ops.stack_size] = data;
+		elf_dwaf_info_ops.stack_size++;
+	}
+	else {
+		dwarf_uint32_array_add_entry(elf_dwaf_info_ops.stack, data);
+		elf_dwaf_info_ops.stack_size++;
+	}
+	return;
+}
+
+void elf_dwarf_info_ops_DW_OP_plus_uconst(uint8 *addr)
+{
+	uint32 size;
+	uint32 data1 = elf_dwarf_info_ops_pop();
+	uint32 data2 = elf_dwarf_decode_uleb128(addr, &size);
+	//printf("data1=%u data2=%u\n", data1, data2);
+	elf_dwarf_info_ops_push(data1 + data2);
+	return;
+}
+void elf_dwarf_info_ops_DW_OP(ElfDwarfInfoOpsType optype, uint8 *data)
+{
+	switch (optype) {
+	case DW_OP_plus_uconst:
+		elf_dwarf_info_ops_DW_OP_plus_uconst(data);
+		break;
+	default:
+		printf("not supported optype = 0x%x\n", optype);
+		ASSERT(0);
+		break;
+	}
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/elf_dwarf_info_ops.h
@@ -0,0 +1,184 @@
+#ifndef _ELF_DWARF_INFO_OPS_H_
+#define _ELF_DWARF_INFO_OPS_H_
+
+#include "elf_dwarf_util.h"
+
+typedef enum {
+	DW_OP_addr                      = 0x03,
+	DW_OP_deref                     = 0x06,
+	DW_OP_const1u                   = 0x08,
+	DW_OP_const1s                   = 0x09,
+	DW_OP_const2u                   = 0x0a,
+	DW_OP_const2s                   = 0x0b,
+	DW_OP_const4u                   = 0x0c,
+	DW_OP_const4s                   = 0x0d,
+	DW_OP_const8u                   = 0x0e,
+	DW_OP_const8s                   = 0x0f,
+	DW_OP_constu                    = 0x10,
+	DW_OP_consts                    = 0x11,
+	DW_OP_dup                       = 0x12,
+	DW_OP_drop                      = 0x13,
+	DW_OP_over                      = 0x14,
+	DW_OP_pick                      = 0x15,
+	DW_OP_swap                      = 0x16,
+	DW_OP_rot                       = 0x17,
+	DW_OP_xderef                    = 0x18,
+	DW_OP_abs                       = 0x19,
+	DW_OP_and                       = 0x1a,
+	DW_OP_div                       = 0x1b,
+	DW_OP_minus                     = 0x1c,
+	DW_OP_mod                       = 0x1d,
+	DW_OP_mul                       = 0x1e,
+	DW_OP_neg                       = 0x1f,
+	DW_OP_not                       = 0x20,
+	DW_OP_or                        = 0x21,
+	DW_OP_plus                      = 0x22,
+	DW_OP_plus_uconst               = 0x23,
+	DW_OP_shl                       = 0x24,
+	DW_OP_shr                       = 0x25,
+	DW_OP_shra                      = 0x26,
+	DW_OP_xor                       = 0x27,
+	DW_OP_bra                       = 0x28,
+	DW_OP_eq                        = 0x29,
+	DW_OP_ge                        = 0x2a,
+	DW_OP_gt                        = 0x2b,
+	DW_OP_le                        = 0x2c,
+	DW_OP_lt                        = 0x2d,
+	DW_OP_ne                        = 0x2e,
+	DW_OP_skip                      = 0x2f,
+	DW_OP_lit0                      = 0x30,
+	DW_OP_lit1                      = 0x31,
+	DW_OP_lit2                      = 0x32,
+	DW_OP_lit3                      = 0x33,
+	DW_OP_lit4                      = 0x34,
+	DW_OP_lit5                      = 0x35,
+	DW_OP_lit6                      = 0x36,
+	DW_OP_lit7                      = 0x37,
+	DW_OP_lit8                      = 0x38,
+	DW_OP_lit9                      = 0x39,
+	DW_OP_lit10                     = 0x3a,
+	DW_OP_lit11                     = 0x3b,
+	DW_OP_lit12                     = 0x3c,
+	DW_OP_lit13                     = 0x3d,
+	DW_OP_lit14                     = 0x3e,
+	DW_OP_lit15                     = 0x3f,
+	DW_OP_lit16                     = 0x40,
+	DW_OP_lit17                     = 0x41,
+	DW_OP_lit18                     = 0x42,
+	DW_OP_lit19                     = 0x43,
+	DW_OP_lit20                     = 0x44,
+	DW_OP_lit21                     = 0x45,
+	DW_OP_lit22                     = 0x46,
+	DW_OP_lit23                     = 0x47,
+	DW_OP_lit24                     = 0x48,
+	DW_OP_lit25                     = 0x49,
+	DW_OP_lit26                     = 0x4a,
+	DW_OP_lit27                     = 0x4b,
+	DW_OP_lit28                     = 0x4c,
+	DW_OP_lit29                     = 0x4d,
+	DW_OP_lit30                     = 0x4e,
+	DW_OP_lit31                     = 0x4f,
+	DW_OP_reg0                      = 0x50,
+	DW_OP_reg1                      = 0x51,
+	DW_OP_reg2                      = 0x52,
+	DW_OP_reg3                      = 0x53,
+	DW_OP_reg4                      = 0x54,
+	DW_OP_reg5                      = 0x55,
+	DW_OP_reg6                      = 0x56,
+	DW_OP_reg7                      = 0x57,
+	DW_OP_reg8                      = 0x58,
+	DW_OP_reg9                      = 0x59,
+	DW_OP_reg10                     = 0x5a,
+	DW_OP_reg11                     = 0x5b,
+	DW_OP_reg12                     = 0x5c,
+	DW_OP_reg13                     = 0x5d,
+	DW_OP_reg14                     = 0x5e,
+	DW_OP_reg15                     = 0x5f,
+	DW_OP_reg16                     = 0x60,
+	DW_OP_reg17                     = 0x61,
+	DW_OP_reg18                     = 0x62,
+	DW_OP_reg19                     = 0x63,
+	DW_OP_reg20                     = 0x64,
+	DW_OP_reg21                     = 0x65,
+	DW_OP_reg22                     = 0x66,
+	DW_OP_reg23                     = 0x67,
+	DW_OP_reg24                     = 0x68,
+	DW_OP_reg25                     = 0x69,
+	DW_OP_reg26                     = 0x6a,
+	DW_OP_reg27                     = 0x6b,
+	DW_OP_reg28                     = 0x6c,
+	DW_OP_reg29                     = 0x6d,
+	DW_OP_reg30                     = 0x6e,
+	DW_OP_reg31                     = 0x6f,
+	DW_OP_breg0                     = 0x70,
+	DW_OP_breg1                     = 0x71,
+	DW_OP_breg2                     = 0x72,
+	DW_OP_breg3                     = 0x73,
+	DW_OP_breg4                     = 0x74,
+	DW_OP_breg5                     = 0x75,
+	DW_OP_breg6                     = 0x76,
+	DW_OP_breg7                     = 0x77,
+	DW_OP_breg8                     = 0x78,
+	DW_OP_breg9                     = 0x79,
+	DW_OP_breg10                    = 0x7a,
+	DW_OP_breg11                    = 0x7b,
+	DW_OP_breg12                    = 0x7c,
+	DW_OP_breg13                    = 0x7d,
+	DW_OP_breg14                    = 0x7e,
+	DW_OP_breg15                    = 0x7f,
+	DW_OP_breg16                    = 0x80,
+	DW_OP_breg17                    = 0x81,
+	DW_OP_breg18                    = 0x82,
+	DW_OP_breg19                    = 0x83,
+	DW_OP_breg20                    = 0x84,
+	DW_OP_breg21                    = 0x85,
+	DW_OP_breg22                    = 0x86,
+	DW_OP_breg23                    = 0x87,
+	DW_OP_breg24                    = 0x88,
+	DW_OP_breg25                    = 0x89,
+	DW_OP_breg26                    = 0x8a,
+	DW_OP_breg27                    = 0x8b,
+	DW_OP_breg28                    = 0x8c,
+	DW_OP_breg29                    = 0x8d,
+	DW_OP_breg30                    = 0x8e,
+	DW_OP_breg31                    = 0x8f,
+	DW_OP_regx                      = 0x90,
+	DW_OP_fbreg                     = 0x91,
+	DW_OP_bregx                     = 0x92,
+	DW_OP_piece                     = 0x93,
+	DW_OP_deref_size                = 0x94,
+	DW_OP_xderef_size               = 0x95,
+	DW_OP_nop                       = 0x96,
+	DW_OP_push_object_address       = 0x97,
+	DW_OP_call2                     = 0x98,
+	DW_OP_call4                     = 0x99,
+	DW_OP_call_ref                  = 0x9a,
+	DW_OP_form_tls_address          = 0x9b,
+	DW_OP_call_frame_cfa            = 0x9c,
+	DW_OP_bit_piece                 = 0x9d,
+	DW_OP_implicit_value            = 0x9e,
+	DW_OP_stack_value               = 0x9f,
+	DW_OP_implicit_pointer          = 0xa0,
+	DW_OP_addrx                     = 0xa1,
+	DW_OP_constx                    = 0xa2,
+	DW_OP_entry_value               = 0xa3,
+	DW_OP_const_type                = 0xa4,
+	DW_OP_regval_type               = 0xa5,
+	DW_OP_deref_type                = 0xa6,
+	DW_OP_xderef_type               = 0xa7,
+	DW_OP_convert                   = 0xa8,
+	DW_OP_reinterpret               = 0xa9,
+} ElfDwarfInfoOpsType;
+
+typedef struct {
+	uint32				stack_size;
+	DwarfUint32ArrayType *stack;
+} ElfDwarfStackType;
+
+extern void elf_dwarf_info_ops_init(void);
+extern uint32 elf_dwarf_info_ops_pop(void);
+extern void elf_dwarf_info_ops_push(uint32 data);
+extern void elf_dwarf_info_ops_DW_OP(ElfDwarfInfoOpsType optype, uint8 *data);
+extern void elf_dwarf_info_ops_DW_OP_plus_uconst(uint8 *data);
+
+#endif /* _ELF_DWARF_INFO_OPS_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/elf_dwarf_line.c
@@ -0,0 +1,358 @@
+#include "elf_dwarf_line.h"
+#include "elf_section.h"
+#include "elf_dwarf_util.h"
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#if 0
+#define DBG_PRINTF(arg)	printf arg
+#else
+#define DBG_PRINTF(arg)
+#endif
+
+static void parse_opcode(uint8 *opcode, ElfDwarfLineParsedOpCodeType *op);
+static ElfDwarfLineType *elf_dwarf_line = NULL;
+
+ElfDwarfLineType *elf_dwarf_line_get_ElfDwarfLine(void)
+{
+	return elf_dwarf_line;
+}
+/*
+ * 
+ * address 0
+ * op_index 0
+ * file 1
+ * line 1
+ * column 0
+ * is_stmt determined by default_is_stmt in the line number program header
+ * basic_block “false”
+ * end_sequence “false”
+ * prologue_end “false”
+ * epilogue_begin “false”
+ * isa 0
+ * discriminator 0
+ */
+void elf_dwarf_line_init_ElfDwarfLineStateMachineRegister(ElfDwarfLineStateMachineRegisterType *machine, ElfDwarfLineEntryHeaderType *hdr)
+{
+	elf_dwarf_line_machine_init(machine);
+	machine->is_stmt = hdr->default_is_stmt;
+	return;
+}
+
+
+static uint32 parse_entry_header(ElfDwarfLineEntryHeaderType *header, uint8 *section_data);
+
+static uint32 parse_entry_header(ElfDwarfLineEntryHeaderType *header, uint8 *section_data)
+{
+	int i;
+	uint32 off = 0;
+
+	header->total_length = elf_get_data32(section_data, off);
+	off += 4;
+	header->version = elf_get_data16(section_data, off);
+	off += 2;
+	header->prologue_length = elf_get_data32(section_data, off);
+	off += 4;
+	header->minimum_instruction_length = elf_get_data8(section_data, off);
+	off += 1;
+	if (header->version == ELF_DWARF_VERSION_4) {
+		/* maximum_operations_per_instruction (ubyte) */
+		header->maximum_operations_per_instruction = elf_get_data8(section_data, off);
+		off += 1;
+	}
+	header->default_is_stmt = elf_get_data8(section_data, off);
+	off += 1;
+	header->line_base = elf_get_data8(section_data, off);
+	off += 1;
+	header->line_range = elf_get_data8(section_data, off);
+	off += 1;
+	header->opcode_base = elf_get_data8(section_data, off);
+	off += 1;
+
+	DBG_PRINTF(("total_length=%u\n", header->total_length));
+	DBG_PRINTF(("version=%u\n", header->version));
+	DBG_PRINTF(("prologue_length=%u\n", header->prologue_length));
+	DBG_PRINTF(("minimum_instruction_length=%u\n", header->minimum_instruction_length));
+	DBG_PRINTF(("maximum_operations_per_instruction=%u\n", header->maximum_operations_per_instruction));
+	DBG_PRINTF(("default_is_stmt=%u\n", header->default_is_stmt));
+	DBG_PRINTF(("line_base=%d\n", header->line_base));
+	DBG_PRINTF(("line_range=%u\n", header->line_range));
+	DBG_PRINTF(("opcode_base=%u\n", header->opcode_base));
+
+	for (i = 0; i < header->opcode_base - 1; i++) {
+		uint8 standard_opcode_length = elf_get_data8(section_data, off);
+		header->standard_opcode_lengths[i] = standard_opcode_length;
+		DBG_PRINTF(("opcode_length[%d]=%u\n", i + 1, standard_opcode_length));
+		off++;
+	}
+
+	/*
+	 * The Directory Table:
+	 */
+	int len;
+	char *dir;
+	do {
+		dir = (char*)&section_data[off];
+		len = strlen(dir);
+		off += len + 1;
+		if (len > 0) {
+			DBG_PRINTF(("dir=%s, len=%u\n", dir, len));
+			elf_array_add_entry(header->include_directories, dir);
+		}
+	} while (len > 0);
+
+	/*
+	 *  The File Name Table:
+	 */
+	char *filename;
+	uint32 size;
+	do {
+		filename = (char*)&section_data[off];
+		len = strlen(filename);
+		off += len + 1;
+
+		if (len > 0) {
+			ElfDwarfLineEntryHeaderFileType *obj = elf_obj_alloc(sizeof(ElfDwarfLineEntryHeaderFileType));
+			obj->filename = filename;
+			DBG_PRINTF(("filename=%s, len=%u ", filename, len));
+
+			obj->dir = elf_dwarf_decode_uleb128(&section_data[off], &size);
+			DBG_PRINTF(("Dir=%u ", obj->dir));
+			off += size;
+
+			obj->time = elf_dwarf_decode_uleb128(&section_data[off], &size);
+			DBG_PRINTF(("Time=%u ", obj->time));
+			off += size;
+
+			obj->size = elf_dwarf_decode_uleb128(&section_data[off], &size);
+			DBG_PRINTF(("Size=%u\n", obj->size));
+			off += size;
+
+			elf_array_add_entry(header->file_names, obj);
+		}
+	} while (len > 0);
+
+	return off;
+}
+
+Std_ReturnType elf_dwarf_line_load(uint8 *elf_data)
+{
+	uint8 *section_data;
+	Std_ReturnType err;
+	uint32 section_size;
+	uint32 current_size = 0;
+	uint32 hdr_size;
+
+	err = elf_section_get_dwarf_line(elf_data, &section_data, &section_size);
+	if (err != STD_E_OK) {
+		return err;
+	}
+	DBG_PRINTF(("**section_size=%u\n", section_size));
+
+	elf_dwarf_line = elf_dwarf_line_alloc_empty_ElfDwarfLine();
+	while (current_size < section_size) {
+		DBG_PRINTF(("**current_size=0x%x******\n", current_size));
+		/*
+		 * header
+		 */
+		ElfDwarfLineEntryType *entry = elf_dwarf_line_alloc_empty_ElfDwarfLineEntry();
+		entry->header = elf_dwarf_line_alloc_empty_ElfDwarfLineEntryHeader();
+		hdr_size = parse_entry_header(entry->header, &section_data[current_size]);
+
+		/*
+		 * 6.2.5 The Statement Program
+		 */
+		uint32 off = hdr_size;
+		while (off < (entry->header->total_length + 4)) {
+			ElfDwarfLineParsedOpCodeType *op = elf_dwarf_line_alloc_empty_ElfDwarfLineParsedOpCode();
+			op->hdr = entry->header;
+			DBG_PRINTF(("opcode[0x%x]=%u ", current_size + off, section_data[current_size + off] - op->hdr->opcode_base));
+			parse_opcode(&section_data[current_size + off], op);
+			off += op->size;
+			elf_array_add_entry(entry->ops, op);
+		}
+		current_size += off;
+		elf_array_add_entry(elf_dwarf_line->entries, entry);
+	}
+	DBG_PRINTF(("END\n"));
+	return STD_E_OK;
+}
+static void set_ExtDefineFile(uint8 *opcode, ElfDwarfLineParsedOpCodeType *op)
+{
+	int len = strlen((char*)opcode);
+	int off = len + 1;
+	uint32 size;
+
+	/*
+	 * The first is a null terminated string containing a source file name
+	 */
+	op->args.extDefineFile.file = (char*)opcode;
+	/*
+	 * The second is an unsigned LEB128 number representing the directory
+	 * index of the directory in which the file was found.
+	 */
+	op->args.extDefineFile.dir = elf_dwarf_decode_uleb128(&opcode[off], &size);
+	off += size;
+	/*
+	 * The third is an unsigned LEB128 number representing the time
+	 * of last modification of the file.
+	 */
+	op->args.extDefineFile.time = elf_dwarf_decode_uleb128(&opcode[off], &size);
+	off += size;
+	/*
+	 * The fourth is an unsigned LEB128 number representing the length
+	 * in bytes of the file.
+	 */
+	op->args.extDefineFile.size = elf_dwarf_decode_uleb128(&opcode[off], &size);
+
+	return;
+}
+static void set_ExtendedOp(uint8 *opcode, ElfDwarfLineParsedOpCodeType *op)
+{
+	uint32 size;
+	switch (opcode[0]) {
+	case DW_LNE_end_sequence:
+		op->subtype = DW_LNE_end_sequence;
+		DBG_PRINTF(("DW_LNE_end_sequence\n"));
+		break;
+	case DW_LNE_set_address:
+		op->subtype = DW_LNE_set_address;
+		op->args.extSetAddress.addr = elf_get_data32(&opcode[1], 0);
+		DBG_PRINTF(("DW_LNE_set_address:addr=0x%x\n", op->args.extSetAddress.addr));
+		break;
+	case DW_LINE_define_file:
+		op->subtype = DW_LINE_define_file;
+		set_ExtDefineFile(&opcode[1], op);
+		DBG_PRINTF(("DW_LINE_define_file\n"));
+		break;
+	case DW_LNE_set_discriminator:
+		op->subtype = DW_LNE_set_discriminator;
+		op->args.extSetDescriminator.discriminator = elf_dwarf_decode_uleb128(&opcode[1], &size);
+		DBG_PRINTF(("DW_LNE_set_discriminator\n"));
+		break;
+	default:
+		op->subtype = DW_LINE_unknown;
+		break;
+	}
+	return;
+}
+static void set_StandardOp(uint8 *opcode, ElfDwarfLineParsedOpCodeType *op)
+{
+	uint32 size = 0;
+
+	switch (op->subtype) {
+	case DW_LNS_copy:
+		DBG_PRINTF(("DW_LNS_copy\n"));
+		break;
+	case DW_LNS_advance_pc:
+		op->args.stdAdvancePc.advance_size = elf_dwarf_decode_uleb128(opcode, &size) * ((uint32)op->hdr->minimum_instruction_length);
+		DBG_PRINTF(("DW_LNS_advance_pc:advance_size=0x%x\n", op->args.stdAdvancePc.advance_size));
+		break;
+	case DW_LNS_advance_line:
+		op->args.stdAdvanceLine.advance_line = elf_dwarf_decode_sleb128(opcode, &size);
+		DBG_PRINTF(("DW_LNS_advance_line:advance_line=%d\n", op->args.stdAdvanceLine.advance_line));
+		break;
+	case DW_LNS_set_file:
+		op->args.stdSetFile.file = elf_dwarf_decode_uleb128(opcode, &size);
+		DBG_PRINTF(("DW_LNS_set_file:file=%d\n", op->args.stdSetFile.file));
+		break;
+	case DW_LNS_set_column:
+		op->args.stdSetColumn.column = elf_dwarf_decode_uleb128(opcode, &size);
+		DBG_PRINTF(("DW_LNS_set_column:ficolumnle=%d\n", op->args.stdSetColumn.column));
+		break;
+	case DW_LNS_negate_stmt:
+		DBG_PRINTF(("DW_LNS_negate_stmt\n"));
+		break;
+	case DW_LNS_set_basic_block:
+		DBG_PRINTF(("DW_LNS_set_basic_block\n"));
+		break;
+	case DW_LNS_const_add_pc:
+		{
+			uint32 adjusted_opcode = (255 - op->hdr->opcode_base);
+			op->args.stdConstAddPc.const_add_pc = (adjusted_opcode / op->hdr->line_range) * op->hdr->minimum_instruction_length;
+			size = 0;
+		}
+		DBG_PRINTF(("DW_LNS_const_add_pc\n"));
+		break;
+	case DW_LNS_fixed_advance_pc:
+		op->args.stdFixedAdvancePc.fixed_advance_pc = elf_get_data16(opcode, 0) * op->hdr->minimum_instruction_length;
+		DBG_PRINTF(("DW_LNS_fixed_advance_pc:fixed_advance_pc=%d\n", op->args.stdFixedAdvancePc.fixed_advance_pc));
+		size = 2;
+		break;
+	default:
+		break;
+	}
+	op->size = size + 1;
+	return;
+}
+static void set_SpecialOp(uint8 *opcode, ElfDwarfLineParsedOpCodeType *op)
+{
+	sint32 adjusted_opcode;
+
+	adjusted_opcode = ((opcode[0]) - (op->hdr->opcode_base));
+	//printf("adjusted_opcode=%d ", adjusted_opcode);
+
+	op->size = 1;
+	op->args.special.advance_addr = ((uint32)(adjusted_opcode / op->hdr->line_range)) * ((uint32)op->hdr->minimum_instruction_length);
+	op->args.special.advance_line = op->hdr->line_base + (adjusted_opcode % op->hdr->line_range);
+	DBG_PRINTF(("set_SpecialOp:advance_addr=%d ", op->args.special.advance_addr));
+	DBG_PRINTF(("advance_line=%d\n", op->args.special.advance_line));
+	return;
+}
+
+static void parse_opcode(uint8 *opcode, ElfDwarfLineParsedOpCodeType *op)
+{
+	if (opcode[0] == OPTYPE_EXTENDED) {
+		op->type = OPTYPE_EXTENDED;
+		op->size = opcode[1] + 2;
+		set_ExtendedOp(&opcode[2], op);
+	}
+	else if ((opcode[0] >= DW_LNS_copy) && (opcode[0] <= DW_LNS_fixed_advance_pc)) {
+		op->type = OPTYPE_STANDARD;
+		op->subtype = opcode[0];
+		set_StandardOp(&opcode[1], op);
+	}
+	else {
+		op->type = OPTYPE_SPECIAL;
+		set_SpecialOp(&opcode[0], op);
+	}
+}
+
+
+ElfDwarfLineType *elf_dwarf_line_alloc_empty_ElfDwarfLine(void)
+{
+	ElfDwarfLineType *obj;
+	obj = elf_obj_alloc(sizeof(ElfDwarfLineType));
+	obj->entries = elf_array_alloc();
+	return obj;
+}
+
+ElfDwarfLineEntryHeaderType *elf_dwarf_line_alloc_empty_ElfDwarfLineEntryHeader(void)
+{
+	ElfDwarfLineEntryHeaderType *obj = elf_obj_alloc(sizeof(ElfDwarfLineEntryHeaderType));
+	obj->file_names = elf_array_alloc();
+	obj->include_directories = elf_array_alloc();
+	return obj;
+}
+
+ElfDwarfLineParsedOpCodeType *elf_dwarf_line_alloc_empty_ElfDwarfLineParsedOpCode(void)
+{
+	ElfDwarfLineParsedOpCodeType *obj;
+
+	obj = elf_obj_alloc(sizeof(ElfDwarfLineParsedOpCodeType));
+
+	return obj;
+}
+
+ElfDwarfLineEntryType *elf_dwarf_line_alloc_empty_ElfDwarfLineEntry(void)
+{
+	ElfDwarfLineEntryType *obj;
+
+	obj = elf_obj_alloc(sizeof(ElfDwarfLineEntryType));
+	obj->header = elf_dwarf_line_alloc_empty_ElfDwarfLineEntryHeader();
+	obj->ops = elf_array_alloc();
+
+	return obj;
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/elf_dwarf_line.h
@@ -0,0 +1,232 @@
+#ifndef _ELF_DWARF_LINE_H_
+#define _ELF_DWARF_LINE_H_
+
+#include "loader/elf.h"
+#include "elf_dwarf_util.h"
+#include "std_errno.h"
+
+#define STD_OP_CODE_MAX	256
+typedef struct {
+	char		*filename;
+	uint32		dir;
+	uint32		time;
+	uint32		size;
+} ElfDwarfLineEntryHeaderFileType;
+
+typedef struct {
+	uint32 					total_length;
+	uint16 					version;
+	uint32 					prologue_length;
+	uint8  					minimum_instruction_length;
+	uint8					maximum_operations_per_instruction;
+	uint8  					default_is_stmt;
+	sint8  					line_base;
+	uint8  					line_range;
+	uint8  					opcode_base;
+	uint8  					standard_opcode_lengths[STD_OP_CODE_MAX];
+	ElfPointerArrayType		*include_directories;
+	ElfPointerArrayType		*file_names;
+} ElfDwarfLineEntryHeaderType;
+
+
+extern Std_ReturnType elf_dwarf_line_load(uint8 *elf_data);
+
+typedef enum {
+	OPTYPE_EXTENDED	= 0,
+	OPTYPE_STANDARD,
+	OPTYPE_SPECIAL,
+} ElfDwarfLineOpType;
+
+typedef struct {
+	uint32 advance_addr;
+	sint32 advance_line;
+} DwLineSpecialType;
+
+
+typedef enum {
+	DW_LNE_end_sequence = 1,
+	DW_LNE_set_address,
+	DW_LINE_define_file,
+	DW_LNE_set_discriminator, /* dwarf ver.4 */
+	DW_LNE_lo_user = 0x80,
+	DW_LNE_hi_user = 0xff,
+	DW_LINE_unknown,
+} ElfDwarfLineOpExtendedType;
+
+typedef struct {
+	uint32 addr;
+} DwLineSetAddressType;
+typedef struct {
+	char 	*file;
+	uint32	dir;
+	uint32	time;
+	uint32	size;
+} DwLineDefineFileType;
+typedef struct {
+	uint32	discriminator;
+} DwLineSetDiscriminatorType;
+typedef enum {
+	DW_LNS_copy = 1,
+	DW_LNS_advance_pc,
+	DW_LNS_advance_line,
+	DW_LNS_set_file,
+	DW_LNS_set_column,
+	DW_LNS_negate_stmt,
+	DW_LNS_set_basic_block,
+	DW_LNS_const_add_pc,
+	DW_LNS_fixed_advance_pc,
+} ElfDwarfLineOpStandardType;
+
+typedef struct {
+	uint32 advance_size;
+} DwLnsAdvancePcType;
+
+typedef struct {
+	sint32 advance_line;
+} DwLnsAdvanceLineType;
+
+typedef struct {
+	uint32 file;
+} DwLnsSetFileType;
+
+typedef struct {
+	uint32 column;
+} DwLnsSetColumnType;
+
+typedef struct {
+	uint32 fixed_advance_pc;
+} DwLnsFixedAdvancePcType;
+typedef struct {
+	uint32 const_add_pc;
+} DwLnsConsdAddPcType;
+
+typedef struct {
+	ElfDwarfLineEntryHeaderType		*hdr;
+	uint32 							size;
+	ElfDwarfLineOpType				type;
+	int								subtype;
+	union {
+		DwLineSetAddressType		extSetAddress;
+		DwLineDefineFileType		extDefineFile;
+		DwLineSetDiscriminatorType	extSetDescriminator;
+		DwLnsAdvancePcType			stdAdvancePc;
+		DwLnsAdvanceLineType		stdAdvanceLine;
+		DwLnsSetFileType			stdSetFile;
+		DwLnsSetColumnType			stdSetColumn;
+		DwLnsFixedAdvancePcType		stdFixedAdvancePc;
+		DwLnsConsdAddPcType			stdConstAddPc;
+		DwLineSpecialType			special;
+	} args;
+} ElfDwarfLineParsedOpCodeType;
+
+
+typedef struct {
+	ElfDwarfLineEntryHeaderType		*header;
+	ElfPointerArrayType				*ops;
+} ElfDwarfLineEntryType;
+
+
+typedef struct {
+	ElfPointerArrayType				*entries;
+} ElfDwarfLineType;
+
+extern ElfDwarfLineType *elf_dwarf_line_alloc_empty_ElfDwarfLine(void);
+extern ElfDwarfLineEntryHeaderType *elf_dwarf_line_alloc_empty_ElfDwarfLineEntryHeader(void);
+extern ElfDwarfLineEntryType *elf_dwarf_line_alloc_empty_ElfDwarfLineEntry(void);
+extern ElfDwarfLineParsedOpCodeType *elf_dwarf_line_alloc_empty_ElfDwarfLineParsedOpCode(void);
+
+typedef struct {
+	/*
+	 * The program-counter value corresponding to a machine instruction
+	 * generated by the compiler.
+	 */
+	uint32	address;
+
+	/*
+	 * An unsigned integer representing the index of an operation within a VLIW
+	 * instruction. The index of the first operation is 0. For non-VLIW
+	 * architectures, this register will always be 0.
+	 * The address and op_index registers, taken together, form an operation
+	 * pointer that can reference any individual operation with the instruction
+	 * stream.
+	 */
+	uint32 op_index;
+	/*
+	 * An unsigned integer indicating the identity of the source file
+	 * corresponding to a machine instruction.
+	 */
+	uint32	file;
+	/*
+	 * An unsigned integer indicating a source line number. Lines are
+	 * numbered beginning at 1. The compiler may emit the value 0 in cases
+	 * where an instruction cannot be attributed to any source line.
+	 */
+	uint32	line;
+	/*
+	 * An unsigned integer indicating a column number within a source line.
+	 * Columns are numbered beginning at 1. The value 0 is reserved to
+	 * indicate that a statement begins at the ‘‘left edge’’ of the line.
+	 */
+	uint32	column;
+	/*
+	 * A boolean indicating that the current instruction is the beginning of a statement.
+	 */
+	bool	is_stmt;
+	/*
+	 * A boolean indicating that the current instruction is the beginning of a
+	 * basic block.
+	 */
+	bool	basic_block;
+	/*
+	 * A boolean indicating that the current address is that of the first byte after
+	 * the end of a sequence of target machine instructions.
+	 */
+	bool	end_sequence;
+	/*
+	 * A boolean indicating that the current address is one (of possibly many)
+	 * where execution should be suspended for an entry breakpoint of a
+	 * function.
+	 */
+	bool prologue_end;
+	/*
+	 * A boolean indicating that the current address is one (of possibly many)
+	 * where execution should be suspended for an exit breakpoint of a function.
+	 */
+	bool epilogue_begin;
+	/*
+	 * An unsigned integer whose value encodes the applicable instruction set
+	 * architecture for the current instruction.
+	 * The encoding of instruction sets should be shared by all users of a given
+	 * architecture. It is recommended that this encoding be defined by the ABI
+	 * authoring committee for each architecture.
+	 */
+	uint32 isa;
+	/*
+	 * An unsigned integer identifying the block to which the current instruction
+	 * belongs. Discriminator values are assigned arbitrarily by the DWARF
+	 * producer and serve to distinguish among multiple blocks that may all be
+	 * associated with the same source file, line, and column. Where only one
+	 * block exists for a given source position, the discriminator value should be
+	 * zero.
+	 */
+	uint32 discriminator;
+} ElfDwarfLineStateMachineRegisterType;
+extern void elf_dwarf_line_init_ElfDwarfLineStateMachineRegister(ElfDwarfLineStateMachineRegisterType *machine, ElfDwarfLineEntryHeaderType *hdr);
+extern ElfDwarfLineType *elf_dwarf_line_get_ElfDwarfLine(void);
+
+static inline void elf_dwarf_line_machine_init(ElfDwarfLineStateMachineRegisterType *machine)
+{
+	machine->address = 0;
+	machine->op_index = 0;
+	machine->file = 1;
+	machine->line = 1;
+	machine->column = 0;
+	machine->basic_block = FALSE;
+	machine->end_sequence = FALSE;
+	machine->prologue_end = FALSE;
+	machine->epilogue_begin = FALSE;
+	machine->isa = 0;
+	machine->discriminator = 0;
+}
+
+#endif /* _ELF_DWARF_LINE_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/elf_dwarf_loc.c
@@ -0,0 +1,179 @@
+#include "elf_dwarf_loc.h"
+#include "elf_section.h"
+#include "elf_dwarf_info_ops.h"
+#include "cpu.h"
+#include "assert.h"
+#include <string.h>
+
+#if 0
+#define DBG_PRINTF(arg)	printf arg
+#else
+#define DBG_PRINTF(arg)
+#endif
+static ElfDwarfLocEntryType *elf_dwarf_loc_alloc_ElfDwarfLocEntry(uint8 *raw_data, uint32 off);
+
+static ElfPointerArrayType *elf_dwarf_loc_lists;
+
+Std_ReturnType elf_dwarf_loc_load(uint8 *elf_data)
+{
+	uint8 *section_data;
+	uint32 section_size;
+	Std_ReturnType err;
+	uint32 current_size = 0;
+	uint32 off = 0;
+	ElfDwarfLocEntryType *entry;
+	ElfDwarfLocEntryType *prev_entry;
+
+	err = elf_section_get(elf_data, SECTION_DWARF_LOC_NAME, &section_data, &section_size);
+	if (err != STD_E_OK) {
+		return err;
+	}
+	DBG_PRINTF(("**loc section_size=%u\n", section_size));
+	elf_dwarf_loc_lists = elf_array_alloc();
+	ASSERT(elf_dwarf_loc_lists != NULL);
+
+	prev_entry = NULL;
+	while (current_size < section_size) {
+		DBG_PRINTF(("**loc current_size=0x%x******\n", current_size));
+
+		entry = elf_dwarf_loc_alloc_ElfDwarfLocEntry(&section_data[off], off);
+		elf_array_add_entry(elf_dwarf_loc_lists, entry);
+		if (prev_entry != NULL) {
+			if ((prev_entry->relativeAddress0 == 0) && (prev_entry->relativeAddress1 == 0)) {
+				prev_entry->next = NULL;
+			}
+			else {
+				prev_entry->next = entry;
+			}
+		}
+
+		off += entry->entrySize;
+		current_size += entry->entrySize;
+
+		prev_entry = entry;
+	}
+	DBG_PRINTF(("END\n"));
+	return STD_E_OK;
+}
+
+static ElfDwarfLocEntryType *elf_dwarf_loc_alloc_ElfDwarfLocEntry(uint8 *raw_data, uint32 off)
+{
+	int i;
+	ElfDwarfLocEntryType *obj;
+
+	obj = elf_obj_alloc(sizeof(ElfDwarfLocEntryType));
+	obj->entryOffset = off;
+	obj->relativeAddress0 = *(uint32*)&raw_data[0];
+	obj->relativeAddress1 = *(uint32*)&raw_data[4];
+
+	DBG_PRINTF(("off=0x%x\n", obj->entryOffset));
+	DBG_PRINTF(("addr1=0x%x\n", obj->relativeAddress0));
+	DBG_PRINTF(("addr2=0x%x\n", obj->relativeAddress1));
+	DBG_PRINTF(("range=0x%x\n", obj->relativeAddress1 - obj->relativeAddress0));
+	if ((obj->relativeAddress0 == 0) && (obj->relativeAddress1 == 0)) {
+		/*
+		 * End of list
+		 */
+		obj->block_length = 0;
+		obj->blocks = NULL;
+		obj->entrySize = 8;
+		return obj;
+	}
+	obj->block_length = *(uint16*)&raw_data[8];
+	obj->blocks = (uint8*)&raw_data[10];
+	DBG_PRINTF(("length=%d\n", obj->block_length));
+	for (i = 0; i < obj->block_length; i++) {
+		DBG_PRINTF((" block[%d]=0x%x\n", i, obj->blocks[i]));
+	}
+	obj->entrySize = 10 + obj->block_length;
+
+	return obj;
+}
+static ElfDwarfLocEntryType *search_location_entry(uint32 off)
+{
+	int i;
+
+	for (i = 0; elf_dwarf_loc_lists->current_array_size; i++) {
+		ElfDwarfLocEntryType *entry = (ElfDwarfLocEntryType*)(elf_dwarf_loc_lists->data[i]);
+		if (entry->entryOffset == off) {
+			return entry;
+		}
+	}
+	return NULL;
+
+}
+
+static void elf_dwarf_loc_compile_fbreg(DwarfDataSubprogramType *subprogram, DwarfLocalVariableType *localVariable, uint32 pc, uint32 funcaddr, uint32 *vaddr)
+{
+	uint32 size;
+	ElfDwarfLocEntryType *loc;
+	int value1;
+	int value2;
+	int regInx;
+	int regData;
+	uint32 off = funcaddr;
+
+	loc = search_location_entry(subprogram->frame_loc_offset);
+	ASSERT(loc != NULL);
+
+	value1 = elf_dwarf_decode_sleb128(&localVariable->DW_AT_location->encoded.op.ops[1], &size);
+	printf("value1=%d\n", value1);
+	printf("pc=0x%x funcaddr=0x%x\n", pc, funcaddr);
+
+	/*
+	 * search loc on pc
+	 */
+	while (loc != NULL) {
+		uint32 range = (loc->relativeAddress1 - loc->relativeAddress0);
+		uint32 saddr = off;
+		uint32 eaddr = off + range;
+		//printf("relativeAddress0=0x%x relativeAddress1=0x%x\n", loc->relativeAddress0, loc->relativeAddress1);
+		//printf("off=0x%x range=0x%x saddr=0x%x eaddr=0x%x\n", off, range, saddr, eaddr);
+		if ((pc >= saddr) && (pc < eaddr)) {
+			break;
+		}
+		off += range;
+		loc = loc->next;
+	}
+	ASSERT(loc != NULL);
+
+	if ((loc->blocks[0] >= DW_OP_breg0) && (loc->blocks[0] <= DW_OP_breg31)) {
+		value2 = elf_dwarf_decode_sleb128(&loc->blocks[1], &size);
+		regInx = loc->blocks[0] - DW_OP_breg0;
+		regData = (int)cpu_get_current_core_register(regInx);
+		regData = regData + value1 + value2;
+		*vaddr = regData;
+		printf("vaddr=0x%x\n", regData);
+	}
+	else {
+		printf("not supported: elf_dwarf_loc_compile_fbreg:op=0x%x\n", loc->blocks[0]);
+		ASSERT(0);
+	}
+
+	return;
+}
+
+
+bool printLocalValueV850(DwarfDataSubprogramType *subprogram, DwarfLocalVariableType *localVariable, uint32 pc, uint32 funcaddr, uint32 *vaddr)
+{
+	if (localVariable->DW_AT_location == NULL) {
+		printf("Not Supported: DW_AT_location symbol=%s\n", localVariable->name);
+		return FALSE;
+	}
+	switch (localVariable->DW_AT_location->type) {
+	case DW_FORM_block1:
+		switch (localVariable->DW_AT_location->encoded.op.ops[0]) {
+		case DW_OP_fbreg:
+			elf_dwarf_loc_compile_fbreg(subprogram, localVariable, pc, funcaddr, vaddr);
+			break;
+		default:
+			printf("not supported ops[0]=0x%x\n", localVariable->DW_AT_location->encoded.op.ops[0]);
+			break;
+		}
+		break;
+	default:
+		printf("Not Supported: DW_AT_location form=0x%x\n", localVariable->DW_AT_location->type);
+		return FALSE;
+	}
+	return TRUE;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/elf_dwarf_loc.h
@@ -0,0 +1,23 @@
+#ifndef _ELF_DWARF_LOC_H_
+#define _ELF_DWARF_LOC_H_
+
+#include "loader/elf.h"
+#include "elf_dwarf_util.h"
+#include "data_type/elf_dwarf_subprogram_type.h"
+#include "std_errno.h"
+
+struct ElfDwarfLocEntryType_tag;
+typedef struct ElfDwarfLocEntryType_tag {
+	uint32	entryOffset;
+	uint32	entrySize;
+	uint32	relativeAddress0;
+	uint32	relativeAddress1;
+	uint16	block_length;
+	uint8	*blocks;
+	struct ElfDwarfLocEntryType_tag *next;
+} ElfDwarfLocEntryType;
+
+extern Std_ReturnType elf_dwarf_loc_load(uint8 *elf_data);
+extern bool printLocalValueV850(DwarfDataSubprogramType *subprogram, DwarfLocalVariableType *localVariable, uint32 pc, uint32 funcaddr, uint32 *vaddr);
+
+#endif /* _ELF_DWARF_LOC_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/elf_dwarf_util.c
@@ -0,0 +1,123 @@
+#include "elf_dwarf_util.h"
+#include "athrill_memory.h"
+#include "assert.h"
+#include <string.h>
+#include <stdlib.h>
+
+uint32 elf_dwarf_decode_uleb128(uint8 *ptr, uint32 *size)
+{
+	uint8 i;
+	uint8 byte;
+	uint32 data = 0;
+	uint32 shift = 0;
+
+    for (i = 0; i < 4; i++) {
+        byte = ptr[i];
+        data |= ((uint32)(byte & 0x7f)) << shift;
+        shift += 7;
+        if ((byte & 0x80) == 0) {
+            break;
+        }
+    }
+    *size = i + 1;
+	return data;
+}
+
+sint32 elf_dwarf_decode_sleb128(uint8 *ptr, uint32 *size)
+{
+	uint8 i;
+	uint8 sign = 0;
+	uint8 byte;
+	sint32 data = 0;
+	sint32 shift = 0;
+
+    for (i = 0; i < 5; i++) {
+        byte = ptr[i];
+        sign = byte & 0x40;
+        data |= ((sint32)(byte & 0x7f)) << shift;
+        shift += 7;
+        if ((byte & 0x80) == 0) {
+            break;
+        }
+    }
+    *size = i + 1;
+
+    if (sign) {
+    	data |=  (- (1 << shift));
+    }
+
+	return data;
+}
+
+void elf_array_realloc(ElfPointerArrayType *array)
+{
+	void *new_ptr;
+	if (array->current_array_size >= array->max_array_size) {
+		array->max_array_size += ELF_POINTER_ARRAY_SIZE_UNIT;
+		new_ptr = realloc(array->data, (array->max_array_size * sizeof(void*)));
+		ASSERT(new_ptr != NULL);
+		array->data = new_ptr;
+	}
+	return;
+}
+extern void elf_array_add_entry(ElfPointerArrayType *array, void *entry)
+{
+	if (array->current_array_size >= array->max_array_size) {
+		elf_array_realloc(array);
+	}
+	array->data[array->current_array_size] = entry;
+	array->current_array_size++;
+	return;
+}
+ElfPointerArrayType *elf_array_alloc(void)
+{
+	ElfPointerArrayType *array = athrill_mem_alloc(sizeof(ElfPointerArrayType));
+	ASSERT(array != NULL);
+	array->current_array_size = 0;
+	array->max_array_size = 0;
+	array->data = NULL;
+	elf_array_realloc(array);
+	return array;
+}
+
+void *elf_obj_alloc(uint32 size)
+{
+	void *obj;
+	obj = athrill_mem_alloc(size);
+	ASSERT(obj != NULL);
+	memset(obj, 0, size);
+	return obj;
+}
+
+DwarfUint32ArrayType *dwarf_uint32_array_alloc(void)
+{
+	DwarfUint32ArrayType *array = athrill_mem_alloc(sizeof(DwarfUint32ArrayType));
+	ASSERT(array != NULL);
+	array->current_array_size = 0;
+	array->max_array_size = 0;
+	array->data = NULL;
+	dwarf_uint32_array_realloc(array);
+	return array;
+}
+void dwarf_uint32_array_realloc(DwarfUint32ArrayType *array)
+{
+	void *new_ptr;
+
+	if (array->current_array_size >= array->max_array_size) {
+		array->max_array_size += DWARF_ARRAY_SIZE_UNIT32;
+		new_ptr = realloc(array->data, (array->max_array_size * sizeof(uint32)));
+		ASSERT(new_ptr != NULL);
+		array->data = new_ptr;
+	}
+	return;
+}
+void dwarf_uint32_array_add_entry(DwarfUint32ArrayType *array, uint32 entry)
+{
+	if (array->current_array_size >= array->max_array_size) {
+		dwarf_uint32_array_realloc(array);
+	}
+	array->data[array->current_array_size] = entry;
+	array->current_array_size++;
+	return;
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/elf_dwarf_util.h
@@ -0,0 +1,38 @@
+#ifndef _ELF_DWARF_UTIL_H_
+#define _ELF_DWARF_UTIL_H_
+
+#include "std_types.h"
+
+extern uint32 elf_dwarf_decode_uleb128(uint8 *ptr, uint32 *size);
+
+#define BYTESLEBMAX 10
+extern sint32 elf_dwarf_decode_sleb128(uint8 *ptr, uint32 *size);
+
+/*
+ * reallocと同じ
+ * 異常発生時はASSERTで失敗する．
+ */
+#define ELF_POINTER_ARRAY_SIZE_UNIT		16
+typedef struct {
+	uint32 max_array_size;
+	uint32 current_array_size;
+	void **data;
+} ElfPointerArrayType;
+extern ElfPointerArrayType *elf_array_alloc(void);
+extern void elf_array_realloc(ElfPointerArrayType *array);
+extern void elf_array_add_entry(ElfPointerArrayType *array, void *entry);
+
+extern void *elf_obj_alloc(uint32 size);
+
+#define DWARF_ARRAY_SIZE_UNIT32		16
+typedef struct {
+	uint32 max_array_size;
+	uint32 current_array_size;
+	uint32 *data;
+} DwarfUint32ArrayType;
+extern DwarfUint32ArrayType *dwarf_uint32_array_alloc(void);
+extern void dwarf_uint32_array_realloc(DwarfUint32ArrayType *array);
+extern void dwarf_uint32_array_add_entry(DwarfUint32ArrayType *array, uint32 entry);
+
+
+#endif /* _ELF_DWARF_UTIL_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/elf_section.c
@@ -0,0 +1,248 @@
+#include "elf_section.h"
+#include <stdio.h>
+#include <string.h>
+
+/*
+ * セクション情報(内部向け)
+ */
+typedef struct {
+	Elf32_Shdr *shdr;
+	uint8		*shdata;
+} ElfSectionHeaderType;
+
+/*
+ * ストリングテーブルのセクション情報(内部向け)
+ */
+typedef ElfSectionHeaderType ElfStringTableSectionType;
+
+/*
+ * シンボルのセクション情報(内部向け)
+ */
+typedef struct {
+	Elf32_Shdr 					*shdr;
+	Elf32_Sym					*sym;
+	uint32						symbol_num;
+	ElfStringTableSectionType	*string_table;
+} ElfSymbolSectionType;
+
+static ElfSymbolSectionType 		elf_symbol_section;
+static ElfStringTableSectionType	elf_string_table_section;
+static char *section_name = NULL;
+static uint8 *elf_binary_data = NULL;
+
+Std_ReturnType elf_symbol_load(uint8 *elf_data)
+{
+	uint32 i;
+	uint32 shdr_num;
+	uint32 shdr_off;
+	uint32 shdr_size;
+	uint32 sec_shr_index;
+	Elf32_Ehdr *hdr = (Elf32_Ehdr*)elf_data;
+	Elf32_Shdr *shdr;
+
+	elf_binary_data = elf_data;
+
+	sec_shr_index = hdr->e_shstrndx;
+	shdr_num = hdr->e_shnum;
+	shdr_off = hdr->e_shoff;
+	shdr_size = hdr->e_shentsize;
+
+	/*
+	 * search_section_name
+	 */
+	for (i = 0; i < shdr_num; i++) {
+		if (i != sec_shr_index) {
+			continue;
+		}
+		shdr = (Elf32_Shdr *)&elf_data[(shdr_off + (i * shdr_size))];
+		section_name = (char*)&elf_data[shdr->sh_offset];
+		break;
+	}
+
+	/*
+	 * search section
+	 */
+	for (i = 0; i < shdr_num; i++) {
+		shdr = (Elf32_Shdr *)&elf_data[(shdr_off + (i * shdr_size))];
+		if (i == sec_shr_index) {
+			continue;
+		}
+
+		if (shdr->sh_type == SHT_SYMTAB) {
+			elf_symbol_section.shdr = shdr;
+			elf_symbol_section.sym = (Elf32_Sym*)&elf_data[shdr->sh_offset];
+			elf_symbol_section.symbol_num = shdr->sh_size / sizeof(Elf32_Sym);
+			printf("ELF SYMBOL SECTION LOADED:index=%u\n", i);
+			printf("ELF SYMBOL SECTION LOADED:sym_num=%u\n", elf_symbol_section.symbol_num);
+		}
+		else if (shdr->sh_type == SHT_STRTAB) {
+			printf("ELF STRING TABLE SECTION LOADED:index=%u\n", i);
+			elf_string_table_section.shdata = &elf_data[shdr->sh_offset];
+			elf_string_table_section.shdr = shdr;
+		}
+	}
+
+	if ((elf_symbol_section.shdr == NULL) || (elf_string_table_section.shdr == NULL)) {
+		printf("ERROR: can not found symbol section...\n");
+		return STD_E_INVALID;
+	}
+	elf_symbol_section.string_table = &elf_string_table_section;
+	return STD_E_OK;
+}
+
+Std_ReturnType elfsym_get_symbol_num(uint32 *sym_num)
+{
+	if ((elf_symbol_section.shdr == NULL) || (elf_string_table_section.shdr == NULL)) {
+		return STD_E_INVALID;
+	}
+	*sym_num = elf_symbol_section.symbol_num;
+	return STD_E_OK;
+}
+
+Std_ReturnType elfsym_get_symbol(uint32 index, ElfSymbolType *elfsym)
+{
+	Elf32_Sym *sym;
+	if ((elf_symbol_section.shdr == NULL) || (elf_string_table_section.shdr == NULL)) {
+		return STD_E_INVALID;
+	}
+	sym = &elf_symbol_section.sym[index];
+	elfsym->addr = sym->st_value;
+	elfsym->size = sym->st_size;
+	//printf("type=0x%x name=%s\n", sym->st_info, (char*)&(elf_symbol_section.string_table->shdata[sym->st_name]));
+	switch ((sym->st_info & 0x0F)) {
+	case STT_OBJECT:
+		elfsym->type = SYMBOL_TYPE_OBJECT;
+		break;
+	case STT_FUNC:
+		elfsym->type = SYMBOL_TYPE_FUNC;
+		break;
+	case STT_NOTYPE:
+		elfsym->type = SYMBOL_TYPE_NOTYPE;
+		break;
+	default:
+		elfsym->type = SYMBOL_TYPE_NOSUP;
+		break;
+	}
+	elfsym->name = (char*)&(elf_symbol_section.string_table->shdata[sym->st_name]);
+
+	return STD_E_OK;
+}
+
+Std_ReturnType elf_section_get(uint8 *elf_data, char *key, uint8 **section_data, uint32 *section_size)
+{
+	uint32 i;
+	uint32 shdr_num;
+	uint32 shdr_off;
+	uint32 shdr_size;
+	uint32 sec_shr_index;
+	Elf32_Ehdr *hdr = (Elf32_Ehdr*)elf_data;
+	Elf32_Shdr *shdr;
+	uint32 key_len = strlen(key);
+
+	sec_shr_index = hdr->e_shstrndx;
+	shdr_num = hdr->e_shnum;
+	shdr_off = hdr->e_shoff;
+	shdr_size = hdr->e_shentsize;
+
+
+	/*
+	 * search section
+	 */
+	for (i = 0; i < shdr_num; i++) {
+		shdr = (Elf32_Shdr *)&elf_data[(shdr_off + (i * shdr_size))];
+		if (i == sec_shr_index) {
+			continue;
+		}
+		uint32 len = strlen(&section_name[shdr->sh_name]);
+		if (key_len != len) {
+			continue;
+		}
+		if (strncmp(key, &section_name[shdr->sh_name], key_len) != 0) {
+			continue;
+		}
+		*section_data = &elf_data[shdr->sh_offset];
+		*section_size = shdr->sh_size;
+		//printf("inx=%u sh_name=%s\n", i, &section_name[shdr->sh_name]);
+
+		return STD_E_OK;
+	}
+	return STD_E_NOENT;
+}
+
+extern Std_ReturnType elf_section_get_dwarf_line(uint8 *elf_data, uint8 **section_data, uint32 *section_size)
+{
+	return elf_section_get(elf_data, SECTION_DWARF_LINE_NAME, section_data, section_size);
+}
+
+uint8 elf_get_data8(uint8 *elf_data, uint32 off)
+{
+	return elf_data[off];
+}
+uint16 elf_get_data16(uint8 *elf_data, uint32 off)
+{
+	uint16 data = 0;
+
+	data |=  ( ((uint16)elf_data[off + 0]) << 0 );
+	data |=  ( ((uint16)elf_data[off + 1]) << 8 );
+	return data;
+}
+uint32 elf_get_data32(uint8 *elf_data, uint32 off)
+{
+	uint32 data = 0;
+
+	data |=  ( ((uint32)elf_data[off + 0]) << 0 );
+	data |=  ( ((uint32)elf_data[off + 1]) << 8 );
+	data |=  ( ((uint32)elf_data[off + 2]) << 16 );
+	data |=  ( ((uint32)elf_data[off + 3]) << 24 );
+	return data;
+}
+
+float elf_get_float32(uint8 *elf_data, uint32 off)
+{
+	union {
+		uint32 raw;
+		float32 value;
+	} data;
+	data.raw = 0;
+
+	data.raw |=  ( ((uint32)elf_data[off + 0]) << 0 );
+	data.raw |=  ( ((uint32)elf_data[off + 1]) << 8 );
+	data.raw |=  ( ((uint32)elf_data[off + 2]) << 16 );
+	data.raw |=  ( ((uint32)elf_data[off + 3]) << 24 );
+	return data.value;
+}
+uint64 elf_get_data64(uint8 *elf_data, uint32 off)
+{
+	uint64 *data;
+	uint8 array[8];
+
+	data = (uint64*)array;
+	array[0] = elf_data[off + 0];
+	array[1] = elf_data[off + 1];
+	array[2] = elf_data[off + 2];
+	array[3] = elf_data[off + 3];
+	array[4] = elf_data[off + 4];
+	array[5] = elf_data[off + 5];
+	array[6] = elf_data[off + 6];
+	array[7] = elf_data[off + 7];
+
+	return *data;
+}
+
+float64 elf_get_float64(uint8 *elf_data, uint32 off)
+{
+	union {
+		uint8 array[8];
+		float64 value;
+	} data;
+	data.array[0] = elf_data[off + 0];
+	data.array[1] = elf_data[off + 1];
+	data.array[2] = elf_data[off + 2];
+	data.array[3] = elf_data[off + 3];
+	data.array[4] = elf_data[off + 4];
+	data.array[5] = elf_data[off + 5];
+	data.array[6] = elf_data[off + 6];
+	data.array[7] = elf_data[off + 7];
+
+	return data.value;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/elf_section.h
@@ -0,0 +1,41 @@
+#ifndef _ELF_SECTION_H_
+#define _ELF_SECTION_H_
+
+#include "loader/elf.h"
+#include "std_errno.h"
+
+extern Std_ReturnType elf_symbol_load(uint8 *elf_data);
+extern Std_ReturnType elfsym_get_symbol_num(uint32 *sym_num);
+
+typedef enum {
+	SYMBOL_TYPE_OBJECT,
+	SYMBOL_TYPE_FUNC,
+	SYMBOL_TYPE_NOTYPE,
+	SYMBOL_TYPE_NOSUP,
+} ElfSymbolEnumType;
+
+typedef struct {
+	char* 				name;
+	uint32 				size;
+	uint32 				addr;
+	ElfSymbolEnumType	type;
+} ElfSymbolType;
+extern Std_ReturnType elfsym_get_symbol(uint32 index, ElfSymbolType *elfsym);
+
+
+#define SECTION_DWARF_LINE_NAME		".debug_line"
+#define SECTION_DWARF_ABBREV_NAME	".debug_abbrev"
+#define SECTION_DWARF_INFO_NAME		".debug_info"
+#define SECTION_DWARF_STR_NAME		".debug_str"
+#define SECTION_DWARF_LOC_NAME		".debug_loc"
+extern Std_ReturnType elf_section_get_dwarf_line(uint8 *elf_data, uint8 **section_data, uint32 *section_size);
+extern Std_ReturnType elf_section_get(uint8 *elf_data, char *key, uint8 **section_data, uint32 *section_size);
+
+extern uint8 elf_get_data8(uint8 *elf_data, uint32 off);
+extern uint16 elf_get_data16(uint8 *elf_data, uint32 off);
+extern uint32 elf_get_data32(uint8 *elf_data, uint32 off);
+extern uint64 elf_get_data64(uint8 *elf_data, uint32 off);
+extern float32 elf_get_float32(uint8 *elf_data, uint32 off);
+extern float64 elf_get_float64(uint8 *elf_data, uint32 off);
+
+#endif /* _ELF_SECTION_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/file_address_mapping.c
@@ -0,0 +1,302 @@
+#include "file_address_mapping.h"
+#include "elf_dwarf_line.h"
+#include "assert.h"
+#include <string.h>
+
+typedef struct {
+	KeyAddressType	key;
+	ValueFileType	value;
+} KeyValueMappingType;
+
+static ElfPointerArrayType *key_value_mapping;
+static void file_address_mapping_add(KeyAddressType *key, ValueFileType *value);
+static void file_address_mapping_build(void);
+
+void file_address_mapping_init(void)
+{
+	key_value_mapping = elf_array_alloc();
+	file_address_mapping_build();
+
+	return;
+}
+static void do_ext_build(ElfDwarfLineParsedOpCodeType *op, ElfDwarfLineStateMachineRegisterType *machine);
+static void do_std_build(ElfDwarfLineParsedOpCodeType *op, ElfDwarfLineStateMachineRegisterType *machine);
+static void do_spc_build(ElfDwarfLineParsedOpCodeType *op, ElfDwarfLineStateMachineRegisterType *machine);
+static void add_map(KeyValueMappingType *map, ElfDwarfLineParsedOpCodeType *op, ElfDwarfLineStateMachineRegisterType *machine);
+
+static void file_address_mapping_build(void)
+{
+	uint32 entry_inx;
+	uint32 op_inx;
+	ElfDwarfLineStateMachineRegisterType machine;
+	ElfDwarfLineType *edl = elf_dwarf_line_get_ElfDwarfLine();
+
+	if (edl == NULL) {
+		printf("Not found: ElfDwarfLine\n");
+		return;
+	}
+	//printf("edl=0x%p\n", edl);
+	//printf("file_address_mapping_build:enter:size=%u\n", edl->entries->current_array_size);
+	for (entry_inx = 0; entry_inx < edl->entries->current_array_size; entry_inx++) {
+		ElfDwarfLineEntryType *entry = (ElfDwarfLineEntryType *)edl->entries->data[entry_inx];
+		elf_dwarf_line_init_ElfDwarfLineStateMachineRegister(&machine, entry->header);
+
+		//printf("file_address_mapping_build:op_num=%u\n", entry->ops->current_array_size);
+		for (op_inx = 0; op_inx < entry->ops->current_array_size; op_inx++) {
+			ElfDwarfLineParsedOpCodeType *op = (ElfDwarfLineParsedOpCodeType *)entry->ops->data[op_inx];
+
+			switch (op->type) {
+			case OPTYPE_EXTENDED:
+				do_ext_build(op, &machine);
+				break;
+			case OPTYPE_SPECIAL:
+				do_spc_build(op, &machine);
+				break;
+			case OPTYPE_STANDARD:
+				do_std_build(op, &machine);
+				break;
+			default:
+				break;
+			}
+		}
+
+	}
+	//printf("file_address_mapping_build:exit\n");
+	return;
+}
+#if 0
+#include "file.h"
+static bool is_first = FALSE;
+static FileType my_file;
+static char my_buffer[4096];
+#endif
+
+static void file_address_mapping_add(KeyAddressType *key, ValueFileType *value)
+{
+	KeyValueMappingType *obj = elf_obj_alloc(sizeof(KeyValueMappingType));
+	obj->key = *key;
+	obj->value = *value;
+	elf_array_add_entry(key_value_mapping, obj);
+
+#if 0
+	if (is_first == FALSE) {
+		is_first = TRUE;
+		printf("0x%x - 0x%x : %s/%s %d\n",
+				key->address_start, key->address_end,
+				value->dir, value->file,
+				value->line);
+		file_ropen_filepath(value->dir, value->file, &my_file);
+		file_readline(&my_file, my_buffer, sizeof(my_buffer), value->line);
+		//printf("%3u : %s\n", value->line, my_buffer);
+		printf("[%u] %s\n", value->line, my_buffer);
+		file_close(&my_file);
+	}
+#endif
+	return;
+}
+
+Std_ReturnType file_address_mapping_get(uint32 addr, ValueFileType *value)
+{
+	uint32 i;
+	KeyValueMappingType *map;
+	KeyValueMappingType *last = NULL;
+	uint32 min = 0xFFFFFFFF;
+
+	for (i = 0; i < key_value_mapping->current_array_size; i++) {
+		map = (KeyValueMappingType *)key_value_mapping->data[i];
+		if (addr > map->key.addr) {
+			if ((addr - map->key.addr) < min) {
+				last = map;
+				min = (addr - map->key.addr);
+			}
+			continue;
+		}
+		else if (addr == map->key.addr) {
+			*value = map->value;
+			return STD_E_OK;
+		}
+	}
+
+	if (last != NULL) {
+		*value = last->value;
+		return STD_E_OK;
+	}
+	return STD_E_NOENT;
+}
+
+Std_ReturnType file_address_mapping_get_addr(const char*file, uint32 line, KeyAddressType *value)
+{
+	uint32 i;
+	KeyValueMappingType *map;
+	int len = strlen(file);
+	int file_len;
+
+	for (i = 0; i < key_value_mapping->current_array_size; i++) {
+		map = (KeyValueMappingType *)key_value_mapping->data[i];
+		file_len = strlen(map->value.file);
+		if (len != file_len) {
+			continue;
+		}
+		if (line != map->value.line) {
+			continue;
+		}
+		if (strncmp(file, map->value.file, len) == 0) {
+			*value = map->key;
+			return STD_E_OK;
+		}
+	}
+	return STD_E_NOENT;
+}
+Std_ReturnType file_address_mapping_get_candidate(const char*file, uint32 line, ValueFileType *value)
+{
+	uint32 i;
+	KeyValueMappingType *map;
+	int len = strlen(file);
+	int file_len;
+
+	for (i = 0; i < key_value_mapping->current_array_size; i++) {
+		map = (KeyValueMappingType *)key_value_mapping->data[i];
+		file_len = strlen(map->value.file);
+		if (len != file_len) {
+			continue;
+		}
+		if (line >= map->value.line) {
+			continue;
+		}
+		if (strncmp(file, map->value.file, len) == 0) {
+			*value = map->value;
+			return STD_E_OK;
+		}
+	}
+	return STD_E_NOENT;
+}
+
+Std_ReturnType file_address_mapping_get_last(KeyAddressType *key, ValueFileType *value)
+{
+	KeyValueMappingType *map;
+	if (key_value_mapping->current_array_size == 0) {
+		return STD_E_NOENT;
+	}
+	map = (KeyValueMappingType *)key_value_mapping->data[key_value_mapping->current_array_size - 1];
+	*key = map->key;
+	*value = map->value;
+	return STD_E_OK;
+}
+
+
+static void do_ext_build(ElfDwarfLineParsedOpCodeType *op, ElfDwarfLineStateMachineRegisterType *machine)
+{
+	//printf("do_ext_build:op->subtype=%d\n", op->subtype);
+	switch (op->subtype) {
+	case DW_LNE_end_sequence:
+		elf_dwarf_line_machine_init(machine);
+		break;
+	case DW_LNE_set_address:
+		machine->address = op->args.extSetAddress.addr;
+		break;
+	case DW_LINE_define_file:
+		ASSERT(0);
+		break;
+	case DW_LNE_set_discriminator:
+		break;
+	default:
+		break;
+	}
+	return;
+}
+static void do_std_build(ElfDwarfLineParsedOpCodeType *op, ElfDwarfLineStateMachineRegisterType *machine)
+{
+
+	switch (op->subtype) {
+	case DW_LNS_copy:
+		{
+			KeyValueMappingType map;
+			map.key.addr = machine->address;
+			map.value.line = machine->line;
+			//printf("std:%u	", map.value.line);
+			//printf("0x%x\n", map.key.addr);
+			add_map(&map, op, machine);
+		}
+		break;
+	case DW_LNS_advance_pc:
+		machine->address += op->args.stdAdvancePc.advance_size;
+		break;
+	case DW_LNS_advance_line:
+		machine->line = (((sint32)(machine->line)) + op->args.stdAdvanceLine.advance_line);
+		break;
+	case DW_LNS_set_file:
+		machine->file = op->args.stdSetFile.file;
+		break;
+	case DW_LNS_set_column:
+		break;
+	case DW_LNS_negate_stmt:
+		break;
+	case DW_LNS_set_basic_block:
+		break;
+	case DW_LNS_const_add_pc:
+		machine->address += op->args.stdConstAddPc.const_add_pc;
+		break;
+	case DW_LNS_fixed_advance_pc:
+		machine->address += op->args.stdFixedAdvancePc.fixed_advance_pc;
+		break;
+	default:
+		break;
+	}
+	return;
+}
+
+static void add_map(KeyValueMappingType *map, ElfDwarfLineParsedOpCodeType *op, ElfDwarfLineStateMachineRegisterType *machine)
+{
+	uint32 file_inx;
+	uint32 dir_inx;
+	DwLineDefineFileType *dldf;
+	char *file;
+	char *dir;
+
+	file_inx = machine->file  - 1;
+	ASSERT(file_inx < op->hdr->file_names->current_array_size);
+	dldf = (DwLineDefineFileType*)op->hdr->file_names->data[file_inx];
+	file = dldf->file;
+
+	dir_inx = dldf->dir;
+	if (dir_inx == 0) {
+		//TODO current dir
+		dir = ".";
+	}
+	else {
+		dir = (char*)op->hdr->include_directories->data[dir_inx -1];
+	}
+#if 0
+	printf("%s %u 0x%x dir=%s\n", file, map->value.line, map->key.addr, dir);
+#endif
+
+	map->value.file = file;
+	map->value.dir = dir;
+	//printf("file=%s		", file);
+
+	file_address_mapping_add(&map->key, &map->value);
+
+	return;
+}
+static void do_spc_build(ElfDwarfLineParsedOpCodeType *op, ElfDwarfLineStateMachineRegisterType *machine)
+{
+	machine->address = machine->address + op->args.special.advance_addr;
+	machine->line = machine->line + op->args.special.advance_line;
+
+	//if (op->args.special.advance_addr != 0x0) {
+		KeyValueMappingType map;
+
+		map.key.addr = machine->address;
+		map.value.line = machine->line;
+
+
+		add_map(&map, op, machine);
+		//printf("%u	", map.value.line);
+		//printf("0x%x\n", map.key.addr);
+	//}
+
+	return;
+}
+
+
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/dwarf/file_address_mapping.h
@@ -0,0 +1,23 @@
+#ifndef _FILE_ADDRESS_MAPPING_H_
+#define _FILE_ADDRESS_MAPPING_H_
+
+#include "std_types.h"
+#include "std_errno.h"
+
+typedef struct {
+	uint32	addr;
+} KeyAddressType;
+
+typedef struct {
+	char	*dir;
+	char	*file;
+	uint32	line;
+} ValueFileType;
+
+extern void file_address_mapping_init(void);
+extern Std_ReturnType file_address_mapping_get(uint32 addr, ValueFileType *value);
+extern Std_ReturnType file_address_mapping_get_addr(const char*file, uint32 line, KeyAddressType *value);
+extern Std_ReturnType file_address_mapping_get_candidate(const char*file, uint32 line, ValueFileType *value);
+extern Std_ReturnType file_address_mapping_get_last(KeyAddressType *key, ValueFileType *value);
+
+#endif /* _FILE_ADDRESS_MAPPING_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/file.c
@@ -0,0 +1,164 @@
+#include "file.h"
+#include "string.h"
+#include <stdio.h>
+#include <sys/stat.h>
+
+bool file_exist(const char *path)
+{
+	struct stat st;
+	int err;
+
+	err = stat(path, &st);
+	if (err < 0) {
+		return FALSE;
+	}
+	return TRUE;
+}
+
+uint32 file_get_parent_folder_pathlen(const char *filepath)
+{
+	uint32 retlen = 0;
+	int i;
+	int len = strlen(filepath);
+
+	for (i = (len -1); i >= 0; i--) {
+		if (filepath[i] != '/') {
+			continue;
+		}
+		retlen = i + 1;
+		break;
+	}
+	return retlen;
+}
+
+bool file_load(FileType *file)
+{
+	size_t ret;
+	FILE *fp;
+	int fd;
+    struct stat st;
+    int err;
+
+    fp = fopen((char*)file->filepath.str, "rb");
+    if (fp == NULL) {
+		printf("ERROR can not open %s\n", file->filepath.str);
+		return FALSE;
+    }
+    fd = fileno(fp);
+
+    err = fstat(fd, &st);
+    if (err < 0) {
+		printf("ERROR can not fstat %s\n", file->filepath.str);
+	    fclose(fp);
+		return FALSE;
+    }
+    file->size = st.st_size;
+    if (file->size > MAX_FILE_SIZE) {
+			printf("ERROR file size too large %s size=%u(MAX=%u)\n", file->filepath.str, file->size, MAX_FILE_SIZE);
+	    fclose(fp);
+		return FALSE;
+    }
+
+    ret = fread(file->buffer, st.st_size, 1, fp);
+    if (ret == 0) {
+		printf("ERROR can not fread %s\n", file->filepath.str);
+	    fclose(fp);
+    	return FALSE;
+    }
+    fclose(fp);
+    return TRUE;
+}
+
+bool file_ropen(FileType *file)
+{
+	file->fp = fopen((char*)file->filepath.str, "rb");
+	if (file->fp == NULL) {
+		printf("file open error:%s\n", file->filepath.str);
+		return FALSE;
+	}
+	return TRUE;
+}
+bool file_wopen(FileType *file)
+{
+	file->fp = fopen((char*)file->filepath.str, "wb");
+	if (file->fp == NULL) {
+		printf("file open error:%s\n", file->filepath.str);
+		return FALSE;
+	}
+	return TRUE;
+}
+
+bool file_ropen_filepath(const char *dir, const char *filename, FileType *file)
+{
+	snprintf((char*)file->filepath.str, sizeof(file->filepath.str), "%s/%s", dir, filename);
+	return file_ropen(file);
+}
+
+
+uint32 file_getline(FileType *file, char *line, int size)
+{
+	uint32 n = 0;
+	char c;
+	while (n < size) {
+		c = fgetc(file->fp);
+		if (c < 0 || c == '\n') {
+			break;
+		}
+		line[n] = c;
+		n++;
+	}
+	return n;
+}
+uint32 file_readline(FileType *file, char *line, int size, int lineno)
+{
+	int count = 0;
+	uint32 n = 0;
+	(void)fseek(file->fp, 0, SEEK_SET);
+	for (count = 0; count < lineno; count++) {
+		n = file_getline(file, line, size);
+		line[n] = '\0';
+		//printf("%-3u : %s\n", count+1, line);
+	}
+	return n;
+}
+
+void file_putline(FileType *file, char *line, int size)
+{
+	(void)fseek(file->fp, 0, SEEK_SET);
+	(void)fprintf(file->fp, "%s\n", line);
+	return;
+}
+
+void file_appendline(FileType *file)
+{
+	if (file != NULL) {
+		(void)fprintf(file->fp, "%s\n", file->buffer);
+	}
+	return;
+}
+
+void file_close(FileType *file)
+{
+	if (file->fp != NULL) {
+		fclose(file->fp);
+		file->fp = NULL;
+	}
+	return;
+}
+
+bool file_printline(const char *dir, const char *filename, FileType *file, uint32 start, uint32 end)
+{
+	uint32 count;
+	if (file_ropen_filepath(dir, filename, file) == FALSE) {
+		return FALSE;
+	}
+
+	for (count = start; count <= end; count++) {
+		file_readline(file, (char*)file->buffer, sizeof(file->buffer), count);
+		printf("[%s %3u] %s\n", (char*)file->filepath.str, count, (char*)file->buffer);
+	}
+
+	file_close(file);
+	return TRUE;
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/file.h
@@ -0,0 +1,33 @@
+#ifndef _FILE_H_
+#define _FILE_H_
+
+#include "std_types.h"
+#include "token.h"
+
+extern bool file_exist(const char *path);
+
+#define MAX_FILE_SIZE	((uint32)(1024 * 1024 * 10))
+typedef struct {
+	TokenStringType filepath;
+	void			*fp;
+	uint32			size;
+	uint8			buffer[MAX_FILE_SIZE];
+} FileType;
+extern bool file_load(FileType *file);
+
+extern uint32 file_get_parent_folder_pathlen(const char *filepath);
+
+extern bool file_ropen(FileType *file);
+extern bool file_wopen(FileType *file);
+extern bool file_ropen_filepath(const char *dir, const char *filename, FileType *file);
+extern uint32 file_getline(FileType *file, char *line, int size);
+extern uint32 file_readline(FileType *file, char *line, int size, int lineno);
+
+extern void file_putline(FileType *file, char *line, int size);
+extern void file_appendline(FileType *file);
+
+extern void file_close(FileType *file);
+
+extern bool file_printline(const char *dir, const char *filename, FileType *file, uint32 start, uint32 end);
+
+#endif /* _FILE_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/hash.c
@@ -0,0 +1,135 @@
+#include "hash.h"
+#include <stdlib.h>
+#include <stdio.h>
+
+struct HashEntry;
+typedef struct HashEntry {
+	struct HashEntry 	*list;
+	struct HashEntry 	*next;
+	HashValueType		value;
+} HashEntryType;
+
+typedef struct  {
+	struct HashEntry 	*next;
+	struct HashEntry 	*last;
+} HashHeadType;
+
+typedef struct {
+	struct HashEntry 	*ref;
+	struct HashEntry 	*next;
+	struct HashEntry 	*last;
+} HashListCtrlType;
+static HashListCtrlType HashListCtrl[HASHID_NUM];
+static HashHeadType HashTable[HASHID_NUM][HASHSIZE];
+
+static uint32 hashValue(uint32 rawdata)
+{
+	return rawdata % HASHSIZE;
+}
+static HashEntryType *getEntry(void)
+{
+	return malloc(sizeof(HashEntryType));
+}
+
+void hash_init(void)
+{
+	int i;
+	int k;
+
+	for (k = 0; k < HASHID_NUM; k++) {
+		HashListCtrl[k].ref = NULL;
+		HashListCtrl[k].next = NULL;
+		HashListCtrl[k].last = NULL;
+		for (i = 0; i < HASHSIZE; i++) {
+			HashTable[k][i].next = NULL;
+			HashTable[k][i].last = NULL;
+		}
+	}
+	return;
+}
+
+HashValueType* hash_search(HashIdType id, HashValueType *value)
+{
+	HashEntryType *entry;
+	HashHeadType *head;
+	uint32 hvalue;
+
+	hvalue = hashValue(value->rawdata);
+	head = &HashTable[id][hvalue];
+
+	entry = head->next;
+	while (entry != NULL) {
+		if (value->rawdata == entry->value.rawdata) {
+			return &entry->value;
+		}
+		entry = entry->next;
+	}
+	return NULL;
+}
+
+void hash_add(HashIdType id, HashValueType *value)
+{
+	HashValueType *tmp;
+	HashEntryType *entry;
+	HashHeadType *head;
+	uint32 hvalue;
+
+	tmp = hash_search(id, value);
+	if (tmp != NULL) {
+		return;
+	}
+	//printf("hash_add:0x%x\n", value->rawdata);
+	//fflush(stdout);
+
+	hvalue = hashValue(value->rawdata);
+	head = &HashTable[id][hvalue];
+	entry = getEntry();
+	entry->value = *value;
+	entry->next = NULL;
+	entry->list = NULL;
+
+	/*
+	 * ハッシュリスト登録
+	 */
+	if (head->last == NULL) {
+		head->next = head->last = entry;
+	}
+	else {
+		head->last->next = entry;
+		head->last = entry;
+	}
+
+	/*
+	 * 全エントリ管理用リスト登録
+	 */
+	if (HashListCtrl[id].last == NULL) {
+		HashListCtrl[id].next = HashListCtrl[id].last = entry;
+	}
+	else {
+		HashListCtrl[id].last->list = entry;
+		HashListCtrl[id].last = entry;
+	}
+
+	return;
+}
+
+HashValueType* hash_first(HashIdType id)
+{
+	HashListCtrl[id].ref = HashListCtrl[id].next;
+	if (HashListCtrl[id].ref == NULL) {
+		return NULL;
+	}
+	return &HashListCtrl[id].ref->value;
+}
+
+HashValueType* hash_next(HashIdType id)
+{
+	if (HashListCtrl[id].ref == NULL) {
+		return NULL;
+	}
+	if (HashListCtrl[id].ref->list == NULL) {
+		return NULL;
+	}
+	HashListCtrl[id].ref = HashListCtrl[id].ref->list;
+	return &HashListCtrl[id].ref->value;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/hash.h
@@ -0,0 +1,26 @@
+﻿#ifndef _HASH_H_
+#define _HASH_H_
+
+#include "std_types.h"
+
+#define HASH_VALUE_CONTAINER_SIZE	4
+typedef struct {
+	uint32 rawdata;
+	uint8  data[HASH_VALUE_CONTAINER_SIZE];
+} HashValueType;
+typedef uint32 HashIdType;
+
+#define HASHID_MIN	0
+#define HASHID_MAX	0
+#define HASHID_NUM	1
+#define HASHSIZE	119U
+
+extern void hash_init(void);
+extern HashValueType* hash_search(HashIdType id, HashValueType *value);
+extern void hash_add(HashIdType id, HashValueType *value);
+
+extern HashValueType* hash_first(HashIdType id);
+extern HashValueType* hash_next(HashIdType id);
+
+
+#endif /* _HASH_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/list.h
@@ -0,0 +1,136 @@
+#ifndef _LIST_H_
+#define _LIST_H_
+
+#include "std_types.h"
+#include "assert.h"
+#include <stdlib.h>
+
+/*
+ * PRIVATE
+ */
+#define ListEntry_Init(entry)	\
+do { \
+	(entry)->next = (entry);	\
+	(entry)->prev = (entry);	\
+} while (0)
+
+#define ListEntry_InsertHead(first, elm) \
+do { \
+	if ((first) != NULL) {	\
+		(elm)->next = (first);	\
+		(elm)->prev = (first)->prev;	\
+		(first)->prev->next = (elm); \
+		(first)->prev = (elm);	\
+	}	\
+	(first) = (elm);	\
+} while (0)
+
+#define List_IsEmpty(first)	((first)->next == (first))
+#define ListEntry_First(first)	(first)
+
+#define ListEntry_Remove(first, elm)	\
+do { \
+	if ((first) != NULL) { \
+		if ((first) == (elm)) { \
+			if (List_IsEmpty(first)) {	\
+				(first) = NULL;	\
+			}	\
+			else { \
+				(first) = (elm)->next; \
+			} \
+		} \
+		(elm)->next->prev = (elm)->prev;	\
+		(elm)->prev->next = (elm)->next;	\
+		ListEntry_Init(elm); \
+	} \
+} while (0)
+
+
+/*
+ * PUBLIC
+ */
+#define ListEntryType(name, dataTypeName)	\
+struct name {	\
+	struct name *next;	\
+	struct name *prev;	\
+	dataTypeName data;	\
+}
+
+#define ListHeadType(entry_type)	\
+struct {	\
+	uint32 entry_size; \
+	uint32 entry_num;	\
+	struct entry_type *entries;	\
+	struct entry_type *free;	\
+	uint32 free_num;	\
+}
+
+#define List_Init(headp, entry_type, prealloc_size)	\
+do {	\
+	int _i;	\
+	(headp)->entry_size = sizeof(entry_type);	\
+	(headp)->entry_num = 0;	\
+	(headp)->entries = NULL;	\
+	(headp)->free = NULL;	\
+	(headp)->free_num = (prealloc_size);	\
+	for (_i = 0; _i < (prealloc_size); _i++) { \
+		entry_type *_tmp = (entry_type*)malloc(sizeof(entry_type)); \
+		ASSERT(_tmp != NULL); \
+		ListEntry_Init(_tmp);	\
+		ListEntry_InsertHead((headp)->free, _tmp);	\
+	} \
+} while (0)
+
+#define ListEntry_Alloc(headp, entry_type, new_entrypp) \
+do { \
+	entry_type *_tmp;	\
+	if ((headp)->free_num > 0) {	\
+		_tmp = ListEntry_First((headp)->free);	\
+		(headp)->free_num--;	\
+	} \
+	else { \
+		_tmp = (entry_type*)malloc(sizeof(entry_type)); \
+		ASSERT(_tmp != NULL); \
+		ListEntry_Init(_tmp);	\
+		ListEntry_InsertHead((headp)->free, _tmp);	\
+	} \
+	ListEntry_Remove((headp)->free, _tmp); \
+	*(new_entrypp) = _tmp;	\
+} while (0)
+
+#define ListEntry_Free(headp, entryp) \
+do { \
+	ListEntry_Init(entryp);	\
+	ListEntry_InsertHead((headp)->free, entryp);	\
+	(headp)->free_num++;	\
+} while (0)
+
+
+#define ListEntry_AddEntry(headp, entryp)	\
+do { \
+	ListEntry_Init(entryp);	\
+	ListEntry_InsertHead((headp)->entries, entryp);	\
+	(headp)->entry_num++;	\
+} while (0)
+
+#define ListEntry_RemoveEntry(headp, entryp)	\
+do { \
+	ListEntry_Remove((headp)->entries, entryp); \
+	(headp)->entry_num--;	\
+} while (0)
+
+#define ListEntry_RemoveAll(headp, entry_type) \
+do { \
+	while ((headp)->entry_num > 0) {	\
+		entry_type _tmp = ListEntry_First((headp)->entries);	\
+		ListEntry_RemoveEntry(headp, _tmp);	\
+	}	\
+} while (0)
+
+#define ListEntry_Foreach(headp, var)	\
+	int _i = 0;	\
+	for ((var) = (headp)->entries; \
+		_i < (headp)->entry_num; \
+		(var) = (var)->next, _i++)
+
+#endif /* _LIST_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/loader/elf.h
@@ -0,0 +1,107 @@
+/*-
+ * Copyright (c) 1996-1998 John D. Polstra.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+#ifndef __ELF_H__
+#define __ELF_H__
+
+#include "std_types.h"
+#include "loader/elf_common.h"
+
+/*
+ * ELF definitions common to all 32-bit architectures.
+ */
+typedef uint32_t	Elf32_Addr;
+typedef uint16_t	Elf32_Half;
+typedef uint32_t	Elf32_Off;
+typedef int32_t		Elf32_Sword;
+typedef uint32_t	Elf32_Word;
+typedef uint16 Elf32_Section;
+
+/*
+ * ELF header.
+ */
+typedef struct {
+	unsigned char	e_ident[EI_NIDENT];	/* File identification. */
+	Elf32_Half	e_type;		/* File type. */
+	Elf32_Half	e_machine;	/* Machine architecture. */
+	Elf32_Word	e_version;	/* ELF format version. */
+	Elf32_Addr	e_entry;	/* Entry point. */
+	Elf32_Off	e_phoff;	/* Program header file offset. */
+	Elf32_Off	e_shoff;	/* Section header file offset. */
+	Elf32_Word	e_flags;	/* Architecture-specific flags. */
+	Elf32_Half	e_ehsize;	/* Size of ELF header in bytes. */
+	Elf32_Half	e_phentsize;	/* Size of program header entry. */
+	Elf32_Half	e_phnum;	/* Number of program header entries. */
+	Elf32_Half	e_shentsize;	/* Size of section header entry. */
+	Elf32_Half	e_shnum;	/* Number of section header entries. */
+	Elf32_Half	e_shstrndx;	/* Section name strings section. */
+} Elf32_Ehdr;
+
+/*
+ * Section header.
+ */
+typedef struct {
+	Elf32_Word	sh_name;	/* Section name (index into the
+					   section header string table). */
+	Elf32_Word	sh_type;	/* Section type. */
+	Elf32_Word	sh_flags;	/* Section flags. */
+	Elf32_Addr	sh_addr;	/* Address in memory image. */
+	Elf32_Off	sh_offset;	/* Offset in file. */
+	Elf32_Word	sh_size;	/* Size in bytes. */
+	Elf32_Word	sh_link;	/* Index of a related section. */
+	Elf32_Word	sh_info;	/* Depends on section type. */
+	Elf32_Word	sh_addralign;	/* Alignment in bytes. */
+	Elf32_Word	sh_entsize;	/* Size of each entry in section. */
+} Elf32_Shdr;
+
+/*
+ * Program header.
+ */
+typedef struct {
+	Elf32_Word	p_type;		/* Entry type. */
+	Elf32_Off	p_offset;	/* File offset of contents. */
+	Elf32_Addr	p_vaddr;	/* Virtual address in memory image. */
+	Elf32_Addr	p_paddr;	/* Physical address (not used). */
+	Elf32_Word	p_filesz;	/* Size of contents in file. */
+	Elf32_Word	p_memsz;	/* Size of contents in memory. */
+	Elf32_Word	p_flags;	/* Access permission flags. */
+	Elf32_Word	p_align;	/* Alignment in memory and file. */
+} Elf32_Phdr;
+
+/* Symbol table entry.  */
+
+
+typedef struct {
+	Elf32_Word    st_name;        /* Symbol name (string tbl index) */
+	Elf32_Addr    st_value;       /* Symbol value */
+	Elf32_Word    st_size;        /* Symbol size */
+	unsigned char st_info;        /* Symbol type and binding */
+	unsigned char st_other;       /* Symbol visibility */
+	Elf32_Section st_shndx;       /* Section index */
+} Elf32_Sym;
+
+#endif /* __ELF_H__ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/loader/elf_common.h
@@ -0,0 +1,1123 @@
+/*-
+ * Copyright (c) 2000, 2001, 2008, 2011, David E. O'Brien
+ * Copyright (c) 1998 John D. Polstra.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#ifndef _SYS_ELF_COMMON_H_
+#define	_SYS_ELF_COMMON_H_ 1
+
+#define ELF_DWARF_VERSION_1		1
+#define ELF_DWARF_VERSION_2		2
+#define ELF_DWARF_VERSION_3		3
+#define ELF_DWARF_VERSION_4		4
+
+
+typedef uint32 uint32_t;
+typedef int		int32_t;
+typedef uint16 uint16_t;
+typedef uint8 uint8_t;
+
+typedef uint32_t u_int32_t;
+
+/*
+ * ELF definitions that are independent of architecture or word size.
+ */
+
+/*
+ * Note header.  The ".note" section contains an array of notes.  Each
+ * begins with this header, aligned to a word boundary.  Immediately
+ * following the note header is n_namesz bytes of name, padded to the
+ * next word boundary.  Then comes n_descsz bytes of descriptor, again
+ * padded to a word boundary.  The values of n_namesz and n_descsz do
+ * not include the padding.
+ */
+
+typedef struct {
+	u_int32_t	n_namesz;	/* Length of name. */
+	u_int32_t	n_descsz;	/* Length of descriptor. */
+	u_int32_t	n_type;		/* Type of this note. */
+} Elf_Note;
+
+/*
+ * The header for GNU-style hash sections.
+ */
+
+typedef struct {
+	u_int32_t	gh_nbuckets;	/* Number of hash buckets. */
+	u_int32_t	gh_symndx;	/* First visible symbol in .dynsym. */
+	u_int32_t	gh_maskwords;	/* #maskwords used in bloom filter. */
+	u_int32_t	gh_shift2;	/* Bloom filter shift count. */
+} Elf_GNU_Hash_Header;
+
+/* Indexes into the e_ident array.  Keep synced with
+   http://www.sco.com/developers/gabi/latest/ch4.eheader.html */
+#define	EI_MAG0		0	/* Magic number, byte 0. */
+#define	EI_MAG1		1	/* Magic number, byte 1. */
+#define	EI_MAG2		2	/* Magic number, byte 2. */
+#define	EI_MAG3		3	/* Magic number, byte 3. */
+#define	EI_CLASS	4	/* Class of machine. */
+#define	EI_DATA		5	/* Data format. */
+#define	EI_VERSION	6	/* ELF format version. */
+#define	EI_OSABI	7	/* Operating system / ABI identification */
+#define	EI_ABIVERSION	8	/* ABI version */
+#define	OLD_EI_BRAND	8	/* Start of architecture identification. */
+#define	EI_PAD		9	/* Start of padding (per SVR4 ABI). */
+#define	EI_NIDENT	16	/* Size of e_ident array. */
+
+/* Values for the magic number bytes. */
+#define	ELFMAG0		0x7f
+#define	ELFMAG1		'E'
+#define	ELFMAG2		'L'
+#define	ELFMAG3		'F'
+#define	ELFMAG		"\177ELF"	/* magic string */
+#define	SELFMAG		4		/* magic string size */
+
+/* Values for e_ident[EI_VERSION] and e_version. */
+#define	EV_NONE		0U
+#define	EV_CURRENT	1U
+
+/* Values for e_ident[EI_CLASS]. */
+#define	ELFCLASSNONE	0	/* Unknown class. */
+#define	ELFCLASS32	1	/* 32-bit architecture. */
+#define	ELFCLASS64	2	/* 64-bit architecture. */
+
+/* Values for e_ident[EI_DATA]. */
+#define	ELFDATANONE	0	/* Unknown data format. */
+#define	ELFDATA2LSB	1	/* 2's complement little-endian. */
+#define	ELFDATA2MSB	2	/* 2's complement big-endian. */
+
+/* Values for e_ident[EI_OSABI]. */
+#define	ELFOSABI_NONE		0	/* UNIX System V ABI */
+#define	ELFOSABI_HPUX		1	/* HP-UX operating system */
+#define	ELFOSABI_NETBSD		2	/* NetBSD */
+#define	ELFOSABI_LINUX		3	/* GNU/Linux */
+#define	ELFOSABI_HURD		4	/* GNU/Hurd */
+#define	ELFOSABI_86OPEN		5	/* 86Open common IA32 ABI */
+#define	ELFOSABI_SOLARIS	6	/* Solaris */
+#define	ELFOSABI_AIX		7	/* AIX */
+#define	ELFOSABI_IRIX		8	/* IRIX */
+#define	ELFOSABI_FREEBSD	9	/* FreeBSD */
+#define	ELFOSABI_TRU64		10	/* TRU64 UNIX */
+#define	ELFOSABI_MODESTO	11	/* Novell Modesto */
+#define	ELFOSABI_OPENBSD	12	/* OpenBSD */
+#define	ELFOSABI_OPENVMS	13	/* Open VMS */
+#define	ELFOSABI_NSK		14	/* HP Non-Stop Kernel */
+#define	ELFOSABI_AROS		15	/* Amiga Research OS */
+#define	ELFOSABI_ARM		97	/* ARM */
+#define	ELFOSABI_STANDALONE	255	/* Standalone (embedded) application */
+
+#define	ELFOSABI_SYSV		ELFOSABI_NONE	/* symbol used in old spec */
+#define	ELFOSABI_MONTEREY	ELFOSABI_AIX	/* Monterey */
+
+/* e_ident */
+#define	IS_ELF(ehdr)	((ehdr).e_ident[EI_MAG0] == ELFMAG0 && \
+			 (ehdr).e_ident[EI_MAG1] == ELFMAG1 && \
+			 (ehdr).e_ident[EI_MAG2] == ELFMAG2 && \
+			 (ehdr).e_ident[EI_MAG3] == ELFMAG3)
+
+/* Values for e_type. */
+#define	ET_NONE		0	/* Unknown type. */
+#define	ET_REL		1	/* Relocatable. */
+#define	ET_EXEC		2	/* Executable. */
+#define	ET_DYN		3	/* Shared object. */
+#define	ET_CORE		4	/* Core file. */
+#define	ET_LOOS		0xfe00	/* First operating system specific. */
+#define	ET_HIOS		0xfeff	/* Last operating system-specific. */
+#define	ET_LOPROC	0xff00	/* First processor-specific. */
+#define	ET_HIPROC	0xffff	/* Last processor-specific. */
+
+/* Values for e_machine. */
+#define	EM_NONE		0	/* Unknown machine. */
+#define	EM_M32		1	/* AT&T WE32100. */
+#define	EM_SPARC	2	/* Sun SPARC. */
+#define	EM_386		3	/* Intel i386. */
+#define	EM_68K		4	/* Motorola 68000. */
+#define	EM_88K		5	/* Motorola 88000. */
+#define	EM_860		7	/* Intel i860. */
+#define	EM_MIPS		8	/* MIPS R3000 Big-Endian only. */
+#define	EM_S370		9	/* IBM System/370. */
+#define	EM_MIPS_RS3_LE	10	/* MIPS R3000 Little-Endian. */
+#define	EM_PARISC	15	/* HP PA-RISC. */
+#define	EM_VPP500	17	/* Fujitsu VPP500. */
+#define	EM_SPARC32PLUS	18	/* SPARC v8plus. */
+#define	EM_960		19	/* Intel 80960. */
+#define	EM_PPC		20	/* PowerPC 32-bit. */
+#define	EM_PPC64	21	/* PowerPC 64-bit. */
+#define	EM_S390		22	/* IBM System/390. */
+#define	EM_V800		36	/* NEC V800. */
+#define	EM_FR20		37	/* Fujitsu FR20. */
+#define	EM_RH32		38	/* TRW RH-32. */
+#define	EM_RCE		39	/* Motorola RCE. */
+#define	EM_ARM		40	/* ARM. */
+#define	EM_SH		42	/* Hitachi SH. */
+#define	EM_SPARCV9	43	/* SPARC v9 64-bit. */
+#define	EM_TRICORE	44	/* Siemens TriCore embedded processor. */
+#define	EM_ARC		45	/* Argonaut RISC Core. */
+#define	EM_H8_300	46	/* Hitachi H8/300. */
+#define	EM_H8_300H	47	/* Hitachi H8/300H. */
+#define	EM_H8S		48	/* Hitachi H8S. */
+#define	EM_H8_500	49	/* Hitachi H8/500. */
+#define	EM_IA_64	50	/* Intel IA-64 Processor. */
+#define	EM_MIPS_X	51	/* Stanford MIPS-X. */
+#define	EM_COLDFIRE	52	/* Motorola ColdFire. */
+#define	EM_68HC12	53	/* Motorola M68HC12. */
+#define	EM_MMA		54	/* Fujitsu MMA. */
+#define	EM_PCP		55	/* Siemens PCP. */
+#define	EM_NCPU		56	/* Sony nCPU. */
+#define	EM_NDR1		57	/* Denso NDR1 microprocessor. */
+#define	EM_STARCORE	58	/* Motorola Star*Core processor. */
+#define	EM_ME16		59	/* Toyota ME16 processor. */
+#define	EM_ST100	60	/* STMicroelectronics ST100 processor. */
+#define	EM_TINYJ	61	/* Advanced Logic Corp. TinyJ processor. */
+#define	EM_X86_64	62	/* Advanced Micro Devices x86-64 */
+#define	EM_AMD64	EM_X86_64	/* Advanced Micro Devices x86-64 (compat) */
+#define	EM_PDSP		63	/* Sony DSP Processor. */
+#define	EM_FX66		66	/* Siemens FX66 microcontroller. */
+#define	EM_ST9PLUS	67	/* STMicroelectronics ST9+ 8/16
+				   microcontroller. */
+#define	EM_ST7		68	/* STmicroelectronics ST7 8-bit
+				   microcontroller. */
+#define	EM_68HC16	69	/* Motorola MC68HC16 microcontroller. */
+#define	EM_68HC11	70	/* Motorola MC68HC11 microcontroller. */
+#define	EM_68HC08	71	/* Motorola MC68HC08 microcontroller. */
+#define	EM_68HC05	72	/* Motorola MC68HC05 microcontroller. */
+#define	EM_SVX		73	/* Silicon Graphics SVx. */
+#define	EM_ST19		74	/* STMicroelectronics ST19 8-bit mc. */
+#define	EM_VAX		75	/* Digital VAX. */
+#define	EM_CRIS		76	/* Axis Communications 32-bit embedded
+				   processor. */
+#define	EM_JAVELIN	77	/* Infineon Technologies 32-bit embedded
+				   processor. */
+#define	EM_FIREPATH	78	/* Element 14 64-bit DSP Processor. */
+#define	EM_ZSP		79	/* LSI Logic 16-bit DSP Processor. */
+#define	EM_MMIX		80	/* Donald Knuth's educational 64-bit proc. */
+#define	EM_HUANY	81	/* Harvard University machine-independent
+				   object files. */
+#define	EM_PRISM	82	/* SiTera Prism. */
+#define	EM_AVR		83	/* Atmel AVR 8-bit microcontroller. */
+#define	EM_FR30		84	/* Fujitsu FR30. */
+#define	EM_D10V		85	/* Mitsubishi D10V. */
+#define	EM_D30V		86	/* Mitsubishi D30V. */
+#define	EM_V850		87	/* NEC v850. */
+#define	EM_M32R		88	/* Mitsubishi M32R. */
+#define	EM_MN10300	89	/* Matsushita MN10300. */
+#define	EM_MN10200	90	/* Matsushita MN10200. */
+#define	EM_PJ		91	/* picoJava. */
+#define	EM_OPENRISC	92	/* OpenRISC 32-bit embedded processor. */
+#define	EM_ARC_A5	93	/* ARC Cores Tangent-A5. */
+#define	EM_XTENSA	94	/* Tensilica Xtensa Architecture. */
+#define	EM_VIDEOCORE	95	/* Alphamosaic VideoCore processor. */
+#define	EM_TMM_GPP	96	/* Thompson Multimedia General Purpose
+				   Processor. */
+#define	EM_NS32K	97	/* National Semiconductor 32000 series. */
+#define	EM_TPC		98	/* Tenor Network TPC processor. */
+#define	EM_SNP1K	99	/* Trebia SNP 1000 processor. */
+#define	EM_ST200	100	/* STMicroelectronics ST200 microcontroller. */
+#define	EM_IP2K		101	/* Ubicom IP2xxx microcontroller family. */
+#define	EM_MAX		102	/* MAX Processor. */
+#define	EM_CR		103	/* National Semiconductor CompactRISC
+				   microprocessor. */
+#define	EM_F2MC16	104	/* Fujitsu F2MC16. */
+#define	EM_MSP430	105	/* Texas Instruments embedded microcontroller
+				   msp430. */
+#define	EM_BLACKFIN	106	/* Analog Devices Blackfin (DSP) processor. */
+#define	EM_SE_C33	107	/* S1C33 Family of Seiko Epson processors. */
+#define	EM_SEP		108	/* Sharp embedded microprocessor. */
+#define	EM_ARCA		109	/* Arca RISC Microprocessor. */
+#define	EM_UNICORE	110	/* Microprocessor series from PKU-Unity Ltd.
+				   and MPRC of Peking University */
+
+/* Non-standard or deprecated. */
+#define	EM_486		6	/* Intel i486. */
+#define	EM_MIPS_RS4_BE	10	/* MIPS R4000 Big-Endian */
+#define	EM_ALPHA_STD	41	/* Digital Alpha (standard value). */
+#define	EM_ALPHA	0x9026	/* Alpha (written in the absence of an ABI) */
+
+/* Special section indexes. */
+#define	SHN_UNDEF	     0		/* Undefined, missing, irrelevant. */
+#define	SHN_LORESERVE	0xff00		/* First of reserved range. */
+#define	SHN_LOPROC	0xff00		/* First processor-specific. */
+#define	SHN_HIPROC	0xff1f		/* Last processor-specific. */
+#define	SHN_LOOS	0xff20		/* First operating system-specific. */
+#define	SHN_HIOS	0xff3f		/* Last operating system-specific. */
+#define	SHN_ABS		0xfff1		/* Absolute values. */
+#define	SHN_COMMON	0xfff2		/* Common data. */
+#define	SHN_XINDEX	0xffff		/* Escape -- index stored elsewhere. */
+#define	SHN_HIRESERVE	0xffff		/* Last of reserved range. */
+
+/* sh_type */
+#define	SHT_NULL		0	/* inactive */
+#define	SHT_PROGBITS		1	/* program defined information */
+#define	SHT_SYMTAB		2	/* symbol table section */
+#define	SHT_STRTAB		3	/* string table section */
+#define	SHT_RELA		4	/* relocation section with addends */
+#define	SHT_HASH		5	/* symbol hash table section */
+#define	SHT_DYNAMIC		6	/* dynamic section */
+#define	SHT_NOTE		7	/* note section */
+#define	SHT_NOBITS		8	/* no space section */
+#define	SHT_REL			9	/* relocation section - no addends */
+#define	SHT_SHLIB		10	/* reserved - purpose unknown */
+#define	SHT_DYNSYM		11	/* dynamic symbol table section */
+#define	SHT_INIT_ARRAY		14	/* Initialization function pointers. */
+#define	SHT_FINI_ARRAY		15	/* Termination function pointers. */
+#define	SHT_PREINIT_ARRAY	16	/* Pre-initialization function ptrs. */
+#define	SHT_GROUP		17	/* Section group. */
+#define	SHT_SYMTAB_SHNDX	18	/* Section indexes (see SHN_XINDEX). */
+#define	SHT_LOOS		0x60000000	/* First of OS specific semantics */
+#define	SHT_LOSUNW		0x6ffffff4
+#define	SHT_SUNW_dof		0x6ffffff4
+#define	SHT_SUNW_cap		0x6ffffff5
+#define	SHT_SUNW_SIGNATURE	0x6ffffff6
+#define	SHT_GNU_HASH		0x6ffffff6
+#define	SHT_SUNW_ANNOTATE	0x6ffffff7
+#define	SHT_SUNW_DEBUGSTR	0x6ffffff8
+#define	SHT_SUNW_DEBUG		0x6ffffff9
+#define	SHT_SUNW_move		0x6ffffffa
+#define	SHT_SUNW_COMDAT		0x6ffffffb
+#define	SHT_SUNW_syminfo	0x6ffffffc
+#define	SHT_SUNW_verdef		0x6ffffffd
+#define	SHT_GNU_verdef		0x6ffffffd	/* Symbol versions provided */
+#define	SHT_SUNW_verneed	0x6ffffffe
+#define	SHT_GNU_verneed		0x6ffffffe	/* Symbol versions required */
+#define	SHT_SUNW_versym		0x6fffffff
+#define	SHT_GNU_versym		0x6fffffff	/* Symbol version table */
+#define	SHT_HISUNW		0x6fffffff
+#define	SHT_HIOS		0x6fffffff	/* Last of OS specific semantics */
+#define	SHT_LOPROC		0x70000000	/* reserved range for processor */
+#define	SHT_AMD64_UNWIND	0x70000001	/* unwind information */
+#define	SHT_MIPS_REGINFO	0x70000006
+#define	SHT_MIPS_OPTIONS	0x7000000d
+#define	SHT_MIPS_DWARF		0x7000001e	/* MIPS gcc uses MIPS_DWARF */
+#define	SHT_HIPROC		0x7fffffff	/* specific section header types */
+#define	SHT_LOUSER		0x80000000	/* reserved range for application */
+#define	SHT_HIUSER		0xffffffff	/* specific indexes */
+
+/* Flags for sh_flags. */
+#define	SHF_WRITE		0x1	/* Section contains writable data. */
+#define	SHF_ALLOC		0x2	/* Section occupies memory. */
+#define	SHF_EXECINSTR		0x4	/* Section contains instructions. */
+#define	SHF_MERGE		0x10	/* Section may be merged. */
+#define	SHF_STRINGS		0x20	/* Section contains strings. */
+#define	SHF_INFO_LINK		0x40	/* sh_info holds section index. */
+#define	SHF_LINK_ORDER		0x80	/* Special ordering requirements. */
+#define	SHF_OS_NONCONFORMING	0x100	/* OS-specific processing required. */
+#define	SHF_GROUP		0x200	/* Member of section group. */
+#define	SHF_TLS			0x400	/* Section contains TLS data. */
+#define	SHF_MASKOS	0x0ff00000	/* OS-specific semantics. */
+#define	SHF_MASKPROC	0xf0000000	/* Processor-specific semantics. */
+
+/* Values for p_type. */
+#define	PT_NULL		0U	/* Unused entry. */
+#define	PT_LOAD		1U	/* Loadable segment. */
+#define	PT_DYNAMIC	2U	/* Dynamic linking information segment. */
+#define	PT_INTERP	3U	/* Pathname of interpreter. */
+#define	PT_NOTE		4U	/* Auxiliary information. */
+#define	PT_SHLIB	5U	/* Reserved (not used). */
+#define	PT_PHDR		6U	/* Location of program header itself. */
+#define	PT_TLS		7U	/* Thread local storage segment */
+#define	PT_LOOS		0x60000000	/* First OS-specific. */
+#define	PT_SUNW_UNWIND	0x6464e550	/* amd64 UNWIND program header */
+#define	PT_GNU_EH_FRAME	0x6474e550
+#define	PT_GNU_STACK	0x6474e551
+#define	PT_GNU_RELRO	0x6474e552
+#define	PT_LOSUNW	0x6ffffffa
+#define	PT_SUNWBSS	0x6ffffffa	/* Sun Specific segment */
+#define	PT_SUNWSTACK	0x6ffffffb	/* describes the stack segment */
+#define	PT_SUNWDTRACE	0x6ffffffc	/* private */
+#define	PT_SUNWCAP	0x6ffffffd	/* hard/soft capabilities segment */
+#define	PT_HISUNW	0x6fffffff
+#define	PT_HIOS		0x6fffffff	/* Last OS-specific. */
+#define	PT_LOPROC	0x70000000	/* First processor-specific type. */
+#define	PT_HIPROC	0x7fffffff	/* Last processor-specific type. */
+
+/* Values for p_flags. */
+#define	PF_X		0x1		/* Executable. */
+#define	PF_W		0x2		/* Writable. */
+#define	PF_R		0x4		/* Readable. */
+#define	PF_MASKOS	0x0ff00000	/* Operating system-specific. */
+#define	PF_MASKPROC	0xf0000000	/* Processor-specific. */
+
+/* Extended program header index. */
+#define	PN_XNUM		0xffff
+
+/* Values for d_tag. */
+#define	DT_NULL		0	/* Terminating entry. */
+#define	DT_NEEDED	1	/* String table offset of a needed shared
+				   library. */
+#define	DT_PLTRELSZ	2	/* Total size in bytes of PLT relocations. */
+#define	DT_PLTGOT	3	/* Processor-dependent address. */
+#define	DT_HASH		4	/* Address of symbol hash table. */
+#define	DT_STRTAB	5	/* Address of string table. */
+#define	DT_SYMTAB	6	/* Address of symbol table. */
+#define	DT_RELA		7	/* Address of ElfNN_Rela relocations. */
+#define	DT_RELASZ	8	/* Total size of ElfNN_Rela relocations. */
+#define	DT_RELAENT	9	/* Size of each ElfNN_Rela relocation entry. */
+#define	DT_STRSZ	10	/* Size of string table. */
+#define	DT_SYMENT	11	/* Size of each symbol table entry. */
+#define	DT_INIT		12	/* Address of initialization function. */
+#define	DT_FINI		13	/* Address of finalization function. */
+#define	DT_SONAME	14	/* String table offset of shared object
+				   name. */
+#define	DT_RPATH	15	/* String table offset of library path. [sup] */
+#define	DT_SYMBOLIC	16	/* Indicates "symbolic" linking. [sup] */
+#define	DT_REL		17	/* Address of ElfNN_Rel relocations. */
+#define	DT_RELSZ	18	/* Total size of ElfNN_Rel relocations. */
+#define	DT_RELENT	19	/* Size of each ElfNN_Rel relocation. */
+#define	DT_PLTREL	20	/* Type of relocation used for PLT. */
+#define	DT_DEBUG	21	/* Reserved (not used). */
+#define	DT_TEXTREL	22	/* Indicates there may be relocations in
+				   non-writable segments. [sup] */
+#define	DT_JMPREL	23	/* Address of PLT relocations. */
+#define	DT_BIND_NOW	24	/* [sup] */
+#define	DT_INIT_ARRAY	25	/* Address of the array of pointers to
+				   initialization functions */
+#define	DT_FINI_ARRAY	26	/* Address of the array of pointers to
+				   termination functions */
+#define	DT_INIT_ARRAYSZ	27	/* Size in bytes of the array of
+				   initialization functions. */
+#define	DT_FINI_ARRAYSZ	28	/* Size in bytes of the array of
+				   termination functions. */
+#define	DT_RUNPATH	29	/* String table offset of a null-terminated
+				   library search path string. */
+#define	DT_FLAGS	30	/* Object specific flag values. */
+#define	DT_ENCODING	32	/* Values greater than or equal to DT_ENCODING
+				   and less than DT_LOOS follow the rules for
+				   the interpretation of the d_un union
+				   as follows: even == 'd_ptr', odd == 'd_val'
+				   or none */
+#define	DT_PREINIT_ARRAY 32	/* Address of the array of pointers to
+				   pre-initialization functions. */
+#define	DT_PREINIT_ARRAYSZ 33	/* Size in bytes of the array of
+				   pre-initialization functions. */
+#define	DT_MAXPOSTAGS	34	/* number of positive tags */
+#define	DT_LOOS		0x6000000d	/* First OS-specific */
+#define	DT_SUNW_AUXILIARY	0x6000000d	/* symbol auxiliary name */
+#define	DT_SUNW_RTLDINF		0x6000000e	/* ld.so.1 info (private) */
+#define	DT_SUNW_FILTER		0x6000000f	/* symbol filter name */
+#define	DT_SUNW_CAP		0x60000010	/* hardware/software */
+#define	DT_HIOS		0x6ffff000	/* Last OS-specific */
+
+/*
+ * DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the
+ * Dyn.d_un.d_val field of the Elf*_Dyn structure.
+ */
+#define	DT_VALRNGLO	0x6ffffd00
+#define	DT_CHECKSUM	0x6ffffdf8	/* elf checksum */
+#define	DT_PLTPADSZ	0x6ffffdf9	/* pltpadding size */
+#define	DT_MOVEENT	0x6ffffdfa	/* move table entry size */
+#define	DT_MOVESZ	0x6ffffdfb	/* move table size */
+#define	DT_FEATURE_1	0x6ffffdfc	/* feature holder */
+#define	DT_POSFLAG_1	0x6ffffdfd	/* flags for DT_* entries, effecting */
+					/*	the following DT_* entry. */
+					/*	See DF_P1_* definitions */
+#define	DT_SYMINSZ	0x6ffffdfe	/* syminfo table size (in bytes) */
+#define	DT_SYMINENT	0x6ffffdff	/* syminfo entry size (in bytes) */
+#define	DT_VALRNGHI	0x6ffffdff
+
+/*
+ * DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the
+ * Dyn.d_un.d_ptr field of the Elf*_Dyn structure.
+ *
+ * If any adjustment is made to the ELF object after it has been
+ * built, these entries will need to be adjusted.
+ */
+#define	DT_ADDRRNGLO	0x6ffffe00
+#define	DT_GNU_HASH	0x6ffffef5	/* GNU-style hash table */
+#define	DT_CONFIG	0x6ffffefa	/* configuration information */
+#define	DT_DEPAUDIT	0x6ffffefb	/* dependency auditing */
+#define	DT_AUDIT	0x6ffffefc	/* object auditing */
+#define	DT_PLTPAD	0x6ffffefd	/* pltpadding (sparcv9) */
+#define	DT_MOVETAB	0x6ffffefe	/* move table */
+#define	DT_SYMINFO	0x6ffffeff	/* syminfo table */
+#define	DT_ADDRRNGHI	0x6ffffeff
+
+#define	DT_VERSYM	0x6ffffff0	/* Address of versym section. */
+#define	DT_RELACOUNT	0x6ffffff9	/* number of RELATIVE relocations */
+#define	DT_RELCOUNT	0x6ffffffa	/* number of RELATIVE relocations */
+#define	DT_FLAGS_1	0x6ffffffb	/* state flags - see DF_1_* defs */
+#define	DT_VERDEF	0x6ffffffc	/* Address of verdef section. */
+#define	DT_VERDEFNUM	0x6ffffffd	/* Number of elems in verdef section */
+#define	DT_VERNEED	0x6ffffffe	/* Address of verneed section. */
+#define	DT_VERNEEDNUM	0x6fffffff	/* Number of elems in verneed section */
+
+#define	DT_LOPROC	0x70000000	/* First processor-specific type. */
+#define	DT_DEPRECATED_SPARC_REGISTER	0x7000001
+#define	DT_AUXILIARY	0x7ffffffd	/* shared library auxiliary name */
+#define	DT_USED		0x7ffffffe	/* ignored - same as needed */
+#define	DT_FILTER	0x7fffffff	/* shared library filter name */
+#define	DT_HIPROC	0x7fffffff	/* Last processor-specific type. */
+
+/* Values for DT_FLAGS */
+#define	DF_ORIGIN	0x0001	/* Indicates that the object being loaded may
+				   make reference to the $ORIGIN substitution
+				   string */
+#define	DF_SYMBOLIC	0x0002	/* Indicates "symbolic" linking. */
+#define	DF_TEXTREL	0x0004	/* Indicates there may be relocations in
+				   non-writable segments. */
+#define	DF_BIND_NOW	0x0008	/* Indicates that the dynamic linker should
+				   process all relocations for the object
+				   containing this entry before transferring
+				   control to the program. */
+#define	DF_STATIC_TLS	0x0010	/* Indicates that the shared object or
+				   executable contains code using a static
+				   thread-local storage scheme. */
+
+/* Values for DT_FLAGS_1 */
+#define	DF_1_BIND_NOW	0x00000001	/* Same as DF_BIND_NOW */
+#define	DF_1_GLOBAL	0x00000002	/* Set the RTLD_GLOBAL for object */
+#define	DF_1_NODELETE	0x00000008	/* Set the RTLD_NODELETE for object */
+#define	DF_1_LOADFLTR	0x00000010	/* Immediate loading of filtees */
+#define	DF_1_NOOPEN     0x00000040	/* Do not allow loading on dlopen() */
+#define	DF_1_ORIGIN	0x00000080	/* Process $ORIGIN */
+#define	DF_1_NODEFLIB	0x00000800	/* Do not search default paths */
+
+/* Values for n_type.  Used in core files. */
+#define	NT_PRSTATUS	1	/* Process status. */
+#define	NT_FPREGSET	2	/* Floating point registers. */
+#define	NT_PRPSINFO	3	/* Process state info. */
+#define	NT_THRMISC	7	/* Thread miscellaneous info. */
+
+/* Symbol Binding - ELFNN_ST_BIND - st_info */
+#define	STB_LOCAL	0	/* Local symbol */
+#define	STB_GLOBAL	1	/* Global symbol */
+#define	STB_WEAK	2	/* like global - lower precedence */
+#define	STB_LOOS	10	/* Reserved range for operating system */
+#define	STB_HIOS	12	/*   specific semantics. */
+#define	STB_LOPROC	13	/* reserved range for processor */
+#define	STB_HIPROC	15	/*   specific semantics. */
+
+/* Symbol type - ELFNN_ST_TYPE - st_info */
+#define	STT_NOTYPE	0	/* Unspecified type. */
+#define	STT_OBJECT	1	/* Data object. */
+#define	STT_FUNC	2	/* Function. */
+#define	STT_SECTION	3	/* Section. */
+#define	STT_FILE	4	/* Source file. */
+#define	STT_COMMON	5	/* Uninitialized common block. */
+#define	STT_TLS		6	/* TLS object. */
+#define	STT_NUM		7
+#define	STT_LOOS	10	/* Reserved range for operating system */
+#define	STT_GNU_IFUNC	10
+#define	STT_HIOS	12	/*   specific semantics. */
+#define	STT_LOPROC	13	/* reserved range for processor */
+#define	STT_HIPROC	15	/*   specific semantics. */
+
+/* Symbol visibility - ELFNN_ST_VISIBILITY - st_other */
+#define	STV_DEFAULT	0x0	/* Default visibility (see binding). */
+#define	STV_INTERNAL	0x1	/* Special meaning in relocatable objects. */
+#define	STV_HIDDEN	0x2	/* Not visible. */
+#define	STV_PROTECTED	0x3	/* Visible but not preemptible. */
+#define	STV_EXPORTED	0x4
+#define	STV_SINGLETON	0x5
+#define	STV_ELIMINATE	0x6
+
+/* Special symbol table indexes. */
+#define	STN_UNDEF	0	/* Undefined symbol index. */
+
+/* Symbol versioning flags. */
+#define	VER_DEF_CURRENT	1
+#define	VER_DEF_IDX(x)	VER_NDX(x)
+
+#define	VER_FLG_BASE	0x01
+#define	VER_FLG_WEAK	0x02
+
+#define	VER_NEED_CURRENT	1
+#define	VER_NEED_WEAK	(1u << 15)
+#define	VER_NEED_HIDDEN	VER_NDX_HIDDEN
+#define	VER_NEED_IDX(x)	VER_NDX(x)
+
+#define	VER_NDX_LOCAL	0
+#define	VER_NDX_GLOBAL	1
+#define	VER_NDX_GIVEN	2
+
+#define	VER_NDX_HIDDEN	(1u << 15)
+#define	VER_NDX(x)	((x) & ~(1u << 15))
+
+#define	CA_SUNW_NULL	0
+#define	CA_SUNW_HW_1	1		/* first hardware capabilities entry */
+#define	CA_SUNW_SF_1	2		/* first software capabilities entry */
+
+/*
+ * Syminfo flag values
+ */
+#define	SYMINFO_FLG_DIRECT	0x0001	/* symbol ref has direct association */
+					/*	to object containing defn. */
+#define	SYMINFO_FLG_PASSTHRU	0x0002	/* ignored - see SYMINFO_FLG_FILTER */
+#define	SYMINFO_FLG_COPY	0x0004	/* symbol is a copy-reloc */
+#define	SYMINFO_FLG_LAZYLOAD	0x0008	/* object containing defn should be */
+					/*	lazily-loaded */
+#define	SYMINFO_FLG_DIRECTBIND	0x0010	/* ref should be bound directly to */
+					/*	object containing defn. */
+#define	SYMINFO_FLG_NOEXTDIRECT	0x0020	/* don't let an external reference */
+					/*	directly bind to this symbol */
+#define	SYMINFO_FLG_FILTER	0x0002	/* symbol ref is associated to a */
+#define	SYMINFO_FLG_AUXILIARY	0x0040	/* 	standard or auxiliary filter */
+
+/*
+ * Syminfo.si_boundto values.
+ */
+#define	SYMINFO_BT_SELF		0xffff	/* symbol bound to self */
+#define	SYMINFO_BT_PARENT	0xfffe	/* symbol bound to parent */
+#define	SYMINFO_BT_NONE		0xfffd	/* no special symbol binding */
+#define	SYMINFO_BT_EXTERN	0xfffc	/* symbol defined as external */
+#define	SYMINFO_BT_LOWRESERVE	0xff00	/* beginning of reserved entries */
+
+/*
+ * Syminfo version values.
+ */
+#define	SYMINFO_NONE		0	/* Syminfo version */
+#define	SYMINFO_CURRENT		1
+#define	SYMINFO_NUM		2
+
+/*
+ * Relocation types.
+ *
+ * All machine architectures are defined here to allow tools on one to
+ * handle others.
+ */
+
+#define	R_386_NONE		0	/* No relocation. */
+#define	R_386_32		1	/* Add symbol value. */
+#define	R_386_PC32		2	/* Add PC-relative symbol value. */
+#define	R_386_GOT32		3	/* Add PC-relative GOT offset. */
+#define	R_386_PLT32		4	/* Add PC-relative PLT offset. */
+#define	R_386_COPY		5	/* Copy data from shared object. */
+#define	R_386_GLOB_DAT		6	/* Set GOT entry to data address. */
+#define	R_386_JMP_SLOT		7	/* Set GOT entry to code address. */
+#define	R_386_RELATIVE		8	/* Add load address of shared object. */
+#define	R_386_GOTOFF		9	/* Add GOT-relative symbol address. */
+#define	R_386_GOTPC		10	/* Add PC-relative GOT table address. */
+#define	R_386_TLS_TPOFF		14	/* Negative offset in static TLS block */
+#define	R_386_TLS_IE		15	/* Absolute address of GOT for -ve static TLS */
+#define	R_386_TLS_GOTIE		16	/* GOT entry for negative static TLS block */
+#define	R_386_TLS_LE		17	/* Negative offset relative to static TLS */
+#define	R_386_TLS_GD		18	/* 32 bit offset to GOT (index,off) pair */
+#define	R_386_TLS_LDM		19	/* 32 bit offset to GOT (index,zero) pair */
+#define	R_386_16		20
+#define	R_386_PC16		21
+#define	R_386_8			22
+#define	R_386_PC8		23
+#define	R_386_TLS_GD_32		24	/* 32 bit offset to GOT (index,off) pair */
+#define	R_386_TLS_GD_PUSH	25	/* pushl instruction for Sun ABI GD sequence */
+#define	R_386_TLS_GD_CALL	26	/* call instruction for Sun ABI GD sequence */
+#define	R_386_TLS_GD_POP	27	/* popl instruction for Sun ABI GD sequence */
+#define	R_386_TLS_LDM_32	28	/* 32 bit offset to GOT (index,zero) pair */
+#define	R_386_TLS_LDM_PUSH	29	/* pushl instruction for Sun ABI LD sequence */
+#define	R_386_TLS_LDM_CALL	30	/* call instruction for Sun ABI LD sequence */
+#define	R_386_TLS_LDM_POP	31	/* popl instruction for Sun ABI LD sequence */
+#define	R_386_TLS_LDO_32	32	/* 32 bit offset from start of TLS block */
+#define	R_386_TLS_IE_32		33	/* 32 bit offset to GOT static TLS offset entry */
+#define	R_386_TLS_LE_32		34	/* 32 bit offset within static TLS block */
+#define	R_386_TLS_DTPMOD32	35	/* GOT entry containing TLS index */
+#define	R_386_TLS_DTPOFF32	36	/* GOT entry containing TLS offset */
+#define	R_386_TLS_TPOFF32	37	/* GOT entry of -ve static TLS offset */
+#define	R_386_IRELATIVE		42	/* PLT entry resolved indirectly at runtime */
+
+#define	R_ARM_NONE		0	/* No relocation. */
+#define	R_ARM_PC24		1
+#define	R_ARM_ABS32		2
+#define	R_ARM_REL32		3
+#define	R_ARM_PC13		4
+#define	R_ARM_ABS16		5
+#define	R_ARM_ABS12		6
+#define	R_ARM_THM_ABS5		7
+#define	R_ARM_ABS8		8
+#define	R_ARM_SBREL32		9
+#define	R_ARM_THM_PC22		10
+#define	R_ARM_THM_PC8		11
+#define	R_ARM_AMP_VCALL9	12
+#define	R_ARM_SWI24		13
+#define	R_ARM_THM_SWI8		14
+#define	R_ARM_XPC25		15
+#define	R_ARM_THM_XPC22		16
+/* TLS relocations */
+#define	R_ARM_TLS_DTPMOD32	17	/* ID of module containing symbol */
+#define	R_ARM_TLS_DTPOFF32	18	/* Offset in TLS block */
+#define	R_ARM_TLS_TPOFF32	19	/* Offset in static TLS block */
+#define	R_ARM_COPY		20	/* Copy data from shared object. */
+#define	R_ARM_GLOB_DAT		21	/* Set GOT entry to data address. */
+#define	R_ARM_JUMP_SLOT		22	/* Set GOT entry to code address. */
+#define	R_ARM_RELATIVE		23	/* Add load address of shared object. */
+#define	R_ARM_GOTOFF		24	/* Add GOT-relative symbol address. */
+#define	R_ARM_GOTPC		25	/* Add PC-relative GOT table address. */
+#define	R_ARM_GOT32		26	/* Add PC-relative GOT offset. */
+#define	R_ARM_PLT32		27	/* Add PC-relative PLT offset. */
+#define	R_ARM_GNU_VTENTRY	100
+#define	R_ARM_GNU_VTINHERIT	101
+#define	R_ARM_RSBREL32		250
+#define	R_ARM_THM_RPC22		251
+#define	R_ARM_RREL32		252
+#define	R_ARM_RABS32		253
+#define	R_ARM_RPC24		254
+#define	R_ARM_RBASE		255
+
+/*	Name			Value	   Field	Calculation */
+#define	R_IA_64_NONE		0	/* None */
+#define	R_IA_64_IMM14		0x21	/* immediate14	S + A */
+#define	R_IA_64_IMM22		0x22	/* immediate22	S + A */
+#define	R_IA_64_IMM64		0x23	/* immediate64	S + A */
+#define	R_IA_64_DIR32MSB	0x24	/* word32 MSB	S + A */
+#define	R_IA_64_DIR32LSB	0x25	/* word32 LSB	S + A */
+#define	R_IA_64_DIR64MSB	0x26	/* word64 MSB	S + A */
+#define	R_IA_64_DIR64LSB	0x27	/* word64 LSB	S + A */
+#define	R_IA_64_GPREL22		0x2a	/* immediate22	@gprel(S + A) */
+#define	R_IA_64_GPREL64I	0x2b	/* immediate64	@gprel(S + A) */
+#define	R_IA_64_GPREL32MSB	0x2c	/* word32 MSB	@gprel(S + A) */
+#define	R_IA_64_GPREL32LSB	0x2d	/* word32 LSB	@gprel(S + A) */
+#define	R_IA_64_GPREL64MSB	0x2e	/* word64 MSB	@gprel(S + A) */
+#define	R_IA_64_GPREL64LSB	0x2f	/* word64 LSB	@gprel(S + A) */
+#define	R_IA_64_LTOFF22		0x32	/* immediate22	@ltoff(S + A) */
+#define	R_IA_64_LTOFF64I	0x33	/* immediate64	@ltoff(S + A) */
+#define	R_IA_64_PLTOFF22	0x3a	/* immediate22	@pltoff(S + A) */
+#define	R_IA_64_PLTOFF64I	0x3b	/* immediate64	@pltoff(S + A) */
+#define	R_IA_64_PLTOFF64MSB	0x3e	/* word64 MSB	@pltoff(S + A) */
+#define	R_IA_64_PLTOFF64LSB	0x3f	/* word64 LSB	@pltoff(S + A) */
+#define	R_IA_64_FPTR64I		0x43	/* immediate64	@fptr(S + A) */
+#define	R_IA_64_FPTR32MSB	0x44	/* word32 MSB	@fptr(S + A) */
+#define	R_IA_64_FPTR32LSB	0x45	/* word32 LSB	@fptr(S + A) */
+#define	R_IA_64_FPTR64MSB	0x46	/* word64 MSB	@fptr(S + A) */
+#define	R_IA_64_FPTR64LSB	0x47	/* word64 LSB	@fptr(S + A) */
+#define	R_IA_64_PCREL60B	0x48	/* immediate60 form1 S + A - P */
+#define	R_IA_64_PCREL21B	0x49	/* immediate21 form1 S + A - P */
+#define	R_IA_64_PCREL21M	0x4a	/* immediate21 form2 S + A - P */
+#define	R_IA_64_PCREL21F	0x4b	/* immediate21 form3 S + A - P */
+#define	R_IA_64_PCREL32MSB	0x4c	/* word32 MSB	S + A - P */
+#define	R_IA_64_PCREL32LSB	0x4d	/* word32 LSB	S + A - P */
+#define	R_IA_64_PCREL64MSB	0x4e	/* word64 MSB	S + A - P */
+#define	R_IA_64_PCREL64LSB	0x4f	/* word64 LSB	S + A - P */
+#define	R_IA_64_LTOFF_FPTR22	0x52	/* immediate22	@ltoff(@fptr(S + A)) */
+#define	R_IA_64_LTOFF_FPTR64I	0x53	/* immediate64	@ltoff(@fptr(S + A)) */
+#define	R_IA_64_LTOFF_FPTR32MSB	0x54	/* word32 MSB	@ltoff(@fptr(S + A)) */
+#define	R_IA_64_LTOFF_FPTR32LSB	0x55	/* word32 LSB	@ltoff(@fptr(S + A)) */
+#define	R_IA_64_LTOFF_FPTR64MSB	0x56	/* word64 MSB	@ltoff(@fptr(S + A)) */
+#define	R_IA_64_LTOFF_FPTR64LSB	0x57	/* word64 LSB	@ltoff(@fptr(S + A)) */
+#define	R_IA_64_SEGREL32MSB	0x5c	/* word32 MSB	@segrel(S + A) */
+#define	R_IA_64_SEGREL32LSB	0x5d	/* word32 LSB	@segrel(S + A) */
+#define	R_IA_64_SEGREL64MSB	0x5e	/* word64 MSB	@segrel(S + A) */
+#define	R_IA_64_SEGREL64LSB	0x5f	/* word64 LSB	@segrel(S + A) */
+#define	R_IA_64_SECREL32MSB	0x64	/* word32 MSB	@secrel(S + A) */
+#define	R_IA_64_SECREL32LSB	0x65	/* word32 LSB	@secrel(S + A) */
+#define	R_IA_64_SECREL64MSB	0x66	/* word64 MSB	@secrel(S + A) */
+#define	R_IA_64_SECREL64LSB	0x67	/* word64 LSB	@secrel(S + A) */
+#define	R_IA_64_REL32MSB	0x6c	/* word32 MSB	BD + A */
+#define	R_IA_64_REL32LSB	0x6d	/* word32 LSB	BD + A */
+#define	R_IA_64_REL64MSB	0x6e	/* word64 MSB	BD + A */
+#define	R_IA_64_REL64LSB	0x6f	/* word64 LSB	BD + A */
+#define	R_IA_64_LTV32MSB	0x74	/* word32 MSB	S + A */
+#define	R_IA_64_LTV32LSB	0x75	/* word32 LSB	S + A */
+#define	R_IA_64_LTV64MSB	0x76	/* word64 MSB	S + A */
+#define	R_IA_64_LTV64LSB	0x77	/* word64 LSB	S + A */
+#define	R_IA_64_PCREL21BI	0x79	/* immediate21 form1 S + A - P */
+#define	R_IA_64_PCREL22		0x7a	/* immediate22	S + A - P */
+#define	R_IA_64_PCREL64I	0x7b	/* immediate64	S + A - P */
+#define	R_IA_64_IPLTMSB		0x80	/* function descriptor MSB special */
+#define	R_IA_64_IPLTLSB		0x81	/* function descriptor LSB speciaal */
+#define	R_IA_64_SUB		0x85	/* immediate64	A - S */
+#define	R_IA_64_LTOFF22X	0x86	/* immediate22	special */
+#define	R_IA_64_LDXMOV		0x87	/* immediate22	special */
+#define	R_IA_64_TPREL14		0x91	/* imm14	@tprel(S + A) */
+#define	R_IA_64_TPREL22		0x92	/* imm22	@tprel(S + A) */
+#define	R_IA_64_TPREL64I	0x93	/* imm64	@tprel(S + A) */
+#define	R_IA_64_TPREL64MSB	0x96	/* word64 MSB	@tprel(S + A) */
+#define	R_IA_64_TPREL64LSB	0x97	/* word64 LSB	@tprel(S + A) */
+#define	R_IA_64_LTOFF_TPREL22	0x9a	/* imm22	@ltoff(@tprel(S+A)) */
+#define	R_IA_64_DTPMOD64MSB	0xa6	/* word64 MSB	@dtpmod(S + A) */
+#define	R_IA_64_DTPMOD64LSB	0xa7	/* word64 LSB	@dtpmod(S + A) */
+#define	R_IA_64_LTOFF_DTPMOD22	0xaa	/* imm22	@ltoff(@dtpmod(S+A)) */
+#define	R_IA_64_DTPREL14	0xb1	/* imm14	@dtprel(S + A) */
+#define	R_IA_64_DTPREL22	0xb2	/* imm22	@dtprel(S + A) */
+#define	R_IA_64_DTPREL64I	0xb3	/* imm64	@dtprel(S + A) */
+#define	R_IA_64_DTPREL32MSB	0xb4	/* word32 MSB	@dtprel(S + A) */
+#define	R_IA_64_DTPREL32LSB	0xb5	/* word32 LSB	@dtprel(S + A) */
+#define	R_IA_64_DTPREL64MSB	0xb6	/* word64 MSB	@dtprel(S + A) */
+#define	R_IA_64_DTPREL64LSB	0xb7	/* word64 LSB	@dtprel(S + A) */
+#define	R_IA_64_LTOFF_DTPREL22	0xba	/* imm22	@ltoff(@dtprel(S+A)) */
+
+/* Linux style aliases */
+#define	R_IA64_NONE		R_IA_64_NONE
+#define	R_IA64_IMM14		R_IA_64_IMM14
+#define	R_IA64_IMM22		R_IA_64_IMM22
+#define	R_IA64_IMM64		R_IA_64_IMM64
+#define	R_IA64_DIR32MSB		R_IA_64_DIR32MSB
+#define	R_IA64_DIR32LSB		R_IA_64_DIR32LSB
+#define	R_IA64_DIR64MSB		R_IA_64_DIR64MSB
+#define	R_IA64_DIR64LSB		R_IA_64_DIR64LSB
+#define	R_IA64_GPREL22		R_IA_64_GPREL22
+#define	R_IA64_GPREL64I		R_IA_64_GPREL64I
+#define	R_IA64_GPREL32MSB	R_IA_64_GPREL32MSB
+#define	R_IA64_GPREL32LSB	R_IA_64_GPREL32LSB
+#define	R_IA64_GPREL64MSB	R_IA_64_GPREL64MSB
+#define	R_IA64_GPREL64LSB	R_IA_64_GPREL64LSB
+#define	R_IA64_LTOFF22		R_IA_64_LTOFF22
+#define	R_IA64_LTOFF64I		R_IA_64_LTOFF64I
+#define	R_IA64_PLTOFF22		R_IA_64_PLTOFF22
+#define	R_IA64_PLTOFF64I	R_IA_64_PLTOFF64I
+#define	R_IA64_PLTOFF64MSB	R_IA_64_PLTOFF64MSB
+#define	R_IA64_PLTOFF64LSB	R_IA_64_PLTOFF64LSB
+#define	R_IA64_FPTR64I		R_IA_64_FPTR64I
+#define	R_IA64_FPTR32MSB	R_IA_64_FPTR32MSB
+#define	R_IA64_FPTR32LSB	R_IA_64_FPTR32LSB
+#define	R_IA64_FPTR64MSB	R_IA_64_FPTR64MSB
+#define	R_IA64_FPTR64LSB	R_IA_64_FPTR64LSB
+#define	R_IA64_PCREL60B		R_IA_64_PCREL60B
+#define	R_IA64_PCREL21B		R_IA_64_PCREL21B
+#define	R_IA64_PCREL21M		R_IA_64_PCREL21M
+#define	R_IA64_PCREL21F		R_IA_64_PCREL21F
+#define	R_IA64_PCREL32MSB	R_IA_64_PCREL32MSB
+#define	R_IA64_PCREL32LSB	R_IA_64_PCREL32LSB
+#define	R_IA64_PCREL64MSB	R_IA_64_PCREL64MSB
+#define	R_IA64_PCREL64LSB	R_IA_64_PCREL64LSB
+#define	R_IA64_LTOFF_FPTR22	R_IA_64_LTOFF_FPTR22
+#define	R_IA64_LTOFF_FPTR64I	R_IA_64_LTOFF_FPTR64I
+#define	R_IA64_LTOFF_FPTR32MSB	R_IA_64_LTOFF_FPTR32MSB
+#define	R_IA64_LTOFF_FPTR32LSB	R_IA_64_LTOFF_FPTR32LSB
+#define	R_IA64_LTOFF_FPTR64MSB	R_IA_64_LTOFF_FPTR64MSB
+#define	R_IA64_LTOFF_FPTR64LSB	R_IA_64_LTOFF_FPTR64LSB
+#define	R_IA64_SEGREL32MSB	R_IA_64_SEGREL32MSB
+#define	R_IA64_SEGREL32LSB	R_IA_64_SEGREL32LSB
+#define	R_IA64_SEGREL64MSB	R_IA_64_SEGREL64MSB
+#define	R_IA64_SEGREL64LSB	R_IA_64_SEGREL64LSB
+#define	R_IA64_SECREL32MSB	R_IA_64_SECREL32MSB
+#define	R_IA64_SECREL32LSB	R_IA_64_SECREL32LSB
+#define	R_IA64_SECREL64MSB	R_IA_64_SECREL64MSB
+#define	R_IA64_SECREL64LSB	R_IA_64_SECREL64LSB
+#define	R_IA64_REL32MSB		R_IA_64_REL32MSB
+#define	R_IA64_REL32LSB		R_IA_64_REL32LSB
+#define	R_IA64_REL64MSB		R_IA_64_REL64MSB
+#define	R_IA64_REL64LSB		R_IA_64_REL64LSB
+#define	R_IA64_LTV32MSB		R_IA_64_LTV32MSB
+#define	R_IA64_LTV32LSB		R_IA_64_LTV32LSB
+#define	R_IA64_LTV64MSB		R_IA_64_LTV64MSB
+#define	R_IA64_LTV64LSB		R_IA_64_LTV64LSB
+#define	R_IA64_PCREL21BI	R_IA_64_PCREL21BI
+#define	R_IA64_PCREL22		R_IA_64_PCREL22
+#define	R_IA64_PCREL64I		R_IA_64_PCREL64I
+#define	R_IA64_IPLTMSB		R_IA_64_IPLTMSB
+#define	R_IA64_IPLTLSB		R_IA_64_IPLTLSB
+#define	R_IA64_SUB		R_IA_64_SUB
+#define	R_IA64_LTOFF22X		R_IA_64_LTOFF22X
+#define	R_IA64_LDXMOV		R_IA_64_LDXMOV
+#define	R_IA64_TPREL14		R_IA_64_TPREL14
+#define	R_IA64_TPREL22		R_IA_64_TPREL22
+#define	R_IA64_TPREL64I		R_IA_64_TPREL64I
+#define	R_IA64_TPREL64MSB	R_IA_64_TPREL64MSB
+#define	R_IA64_TPREL64LSB	R_IA_64_TPREL64LSB
+#define	R_IA64_LTOFF_TPREL22	R_IA_64_LTOFF_TPREL22
+#define	R_IA64_DTPMOD64MSB	R_IA_64_DTPMOD64MSB
+#define	R_IA64_DTPMOD64LSB	R_IA_64_DTPMOD64LSB
+#define	R_IA64_LTOFF_DTPMOD22	R_IA_64_LTOFF_DTPMOD22
+#define	R_IA64_DTPREL14		R_IA_64_DTPREL14
+#define	R_IA64_DTPREL22		R_IA_64_DTPREL22
+#define	R_IA64_DTPREL64I	R_IA_64_DTPREL64I
+#define	R_IA64_DTPREL32MSB	R_IA_64_DTPREL32MSB
+#define	R_IA64_DTPREL32LSB	R_IA_64_DTPREL32LSB
+#define	R_IA64_DTPREL64MSB	R_IA_64_DTPREL64MSB
+#define	R_IA64_DTPREL64LSB	R_IA_64_DTPREL64LSB
+#define	R_IA64_LTOFF_DTPREL22	R_IA_64_LTOFF_DTPREL22
+
+#define	R_MIPS_NONE	0	/* No reloc */
+#define	R_MIPS_16	1	/* Direct 16 bit */
+#define	R_MIPS_32	2	/* Direct 32 bit */
+#define	R_MIPS_REL32	3	/* PC relative 32 bit */
+#define	R_MIPS_26	4	/* Direct 26 bit shifted */
+#define	R_MIPS_HI16	5	/* High 16 bit */
+#define	R_MIPS_LO16	6	/* Low 16 bit */
+#define	R_MIPS_GPREL16	7	/* GP relative 16 bit */
+#define	R_MIPS_LITERAL	8	/* 16 bit literal entry */
+#define	R_MIPS_GOT16	9	/* 16 bit GOT entry */
+#define	R_MIPS_PC16	10	/* PC relative 16 bit */
+#define	R_MIPS_CALL16	11	/* 16 bit GOT entry for function */
+#define	R_MIPS_GPREL32	12	/* GP relative 32 bit */
+#define	R_MIPS_64	18	/* Direct 64 bit */
+#define	R_MIPS_GOTHI16	21	/* GOT HI 16 bit */
+#define	R_MIPS_GOTLO16	22	/* GOT LO 16 bit */
+#define	R_MIPS_CALLHI16 30	/* upper 16 bit GOT entry for function */
+#define	R_MIPS_CALLLO16 31	/* lower 16 bit GOT entry for function */
+
+#define	R_PPC_NONE		0	/* No relocation. */
+#define	R_PPC_ADDR32		1
+#define	R_PPC_ADDR24		2
+#define	R_PPC_ADDR16		3
+#define	R_PPC_ADDR16_LO		4
+#define	R_PPC_ADDR16_HI		5
+#define	R_PPC_ADDR16_HA		6
+#define	R_PPC_ADDR14		7
+#define	R_PPC_ADDR14_BRTAKEN	8
+#define	R_PPC_ADDR14_BRNTAKEN	9
+#define	R_PPC_REL24		10
+#define	R_PPC_REL14		11
+#define	R_PPC_REL14_BRTAKEN	12
+#define	R_PPC_REL14_BRNTAKEN	13
+#define	R_PPC_GOT16		14
+#define	R_PPC_GOT16_LO		15
+#define	R_PPC_GOT16_HI		16
+#define	R_PPC_GOT16_HA		17
+#define	R_PPC_PLTREL24		18
+#define	R_PPC_COPY		19
+#define	R_PPC_GLOB_DAT		20
+#define	R_PPC_JMP_SLOT		21
+#define	R_PPC_RELATIVE		22
+#define	R_PPC_LOCAL24PC		23
+#define	R_PPC_UADDR32		24
+#define	R_PPC_UADDR16		25
+#define	R_PPC_REL32		26
+#define	R_PPC_PLT32		27
+#define	R_PPC_PLTREL32		28
+#define	R_PPC_PLT16_LO		29
+#define	R_PPC_PLT16_HI		30
+#define	R_PPC_PLT16_HA		31
+#define	R_PPC_SDAREL16		32
+#define	R_PPC_SECTOFF		33
+#define	R_PPC_SECTOFF_LO	34
+#define	R_PPC_SECTOFF_HI	35
+#define	R_PPC_SECTOFF_HA	36
+
+/*
+ * 64-bit relocations
+ */
+#define	R_PPC64_ADDR64		38
+#define	R_PPC64_ADDR16_HIGHER	39
+#define	R_PPC64_ADDR16_HIGHERA	40
+#define	R_PPC64_ADDR16_HIGHEST	41
+#define	R_PPC64_ADDR16_HIGHESTA	42
+#define	R_PPC64_UADDR64		43
+#define	R_PPC64_REL64		44
+#define	R_PPC64_PLT64		45
+#define	R_PPC64_PLTREL64	46
+#define	R_PPC64_TOC16		47
+#define	R_PPC64_TOC16_LO	48
+#define	R_PPC64_TOC16_HI	49
+#define	R_PPC64_TOC16_HA	50
+#define	R_PPC64_TOC		51
+#define	R_PPC64_DTPMOD64	68
+#define	R_PPC64_TPREL64		73
+#define	R_PPC64_DTPREL64	78
+
+/*
+ * TLS relocations
+ */
+#define	R_PPC_TLS		67
+#define	R_PPC_DTPMOD32		68
+#define	R_PPC_TPREL16		69
+#define	R_PPC_TPREL16_LO	70
+#define	R_PPC_TPREL16_HI	71
+#define	R_PPC_TPREL16_HA	72
+#define	R_PPC_TPREL32		73
+#define	R_PPC_DTPREL16		74
+#define	R_PPC_DTPREL16_LO	75
+#define	R_PPC_DTPREL16_HI	76
+#define	R_PPC_DTPREL16_HA	77
+#define	R_PPC_DTPREL32		78
+#define	R_PPC_GOT_TLSGD16	79
+#define	R_PPC_GOT_TLSGD16_LO	80
+#define	R_PPC_GOT_TLSGD16_HI	81
+#define	R_PPC_GOT_TLSGD16_HA	82
+#define	R_PPC_GOT_TLSLD16	83
+#define	R_PPC_GOT_TLSLD16_LO	84
+#define	R_PPC_GOT_TLSLD16_HI	85
+#define	R_PPC_GOT_TLSLD16_HA	86
+#define	R_PPC_GOT_TPREL16	87
+#define	R_PPC_GOT_TPREL16_LO	88
+#define	R_PPC_GOT_TPREL16_HI	89
+#define	R_PPC_GOT_TPREL16_HA	90
+
+/*
+ * The remaining relocs are from the Embedded ELF ABI, and are not in the
+ *  SVR4 ELF ABI.
+ */
+
+#define	R_PPC_EMB_NADDR32	101
+#define	R_PPC_EMB_NADDR16	102
+#define	R_PPC_EMB_NADDR16_LO	103
+#define	R_PPC_EMB_NADDR16_HI	104
+#define	R_PPC_EMB_NADDR16_HA	105
+#define	R_PPC_EMB_SDAI16	106
+#define	R_PPC_EMB_SDA2I16	107
+#define	R_PPC_EMB_SDA2REL	108
+#define	R_PPC_EMB_SDA21		109
+#define	R_PPC_EMB_MRKREF	110
+#define	R_PPC_EMB_RELSEC16	111
+#define	R_PPC_EMB_RELST_LO	112
+#define	R_PPC_EMB_RELST_HI	113
+#define	R_PPC_EMB_RELST_HA	114
+#define	R_PPC_EMB_BIT_FLD	115
+#define	R_PPC_EMB_RELSDA	116
+
+#define	R_SH_NONE		0
+#define	R_SH_DIR32		1
+#define	R_SH_REL32		2
+#define	R_SH_DIR8WPN		3
+#define	R_SH_IND12W		4
+#define	R_SH_DIR8WPL		5
+#define	R_SH_DIR8WPZ		6
+#define	R_SH_DIR8BP		7
+#define	R_SH_DIR8W		8
+#define	R_SH_DIR8L		9
+#define	R_SH_GOT32		0xa0
+#define	R_SH_PLT32		0xa1
+#define	R_SH_COPY		0xa2
+#define	R_SH_GLOB_DAT		0xa3
+#define	R_SH_JMP_SLOT		0xa4
+#define	R_SH_RELATIVE		0xa5
+#define	R_SH_GOTOFF		0xa6
+#define	R_SH_GOTPC		0xa7
+
+#define	R_SPARC_NONE		0
+#define	R_SPARC_8		1
+#define	R_SPARC_16		2
+#define	R_SPARC_32		3
+#define	R_SPARC_DISP8		4
+#define	R_SPARC_DISP16		5
+#define	R_SPARC_DISP32		6
+#define	R_SPARC_WDISP30		7
+#define	R_SPARC_WDISP22		8
+#define	R_SPARC_HI22		9
+#define	R_SPARC_22		10
+#define	R_SPARC_13		11
+#define	R_SPARC_LO10		12
+#define	R_SPARC_GOT10		13
+#define	R_SPARC_GOT13		14
+#define	R_SPARC_GOT22		15
+#define	R_SPARC_PC10		16
+#define	R_SPARC_PC22		17
+#define	R_SPARC_WPLT30		18
+#define	R_SPARC_COPY		19
+#define	R_SPARC_GLOB_DAT	20
+#define	R_SPARC_JMP_SLOT	21
+#define	R_SPARC_RELATIVE	22
+#define	R_SPARC_UA32		23
+#define	R_SPARC_PLT32		24
+#define	R_SPARC_HIPLT22		25
+#define	R_SPARC_LOPLT10		26
+#define	R_SPARC_PCPLT32		27
+#define	R_SPARC_PCPLT22		28
+#define	R_SPARC_PCPLT10		29
+#define	R_SPARC_10		30
+#define	R_SPARC_11		31
+#define	R_SPARC_64		32
+#define	R_SPARC_OLO10		33
+#define	R_SPARC_HH22		34
+#define	R_SPARC_HM10		35
+#define	R_SPARC_LM22		36
+#define	R_SPARC_PC_HH22		37
+#define	R_SPARC_PC_HM10		38
+#define	R_SPARC_PC_LM22		39
+#define	R_SPARC_WDISP16		40
+#define	R_SPARC_WDISP19		41
+#define	R_SPARC_GLOB_JMP	42
+#define	R_SPARC_7		43
+#define	R_SPARC_5		44
+#define	R_SPARC_6		45
+#define	R_SPARC_DISP64		46
+#define	R_SPARC_PLT64		47
+#define	R_SPARC_HIX22		48
+#define	R_SPARC_LOX10		49
+#define	R_SPARC_H44		50
+#define	R_SPARC_M44		51
+#define	R_SPARC_L44		52
+#define	R_SPARC_REGISTER	53
+#define	R_SPARC_UA64		54
+#define	R_SPARC_UA16		55
+#define	R_SPARC_TLS_GD_HI22	56
+#define	R_SPARC_TLS_GD_LO10	57
+#define	R_SPARC_TLS_GD_ADD	58
+#define	R_SPARC_TLS_GD_CALL	59
+#define	R_SPARC_TLS_LDM_HI22	60
+#define	R_SPARC_TLS_LDM_LO10	61
+#define	R_SPARC_TLS_LDM_ADD	62
+#define	R_SPARC_TLS_LDM_CALL	63
+#define	R_SPARC_TLS_LDO_HIX22	64
+#define	R_SPARC_TLS_LDO_LOX10	65
+#define	R_SPARC_TLS_LDO_ADD	66
+#define	R_SPARC_TLS_IE_HI22	67
+#define	R_SPARC_TLS_IE_LO10	68
+#define	R_SPARC_TLS_IE_LD	69
+#define	R_SPARC_TLS_IE_LDX	70
+#define	R_SPARC_TLS_IE_ADD	71
+#define	R_SPARC_TLS_LE_HIX22	72
+#define	R_SPARC_TLS_LE_LOX10	73
+#define	R_SPARC_TLS_DTPMOD32	74
+#define	R_SPARC_TLS_DTPMOD64	75
+#define	R_SPARC_TLS_DTPOFF32	76
+#define	R_SPARC_TLS_DTPOFF64	77
+#define	R_SPARC_TLS_TPOFF32	78
+#define	R_SPARC_TLS_TPOFF64	79
+
+#define	R_X86_64_NONE		0	/* No relocation. */
+#define	R_X86_64_64		1	/* Add 64 bit symbol value. */
+#define	R_X86_64_PC32		2	/* PC-relative 32 bit signed sym value. */
+#define	R_X86_64_GOT32		3	/* PC-relative 32 bit GOT offset. */
+#define	R_X86_64_PLT32		4	/* PC-relative 32 bit PLT offset. */
+#define	R_X86_64_COPY		5	/* Copy data from shared object. */
+#define	R_X86_64_GLOB_DAT	6	/* Set GOT entry to data address. */
+#define	R_X86_64_JMP_SLOT	7	/* Set GOT entry to code address. */
+#define	R_X86_64_RELATIVE	8	/* Add load address of shared object. */
+#define	R_X86_64_GOTPCREL	9	/* Add 32 bit signed pcrel offset to GOT. */
+#define	R_X86_64_32		10	/* Add 32 bit zero extended symbol value */
+#define	R_X86_64_32S		11	/* Add 32 bit sign extended symbol value */
+#define	R_X86_64_16		12	/* Add 16 bit zero extended symbol value */
+#define	R_X86_64_PC16		13	/* Add 16 bit signed extended pc relative symbol value */
+#define	R_X86_64_8		14	/* Add 8 bit zero extended symbol value */
+#define	R_X86_64_PC8		15	/* Add 8 bit signed extended pc relative symbol value */
+#define	R_X86_64_DTPMOD64	16	/* ID of module containing symbol */
+#define	R_X86_64_DTPOFF64	17	/* Offset in TLS block */
+#define	R_X86_64_TPOFF64	18	/* Offset in static TLS block */
+#define	R_X86_64_TLSGD		19	/* PC relative offset to GD GOT entry */
+#define	R_X86_64_TLSLD		20	/* PC relative offset to LD GOT entry */
+#define	R_X86_64_DTPOFF32	21	/* Offset in TLS block */
+#define	R_X86_64_GOTTPOFF	22	/* PC relative offset to IE GOT entry */
+#define	R_X86_64_TPOFF32	23	/* Offset in static TLS block */
+#define	R_X86_64_IRELATIVE	37
+
+#define	R_390_NONE		0
+#define	R_390_8			1
+#define	R_390_12		2
+#define	R_390_16		3
+#define	R_390_32		4
+#define	R_390_PC32		5
+#define	R_390_GOT12		6
+#define	R_390_GOT32		7
+#define	R_390_PLT32		8
+#define	R_390_COPY		9
+#define	R_390_GLOB_DAT		10
+#define	R_390_JMP_SLOT		11
+#define	R_390_RELATIVE		12
+#define	R_390_GOTOFF		13
+#define	R_390_GOTPC		14
+#define	R_390_GOT16		15
+#define	R_390_PC16		16
+#define	R_390_PC16DBL		17
+#define	R_390_PLT16DBL		18
+#define	R_390_PC32DBL		19
+#define	R_390_PLT32DBL		20
+#define	R_390_GOTPCDBL		21
+#define	R_390_64		22
+#define	R_390_PC64		23
+#define	R_390_GOT64		24
+#define	R_390_PLT64		25
+#define	R_390_GOTENT		26
+
+#endif /* !_SYS_ELF_COMMON_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/object_container.h
@@ -0,0 +1,188 @@
+#ifndef _OBJECT_CONTAINER_H_
+#define _OBJECT_CONTAINER_H_
+
+#include "std_types.h"
+#include "assert.h"
+#include <stdlib.h>
+
+
+#define OBJECT_CONTAINER_OBJ_DEFAULT_SIZE	4U
+typedef struct {
+	char 	data[OBJECT_CONTAINER_OBJ_DEFAULT_SIZE];
+} ObjectType;
+
+typedef struct {
+	void 	*p;
+} ObjectSortElementType;
+
+typedef struct {
+	/*
+	 * num of using objects
+	 */
+	uint32		num_using_objects;
+	/*
+	 * num of objects including preallocation
+	 */
+	uint32		num_total_objects;
+	/*
+	 * num of append objects if no data.
+	 */
+	uint32		append_size;
+	/*
+	 * object size
+	 */
+	uint32		object_size;
+	/*
+	 * head
+	 */
+	ObjectType	*head;
+} ObjectContainerType;
+
+
+/*********************************************
+ * private
+ *********************************************/
+static inline uint32 object_container_get_element_size(ObjectContainerType *container)
+{
+	uint32 obj_size = sizeof(ObjectType);
+
+	if (container->object_size > OBJECT_CONTAINER_OBJ_DEFAULT_SIZE) {
+		obj_size += (container->object_size) - OBJECT_CONTAINER_OBJ_DEFAULT_SIZE;
+	}
+	return obj_size;
+}
+
+static inline void object_container_expand(ObjectContainerType *container)
+{
+	void *new_ptr;
+	uint32 obj_size = object_container_get_element_size(container);
+
+	container->num_total_objects += container->append_size;
+	new_ptr = realloc(container->head, (container->num_total_objects) * obj_size);
+	ASSERT(new_ptr != NULL);
+	container->head = new_ptr;
+
+	return;
+}
+
+/*********************************************
+ * public
+ *********************************************/
+static inline ObjectContainerType *object_container_create(uint32 object_size, uint32 append_array_size)
+{
+	ObjectContainerType *p = (ObjectContainerType*)malloc(sizeof(ObjectContainerType));
+	ASSERT(p != NULL);
+	p->num_using_objects = 0;
+	p->num_total_objects = 0;
+	p->object_size = object_size;
+	p->append_size = append_array_size;
+	p->head = NULL;
+	return p;
+}
+
+static inline void *object_container_get_element(ObjectContainerType *container, uint32 index)
+{
+	char *p = (char*)(container->head);
+	ObjectType *obj;
+	uint32 obj_size = object_container_get_element_size(container);
+	if (index >= container->num_using_objects) {
+		return NULL;
+	}
+	p += (index * obj_size);
+	obj = (ObjectType*)p;
+
+	return &obj->data[0];
+}
+
+static inline void *object_container_create_element(ObjectContainerType *container)
+{
+	if (container->num_using_objects < container->num_total_objects) {
+		container->num_using_objects++;
+		return object_container_get_element(container, container->num_using_objects - 1);
+	}
+	object_container_expand(container);
+	container->num_using_objects++;
+	return object_container_get_element(container, container->num_using_objects - 1);
+}
+
+static inline ObjectContainerType *object_container_sort(ObjectContainerType *container, bool (*object_compare) (const ObjectSortElementType *obj1, const ObjectSortElementType *obj2))
+{
+	uint32 index;
+	bool isSwap = FALSE;
+	ObjectContainerType *sort_array;
+
+	sort_array = object_container_create(sizeof(ObjectSortElementType), 4U);
+
+	//copy org container ==> sort_array
+	for (index = 0; index < container->num_using_objects; index++) {
+		void *p = object_container_get_element(container, index);
+		ObjectSortElementType *obj = (ObjectSortElementType*)object_container_create_element(sort_array);
+		obj->p = p;
+	}
+
+	//do bubble sort
+	do {
+		isSwap = FALSE;
+		for (index = 0; index < sort_array->num_using_objects - 1; index++) {
+			ObjectSortElementType *obj1 = (ObjectSortElementType*)object_container_get_element(sort_array, index);
+			ObjectSortElementType *obj2 = (ObjectSortElementType*)object_container_get_element(sort_array, index + 1);
+			if (object_compare((const ObjectSortElementType *)obj1, (const ObjectSortElementType *)obj2)) {
+				void *org1 = obj1->p;
+				void *org2 = obj2->p;
+				obj1->p = org2;
+				obj2->p = org1;
+				isSwap = TRUE;
+			}
+		}
+	} while (isSwap == TRUE);
+
+	return sort_array;
+}
+
+static inline void object_container_foreach(ObjectContainerType *container, void (*object_action) (const void *p))
+{
+	uint32 index;
+	for (index = 0; index < container->num_using_objects; index++) {
+		void *p = object_container_get_element(container, index);
+		object_action(p);
+	}
+	return;
+}
+
+static inline void *object_container_find_first(ObjectContainerType *container, bool (*object_filter) (const void *p))
+{
+	uint32 index;
+	for (index = 0; index < container->num_using_objects; index++) {
+		void *p = object_container_get_element(container, index);
+		if (object_filter(p) == TRUE) {
+			return p;
+		}
+	}
+	return NULL;
+}
+static inline void *object_container_find_first2(ObjectContainerType *container, bool (*object_filter) (const void *p, const void *arg), const void *arg)
+{
+	uint32 index;
+	for (index = 0; index < container->num_using_objects; index++) {
+		void *p = object_container_get_element(container, index);
+		if (object_filter(p, arg) == TRUE) {
+			return p;
+		}
+	}
+	return NULL;
+}
+
+
+static inline void object_container_delete(ObjectContainerType *container)
+{
+	if (container == NULL) {
+		return;
+	}
+	if (container->head != NULL) {
+		free(container->head);
+		container->head = NULL;
+	}
+	free(container);
+}
+
+#endif /* _OBJECT_CONTAINER_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/symbol_ops.c
@@ -0,0 +1,250 @@
+#include "cpuemu_config.h"
+#include "symbol_ops.h"
+#include "std_types.h"
+#include "assert.h"
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+static uint32 symbolc_func_max_num = 0;
+static uint32 symbolc_gl_max_num = 0;
+
+static uint32 symbol_func_size = 0;
+static uint32 symbol_gl_size = 0;
+static DbgSymbolType *symbol_func;
+static DbgSymbolType *symbol_gl;
+
+uint32 symbol_get_func_num(void)
+{
+	return symbol_func_size;
+}
+uint32 symbol_get_gl_num(void)
+{
+	return symbol_gl_size;
+}
+int symbol_gl_add(DbgSymbolType *sym)
+{
+	if (symbol_gl_size >= symbolc_gl_max_num) {
+		symbolc_gl_max_num += CPUEMU_CONFIG_OBJECT_SYMBOL_TABLE_NUM;
+		symbol_gl = realloc(symbol_gl, symbolc_gl_max_num * sizeof(DbgSymbolType));
+		ASSERT(symbol_gl != NULL);
+	}
+	symbol_gl[symbol_gl_size] = *sym;
+	symbol_gl_size++;
+	return 0;
+}
+
+int symbol_func_add(DbgSymbolType *sym)
+{
+	if (symbol_func_size >= symbolc_func_max_num) {
+		symbolc_func_max_num += CPUEMU_CONFIG_OBJECT_SYMBOL_TABLE_NUM;
+		symbol_func = realloc(symbol_func, symbolc_func_max_num * sizeof(DbgSymbolType));
+		ASSERT(symbol_func != NULL);
+	}
+	symbol_func[symbol_func_size] = *sym;
+	symbol_func_size++;
+	return 0;
+}
+
+
+int symbol_get_func(char *funcname, uint32 func_len, uint32 *addrp, uint32 *size)
+{
+	int i;
+	uint32 len;
+
+	for (i = 0; i < symbol_func_size; i++) {
+		len = strlen(symbol_func[i].name);
+
+		if (func_len != len) {
+			continue;
+		}
+		if (strncmp(funcname, symbol_func[i].name, func_len) != 0) {
+			continue;
+		}
+		*addrp = symbol_func[i].addr;
+		*size = symbol_func[i].size;
+		return 0;
+	}
+	return -1;
+}
+char * symbol_pc2func(uint32 pc)
+{
+	int i;
+
+	for (i = 0; i < symbol_func_size; i++) {
+		if (pc < symbol_func[i].addr) {
+			continue;
+		}
+		if (pc >= (symbol_func[i].addr + symbol_func[i].size)) {
+			continue;
+		}
+		return  symbol_func[i].name;
+	}
+	return NULL;
+}
+void symbol_set_pc(int funcid, uint32 core_id, uint32 sp)
+{
+	symbol_func[funcid].enter_sp[core_id] = sp;
+	return;
+}
+uint32 symbol_get_entered_sp(int funcid, uint32 core_id)
+{
+	return symbol_func[funcid].enter_sp[core_id];
+}
+
+int symbol_pc2funcid(uint32 pc, uint32 *funcaddr)
+{
+	int i;
+	static int last_funcid = -1;
+
+	if (last_funcid > 0) {
+		if ((pc >= symbol_func[last_funcid].addr) &&
+				(pc < (symbol_func[last_funcid].addr + symbol_func[last_funcid].size))) {
+			*funcaddr = symbol_func[last_funcid].addr;
+			return last_funcid;
+		}
+	}
+
+	for (i = 0; i < symbol_func_size; i++) {
+		if (pc < symbol_func[i].addr) {
+			continue;
+		}
+		if (pc >= (symbol_func[i].addr + symbol_func[i].size)) {
+			continue;
+		}
+		*funcaddr = symbol_func[i].addr;
+		last_funcid = i;
+		return  i;
+	}
+	return -1;
+}
+char * symbol_funcid2funcname(int id)
+{
+	if (id < 0) {
+		return "unknown";
+	}
+	return symbol_func[id].name;
+}
+uint32 symbol_funcid2funcaddr(int id)
+{
+	return symbol_func[id].addr;
+}
+uint32 symbol_funcid2funcsize(int id)
+{
+	return symbol_func[id].size;
+}
+
+
+int symbol_get_gl(char *gl_name, uint32 gl_len, uint32 *addrp, uint32 *size)
+{
+	int i;
+	uint32 len;
+
+	for (i = 0; i < symbol_gl_size; i++) {
+		len = strlen(symbol_gl[i].name);
+
+		if (gl_len != len) {
+			continue;
+		}
+		if (strncmp(gl_name, symbol_gl[i].name, gl_len) != 0) {
+			continue;
+		}
+		*addrp = symbol_gl[i].addr;
+		*size = symbol_gl[i].size;
+		return i;
+	}
+	return -1;
+}
+
+int symbol_addr2glid(uint32 addr, uint32 *gladdr)
+{
+	int i;
+	static int last_funcid = -1;
+
+	if (last_funcid > 0) {
+		if ((addr >= symbol_gl[last_funcid].addr) &&
+				(addr < (symbol_gl[last_funcid].addr + symbol_gl[last_funcid].size))) {
+			*gladdr = symbol_gl[last_funcid].addr;
+			return last_funcid;
+		}
+	}
+
+	for (i = 0; i < symbol_gl_size; i++) {
+		if (addr < symbol_gl[i].addr) {
+			continue;
+		}
+		if (addr >= (symbol_gl[i].addr + symbol_gl[i].size)) {
+			continue;
+		}
+		*gladdr = symbol_gl[i].addr;
+		last_funcid = i;
+		return  i;
+	}
+	return -1;
+
+}
+
+char * symbol_glid2glname(int id)
+{
+	return symbol_gl[id].name;
+}
+
+uint32 symbol_glid2gladdr(int id)
+{
+	return symbol_gl[id].addr;
+}
+
+void symbol_print_gl(char *gl_name, uint32 show_num)
+{
+	int i;
+	uint32 len;
+	uint32 gl_len;
+
+	gl_len = strlen(gl_name);
+	for (i = 0; i < symbol_gl_size; i++) {
+		len = strlen(symbol_gl[i].name);
+		if (len < gl_len) {
+			continue;
+		}
+
+		if (strncmp(gl_name, symbol_gl[i].name, gl_len) != 0) {
+			continue;
+		}
+		if (show_num > 0) {
+			printf("candidate %s\n", symbol_gl[i].name);
+			show_num--;
+		}
+		else {
+			break;
+		}
+	}
+	return;
+}
+
+
+void symbol_print_func(char *gl_name, uint32 show_num)
+{
+	int i;
+	uint32 len;
+	uint32 gl_len;
+
+	gl_len = strlen(gl_name);
+	for (i = 0; i < symbol_func_size; i++) {
+		len = strlen(symbol_func[i].name);
+		if (len < gl_len) {
+			continue;
+		}
+
+		if (strncmp(gl_name, symbol_func[i].name, gl_len) != 0) {
+			continue;
+		}
+		if (show_num > 0) {
+			printf("candidate %s\n", symbol_func[i].name);
+			show_num--;
+		}
+		else {
+			break;
+		}
+	}
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/symbol_ops.h
@@ -0,0 +1,41 @@
+#ifndef _SYMBOL_OPS_H_
+#define _SYMBOL_OPS_H_
+
+#include "std_types.h"
+#include "cpu_config.h"
+
+typedef struct {
+	char *name;
+	uint32 addr;
+	uint32 size;
+	uint32 enter_sp[CPU_CONFIG_CORE_NUM];
+} DbgSymbolType;
+
+extern uint32 symbol_get_func_num(void);
+extern uint32 symbol_get_gl_num(void);
+
+extern int symbol_get_func(char *funcname, uint32 func_len, uint32 *addrp, uint32 *size);
+extern char * symbol_pc2func(uint32 pc);
+extern int symbol_pc2funcid(uint32 pc, uint32 *funcaddr);
+extern char * symbol_funcid2funcname(int id);
+extern uint32 symbol_funcid2funcaddr(int id);
+extern int symbol_get_gl(char *gl_name, uint32 gl_len, uint32 *addrp, uint32 *size);
+
+extern int symbol_addr2glid(uint32 addr, uint32 *gladdr);
+extern char * symbol_glid2glname(int id);
+extern uint32 symbol_glid2gladdr(int id);
+
+extern void symbol_print_gl(char *gl_name, uint32 show_num);
+extern void symbol_print_func(char *gl_name, uint32 show_num);
+
+
+extern int symbol_gl_add(DbgSymbolType *sym);
+extern int symbol_func_add(DbgSymbolType *sym);
+extern uint32 symbol_funcid2funcsize(int id);
+
+
+extern uint32 symbol_get_entered_sp(int funcid, uint32 core_id);
+extern void symbol_set_pc(int funcid, uint32 core_id, uint32 sp);
+
+
+#endif /* _SYMBOL_OPS_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/target/target_os_api.h
@@ -0,0 +1,90 @@
+#ifndef _TARGET_OS_API_H_
+#define _TARGET_OS_API_H_
+
+#ifdef OS_LINUX
+//#define  __USE_GNU
+/*
+ * Sleep
+ */
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#include <sys/ioctl.h>
+
+#define target_os_api_sleep(arg) usleep((arg)*1000)
+#define winsock_init()
+#define winsock_fini()
+#ifdef OS_MAC
+#define PRINT_FMT_UINT64    "%llu"
+#define FMT_UINT64    "llu"
+#define FMT_SINT64    "lld"
+#define PRINT_FMT_SINT64    "%lld"
+#ifndef SOCK_NONBLOCK
+#define SOCK_NONBLOCK O_NONBLOCK
+#endif
+#else
+#define PRINT_FMT_UINT64	"%Lu"
+#define FMT_UINT64	"Lu"
+#define FMT_SINT64	"Ld"
+#define PRINT_FMT_SINT64	"%Ld"
+#endif /* OS_MAC */
+#define target_os_api_sockaddr_type	sockaddr_in
+#define target_os_api_closesocket	close
+#define target_os_api_ioctlsock		ioctl
+
+#define target_os_sockaddr_sin_addr	s_addr
+
+#define target_os_api_open_ctw(filepath, mode)	open((filepath), O_CREAT | O_TRUNC |O_WRONLY, (mode))
+#define target_os_api_open_aw(filepath)	open((filepath), O_APPEND |O_WRONLY)
+#define target_os_api_open_w(filepath)	open((filepath), O_WRONLY)
+#define target_os_api_open_r(filepath)	open((filepath), O_RDONLY)
+
+/*
+ * Winsock
+ */
+#define TARGET_OS_SOCKET_TYPE	int
+#else
+#include <windows.h>
+#include <winsock2.h>
+/*
+ * Winsock
+ */
+#include "winsock_wrapper/winsock_wrapper.h"
+#define TARGET_OS_SOCKET_TYPE	SOCKET
+#define target_os_api_sockaddr_type	sockaddr_in
+
+
+/*
+ * Sleep
+ */
+#define target_os_api_sleep(arg) Sleep(arg)
+#define PRINT_FMT_UINT64	"%I64u"
+#define FMT_UINT64	"I64u"
+#define PRINT_FMT_SINT64	"%I64d"
+#define FMT_SINT64	"I64d"
+#define target_os_api_open_ctw(filepath, mode)	open((filepath), O_CREAT | O_TRUNC |O_WRONLY | O_BINARY, (mode))
+#define target_os_api_open_aw(filepath)	open((filepath), O_APPEND |O_WRONLY | O_BINARY)
+#define target_os_api_open_w(filepath)	open((filepath), O_WRONLY | O_BINARY)
+#define target_os_api_open_r(filepath)	open((filepath), O_RDONLY | O_BINARY)
+#define target_os_api_closesocket	closesocket
+#define target_os_sockaddr_sin_addr	S_un.S_addr
+
+//#define target_os_api_ioctlsock		ioctlsock
+static inline void target_os_api_ioctlsock(SOCKET sock, int flag, unsigned long *valp) 
+{
+	ioctlsocket(sock, flag, valp);
+}
+#endif /* OS_LINUX */
+/*
+ * File I/O
+ */
+
+
+
+
+#endif /* _TARGET_OS_API_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/tcp/tcp_client.c
@@ -0,0 +1,54 @@
+#include "tcp/tcp_client.h"
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <errno.h>
+#include <stdio.h>
+#include <string.h>
+
+Std_ReturnType tcp_client_create(const TcpClientConfigType *config, TcpClientType *client)
+{
+	int ret;
+
+    client->connection.connected = FALSE;
+    ret = tcp_socket_open(&client->connection.socket);
+    if (ret != STD_E_OK) {
+    	return ret;
+    }
+    client->config.server_port = config->server_port;
+    client->config.ipaddr = config->ipaddr;
+	return STD_E_OK;
+}
+
+Std_ReturnType tcp_client_connect(TcpClientType *client)
+{
+	uint32 ipaddr;
+	int ret;
+	struct sockaddr_in addr;
+
+    ret = tcp_inet_get_ipaddr(client->config.ipaddr, &ipaddr);
+    if (ret != STD_E_OK) {
+    	return ret;
+    }
+
+    memset(&addr, 0, sizeof(struct sockaddr_in));
+    addr.sin_family = AF_INET;
+    addr.sin_port = htons(client->config.server_port);
+    addr.sin_addr.s_addr = htonl(ipaddr);
+
+    ret = connect(client->connection.socket.fd, (struct sockaddr*)&addr, sizeof(struct sockaddr_in));
+    if (ret < 0) {
+		printf("%s %s() %u errno=%d\n", __FILE__, __FUNCTION__, __LINE__,  errno);
+		return STD_E_NOENT;
+    }
+    client->connection.connected = TRUE;
+    return STD_E_OK;
+}
+
+void tcp_client_close(TcpClientType *client)
+{
+	if (client != NULL) {
+		tcp_socket_close(&client->connection.socket);
+	}
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/tcp/tcp_client.h
@@ -0,0 +1,21 @@
+#ifndef _TCP_CLIENT_H_
+#define _TCP_CLIENT_H_
+
+#include "tcp_connection.h"
+
+typedef struct {
+	const char* ipaddr;
+	uint16	server_port;
+} TcpClientConfigType;
+
+typedef struct {
+	TcpClientConfigType		config;
+	TcpConnectionType		connection;
+} TcpClientType;
+
+
+extern Std_ReturnType tcp_client_create(const TcpClientConfigType *config, TcpClientType *client);
+extern Std_ReturnType tcp_client_connect(TcpClientType *client);
+extern void tcp_client_close(TcpClientType *server);
+
+#endif /* _TCP_CLIENT_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/tcp/tcp_connection.c
@@ -0,0 +1,98 @@
+#include "tcp_connection.h"
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <errno.h>
+#include <stdio.h>
+
+Std_ReturnType tcp_connection_send(TcpConnectionType *connection, const char *data, uint32 size, uint32 *res)
+{
+	ssize_t snd_size;
+
+	*res = 0;
+	snd_size = send(connection->socket.fd, data, size, 0);
+	if (snd_size < 0) {
+		printf("ERROR: tcp_connection_send() errno=%d\n", errno);
+		connection->connected = FALSE;
+		return STD_E_NOENT;
+	}
+	else if (snd_size == 0) {
+		connection->connected = FALSE;
+		return STD_E_NOENT;
+	}
+	*res = snd_size;
+	return STD_E_OK;
+}
+Std_ReturnType tcp_connection_send_nblk(TcpConnectionType *connection, const char *data, uint32 size, uint32 *res)
+{
+	ssize_t snd_size;
+
+	*res = 0;
+	snd_size = send(connection->socket.fd, data, size, MSG_DONTWAIT);
+	if (snd_size < 0) {
+		if (errno != EAGAIN) {
+			printf("ERROR: tcp_connection_send() errno=%d\n", errno);
+			connection->connected = FALSE;
+		}
+		return STD_E_NOENT;
+	}
+	else if (snd_size == 0) {
+		connection->connected = FALSE;
+		return STD_E_NOENT;
+	}
+	*res = snd_size;
+	return STD_E_OK;
+}
+
+Std_ReturnType tcp_connection_receive_nblk(TcpConnectionType *connection, char *data, uint32 size, uint32 *res)
+{
+	ssize_t rcv_size;
+	*res = 0;
+	rcv_size = recv(connection->socket.fd, data, size, MSG_DONTWAIT);
+	if (rcv_size < 0) {
+		if (errno != EAGAIN) {
+			printf("ERROR: tcp_connection_receive() errno=%d\n", errno);
+			connection->connected = FALSE;
+		}
+		return STD_E_NOENT;
+	}
+	else if (rcv_size == 0) {
+		connection->connected = FALSE;
+		return STD_E_NOENT;
+	}
+	*res = rcv_size;
+	return STD_E_OK;
+}
+
+Std_ReturnType tcp_connection_receive(TcpConnectionType *connection, char *data, uint32 size, uint32 *res)
+{
+	ssize_t rcv_size;
+	*res = 0;
+	rcv_size = recv(connection->socket.fd, data, size, 0);
+	if (rcv_size < 0) {
+		printf("ERROR: tcp_connection_receive() errno=%d\n", errno);
+		connection->connected = FALSE;
+		return STD_E_NOENT;
+	}
+	else if (rcv_size == 0) {
+		connection->connected = FALSE;
+		return STD_E_NOENT;
+	}
+	*res = rcv_size;
+#if 0
+	{
+		uint32 i;
+		for (i = 0; i < rcv_size; i++) {
+			printf("buf[%u]=%c\n", i, data[i]);
+		}
+	}
+#endif
+	return STD_E_OK;
+}
+
+void tcp_connection_close(TcpConnectionType *connection)
+{
+	if (connection != NULL) {
+		tcp_socket_close(&connection->socket);
+	}
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/tcp/tcp_connection.h
@@ -0,0 +1,17 @@
+#ifndef _TCP_CONNECTION_H_
+#define _TCP_CONNECTION_H_
+
+#include "tcp_socket.h"
+
+typedef struct {
+	TcpSocketType	socket;
+	bool			connected;
+} TcpConnectionType;
+
+extern Std_ReturnType tcp_connection_send(TcpConnectionType *connection, const char *data, uint32 size, uint32 *res);
+extern Std_ReturnType tcp_connection_receive(TcpConnectionType *connection, char *data, uint32 size, uint32 *res);
+extern Std_ReturnType tcp_connection_send_nblk(TcpConnectionType *connection, const char *data, uint32 size, uint32 *res);
+extern Std_ReturnType tcp_connection_receive_nblk(TcpConnectionType *connection, char *data, uint32 size, uint32 *res);
+extern void tcp_connection_close(TcpConnectionType *connection);
+
+#endif /* _TCP_CONNECTION_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/tcp/tcp_server.c
@@ -0,0 +1,60 @@
+#include "tcp/tcp_server.h"
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <errno.h>
+#include <stdio.h>
+#include <string.h>
+
+Std_ReturnType tcp_server_create(const TcpServerConfigType *config, TcpServerType *server)
+{
+	int ret;
+	struct sockaddr_in addr;
+
+    ret = tcp_socket_open(&server->socket);
+    if (ret != STD_E_OK) {
+    	return ret;
+    }
+
+    memset(&addr, 0, sizeof(struct sockaddr_in));
+    addr.sin_family = AF_INET;
+    addr.sin_port = htons(config->server_port);
+    addr.sin_addr.s_addr = htonl(INADDR_ANY);
+    server->config.server_port = config->server_port;
+
+    ret = bind(server->socket.fd, (struct sockaddr*)&addr, sizeof(struct sockaddr_in));
+    if (ret < 0) {
+		printf("%s %s() %u errno=%d\n", __FILE__, __FUNCTION__, __LINE__,  errno);
+		return STD_E_NOENT;
+    }
+    ret = listen(server->socket.fd, 10);
+    if (ret < 0) {
+		printf("%s %s() %u errno=%d\n", __FILE__, __FUNCTION__, __LINE__,  errno);
+		return STD_E_NOENT;
+    }
+
+	return STD_E_OK;
+}
+
+Std_ReturnType tcp_server_accept(const TcpServerType *server, TcpConnectionType *connection)
+{
+	struct sockaddr_in addr;
+    socklen_t len = sizeof(struct sockaddr_in);
+
+	//printf("tcp_server_accept: fd=%d\n", server->socket.fd);
+    connection->socket.fd = accept(server->socket.fd, (struct sockaddr *)&addr, &len);
+    if (connection->socket.fd < 0) {
+		printf("%s %s() %u ret=%d\n", __FILE__, __FUNCTION__, __LINE__,  errno);
+		return STD_E_NOENT;
+    }
+    connection->connected = TRUE;
+	return STD_E_OK;
+}
+
+void tcp_server_close(TcpServerType *server)
+{
+	if (server != NULL) {
+		tcp_socket_close(&server->socket);
+	}
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/tcp/tcp_server.h
@@ -0,0 +1,20 @@
+#ifndef _TCP_SERVER_H_
+#define _TCP_SERVER_H_
+
+#include "tcp_connection.h"
+
+typedef struct {
+	uint16	server_port;
+} TcpServerConfigType;
+
+typedef struct {
+	TcpServerConfigType		config;
+	TcpSocketType			socket;
+} TcpServerType;
+
+
+extern Std_ReturnType tcp_server_create(const TcpServerConfigType *config, TcpServerType *server);
+extern Std_ReturnType tcp_server_accept(const TcpServerType *server, TcpConnectionType *connection);
+extern void tcp_server_close(TcpServerType *server);
+
+#endif /* _TCP_SERVER_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/tcp/tcp_socket.c
@@ -0,0 +1,53 @@
+#include "tcp_socket.h"
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include <stdio.h>
+#include <errno.h>
+#include <string.h>
+
+Std_ReturnType tcp_socket_open(TcpSocketType *sock)
+{
+	sock->fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+	if (sock->fd < 0) {
+		printf("%s %s() %u errno=%d\n", __FILE__, __FUNCTION__, __LINE__,  errno);
+		return STD_E_INVALID;
+	}
+	//printf("tcp_socket_open: fd=%d\n", sock->fd);
+	return STD_E_OK;
+}
+
+void tcp_socket_close(TcpSocketType *socket)
+{
+	if (socket->fd >= 0) {
+		close(socket->fd);
+		socket->fd = -1;
+	}
+	return;
+}
+
+Std_ReturnType tcp_inet_get_ipaddr(const char *hostname, uint32 *ipaddr)
+{
+	sint32 result;
+	uint8 addr_array[5];
+    uint8 *paddr = addr_array;
+
+    result = sscanf(hostname, "%hhu.%hhu.%hhu.%hhu",
+    		(uint8*)&addr_array[3],
+			(uint8*)&addr_array[2],
+			(uint8*)&addr_array[1],
+			(uint8*)&addr_array[0]);
+
+    if (result != 4) {
+    	 struct hostent *host_address = gethostbyname(hostname);
+        if (host_address == NULL) {
+    		printf("%s %s() %u ret=%d", __FILE__, __FUNCTION__, __LINE__, STD_E_INVALID);
+        	return STD_E_INVALID;
+        }
+        paddr = (uint8*)host_address->h_addr_list[0];
+    }
+    memcpy((void*)ipaddr, (void*)paddr, 4U);
+    return STD_E_OK;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/tcp/tcp_socket.h
@@ -0,0 +1,15 @@
+#ifndef _TCP_SOCKET_H_
+#define _TCP_SOCKET_H_
+
+#include "std_types.h"
+#include "std_errno.h"
+
+typedef struct {
+	int fd;
+} TcpSocketType;
+
+extern Std_ReturnType tcp_socket_open(TcpSocketType *socket);
+extern void tcp_socket_close(TcpSocketType *socket);
+extern Std_ReturnType tcp_inet_get_ipaddr(const char *hostname, uint32 *ipaddr);
+
+#endif /* _TCP_SOCKET_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/token.c
@@ -0,0 +1,219 @@
+#include "token.h"
+#include "std_errno.h"
+#include "std_types.h"
+#include "assert.h"
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+
+bool token_strcmp(const TokenStringType *str1, const TokenStringType *str2)
+{
+	if (str1->len != str2->len) {
+		return FALSE;
+	}
+	if (strncmp((const char*)str1->str, (const char*)str2->str, str1->len) != 0) {
+		return FALSE;
+	}
+	return TRUE;
+}
+
+/*
+ * デミリタ=空白,",",":"
+ */
+static bool is_delimiter(char c, char *ex_c)
+{
+	if (isspace(c)) {
+		return TRUE;
+	}
+	else if (c == ',') {
+		return TRUE;
+	}
+	else if (c == ':') {
+		return TRUE;
+	}
+	else if (c == '\0') {
+		return TRUE;
+	}
+	else if ((ex_c != NULL) && c == *ex_c) {
+		return TRUE;
+	}
+	return FALSE;
+}
+
+static void set_token(TokenContainerType *token_container, TokenStringType *buffer)
+{
+	uint32 inx = token_container->num - 1;
+	buffer->str[buffer->len] = '\0';
+	char   *endptr;
+
+	long long ret64;
+	long ret32;
+
+	/*
+	 * 10進数チェック
+	 */
+	errno = 0;
+	ret32 = strtol((const char*)buffer->str, &endptr, 10);
+	if ((errno == 0) && (*endptr == '\0')) {
+		token_container->array[inx].type = TOKEN_TYPE_VALUE_DEC;
+		token_container->array[inx].body.dec.value = (uint32)ret32;
+		return;
+	}
+	/*
+	 * 16進数チェック
+	 */
+	if ((buffer->len > 2) && buffer->str[0] == '0' && buffer->str[1] == 'x') {
+		errno = 0;
+		ret64 = strtoull((const char*)buffer->str, &endptr, 16);
+		if ((errno == 0) && (*endptr == '\0')) {
+			token_container->array[inx].type = TOKEN_TYPE_VALUE_HEX;
+			token_container->array[inx].body.hex.value = (uint32)ret64;
+			return;
+		}
+	}
+	token_container->array[inx].type = TOKEN_TYPE_STRING;
+	token_container->array[inx].body.str = *buffer;
+	return;
+}
+
+typedef enum {
+	TOKEN_CHECK_STATE_DEMILITER = 0,
+	TOKEN_CHECK_STATE_CODE,
+} TokenCheckStateType;
+static Std_ReturnType token_split_common(TokenContainerType *token_container, uint8 *str, uint32 len, char *demiliter)
+{
+	uint32 i;
+	volatile TokenCheckStateType state;
+	TokenStringType buffer;
+
+	state = TOKEN_CHECK_STATE_DEMILITER;
+	buffer.len = 0;
+
+	token_container->num = 0;
+
+	for (i = 0; i < len; i++) {
+		switch (state) {
+		case TOKEN_CHECK_STATE_DEMILITER:
+			if (is_delimiter(str[i], demiliter) == TRUE) {
+				break;
+			}
+			if (token_container->num > TOKEN_CONTAINER_MAX_SIZE) {
+				return STD_E_INVALID;
+			}
+			token_container->num++;
+			buffer.str[buffer.len] = str[i];
+			buffer.len++;
+			if (i == (len - 1)) { //終端
+				set_token(token_container, &buffer);
+				buffer.len = 0;
+				state = TOKEN_CHECK_STATE_DEMILITER;
+				break;
+			}
+			state = TOKEN_CHECK_STATE_CODE;
+			break;
+		case TOKEN_CHECK_STATE_CODE:
+			if (is_delimiter(str[i], demiliter) == TRUE) {
+				set_token(token_container, &buffer);
+				buffer.len = 0;
+				state = TOKEN_CHECK_STATE_DEMILITER;
+				break;
+			}
+			if (buffer.len >= (TOKEN_STRING_MAX_SIZE - 1)) {
+				return STD_E_INVALID;
+			}
+			buffer.str[buffer.len] = str[i];
+			buffer.len++;
+			if (i == (len - 1)) { //終端
+				set_token(token_container, &buffer);
+				buffer.len = 0;
+				state = TOKEN_CHECK_STATE_DEMILITER;
+				break;
+			}
+			break;
+		default:
+			return STD_E_INVALID;
+		}
+	}
+
+	return STD_E_OK;
+}
+Std_ReturnType token_split(TokenContainerType *token_container, uint8 *str, uint32 len)
+{
+	return token_split_common(token_container, str, len, NULL);
+}
+Std_ReturnType token_split_with_delimiter(TokenContainerType *token_container, uint8 *str, uint32 len, char delimiter)
+{
+	return token_split_common(token_container, str, len, &delimiter);
+}
+
+
+bool token_split_merge(const TokenContainerType *token_container, uint8 start_index, TokenStringType *out)
+{
+	uint32 i;
+	TokenStringType tmp;
+
+	for (i = start_index; i < token_container->num; i++) {
+		switch (token_container->array[i].type) {
+		case TOKEN_TYPE_STRING:
+			tmp.len = sprintf((char*)&tmp.str[0], "%s ", (char*)token_container->array[i].body.str.str);
+			(void)token_merge(out, &tmp);
+			break;
+		case TOKEN_TYPE_VALUE_DEC:
+			tmp.len = sprintf((char*)&tmp.str[0], "%d ", token_container->array[i].body.dec.value);
+			(void)token_merge(out, &tmp);
+			break;
+		case TOKEN_TYPE_VALUE_HEX:
+			tmp.len = sprintf((char*)&tmp.str[0], "0x%x ", token_container->array[i].body.hex.value);
+			(void)token_merge(out, &tmp);
+			break;
+		default:
+			break;
+		}
+	}
+	return TRUE;
+}
+void token_trim_newline(TokenStringType *token)
+{
+	int i;
+	for (i = 0; i < token->len; i++) {
+		char c = token->str[i];
+		if (c == '\r') {
+			break;
+		}
+		else if (c == '\n') {
+			break;
+		}
+		else if (c == ' ') {
+			break;
+		}
+	}
+	token->len = i;
+	return;
+}
+
+
+
+bool token_merge(TokenStringType *dest, const TokenStringType *src)
+{
+	if ((dest->len + src->len) > (TOKEN_STRING_MAX_SIZE - 1)) {
+		return FALSE;
+	}
+	memcpy(&dest->str[dest->len], src->str,src->len);
+	dest->len += src->len;
+	dest->str[dest->len] = '\0';
+
+	return TRUE;
+}
+
+bool token_string_set(TokenStringType *dest, const char* src)
+{
+	uint32 len = strlen(src);
+	if (len > TOKEN_STRING_MAX_SIZE) {
+		return FALSE;
+	}
+	dest->len = strlen(src);
+	memcpy(dest->str, src, dest->len);
+	dest->str[dest->len] = '\0';
+	return TRUE;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/token.h
@@ -0,0 +1,53 @@
+#ifndef _TOKEN_H_
+#define _TOKEN_H_
+
+#include "std_types.h"
+
+typedef enum {
+	TOKEN_TYPE_VALUE_HEX,
+	TOKEN_TYPE_VALUE_DEC,
+	TOKEN_TYPE_STRING,
+	TOKEN_TYPE_UNKNOWN,
+} TokenEnumType;
+
+typedef struct {
+	uint32 value;
+} TokenValueHexType;
+
+typedef struct {
+	uint32 value;
+} TokenValueDecType;
+
+#define TOKEN_STRING_MAX_SIZE	4096
+typedef struct {
+	uint32 len;
+	uint8 str[TOKEN_STRING_MAX_SIZE];
+} TokenStringType;
+
+typedef struct {
+	TokenEnumType	type;
+	union {
+		TokenValueHexType	hex;
+		TokenValueDecType	dec;
+		TokenStringType		str;
+	} body;
+} TokenValueType;
+
+#define TOKEN_CONTAINER_MAX_SIZE	128
+typedef struct {
+	uint32	num;
+	TokenValueType	array[TOKEN_CONTAINER_MAX_SIZE];
+} TokenContainerType;
+
+extern Std_ReturnType token_split(TokenContainerType *token_container, uint8 *str, uint32 len);
+extern Std_ReturnType token_split_with_delimiter(TokenContainerType *token_container, uint8 *str, uint32 len, char delimiter);
+extern bool token_split_merge(const TokenContainerType *token_container, uint8 start_index, TokenStringType *out);
+extern void token_trim_newline(TokenStringType *token);
+
+extern bool token_string_set(TokenStringType *dest, const char* src);
+extern bool token_strcmp(const TokenStringType *str1, const TokenStringType *str2);
+extern bool token_merge(TokenStringType *dest, const TokenStringType *src);
+
+
+
+#endif /* _TOKEN_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/udp/udp_comm.c
@@ -0,0 +1,123 @@
+#include "udp_comm.h"
+
+#define UDP_COMM_BLOCKING		0
+#define UDP_COMM_NONBLOCKING	1
+
+Std_ReturnType udp_comm_create_ipaddr(const UdpCommConfigType *config, UdpCommType *comm, const char* my_ipaddr)
+{
+	int err;
+	struct target_os_api_sockaddr_type addr;
+	u_long val;
+
+	err = socket(AF_INET, SOCK_DGRAM, 0);
+	if (err < 0) {
+		return STD_E_INVALID;
+	}
+	comm->srv_sock = err;
+
+#ifdef ENABLE_REUSE_UDP_SOCKET
+	int yes = 1;
+	setsockopt(comm->srv_sock, SOL_SOCKET, SO_REUSEADDR, (const char *)&yes, sizeof(yes));	
+#endif
+
+	addr.sin_family = AF_INET;
+	addr.sin_port = htons(config->server_port);
+	if (my_ipaddr == NULL) {
+		addr.sin_addr.target_os_sockaddr_sin_addr = INADDR_ANY;
+	}
+	else {
+		addr.sin_addr.target_os_sockaddr_sin_addr = inet_addr(my_ipaddr);
+	}
+
+	err = bind(comm->srv_sock, (struct sockaddr *)&addr, sizeof(addr));
+	if (err < 0) {
+		return STD_E_INVALID;
+	}
+
+	if (!(config->is_wait)) {
+		val = UDP_COMM_NONBLOCKING;
+	}
+	else {
+		val = UDP_COMM_BLOCKING;
+	}
+	target_os_api_ioctlsock(comm->srv_sock, FIONBIO, &val);
+
+	comm->client_port = htons(config->client_port);
+
+	return STD_E_OK;
+}
+Std_ReturnType udp_comm_create(const UdpCommConfigType *config, UdpCommType *comm)
+{
+	return udp_comm_create_ipaddr(config, comm, NULL);
+}
+
+Std_ReturnType udp_comm_read(UdpCommType *comm)
+{
+	int err;
+
+	err = recv(comm->srv_sock, comm->read_data.buffer, sizeof(comm->read_data.buffer), 0);
+	if (err <= 0) {
+		return STD_E_INVALID;
+	}
+	comm->read_data.len = err;
+
+	return STD_E_OK;
+}
+
+Std_ReturnType udp_comm_write(UdpCommType *comm)
+{
+	int err;
+	struct target_os_api_sockaddr_type addr;
+
+	err = socket(AF_INET, SOCK_DGRAM, 0);
+	if (err < 0) {
+		return STD_E_INVALID;
+	}
+	comm->clt_sock = err;
+
+	addr.sin_family = AF_INET;
+	addr.sin_port = comm->client_port;
+	addr.sin_addr.target_os_sockaddr_sin_addr = inet_addr("127.0.0.1");
+
+	err = sendto(comm->clt_sock, comm->write_data.buffer, comm->write_data.len, 0,
+			(struct sockaddr *)&addr, sizeof(addr));
+	if (err != comm->write_data.len) {
+		return STD_E_INVALID;
+	}
+	target_os_api_closesocket(comm->clt_sock);
+	comm->clt_sock = -1;
+
+	return STD_E_OK;
+}
+Std_ReturnType udp_comm_remote_write(UdpCommType *comm, const char *remote_ipaddr)
+{
+	int err;
+	struct target_os_api_sockaddr_type addr;
+
+	err = socket(AF_INET, SOCK_DGRAM, 0);
+	if (err < 0) {
+		return STD_E_INVALID;
+	}
+	comm->clt_sock = err;
+
+	addr.sin_family = AF_INET;
+	addr.sin_port = comm->client_port;
+	addr.sin_addr.target_os_sockaddr_sin_addr = inet_addr(remote_ipaddr);
+
+	err = sendto(comm->clt_sock, comm->write_data.buffer, comm->write_data.len, 0,
+			(struct sockaddr *)&addr, sizeof(addr));
+	if (err != comm->write_data.len) {
+		return STD_E_INVALID;
+	}
+	target_os_api_closesocket(comm->clt_sock);
+	comm->clt_sock = -1;
+
+	return STD_E_OK;
+}
+
+void udp_server_delete(UdpCommType *comm)
+{
+	target_os_api_closesocket(comm->srv_sock);
+	comm->srv_sock = -1;
+	return;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/udp/udp_comm.h
@@ -0,0 +1,24 @@
+#ifndef _UDP_SERVER_H_
+#define _UDP_SERVER_H_
+
+#include "target/target_os_api.h"
+#include "udp_common.h"
+
+typedef struct {
+	TARGET_OS_SOCKET_TYPE 			srv_sock;
+	UdpBufferType	read_data;
+
+	uint32			client_port;
+	TARGET_OS_SOCKET_TYPE 			clt_sock;
+	UdpBufferType	write_data;
+} UdpCommType;
+
+extern Std_ReturnType udp_comm_create(const UdpCommConfigType *config, UdpCommType *comm);
+extern Std_ReturnType udp_comm_create_ipaddr(const UdpCommConfigType *config, UdpCommType *comm, const char* my_ipaddr);
+
+extern Std_ReturnType udp_comm_read(UdpCommType *comm);
+extern Std_ReturnType udp_comm_write(UdpCommType *comm);
+extern Std_ReturnType udp_comm_remote_write(UdpCommType *comm, const char *remote_ipaddr);
+extern void udp_server_delete(UdpCommType *comm);
+
+#endif /* _UDP_SERVER_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/udp/udp_common.h
@@ -0,0 +1,19 @@
+#ifndef _UDP_COMMON_H_
+#define _UDP_COMMON_H_
+
+#include "std_types.h"
+#include "std_errno.h"
+
+typedef struct {
+	uint16	server_port;
+	uint16	client_port;
+	bool	is_wait;
+} UdpCommConfigType;
+
+#define UDP_BUFFER_LEN	4096
+typedef struct {
+	int len;
+	char buffer[UDP_BUFFER_LEN];
+} UdpBufferType;
+
+#endif /* _UDP_COMMON_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/winsock_wrapper/winsock_wrapper.c
@@ -0,0 +1,22 @@
+#ifdef OS_LINUX
+#else
+#include "winsock_wrapper.h"
+
+int winsock_init(void)
+{
+	WSADATA wsaData;
+	int err;
+
+	err = WSAStartup(MAKEWORD(2,0), &wsaData);
+	if (err < 0) {
+		return -1;
+	}
+
+	return 0;
+}
+
+void winsock_fini(void)
+{
+	WSACleanup();
+}
+#endif
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/lib/winsock_wrapper/winsock_wrapper.h
@@ -0,0 +1,9 @@
+#ifndef _WINSOCK_H_
+#define _WINSOCK_H_
+
+#include <winsock2.h>
+
+extern int winsock_init(void);
+extern void winsock_fini(void);
+
+#endif /* _WINSOCK_H_ */
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/main/cpuemu.c
@@ -0,0 +1,1073 @@
+#include "cpu.h"
+#include "bus.h"
+#include "cpuemu_ops.h"
+#include "bus.h"
+#include "std_device_ops.h"
+#include "std_cpu_ops.h"
+#include "dbg_log.h"
+#include "cpu_control/dbg_cpu_control.h"
+#include "cpu_control/dbg_cpu_thread_control.h"
+#include "cpu_control/dbg_cpu_callback.h"
+#include "elf_section.h"
+#include "symbol_ops.h"
+#include "token.h"
+#include "file.h"
+#include <stdio.h>
+#include <time.h>
+#include <sys/time.h>
+#include "target/target_os_api.h"
+#include "option/option.h"
+#include <fcntl.h>
+#include <string.h>
+#ifdef OS_LINUX
+#include <sys/mman.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include "errno.h"
+#include <dlfcn.h>
+#endif /* OS_LINUX */
+#include "athrill_device.h"
+#include "assert.h"
+#include "athrill_exdev_header.h"
+
+static DeviceClockType cpuemu_dev_clock;
+std_bool private_cpuemu_is_cui_mode = FALSE;
+static uint64 cpuemu_cpu_end_clock = -1LLU;
+static void cpuemu_env_parse_devcfg_string(TokenStringType* strp);
+
+Std_ReturnType cpuemu_symbol_set(void)
+{
+	uint32 i;
+	uint32 num;
+	Std_ReturnType err;
+	DbgSymbolType sym;
+	ElfSymbolType elfsym;
+	bool disable_underscore = FALSE;
+	uint32 name_index = 1U;
+
+	(void)cpuemu_get_devcfg_value("DISABLE_SYMBOL_UNDERSCORE", (uint32*)&disable_underscore);
+	if (disable_underscore != FALSE) {
+		name_index = 0U;
+	}
+
+
+	err = elfsym_get_symbol_num(&num);
+	if (err != STD_E_OK) {
+		return err;
+	}
+
+	for (i = 0; i < num; i++) {
+		err = elfsym_get_symbol(i, &elfsym);
+		if (err != STD_E_OK) {
+			return err;
+		}
+		sym.name = &elfsym.name[name_index];
+		sym.addr = elfsym.addr;
+		sym.size = elfsym.size;
+		switch (elfsym.type) {
+		case SYMBOL_TYPE_OBJECT:
+			if (symbol_gl_add(&sym) < 0) {
+				return STD_E_INVALID;
+			}
+			break;
+		case SYMBOL_TYPE_FUNC:
+			if (symbol_func_add(&sym) < 0) {
+				return STD_E_INVALID;
+			}
+			break;
+		case SYMBOL_TYPE_NOTYPE:
+			if (sym.name[0] != '$') {
+				if (symbol_gl_add(&sym) < 0) {
+					return STD_E_INVALID;
+				}
+				if (symbol_func_add(&sym) < 0) {
+					return STD_E_INVALID;
+				}
+			}
+			break;
+		default:
+			//printf("undefined symbol:%s type:0x%x\n", &elfsym.name[name_index], elfsym.type);
+			break;
+		}
+
+	}
+
+	return STD_E_OK;
+}
+
+int cpu_config_get_core_id_num(void)
+{
+	return (int)virtual_cpu.core_id_num;
+}
+
+void cpuemu_init(void *(*cpu_run)(void *), void *opt)
+{
+	CmdOptionType *copt = (CmdOptionType*)opt;
+	CoreIdType i;
+	dbg_log_init("./log.txt");
+	if (copt->core_id_num > 0) {
+		virtual_cpu.core_id_num = copt->core_id_num;
+	}
+	else {
+		virtual_cpu.core_id_num = CPU_CONFIG_CORE_NUM;
+	}
+#ifdef OS_LINUX
+	memset(&cpuemu_dev_clock.start_tv, 0, sizeof(struct timeval));
+	memset(&cpuemu_dev_clock.elaps_tv, 0, sizeof(struct timeval));
+#endif /* OS_LINUX */
+
+	cpu_init();
+	device_init(&virtual_cpu, &cpuemu_dev_clock);
+	cputhr_control_init();
+	cpuctrl_init();
+	if (cpu_run != NULL) {
+		private_cpuemu_is_cui_mode = TRUE;
+		for (i = 0; i < cpu_config_get_core_id_num(); i++) {
+			dbg_cpu_debug_mode_set(i, TRUE);
+		}
+		cputhr_control_start(cpu_run);
+	}
+	else {
+		private_cpuemu_is_cui_mode = FALSE;
+	}
+#ifdef OS_LINUX
+	device_init_athrill_device();
+#endif /* OS_LINUX */
+	return;
+}
+
+uint64 cpuemu_get_cpu_end_clock(void)
+{
+	return cpuemu_cpu_end_clock;
+}
+void cpuemu_set_cpu_end_clock(uint64 clock)
+{
+	cpuemu_cpu_end_clock = clock;
+	return;
+}
+
+void cpuemu_get_elaps(CpuEmuElapsType *elaps)
+{
+	int core_id;
+	elaps->core_id_num = cpu_config_get_core_id_num();
+	elaps->total_clocks = cpuemu_dev_clock.clock;
+	elaps->intr_clocks = cpuemu_dev_clock.intclock;
+#ifdef OS_LINUX
+	elaps->elaps_tv = cpuemu_dev_clock.elaps_tv;
+#endif /* OS_LINUX */
+	for (core_id = 0; core_id < elaps->core_id_num; core_id++) {
+		elaps->cpu_clocks[core_id] = virtual_cpu.cores[core_id].elaps;
+	}
+	return;
+}
+
+#ifdef OS_LINUX
+void cpuemu_start_elaps(void)
+{
+	(void) gettimeofday(&cpuemu_dev_clock.start_tv, NULL);
+	//printf("start sec=%ld usec=%ld\n", cpuemu_dev_clock.start_tv.tv_sec, cpuemu_dev_clock.start_tv.tv_usec);
+	return;
+}
+
+void cpuemu_end_elaps(void)
+{
+	struct timeval current;
+	struct timeval elaps_tv;
+
+	if (cpuemu_dev_clock.start_tv.tv_sec == 0) {
+		return;
+	}
+
+	(void) gettimeofday(&current, NULL);
+	cpuemu_timeval_sub(&current, &cpuemu_dev_clock.start_tv, &elaps_tv);
+	cpuemu_timeval_add(&elaps_tv, &cpuemu_dev_clock.elaps_tv, &cpuemu_dev_clock.elaps_tv);
+	//printf("current sec=%ld usec=%ld\n", current.tv_sec, current.tv_usec);
+	//printf("elaps sec=%ld usec=%ld\n", elaps_tv.tv_sec, elaps_tv.tv_usec);
+	//printf("total sec=%ld usec=%ld\n", cpuemu_dev_clock.elaps_tv.tv_sec, cpuemu_dev_clock.elaps_tv.tv_usec);
+
+	return;
+}
+#endif /* OS_LINUX */
+
+uint32 cpuemu_get_retaddr(CoreIdType core_id)
+{
+	return cpu_get_return_addr((const TargetCoreType *)&virtual_cpu.cores[core_id]);
+}
+
+Std_ReturnType cpuemu_get_addr_pointer(uint32 addr, uint8 **data)
+{
+	return bus_get_pointer(CPU_CONFIG_CORE_ID_0, addr, data);
+}
+
+
+void cpuemu_get_register(CoreIdType core_id, TargetCoreType *cpu)
+{
+	*cpu = virtual_cpu.cores[core_id].core;
+	return;
+}
+
+static TokenContainerType cpuemu_rom_parameter;
+
+static void cpuemu_set_debug_romdata(void)
+{
+	uint32 param_num;
+	uint32 i;
+	Std_ReturnType err;
+	char *rom_variable_name;
+	static char parameter[4096];
+
+	err = cpuemu_get_devcfg_value("DEBUG_ROM_DEFINE_NUM", &param_num);
+	if (err != STD_E_OK) {
+		return;
+	}
+	printf("rom_param_num=%d\n", param_num);
+	for (i = 0; i < param_num; i++) {
+		snprintf(parameter, sizeof(parameter), "DEBUG_ROM_DEFINE_%d", i);
+		err = cpuemu_get_devcfg_string(parameter, &rom_variable_name);
+		if (err != STD_E_OK) {
+			printf("not found param=%s\n", parameter);
+			return;
+		}
+		err = token_split_with_delimiter(&cpuemu_rom_parameter, (uint8*)rom_variable_name, strlen(rom_variable_name), '=');
+		if (err != STD_E_OK) {
+			printf("can not get param value=%s\n", rom_variable_name);
+			return;
+		}
+		printf("ROM:redefine %s = %d\n",
+				cpuemu_rom_parameter.array[0].body.str.str,
+				cpuemu_rom_parameter.array[1].body.dec.value);
+		{
+			int ret;
+			char *gl_name = (char*)cpuemu_rom_parameter.array[0].body.str.str;
+			uint32 gl_len = strlen(gl_name);
+			uint32 addr;
+			uint32 size;
+			uint8* datap;
+			ret = symbol_get_gl(gl_name, gl_len, &addr, &size);
+			if (ret < 0) {
+				printf("can not found global variable=%s\n", gl_name);
+				return;
+			}
+			err = bus_get_pointer(0U, addr, &datap);
+			if (err != 0) {
+				printf("can not found memory pointer=%s\n", gl_name);
+				return;
+			}
+			switch (size) {
+			case 1:
+				*((uint8*)datap) = (uint8)cpuemu_rom_parameter.array[1].body.dec.value;
+				break;
+			case 2:
+				*((uint16*)datap) = (uint16)cpuemu_rom_parameter.array[1].body.dec.value;
+				break;
+			case 4:
+				*((uint32*)datap) = (uint32)cpuemu_rom_parameter.array[1].body.dec.value;
+				break;
+			default:
+				printf("can not set pointer because gl_size(%s:%u) > 4\n", gl_name, size);
+				break;
+			}
+		}
+	}
+	return;
+}
+
+#ifdef CONFIG_STAT_PERF
+ProfStatType cpuemu_cpu_total_prof;
+ProfStatType cpuemu_dev_total_prof;
+ProfStatType cpuemu_dbg_total_prof[DEBUG_STAT_NUM];
+ProfStatType cpuemu_tool1_prof;
+ProfStatType cpuemu_tool2_prof;
+
+#define CPUEMU_CPU_TOTAL_PROF_START()		profstat_start(&cpuemu_cpu_total_prof)
+#define CPUEMU_CPU_TOTAL_PROF_END()			profstat_end(&cpuemu_cpu_total_prof)
+#define CPUEMU_DEV_TOTAL_PROF_START()		profstat_start(&cpuemu_dev_total_prof)
+#define CPUEMU_DEV_TOTAL_PROF_END()			profstat_end(&cpuemu_dev_total_prof)
+#define CPUEMU_DBG_TOTAL_PROF_START(inx)	profstat_start(&cpuemu_dbg_total_prof[(inx)])
+#define CPUEMU_DBG_TOTAL_PROF_END(inx)		profstat_end(&cpuemu_dbg_total_prof[(inx)])
+#define CPUEMU_TOOL1_PROF_START()			profstat_start(&cpuemu_tool1_prof)
+#define CPUEMU_TOOL1_PROF_END()				profstat_end(&cpuemu_tool1_prof)
+#define CPUEMU_TOOL2_PROF_START()			profstat_start(&cpuemu_tool2_prof)
+#define CPUEMU_TOOL2_PROF_END()				profstat_end(&cpuemu_tool2_prof)
+#else
+#define CPUEMU_CPU_TOTAL_PROF_START()
+#define CPUEMU_CPU_TOTAL_PROF_END()
+#define CPUEMU_DEV_TOTAL_PROF_START()
+#define CPUEMU_DEV_TOTAL_PROF_END()
+#define CPUEMU_DBG_TOTAL_PROF_START(inx)
+#define CPUEMU_DBG_TOTAL_PROF_END(inx)
+#define CPUEMU_TOOL1_PROF_START()
+#define CPUEMU_TOOL1_PROF_END()
+#define CPUEMU_TOOL2_PROF_START()
+#define CPUEMU_TOOL2_PROF_END()
+#endif /* CONFIG_STAT_PERF */
+
+static DbgCpuCallbackFuncEnableType enable_dbg;
+
+static inline std_bool cpuemu_thread_run_nodbg(int core_id_num)
+{
+	std_bool is_halt;
+	CoreIdType i = 0;
+	Std_ReturnType err;
+	/**
+	 * デバイス実行実行
+	 */
+#ifdef OS_LINUX
+	device_supply_clock_athrill_device();
+#endif /* OS_LINUX */
+	device_supply_clock(&cpuemu_dev_clock);
+
+	/**
+	 * CPU 実行
+	 */
+	is_halt = TRUE;
+#ifndef DOPTIMIZE_USE_ONLY_1CPU	
+	for (i = 0; i < core_id_num; i++) {
+#endif
+		virtual_cpu.current_core = &virtual_cpu.cores[i];
+		/**
+		 * CPU 実行開始通知
+		 */
+		dbg_cpu_callback_start_nodbg(cpu_get_pc(&virtual_cpu.cores[i].core), cpu_get_sp(&virtual_cpu.cores[i].core));
+
+		err = cpu_supply_clock(i);
+		if ((err != STD_E_OK) && (cpu_illegal_access(i) == FALSE)) {
+			printf("CPU(pc=0x%x) Exception!!\n", cpu_get_pc(&virtual_cpu.cores[i].core));
+			fflush(stdout);
+			exit(1);
+		}
+		/**
+		 * CPU 実行完了通知
+		 */
+		if (virtual_cpu.cores[i].core.is_halt != TRUE) {
+			is_halt = FALSE;
+		}
+#ifndef DOPTIMIZE_USE_ONLY_1CPU	
+	}
+#endif
+	cpuemu_dev_clock.is_halt = is_halt;
+	return is_halt;
+}
+static inline std_bool cpuemu_thread_run_dbg(int core_id_num)
+{
+	std_bool is_halt;
+	CoreIdType i;
+	Std_ReturnType err;
+
+	CPUEMU_TOOL1_PROF_START();
+		CPUEMU_TOOL2_PROF_START();
+		CPUEMU_TOOL2_PROF_END();
+	CPUEMU_TOOL1_PROF_END();
+
+	/**
+	 * デバイス実行実行
+	 */
+	CPUEMU_DEV_TOTAL_PROF_START();
+#ifdef OS_LINUX
+	device_supply_clock_athrill_device();
+#endif /* OS_LINUX */
+	device_supply_clock(&cpuemu_dev_clock);
+	CPUEMU_DEV_TOTAL_PROF_END();
+
+	/**
+	 * CPU 実行
+	 */
+	is_halt = TRUE;
+	for (i = 0; i < core_id_num; i++) {
+		virtual_cpu.current_core = &virtual_cpu.cores[i];
+
+		CPUEMU_CPU_TOTAL_PROF_START();
+		/*
+		 * バスのアクセスログをクリアする
+		 */
+		CPUEMU_DBG_TOTAL_PROF_START(0);
+		bus_access_set_log(BUS_ACCESS_TYPE_NONE, 8U, 0, 0);
+		CPUEMU_DBG_TOTAL_PROF_END(0);
+
+		/**
+		 * CPU 実行開始通知
+		 */
+		CPUEMU_DBG_TOTAL_PROF_START(1);
+		dbg_cpu_callback_start(cpu_get_pc(&virtual_cpu.cores[i].core), cpu_get_sp(&virtual_cpu.cores[i].core));
+		CPUEMU_DBG_TOTAL_PROF_END(1);
+
+		CPUEMU_DBG_TOTAL_PROF_START(2);
+		dbg_notify_cpu_clock_supply_start(&virtual_cpu.cores[i].core);
+		CPUEMU_DBG_TOTAL_PROF_END(2);
+
+		CPUEMU_DBG_TOTAL_PROF_START(3);
+		err = cpu_supply_clock(i);
+		if ((err != STD_E_OK) && (cpu_illegal_access(i) == FALSE)) {
+			printf("CPU(pc=0x%x) Exception!!\n", cpu_get_pc(&virtual_cpu.cores[i].core));
+			fflush(stdout);
+			cpuctrl_set_force_break();
+		}
+		CPUEMU_DBG_TOTAL_PROF_END(3);
+		/**
+		 * CPU 実行完了通知
+		 */
+		CPUEMU_DBG_TOTAL_PROF_START(4);
+		dbg_notify_cpu_clock_supply_end(&virtual_cpu.cores[i].core, &enable_dbg);
+		CPUEMU_DBG_TOTAL_PROF_END(4);
+
+		CPUEMU_CPU_TOTAL_PROF_END();
+		if (virtual_cpu.cores[i].core.is_halt != TRUE) {
+			is_halt = FALSE;
+		}
+	}
+	cpuemu_dev_clock.is_halt = is_halt;
+	return is_halt;
+}
+
+#ifdef ATHRILL_PROFILE
+#include <signal.h>
+#include <setjmp.h>
+void intr_handler(int sig);
+jmp_buf buf;
+#endif
+
+void *cpuemu_thread_run(void* arg)
+{
+	std_bool is_halt;
+	int core_id_num = cpu_config_get_core_id_num();
+	static bool (*do_cpu_run) (int);
+	int core_id;
+
+	enable_dbg.enable_bt = TRUE;
+	enable_dbg.enable_ft = TRUE;
+	enable_dbg.enable_watch = TRUE;
+	enable_dbg.enable_prof = TRUE;
+	enable_dbg.enable_sync_time = FALSE;
+	enable_dbg.reset_pc = 0x0;
+	cpuemu_dev_clock.enable_skip = FALSE;
+
+	(void)cpuemu_get_devcfg_value("DEBUG_FUNC_ENABLE_BT", &enable_dbg.enable_bt);
+	(void)cpuemu_get_devcfg_value("DEBUG_FUNC_ENABLE_FT", &enable_dbg.enable_ft);
+	(void)cpuemu_get_devcfg_value("DEBUG_FUNC_ENABLE_PROF", &enable_dbg.enable_watch);
+	(void)cpuemu_get_devcfg_value("DEBUG_FUNC_ENABLE_WATCH", &enable_dbg.enable_prof);
+	(void)cpuemu_get_devcfg_value("DEBUG_FUNC_ENABLE_SYNC_TIME", &enable_dbg.enable_sync_time);
+	(void)cpuemu_get_devcfg_value("DEBUG_FUNC_SHOW_SKIP_TIME", &enable_dbg.show_skip_time);
+	(void)cpuemu_get_devcfg_value_hex("DEBUG_FUNC_RESET_PC", &enable_dbg.reset_pc);
+	for (core_id = 0; core_id < core_id_num; core_id++) {
+		cpu_set_core_pc(core_id, enable_dbg.reset_pc);
+	}
+
+	virtual_cpu.cpu_freq = DEFAULT_CPU_FREQ; /* 100MHz */
+	(void)cpuemu_get_devcfg_value("DEVICE_CPU_FREQ", &virtual_cpu.cpu_freq);
+
+	(void)cpuemu_get_devcfg_value("DEBUG_FUNC_ENABLE_SKIP_CLOCK", (uint32*)&cpuemu_dev_clock.enable_skip);
+	cpuemu_set_debug_romdata();
+
+	if (cpuemu_cui_mode() == TRUE) {
+		do_cpu_run = cpuemu_thread_run_dbg;
+	}
+	else {
+		do_cpu_run = cpuemu_thread_run_nodbg;
+	}
+	uint64 end_clock = cpuemu_get_cpu_end_clock();
+	uint64 *clockp = &cpuemu_dev_clock.clock;
+	bool enable_skip = cpuemu_dev_clock.enable_skip;
+
+#ifdef ATHRILL_PROFILE
+  if ( signal(SIGINT, intr_handler) == SIG_ERR ) {
+    exit(1);
+  }
+
+  if ( setjmp(buf) == 0 ) {
+#endif
+	while (TRUE) {
+		if ((*clockp)>= end_clock) {
+			dbg_log_sync();
+			//printf("EXIT for timeout(%I64u).\n", cpuemu_dev_clock.clock);
+			printf("EXIT for timeout("PRINT_FMT_UINT64").\n", cpuemu_dev_clock.clock);
+			exit(1);
+		}
+		is_halt = do_cpu_run(core_id_num);
+
+		if (enable_skip == TRUE) {
+			if ((is_halt == TRUE) && (cpuemu_dev_clock.can_skip_clock == TRUE)) {
+#ifdef OS_LINUX
+				uint64 skipc_usec = 0;
+				if (enable_dbg.enable_sync_time > 0) {
+					skipc_usec = ( (cpuemu_dev_clock.min_intr_interval - 1) / virtual_cpu.cpu_freq );
+					if (skipc_usec > ((uint64)enable_dbg.enable_sync_time)) {
+						(void)usleep((useconds_t)(skipc_usec - ((uint64)enable_dbg.enable_sync_time)));
+					}
+				}
+				if (enable_dbg.show_skip_time != 0) {
+					static struct timeval prev_elaps;
+					struct timeval result;
+					struct timeval elaps;
+					gettimeofday(&elaps, NULL);
+					cpuemu_timeval_sub(&elaps, &prev_elaps, &result);
+#ifdef OS_MAC
+					printf("skip-clock = %llu : %ld sec %d usec sync_time=%d \n", skipc_usec, result.tv_sec, result.tv_usec, enable_dbg.enable_sync_time);
+#else
+                    printf("skip-clock = %llu : %ld sec %ld usec sync_time=%u \n", skipc_usec, result.tv_sec, result.tv_usec, enable_dbg.enable_sync_time);
+#endif
+					prev_elaps = elaps;
+				}
+#endif /* OS_LINUX */
+#ifndef CPUEMU_CLOCK_BUG_FIX
+				if (cpuemu_dev_clock.min_intr_interval > 2U) {
+					cpuemu_dev_clock.clock += (cpuemu_dev_clock.min_intr_interval - 1);
+				}
+#else
+				if (cpuemu_dev_clock.min_intr_interval != DEVICE_CLOCK_MAX_INTERVAL) {
+					cpuemu_dev_clock.clock += (cpuemu_dev_clock.min_intr_interval);
+				}
+#endif /* CPUEMU_CLOCK_BUG_FIX */
+				else {
+					cpuemu_dev_clock.clock += 1U;
+				}
+			}
+#ifndef CPUEMU_CLOCK_BUG_FIX
+#else
+			else {
+				cpuemu_dev_clock.clock += 1U;
+			}
+#endif /* CPUEMU_CLOCK_BUG_FIX */
+		}
+#ifndef CPUEMU_CLOCK_BUG_FIX
+#else
+		else {
+			cpuemu_dev_clock.clock += 1U;
+		}
+#endif /* CPUEMU_CLOCK_BUG_FIX */
+	}
+#ifdef ATHRILL_PROFILE
+  }
+#endif
+	return NULL;
+}
+
+#ifdef ATHRILL_PROFILE
+void intr_handler(int sig) {
+  printf("Interrupt : %d\n", sig);
+  longjmp(buf, 1);
+}
+#endif
+
+
+typedef struct {
+	TokenStringType	folder_path;
+	TokenStringType rx_path;
+	TokenStringType tx_path;
+} CpuEmuFifoFileType;
+
+static const TokenStringType fifo_tx_string = {
+		.len = 2,
+		.str = { 'T', 'X', '\0' },
+};
+static const TokenStringType fifo_rx_string = {
+		.len = 2,
+		.str = { 'R', 'X', '\0' },
+};
+
+
+static CpuEmuFifoFileType cpuemu_fifo_file;
+static FileType cpuemu_fifocfg;
+
+static Std_ReturnType parse_fifopath(char *buffer, uint32 len)
+{
+	Std_ReturnType err;
+	TokenContainerType token_container;
+
+	err = token_split(&token_container, (uint8*)buffer, len);
+	if (err != STD_E_OK) {
+		goto errdone;
+	}
+	err = STD_E_INVALID;
+	if (token_container.num != 2) {
+		goto errdone;
+	}
+	if (token_container.array[0].type != TOKEN_TYPE_STRING) {
+		goto errdone;
+	}
+	else if (token_container.array[1].type != TOKEN_TYPE_STRING) {
+		goto errdone;
+	}
+
+	if (token_strcmp(&fifo_tx_string, &token_container.array[0].body.str) == TRUE) {
+		if (cpuemu_fifo_file.tx_path.len > 0) {
+			printf("ERROR: INVALID parameter number of TX >= 2\n");
+			return STD_E_INVALID;
+		}
+		cpuemu_fifo_file.tx_path = cpuemu_fifo_file.folder_path;
+		if (token_merge(&cpuemu_fifo_file.tx_path, &token_container.array[1].body.str) == FALSE) {
+			printf("ERROR: INVALID filename is too long: %s\n", token_container.array[1].body.str.str);
+			return STD_E_INVALID;
+		}
+	}
+	else if (token_strcmp(&fifo_rx_string, &token_container.array[0].body.str) == TRUE) {
+		if (cpuemu_fifo_file.rx_path.len > 0) {
+			printf("ERROR: INVALID parameter number of RX >= 2\n");
+			return STD_E_INVALID;
+		}
+		cpuemu_fifo_file.rx_path = cpuemu_fifo_file.folder_path;
+		if (token_merge(&cpuemu_fifo_file.rx_path, &token_container.array[1].body.str) == FALSE) {
+			printf("ERROR: INVALID filename is too long: %s\n", token_container.array[1].body.str.str);
+			return STD_E_INVALID;
+		}
+	}
+
+	return STD_E_OK;
+errdone:
+	printf("ERROR: Invalid parameter. Format should b {TX|RX} <fifo name>\n");
+	return err;
+}
+
+/*
+ * 出力
+ * ・fifoファイル配置フォルダパス
+ * ・tx fifo ファイル配置パス
+ * ・rx fifo ファイル配置パス
+ */
+Std_ReturnType cpuemu_set_comm_fifocfg(const char* fifocfg)
+{
+	uint32 len;
+	Std_ReturnType err;
+	char buffer[4096];
+	bool ret;
+
+	ret = token_string_set(&cpuemu_fifocfg.filepath, fifocfg);
+	if (ret == FALSE) {
+		return STD_E_INVALID;
+	}
+
+	ret = file_ropen(&cpuemu_fifocfg);
+	if (ret == FALSE) {
+		return STD_E_NOENT;
+	}
+
+	//fifoファイル配置フォルダパス
+	len = file_get_parent_folder_pathlen(fifocfg);
+	memcpy(cpuemu_fifo_file.folder_path.str, fifocfg, len);
+	cpuemu_fifo_file.folder_path.str[len] = '\0';
+	cpuemu_fifo_file.folder_path.len = len;
+
+	err = STD_E_INVALID;
+	//fifo ファイル配置パス取得(1回目)
+	len = file_getline(&cpuemu_fifocfg, buffer, 4096);
+	if (len > 0) {
+		err = parse_fifopath(buffer, len);
+		if (err != STD_E_OK) {
+			goto errdone;
+		}
+	}
+	else {
+		printf("ERROR: can not found data on %s...\n", fifocfg);
+		goto errdone;
+	}
+
+	//fifo ファイル配置パス取得(2回目)
+	len = file_getline(&cpuemu_fifocfg, buffer, 4096);
+	if (len > 0) {
+		err = parse_fifopath(buffer, len);
+		if (err != STD_E_OK) {
+			goto errdone;
+		}
+	}
+	else {
+		printf("ERROR: can not found data on %s...\n", fifocfg);
+		goto errdone;
+	}
+
+	err = STD_E_INVALID;
+	if (file_exist(cpuemu_get_comm_rx_fifo()) == FALSE) {
+		printf("ERROR: can not found fifo file %s...\n", cpuemu_get_comm_rx_fifo());
+		goto errdone;
+	}
+	if (file_exist(cpuemu_get_comm_tx_fifo()) == FALSE) {
+		printf("ERROR: can not found fifo file %s...\n", cpuemu_get_comm_rx_fifo());
+		goto errdone;
+	}
+
+	printf("RX fifo:%s\n", cpuemu_get_comm_rx_fifo());
+	printf("TX fifo:%s\n", cpuemu_get_comm_tx_fifo());
+
+	file_close(&cpuemu_fifocfg);
+	return STD_E_OK;
+errdone:
+	cpuemu_fifo_file.tx_path.len = 0;
+	cpuemu_fifo_file.rx_path.len = 0;
+	file_close(&cpuemu_fifocfg);
+	return err;
+}
+
+const char* cpuemu_get_comm_rx_fifo(void)
+{
+	if (cpuemu_fifo_file.rx_path.len > 0) {
+		return (const char*)cpuemu_fifo_file.rx_path.str;
+	}
+	else {
+		return NULL;
+	}
+}
+
+const char* cpuemu_get_comm_tx_fifo(void)
+{
+	if (cpuemu_fifo_file.tx_path.len > 0) {
+		return (const char*)cpuemu_fifo_file.tx_path.str;
+	}
+	else {
+		return NULL;
+	}
+}
+
+#define CPUEMU_DEVCFG_PARAM_MAXNUM	128
+typedef struct {
+	uint32			param_num;
+	struct {
+		TokenValueType	key;
+		TokenValueType	value;
+	} param[CPUEMU_DEVCFG_PARAM_MAXNUM];
+} CpuEmuDevCfgType;
+
+static CpuEmuDevCfgType cpuemu_devcfg;
+static char dvcfg_buffer[4096];
+static TokenContainerType devcfg_token_container;
+static FileType devcfg_file;
+
+Std_ReturnType cpuemu_load_devcfg(const char *path)
+{
+	Std_ReturnType err = STD_E_OK;
+	uint32 len;
+	bool ret;
+
+	cpuemu_devcfg.param_num = 0;
+
+	ret = token_string_set(&devcfg_file.filepath, path);
+	if (ret == FALSE) {
+		return STD_E_INVALID;
+	}
+	ret = file_ropen(&devcfg_file);
+	if (ret == FALSE) {
+		return STD_E_NOENT;
+	}
+	while (TRUE) {
+		err = STD_E_INVALID;
+
+		len = file_getline(&devcfg_file, dvcfg_buffer, 4096);
+		if (len <= 0) {
+			break;
+		}
+
+		err = token_split(&devcfg_token_container, (uint8*)dvcfg_buffer, len);
+		if (err != STD_E_OK) {
+			printf("ERROR: can not parse data on %s...\n", path);
+			goto errdone;
+		}
+		if (devcfg_token_container.num != 2) {
+			printf("ERROR: the token is invalid %s on %s...\n", dvcfg_buffer, path);
+			goto errdone;
+		}
+		cpuemu_devcfg.param[cpuemu_devcfg.param_num].key = devcfg_token_container.array[0];
+		cpuemu_devcfg.param[cpuemu_devcfg.param_num].value = devcfg_token_container.array[1];
+		cpuemu_devcfg.param_num++;
+		//printf("param=%s\n", devcfg_token_container.array[0].body.str.str);
+		//printf("value=%s\n", devcfg_token_container.array[1].body.str.str);
+	}
+
+	file_close(&devcfg_file);
+	return STD_E_OK;
+errdone:
+	file_close(&devcfg_file);
+	return err;
+}
+
+static FileType memcfg_file;
+static char memcfg_buffer[4096];
+static TokenContainerType memcfg_token_container;
+static void analize_memmap_arguments(const TokenContainerType *token, const MemoryAddressMapType *map, MemoryAddressType *memp)
+{
+	int i;
+	if (token->num <= 3) {
+		return;
+	}
+	for (i = 0; i < 2; i++) {
+		if (token->array[3].body.str.str[i] == 'X') {
+			memp->region_executable = TRUE;
+		}
+		else if (token->array[3].body.str.str[i] == 'V') {
+			memp->region_elf_load_from_vaddr = TRUE;
+		}
+	}
+	return;
+}
+Std_ReturnType cpuemu_load_memmap(const char *path, MemoryAddressMapType *map)
+{
+	Std_ReturnType err = STD_E_OK;
+	uint32 len;
+	bool ret;
+	MemoryAddressType *memp = NULL;
+
+	map->ram_num = 0;
+	map->rom_num = 0;
+	map->dev_num = 0;
+	map->ram = NULL;
+	map->rom = NULL;
+	map->dev = NULL;
+
+	ret = token_string_set(&memcfg_file.filepath, path);
+	if (ret == FALSE) {
+		return STD_E_INVALID;
+	}
+	ret = file_ropen(&memcfg_file);
+	if (ret == FALSE) {
+		return STD_E_NOENT;
+	}
+	while (TRUE) {
+		err = STD_E_INVALID;
+
+		len = file_getline(&memcfg_file, memcfg_buffer, 4096);
+		if (len <= 0) {
+			break;
+		}
+
+		err = token_split(&memcfg_token_container, (uint8*)memcfg_buffer, len);
+		if (err != STD_E_OK) {
+			printf("ERROR: can not parse data on %s...\n", path);
+			goto errdone;
+		}
+		/*
+		 * <memtype>, <startaddr>, <size> [, [opt]+ ]
+		 * opt = {V|X}, V= load from virtual address, X = executable region
+		 */
+		if ((memcfg_token_container.num != 3) && (memcfg_token_container.num != 4)) {
+			printf("ERROR: the token is invalid %s on %s...\n", memcfg_buffer, path);
+			goto errdone;
+		}
+		if (!strcmp("ROM", (char*)memcfg_token_container.array[0].body.str.str)) {
+			printf("ROM");
+			map->rom_num++;
+			map->rom = realloc(map->rom, map->rom_num * sizeof(MemoryAddressType));
+			ASSERT(map->rom != NULL);
+			memp = &map->rom[map->rom_num - 1];
+			memp->type = MemoryAddressImplType_ROM;
+			memp->size = memcfg_token_container.array[2].body.dec.value;
+			memp->mmap_addr = NULL;
+			analize_memmap_arguments(&memcfg_token_container, map, memp);
+		}
+		else if (!strcmp("RAM", (char*)memcfg_token_container.array[0].body.str.str)) {
+			printf("RAM");
+			map->ram_num++;
+			map->ram = realloc(map->ram, map->ram_num * sizeof(MemoryAddressType));
+			ASSERT(map->ram != NULL);
+			memp = &map->ram[map->ram_num - 1];
+			memp->type = MemoryAddressImplType_RAM;
+			memp->size = memcfg_token_container.array[2].body.dec.value;
+			memp->mmap_addr = NULL;
+			analize_memmap_arguments(&memcfg_token_container, map, memp);
+		}
+#ifdef OS_LINUX
+		else if (!strcmp("MMAP", (char*)memcfg_token_container.array[0].body.str.str)) {
+			map->ram_num++;
+			map->ram = realloc(map->ram, map->ram_num * sizeof(MemoryAddressType));
+			ASSERT(map->ram != NULL);
+			memp = &map->ram[map->ram_num - 1];
+			memp->type = MemoryAddressImplType_MMAP;
+			{
+				char* filepath;
+				int fd;
+				int err;
+				struct stat statbuf;
+				AthrillDeviceMmapInfoType info;
+
+				cpuemu_env_parse_devcfg_string(&memcfg_token_container.array[2].body.str);
+				filepath = (char*)memcfg_token_container.array[2].body.str.str;
+				//printf("mmap path=%s\n", filepath);
+				fd = open(filepath, O_RDWR);
+				if (fd < 0) {
+					printf("can not open mmapfile:%s err=%d\n", filepath, errno);
+					ASSERT(fd >= 0);
+				}
+				err = fstat(fd, &statbuf);
+				ASSERT(err >= 0);
+				memp->size = ((statbuf.st_size + 8191) / 8192) * 8;
+				if (memp->size == 0) {
+					memp->size = 8;
+				}
+				memp->mmap_addr = mmap(NULL, memp->size * 1024, (PROT_READ|PROT_WRITE), MAP_SHARED, fd, 0);
+				ASSERT(memp->mmap_addr != NULL);
+#ifdef OS_MAC
+                printf("MMAP(%s filesize=%lld)", filepath, statbuf.st_size);
+#else
+				printf("MMAP(%s filesize=%lu)", filepath, statbuf.st_size);
+#endif
+				analize_memmap_arguments(&memcfg_token_container, map, memp);
+                info.fd = fd;
+				info.addr = CAST_UINT32_TO_ADDR(memcfg_token_container.array[1].body.hex.value);
+				athrill_device_set_mmap_info(&info);
+			}
+		}
+		else if (!strcmp("MALLOC", (char*)memcfg_token_container.array[0].body.str.str)) {
+			map->ram_num++;
+			map->ram = realloc(map->ram, map->ram_num * sizeof(MemoryAddressType));
+			ASSERT(map->ram != NULL);
+			memp = &map->ram[map->ram_num - 1];
+			memp->type = MemoryAddressImplType_MALLOC;
+			memp->size = memcfg_token_container.array[2].body.dec.value;
+			memp->mmap_addr = NULL;
+			if ((memp->size % (MPU_MALLOC_REGION_UNIT_SIZE * MPU_MALLOC_REGION_UNIT_GROUP_NUM)) != 0) {
+				err = STD_E_INVALID;
+				printf("ERROR: Invalid MALLOC size(%u). The size must be multiples of 10MB.\n", memp->size);
+				goto errdone;
+			}
+			analize_memmap_arguments(&memcfg_token_container, map, memp);
+			printf("MALLOC");
+		}
+		else if (!strcmp("DEV", (char*)memcfg_token_container.array[0].body.str.str)) {
+			char *filepath = (char*)memcfg_token_container.array[2].body.str.str;
+			void *handle = dlopen(filepath, RTLD_NOW);
+			if (handle == NULL) {
+				printf("ERROR: Can not find shared library %s reason=%s\n", filepath, dlerror());
+				continue;
+			}
+			AthrillExDeviceHeaderType *ext_dev_headr = dlsym(handle, "athrill_ex_device");
+			if (ext_dev_headr == NULL) {
+				printf("ERROR: Can not find symbol(athrill_ex_device) on %s\n", filepath);
+				continue;
+			}
+			if (ext_dev_headr->magicno != ATHRILL_EXTERNAL_DEVICE_MAGICNO) {
+				printf("ERROR: magicno is invalid(0x%x) on %s\n", ext_dev_headr->magicno, filepath);
+				continue;
+			}
+			if (ext_dev_headr->version != ATHRILL_EXTERNAL_DEVICE_VERSION) {
+				printf("ERROR: version is invalid(0x%x) on %s\n", ext_dev_headr->version, filepath);
+				continue;
+			}
+			map->dev_num++;
+			map->dev = realloc(map->dev, map->dev_num * sizeof(MemoryAddressType));
+			ASSERT(map->dev != NULL);
+			memp = &map->dev[map->dev_num - 1];
+			memp->type = MemoryAddressImplType_DEV;
+			memp->extdev_handle = handle;
+			memp->size = ext_dev_headr->memory_size;
+			printf("DEV");
+		}
+#endif /* OS_LINUX */
+		else {
+			printf("WARNING: unknown memory type=%s\n", (char*)memcfg_token_container.array[0].body.str.str);
+			continue;
+		}
+		memp->start = memcfg_token_container.array[1].body.hex.value;
+		printf(" : START=0x%x SIZE=%u\n", memp->start, memp->size);
+	}
+
+	file_close(&memcfg_file);
+	return STD_E_OK;
+errdone:
+	file_close(&memcfg_file);
+	return err;
+}
+
+
+Std_ReturnType cpuemu_get_devcfg_value(const char* key, uint32 *value)
+{
+	int i;
+	TokenStringType token;
+
+	token.len = strlen(key);
+	memcpy(token.str, key, token.len);
+	token.str[token.len] = '\0';
+
+	for (i = 0; i < cpuemu_devcfg.param_num; i++) {
+		if (cpuemu_devcfg.param[i].value.type != TOKEN_TYPE_VALUE_DEC) {
+			continue;
+		}
+		if (token_strcmp(&cpuemu_devcfg.param[i].key.body.str, &token) == FALSE) {
+			continue;
+		}
+		*value = cpuemu_devcfg.param[i].value.body.dec.value;
+		return STD_E_OK;
+	}
+	return STD_E_NOENT;
+}
+
+Std_ReturnType cpuemu_get_devcfg_value_hex(const char* key, uint32 *value)
+{
+	int i;
+	TokenStringType token;
+
+	token.len = strlen(key);
+	memcpy(token.str, key, token.len);
+	token.str[token.len] = '\0';
+
+	for (i = 0; i < cpuemu_devcfg.param_num; i++) {
+		if (cpuemu_devcfg.param[i].value.type != TOKEN_TYPE_VALUE_HEX) {
+			continue;
+		}
+		if (token_strcmp(&cpuemu_devcfg.param[i].key.body.str, &token) == FALSE) {
+			continue;
+		}
+		*value = cpuemu_devcfg.param[i].value.body.hex.value;
+		return STD_E_OK;
+	}
+	return STD_E_NOENT;
+}
+
+static void cpuemu_env_parse_devcfg_string(TokenStringType* strp)
+{
+	static char env_name[TOKEN_STRING_MAX_SIZE];
+	static char out_name[TOKEN_STRING_MAX_SIZE];
+	char *start = strchr((const char*)strp->str, '{');
+	char *end = strchr((const char*)strp->str, '}');
+	if ((start == NULL) || (end == NULL)) {
+		return;
+	}
+	int len = ((int)(end - start) - 1);
+	if (len == 0) {
+		return;
+	}
+	memset(env_name, 0, TOKEN_STRING_MAX_SIZE);
+	memcpy(env_name, (start + 1), len);
+
+	//printf("%s\n", env_name);
+	char *ep = getenv(env_name);
+	if (ep == NULL) {
+		return;
+	}
+	//printf("ep = %s\n", ep);
+	memset(out_name, 0, TOKEN_STRING_MAX_SIZE);
+	len = snprintf(out_name, TOKEN_STRING_MAX_SIZE, "%s%s", ep, (end + 1));
+	out_name[len] = '\0';
+	len++;
+	//printf("out_name=%s len=%d\n", out_name, len);
+	memcpy(strp->str, out_name, len);
+	strp->len = len;
+
+	return;
+}
+
+Std_ReturnType cpuemu_get_devcfg_string(const char* key, char **value)
+{
+	int i;
+	TokenStringType token;
+
+	token.len = strlen(key);
+	memcpy(token.str, key, token.len);
+	token.str[token.len] = '\0';
+
+	for (i = 0; i < cpuemu_devcfg.param_num; i++) {
+		if (cpuemu_devcfg.param[i].value.type != TOKEN_TYPE_STRING) {
+			continue;
+		}
+		if (token_strcmp(&cpuemu_devcfg.param[i].key.body.str, &token) == FALSE) {
+			continue;
+		}
+		cpuemu_env_parse_devcfg_string(&cpuemu_devcfg.param[i].value.body.str);
+		*value = (char*)cpuemu_devcfg.param[i].value.body.str.str;
+		printf("%s = %s\n", key, *value);
+		return STD_E_OK;
+	}
+	return STD_E_NOENT;
+}
+
+void cpuemu_raise_intr(uint32 intno)
+{
+	(void)intc_raise_intr(intno);
+	return;
+}
+
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/main/main.c
@@ -0,0 +1,246 @@
+#include "front/parser/dbg_parser.h"
+#include "loader/loader.h"
+#include "option/option.h"
+#include "cpu_control/dbg_cpu_control.h"
+#include "cpu_control/dbg_cpu_thread_control.h"
+#include "cpuemu_config.h"
+#include "cpuemu_ops.h"
+#include "cui/cui_ops.h"
+#include "cui/stdio/cui_ops_stdio.h"
+#include "cui/udp/cui_ops_udp.h"
+#include "file_address_mapping.h"
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include "target/target_os_api.h"
+#include <sched.h>
+#include <limits.h>
+#include "athrill_exdev_header.h"
+#ifdef OS_LINUX
+#include <signal.h>
+#endif
+#include "athrill_memory.h"
+#include "athrill_device.h"
+
+/*
+ * version: X.Y.Z
+ *  X: generation
+ *  Y: function
+ *  Z: bug fix, small changes
+ */
+#define ATHRILL_CORE_VERSION "1.1.2"
+
+#ifndef ATHRILL_TARGET_ARCH
+#define ATHRILL_TARGET_ARCH "UNKNOWN"
+#define ATHRILL_TARGET_VERSION "0.0.0"
+#endif
+
+AthrillMemHeadType athrill_mem_head = { NULL, NULL };
+
+static FILE *save_operation_fp = NULL;
+
+static void load_cui_operation(void)
+{
+	DbgCmdExecutorType *res;
+	char *filename;
+	size_t buffer_size = 1024;
+	char buffer[1025];
+	char *lineptr = buffer;
+	ssize_t len;
+
+	Std_ReturnType err = cpuemu_get_devcfg_string("DEBUG_FUNC_OPLOG", &filename);
+	if (err != STD_E_OK) {
+		return;
+	}
+	save_operation_fp = fopen(filename, "a+");
+	if (save_operation_fp == NULL) {
+		printf("ERROR: can not open oplog file %s\n", filename);
+		return;
+	}
+	while (TRUE) {
+		len = getline(&lineptr, &buffer_size, save_operation_fp);
+		if (len < 0) {
+			break;
+		}
+		buffer[len] = '\0';
+		res = dbg_parse((uint8*)buffer, (uint32)len);
+
+		if (res != NULL) {
+			res->run(res);
+		}
+	}
+	return;
+}
+static void save_cui_operation(const char* op)
+{
+	if (save_operation_fp == NULL) {
+		return;
+	}
+	fprintf(save_operation_fp, "%s\n", op);
+	fflush(save_operation_fp);
+	return;
+}
+
+static void do_cui(void)
+{
+	DbgCmdExecutorType *res;
+	bool is_dbgmode;
+	char buffer[1025];
+	int len;
+
+	load_cui_operation();
+
+	while (TRUE) {
+		is_dbgmode = cpuctrl_is_debug_mode();
+		printf("%s", (is_dbgmode == TRUE) ? "[DBG>" : "[CPU>");
+		fflush(stdout);
+retry:
+		len = cui_getline(buffer, 1024);
+		if (len < 0) {
+			cui_close();
+			target_os_api_sleep(1000);
+			goto retry;
+		}
+		buffer[len] = '\0';
+		res = dbg_parse((uint8*)buffer, (uint32)len);
+
+		if (res != NULL) {
+			res->result_ok = FALSE;
+			res->run(res);
+			if (res->result_ok == TRUE) {
+				save_cui_operation((const char*)res->original_str);
+			}
+		}
+	}
+}
+
+static void athrill_sigterm_handler(int arg)
+{
+	athrill_device_cleanup();
+	sync();
+	sync();
+	sync();
+	sync();
+	sync();
+	exit(0);
+	return;
+}
+
+
+/*
+ * コマンドオプション仕様
+ * -i		インタラクションモード
+ * 	・あり：インタラクションモード
+ * 	・なし：バックグラウンド実行モード
+ * -r(インタラクションモードのみ有効)
+ * 	・あり：リモートモード
+ * 	・なし：直接モード
+ * -t<time>	終了時間(単位：clock)
+ * 	・あり：終了時間
+ * 	・なし：無制限
+ * -b	入力ファイル形式
+ * 	・あり：バイナリデータ
+ * 	・なし：ELFファイル
+ * -p<fifo config file path>
+ * 	・あり：対抗ECUとの通信あり
+ * 	・なし：シングルECU構成
+ */
+int main(int argc, const char *argv[])
+{
+	Std_ReturnType err;
+	CmdOptionType *opt;
+	MemoryAddressMapType memmap;
+	memset(&memmap, 0, sizeof(MemoryAddressMapType));
+
+	if (argc == 1) {
+		printf("Athrill is licensed under the TOPPERS License Agreement (http://www.toppers.jp/en/license.html).\n");
+		printf("ARCH:%s (VERSION CORE:%s TARGET:%s)\n", ATHRILL_TARGET_ARCH, ATHRILL_CORE_VERSION, ATHRILL_TARGET_VERSION);
+		printf("DEVICE:magicno=0x%x version=0x%x\n\n", ATHRILL_EXTERNAL_DEVICE_MAGICNO, ATHRILL_EXTERNAL_DEVICE_VERSION);
+
+		printf("Usage:%s -c<core num> -m <memory config file> [OPTION]... <load_file>\n", "athrill");
+		printf(" %-30s : set core num. if -c is not set, core num = 2.\n", "-c");
+		printf(" %-30s : execute on the interaction mode. if -i is not set, execute on the background mode.\n", "-i");
+		printf(" %-30s : execute on the remote mode. this option is valid on the interaction mode.\n", "-r");
+		printf(" %-30s : set program end time using <timeout> clocks. this option is valid on the background mode.\n", "-t<timeout>");
+		printf(" %-30s : set athrill memory configuration. rom, ram region is configured on your system.\n", "-m<memory config file>");
+		//printf(" %-30s : set communication path with an another emulator.\n", "-p<fifo config file>");
+		printf(" %-30s : set device parameter.\n", "-d<device config file>");
+		return -11;
+	}
+
+	winsock_init();
+#if 0
+	struct sched_param sp;
+
+	sp.sched_priority = sched_get_priority_max(SCHED_FIFO);
+	int ret = sched_setscheduler(0, SCHED_FIFO, &sp);
+	if (ret) {
+		perror("sched_setscheduler");
+		return 1;
+	}
+#endif
+#ifdef OS_LINUX
+	signal(SIGPIPE, SIG_IGN);
+	signal(SIGTERM, athrill_sigterm_handler);
+#endif
+
+	opt = parse_args(argc, argv);
+	if (opt == NULL) {
+		return 1;
+	}
+	printf("core id num=%u\n", opt->core_id_num);
+	if (opt->fifocfgpath != NULL) {
+		err = cpuemu_set_comm_fifocfg(opt->fifocfgpath);
+		if (err != STD_E_OK) {
+			return -1;
+		}
+	}
+	if (opt->devcfgpath != NULL) {
+		err = cpuemu_load_devcfg(opt->devcfgpath);
+		if (err != STD_E_OK) {
+			return -1;
+		}
+	}
+	if (opt->memfilepath != NULL) {
+		err = cpuemu_load_memmap(opt->memfilepath, &memmap);
+		if (err != STD_E_OK) {
+			return -1;
+		}
+	}
+
+	if (opt->is_binary_data) {
+		binary_load((uint8*)opt->load_file.buffer, 0U, opt->load_file.size);
+	}
+	else {
+		elf_load((uint8*)opt->load_file.buffer, &memmap);
+		if (cpuemu_symbol_set() != STD_E_OK) {
+			return -1;
+		}
+		file_address_mapping_init();
+	}
+
+	if (opt->is_interaction == TRUE) {
+		if (opt->is_remote == TRUE) {
+			uint32 athrill_listen_port = CPUEMU_CONFIG_CUI_EMULATOR_PORTNO;
+			uint32 client_listen_port = CPUEMU_CONFIG_CUI_CLIENT_PORTNO;
+			(void)cpuemu_get_devcfg_value("DEBUG_FUNC_REMOTE_ATHRILL_LISTEN_PORT_NO", &athrill_listen_port);
+			(void)cpuemu_get_devcfg_value("DEBUG_FUNC_REMOTE_CLIENT_LISTEN_PORT_NO", &client_listen_port);
+			cui_ops_udp_init((uint16)client_listen_port, (uint16)athrill_listen_port);
+		}
+		else {
+			cui_ops_stdio_init();
+		}
+
+		cpuemu_init(cpuemu_thread_run, opt);
+		do_cui();
+	}
+	else {
+		cpuemu_init(NULL, opt);
+		cpuemu_set_cpu_end_clock(opt->timeout);
+		(void)cpuemu_thread_run(NULL);
+	}
+
+	return 0;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/main/option/option.c
@@ -0,0 +1,130 @@
+#include "option/option.h"
+#include "file.h"
+#include <stdlib.h>
+#include <errno.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+
+static CmdOptionType cmd_option;
+
+static int cmd_atoi(char *arg, uint64 *out)
+{
+	char *endptr;
+	long long ret64;
+	/*
+	 * 10進数チェック
+	 */
+	errno = 0;
+	ret64 = strtoll((const char*)arg, &endptr, 10);
+	if ((errno == 0) && (*endptr == '\0')) {
+		*out = ret64;
+		return 0;
+	}
+	return -1;
+}
+
+static int cmd_atoi32(char *arg, uint32 *out)
+{
+	char *endptr;
+	uint32 ret32;
+	/*
+	 * 10進数チェック
+	 */
+	errno = 0;
+	ret32 = strtol((const char*)arg, &endptr, 10);
+	if ((errno == 0) && (*endptr == '\0')) {
+		*out = ret32;
+		return 0;
+	}
+	return -1;
+}
+
+CmdOptionType *parse_args(int argc, const char* argv[])
+{
+	  int opt;
+
+	  cmd_option.fifocfgpath = NULL;
+	  cmd_option.load_filepath = NULL;
+	  cmd_option.is_binary_data = FALSE;
+	  cmd_option.is_interaction = FALSE;
+	  cmd_option.is_remote = FALSE;
+	  cmd_option.timeout = 0;
+
+	  while ((opt = getopt(argc, (char**)argv, "irbt:p:d:c:m:")) != -1) {
+		  switch (opt) {
+		  case 'i':
+	    	cmd_option.is_interaction = TRUE;
+	        break;
+		  case 'r':
+	    	cmd_option.is_remote = TRUE;
+	        break;
+	      case 'b':
+		    cmd_option.is_binary_data = TRUE;
+	        break;
+	      case 't':
+					if (cmd_atoi(optarg, &cmd_option.timeout) < 0) {
+							printf("error! -t %s\n", optarg);
+						return NULL;
+					}
+	        break;
+	      case 'c':
+					if (cmd_atoi32(optarg, &cmd_option.core_id_num) < 0) {
+							printf("error! -c %s\n", optarg);
+						return NULL;
+					}
+	        break;
+	      case 'p':
+	    	memcpy(cmd_option.buffer_fifopath, optarg, strlen(optarg));
+	    	cmd_option.buffer_fifopath[strlen(optarg)] = '\0';
+	        cmd_option.fifocfgpath = cmd_option.buffer_fifopath;
+	        break;
+	      case 'm':
+	    	memcpy(cmd_option.buffer_memfile, optarg, strlen(optarg));
+	    	cmd_option.buffer_memfile[strlen(optarg)] = '\0';
+	        cmd_option.memfilepath = cmd_option.buffer_memfile;
+	        break;
+	      case 'd':
+	    	memcpy(cmd_option.buffer_devcfgpath, optarg, strlen(optarg));
+	    	cmd_option.buffer_devcfgpath[strlen(optarg)] = '\0';
+	        cmd_option.devcfgpath = cmd_option.buffer_devcfgpath;
+	        break;
+	      default:
+	        printf("parse_args:error! \'%c\' \'%c\'\n", opt, optopt);
+	        return NULL;
+	    }
+	  }
+#if 0
+	  printf("i = %d\n", cmd_option.is_interaction);
+	  printf("b = %d\n", cmd_option.is_binary_data);
+	  printf("t = %llu\n", cmd_option.timeout);
+	  printf("p = %s\n", (cmd_option.fifocfgpath != NULL) ? cmd_option.fifocfgpath : "NULL");
+#endif
+		if (optind >= argc) {
+			printf("ERROR: not found <load file>\n");
+			return NULL;
+		}
+	  memcpy(cmd_option.load_file.filepath.str, argv[optind], strlen(argv[optind]));
+	  cmd_option.load_file.filepath.str[strlen(argv[optind])] = '\0';
+	  cmd_option.load_file.filepath.len = strlen(argv[optind]);
+      cmd_option.load_filepath = (char *)cmd_option.load_file.filepath.str;
+
+      if (file_load(&cmd_option.load_file) == FALSE) {
+    	  return NULL;
+      }
+
+      if ((cmd_option.fifocfgpath != NULL) &&(file_exist(cmd_option.fifocfgpath) == FALSE)) {
+    	  printf("ERROR: not found fifo(%s)\n", cmd_option.fifocfgpath);
+    	  return NULL;
+      }
+      if ((cmd_option.devcfgpath != NULL) &&(file_exist(cmd_option.devcfgpath) == FALSE)) {
+    	  printf("ERROR: not found devcfg(%s)\n", cmd_option.devcfgpath);
+    	  return NULL;
+      }
+      if ((cmd_option.memfilepath != NULL) &&(file_exist(cmd_option.memfilepath) == FALSE)) {
+    	  printf("ERROR: not found memory.txt(%s)\n", cmd_option.memfilepath);
+    	  return NULL;
+      }
+
+	  return &cmd_option;
+}
--- /dev/null
+++ athrill-rh850f1x-0.A.1/athrill/src/main/option/option.h
@@ -0,0 +1,30 @@
+#ifndef _OPTION_H_
+#define _OPTION_H_
+
+#include "std_types.h"
+#include "file.h"
+
+typedef struct {
+	bool	is_interaction;
+	uint32	core_id_num;
+	uint64	timeout;
+	bool	is_binary_data;
+	bool	is_remote;
+
+	char	*fifocfgpath;
+	char	buffer_fifopath[4096];
+
+	char	*load_filepath;
+	FileType load_file;
+
+	char	*devcfgpath;
+	char	buffer_devcfgpath[4096];
+
+	char*				memfilepath;
+	char				buffer_memfile[4096];
+} CmdOptionType;
+
+extern CmdOptionType *parse_args(int argc, const char* argv[]);
+
+
+#endif /* _OPTION_H_ */
